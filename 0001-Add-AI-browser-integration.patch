From 8ee47fdc0fee1f48ad2390f1c1e523f2205912cc Mon Sep 17 00:00:00 2001
From: natanelDaniel <21daniel23nd@gmail.com>
Date: Tue, 13 May 2025 10:08:13 +0300
Subject: [PATCH] Add AI browser integration

---
 .../resources/js/lib/ffmpeg.patch             |   112 +
 .../patches/0000-build-bots-jumbo.patch       |   265 +
 .../cityhash/patches/0001-bswap-clang.patch   |    20 +
 .../cityhash/patches/0002-warnings.patch      |    86 +
 .../patches/000-remove-crc.patch              |   122 +
 .../patches/001-fix-include-paths.patch       |    14 +
 .../patches/002-fix-include-guards.patch      |    21 +
 .../cityhash_v103/patches/003-use-base.patch  |    68 +
 .../patches/004-google-style.patch            |    65 +
 .../patches/005-bswap-clang.patch             |    20 +
 .../cityhash_v103/patches/006-warnings.patch  |    59 +
 .../patches/001-fix-up-includes.patch         |    56 +
 .../patches/002-minimal-logging.patch         |  2135 ++
 .../patches/003-minimal-utilities.patch       |   184 +
 .../004-add-missing-symbolize-header.patch    |    13 +
 .../patches/005-expose-file-helpers.patch     |   135 +
 ...se-sandbox-hook-for-open-object-file.patch |    70 +
 .../symbolize/patches/007-sys-types-h.patch   |    13 +
 .../patches/008-include-cstdlib.patch         |    12 +
 .../patches/009-clone-absl-demangle.patch     |  2388 ++
 .../symbolize/patches/010-clang-format.patch  |  1184 +
 .../third_party/eu-strip/fix-elf-size.patch   |    61 +
 .../test/data/dromaeo/patches/librefs.patch   |   318 +
 .../test/data/dromaeo/patches/webrunner.patch |   156 +
 .../patches/0001-Turn-on-hardened-mode.patch  |    24 +
 .../0002-delete-unprefixed-annotations.patch  |    55 +
 ...ete-static-initializer-in-stacktrace.patch |    33 +
 .../patches/0001-fix-build-with-std-c11.patch |    27 +
 .../patches/0002-fix-shadow-variables.patch   |    65 +
 third_party/afl/src/QuickStartGuide.txt       |     0
 .../libpng_no_checksum/libpng-nocrc.patch     |    15 +
 .../apache-portable-runtime/diff.patch        |   254 +
 third_party/apache-win32/ABOUT_APACHE.txt     |   244 -
 third_party/apache-win32/LICENSE.txt          |   946 -
 third_party/apache-win32/NOTICE.txt           |    60 -
 third_party/apache-win32/OPENSSL-README.txt   |   127 -
 third_party/apache-win32/README.txt           |   110 -
 .../apache-win32/readme-redist-bins.txt       |   416 -
 .../0001-Add-ashmem-get-prot-region.patch     |    28 +
 ...SharedMemory-functions-when-possible.patch |   332 +
 .../0003-Pthread-once-for-funcs-init.patch    |    61 +
 ...xup-ashmem_get_prot_region-for-memfd.patch |    13 +
 ...ard-JNI-Util-for-Chrome-build-config.patch |    41 +
 ...dapt-QRCode-activity-to-edge-to-edge.patch |    67 +
 ...ion-to-ignore-weak-undefined-symbols.patch |    71 +
 .../0002-fix-compatibility-for-chromium.patch |    77 +
 .../expat/0001-Do-not-claim-getrandom.patch   |    31 +
 ...-V8-s-fdlibm-fork-into-Chromium-thir.patch |   469 +
 .../grpc/patches/0001-Remove-absl-Flag.patch  |   217 +
 .../grpc/patches/0002-Replace-LOG-CHECK.patch | 28838 ++++++++++++++++
 ...p-CreateDirectoryReloaderCrlProvider.patch |   129 +
 third_party/hunspell/google.patch             |  1363 +
 .../iaccessible2/set_selection_ranges.patch   |   467 +
 .../patches/0001-hardcode-properties.patch    |    43 +
 ...0002-dont-use-injected-class-runtime.patch |    20 +
 ...-dont-use-condy-probe-array-strategy.patch |    38 +
 .../libtess2/patches/0000-leq-cfi.patch       |    93 +
 .../libusb/assign-endpoints-checks.patch      |    17 +
 third_party/libusb/composite-hid-close.patch  |    32 +
 third_party/libusb/darwin-sigfpe.patch        |    22 +
 third_party/libusb/linux-udev.patch           |   209 +
 third_party/libusb/open-fd.patch              |   236 +
 third_party/libusb/os-priv-alignment.patch    |    43 +
 third_party/libusb/unsigned-shifts.patch      |    94 +
 third_party/libusb/upstream-tick147.patch     |    13 +
 third_party/libusb/windows-build.patch        |    54 +
 .../chromium/chromium-issue-894933.patch      |   113 +
 third_party/libxml/chromium/counted_by.patch  |    50 +
 .../libxml/chromium/remove-getentropy.patch   |    59 +
 .../chromium/undo-sax-deprecation.patch       |    15 +
 .../libxslt/chromium/xslt-locale.patch        |    45 +
 ...place-usage-of-sprintf-with-snprintf.patch |    78 +
 .../patches/0001-add-built-config.h.patch     |    82 +
 .../0001-add-built-zip_err_str.c.patch        |   104 +
 .../patches/0001-add-built-zipconf.h.patch    |    71 +
 .../libzip/patches/0001-patch-configs.patch   |   113 +
 third_party/lzma_sdk/chromium.patch           |    46 +
 .../0001-Fix-sentencepiece-include.patch      |    26 +
 .../patches/compile-with-gpu-on-windows.patch |   261 +
 ...dicated-context-for-some-calculators.patch |    27 +
 .../fix-FormatMessage-win-api-usage.patch     |    71 +
 ...-matrix-string-functions-conditional.patch |    31 +
 .../patches/matrix_undefine_exceptions.patch  |    26 +
 .../mediapipe/patches/no-consume.patch        |   108 +
 ...l-flag-in-inference_calculator_utils.patch |    68 +
 ...bsl-flag-in-resource_util_default.cc.patch |    42 +
 ...-mediapipe-op-resolver-default-value.patch |    26 +
 ...source_util_windows.cc-functionality.patch |   100 +
 .../remove-unused-absl-check-include.patch    |    26 +
 ...remove-unused-absl-debugging-include.patch |    27 +
 .../remove-xnnpack-from-cpu-delegate.patch    |    53 +
 .../patches/replace-absl-log-usages.patch     |   162 +
 ...xecutable-bit-for-files-with-shebang.patch |    26 +
 ...type-map-fix-unused-variable-warning.patch |    25 +
 .../mediapipe/patches/unnecessary-const.patch |    13 +
 .../mediapipe/patches/update-any-usage.patch  |    42 +
 .../use-re2-instead-of-std-regex.patch        |    65 +
 .../patches/chromium_d3_types_index.patch     |    35 +
 third_party/node/patches/html_minifier.patch  |    12 +
 third_party/node/patches/lit_html.patch       |    11 +
 third_party/node/patches/types_chai.patch     |    18 +
 third_party/node/patches/typescript.patch     |    40 +
 ...gnore-Android-Content-Provider-Paths.patch |    67 +
 third_party/opus/src/doc/opus_update.patch    |   244 +
 third_party/ply/license.patch                 |    42 +
 third_party/polymer/v3_0/chromium.patch       |    13 +
 third_party/polymer/v3_0/chromium_dts.patch   |   136 +
 third_party/polymer/v3_0/iron_icon.patch      |    33 +
 .../polymer/v3_0/iron_iconset_svg.patch       |    54 +
 third_party/polymer/v3_0/iron_list.patch      |   145 +
 .../polymer/v3_0/iron_overlay_backdrop.patch  |    27 +
 third_party/polymer/v3_0/paper_progress.patch |    60 +
 third_party/polymer/v3_0/paper_spinner.patch  |    50 +
 third_party/polymer/v3_0/paper_tooltip.patch  |   204 +
 third_party/polymer/v3_0/polymer.patch        |   205 +
 ...hromium-fixes-for-PSM-client-library.patch |  1200 +
 .../0004-fix-shared-library-exports.patch     |    45 +
 .../0008-uninline_get_empty_string.patch      |    32 +
 .../0010-uninline-generated-code.patch        |    13 +
 .../0022-Allow-deprecated-fields.patch        |    41 +
 .../0029-make-initializers-optimizable.patch  |    76 +
 .../0030-workaround-windows-constinit.patch   |   141 +
 .../0031-workaround-cfi-unrelated-cast.patch  |    48 +
 .../0039-generate-mediapipe-anylite.patch     |    93 +
 ...fix-undefined-protobuf-custom-vtable.patch |    42 +
 .../0043-unreachable-code-return.patch        |    13 +
 .../patches/0044-trim-protoc-main.patch       |    63 +
 .../protobuf/patches/0045-string-resize.patch |   119 +
 .../protobuf/patches/0046-absl-log.patch      |    24 +
 .../patches/0047-perfetto-backcompat.patch    |    77 +
 .../patches/0048-csharp-names-redirect.patch  |    12 +
 .../0049-deprecated-declarations-pragma.patch |    19 +
 .../0050-remove-unreachable-code.patch        |    20 +
 .../patches/0051-export-template-define.patch |    24 +
 .../0052-remove-dynamic-annotations.patch     |    35 +
 .../0053-ignore-compatibility-dir.patch       |    11 +
 ...-usage-if-absl-internal-if_constexpr.patch |    91 +
 .../protobuf/third_party/rules_fuzzing.patch  |    13 +
 .../rapidhash/patches/0001-clang-format.patch |   733 +
 ...-Remove-executable-bit-from-build.js.patch |    17 +
 ...eader-include-to-be-an-absolute-path.patch |    23 +
 .../0004-Define-exported-cxx-symbols.patch    |   867 +
 ...1-Remove-executable-bit-from-miri.sh.patch |    17 +
 ...at-most-auxiliary-chunk-errors-as-be.patch |    79 +
 .../patches/0001-Remove-config-include.patch  |    24 +
 .../patches/0002-Fix-absl-includes.patch      |   861 +
 .../patches/0003-Remove-absl-flags.patch      |    49 +
 .../patches/0004-Remove-util-Status.patch     |   190 +
 .../patches/0005-Fix-utf8towide.patch         |   115 +
 .../0006-Fix-gn-check-in-sentencepiece.patch  |    34 +
 ...cePiece-introduce-no-exceptions-mode.patch |   124 +
 .../0001-Support-SHELL-in-chromium.patch      |   115 +
 ...0003-Support-SHELL-tests-in-chromium.patch |  1243 +
 .../0004-Support-SHELL-component-build.patch  |   655 +
 .../patches/0005-Add-SHELL-go-package.patch   |    13 +
 .../patches/0006-Quit-using-ValueOrDie.patch  |   369 +
 ...nused-function-Wunused-local-typedef.patch |    25 +
 .../patches/0008-Fix-Wsign-compare.patch      |    61 +
 ...ossible-BERT-model-output-tensor-nam.patch |    51 +
 ...tDependencyHeads-method-for-Dependen.patch |   156 +
 ...ization-support-to-seq_flow_lite-ops.patch |   235 +
 ...ntization-support-to-the-denylist-op.patch |   105 +
 ...encepiece-tokenization-not-supported.patch |    51 +
 .../0002-rm-noop-deprecated-attribute.patch   |    26 +
 .../patches/0003-do-not-use-absl-any.patch    |    64 +
 .../patches/0004-rm-stdio-static-init.patch   |    38 +
 ...ck-cancel-flag-before-calling-invoke.patch |    57 +
 ...-errors-on-linux-when-using-the-syst.patch |   111 +
 ...ysNSStringToUTF8-to-convert-NSString.patch |    25 +
 ...et-executable-bit-for-common_win.bat.patch |    16 +
 .../0009-Remove-whitespace-tokenizer.patch    |   778 +
 ..._RETURN-and-RETURN_IF_ERROR-macros-w.patch |  3869 +++
 .../com_google_protobuf.patch                 |    25 +
 .../tensorflow_lite_ios_build.patch           |     4 +
 .../tensorflow_text_a0f49e63.patch            |    38 +
 .../tensorflow_text_remove_tf_deps.patch      |    32 +
 .../tflite_support/src/third_party/zlib.patch |    62 +
 .../unrar/patches/chromium_changes.patch      |   788 +
 ...0001-adding-CJK-ideograph-to-isalpha.patch |    34 +
 .../patches/0001-adding-awk-built-files.patch |  1426 +
 ...1-adding-korean-characters-to-ranges.patch |    33 +
 .../utf/patches/0001-utftab-refactor.patch    |    50 +
 third_party/wtl/wtl10.patch                   |    37 +
 third_party/zlib/patches/0000-build.patch     |   158 +
 third_party/zlib/patches/0001-simd.patch      |  1214 +
 .../patches/0002-uninitializedcheck.patch     |    27 +
 .../zlib/patches/0003-uninitializedjump.patch |    15 +
 third_party/zlib/patches/0004-fix-uwp.patch   |    27 +
 .../zlib/patches/0005-infcover-gtest.patch    |   405 +
 .../zlib/patches/0006-fix-check_match.patch   |    42 +
 .../0007-zero-init-deflate-window.patch       |    40 +
 .../0008-minizip-zip-unzip-tools.patch        |    82 +
 .../zlib/patches/0009-infcover-oob.patch      |    24 +
 .../zlib/patches/0010-cmake-enable-simd.patch |    96 +
 third_party/zlib/patches/0011-avx512.patch    |   357 +
 .../zlib/patches/0012-lfs-open64.patch        |    40 +
 .../0013-cpu-feature-detection-for-arm.patch  |    30 +
 ...14-minizip-unzip-with-incorrect-size.patch |    34 +
 ...0015-minizip-unzip-enable-decryption.patch |    28 +
 ...nizip-parse-unicode-path-extra-field.patch |   117 +
 third_party/zxcvbn-cpp/google.patch           |  2637 ++
 .../viewer/caspian/wasmbuild.patch            |   129 +
 ...it-work-for-chromium-s-infra-configs.patch |   160 +
 203 files changed, 66204 insertions(+), 1903 deletions(-)
 create mode 100644 ash/webui/camera_app_ui/resources/js/lib/ffmpeg.patch
 create mode 100644 base/third_party/cityhash/patches/0000-build-bots-jumbo.patch
 create mode 100644 base/third_party/cityhash/patches/0001-bswap-clang.patch
 create mode 100644 base/third_party/cityhash/patches/0002-warnings.patch
 create mode 100644 base/third_party/cityhash_v103/patches/000-remove-crc.patch
 create mode 100644 base/third_party/cityhash_v103/patches/001-fix-include-paths.patch
 create mode 100644 base/third_party/cityhash_v103/patches/002-fix-include-guards.patch
 create mode 100644 base/third_party/cityhash_v103/patches/003-use-base.patch
 create mode 100644 base/third_party/cityhash_v103/patches/004-google-style.patch
 create mode 100644 base/third_party/cityhash_v103/patches/005-bswap-clang.patch
 create mode 100644 base/third_party/cityhash_v103/patches/006-warnings.patch
 create mode 100644 base/third_party/symbolize/patches/001-fix-up-includes.patch
 create mode 100644 base/third_party/symbolize/patches/002-minimal-logging.patch
 create mode 100644 base/third_party/symbolize/patches/003-minimal-utilities.patch
 create mode 100644 base/third_party/symbolize/patches/004-add-missing-symbolize-header.patch
 create mode 100644 base/third_party/symbolize/patches/005-expose-file-helpers.patch
 create mode 100644 base/third_party/symbolize/patches/006-use-sandbox-hook-for-open-object-file.patch
 create mode 100644 base/third_party/symbolize/patches/007-sys-types-h.patch
 create mode 100644 base/third_party/symbolize/patches/008-include-cstdlib.patch
 create mode 100644 base/third_party/symbolize/patches/009-clone-absl-demangle.patch
 create mode 100644 base/third_party/symbolize/patches/010-clang-format.patch
 create mode 100644 buildtools/third_party/eu-strip/fix-elf-size.patch
 create mode 100644 chrome/test/data/dromaeo/patches/librefs.patch
 create mode 100644 chrome/test/data/dromaeo/patches/webrunner.patch
 create mode 100644 third_party/abseil-cpp/patches/0001-Turn-on-hardened-mode.patch
 create mode 100644 third_party/abseil-cpp/patches/0002-delete-unprefixed-annotations.patch
 create mode 100644 third_party/abseil-cpp/patches/0003-delete-static-initializer-in-stacktrace.patch
 create mode 100644 third_party/afl/patches/0001-fix-build-with-std-c11.patch
 create mode 100644 third_party/afl/patches/0002-fix-shadow-variables.patch
 mode change 120000 => 100644 third_party/afl/src/QuickStartGuide.txt
 create mode 100644 third_party/afl/src/experimental/libpng_no_checksum/libpng-nocrc.patch
 create mode 100644 third_party/apache-portable-runtime/diff.patch
 delete mode 100644 third_party/apache-win32/ABOUT_APACHE.txt
 delete mode 100644 third_party/apache-win32/LICENSE.txt
 delete mode 100644 third_party/apache-win32/NOTICE.txt
 delete mode 100644 third_party/apache-win32/OPENSSL-README.txt
 delete mode 100644 third_party/apache-win32/README.txt
 delete mode 100644 third_party/apache-win32/readme-redist-bins.txt
 create mode 100644 third_party/ashmem/patches/0001-Add-ashmem-get-prot-region.patch
 create mode 100644 third_party/ashmem/patches/0002-Use-ASharedMemory-functions-when-possible.patch
 create mode 100644 third_party/ashmem/patches/0003-Pthread-once-for-funcs-init.patch
 create mode 100644 third_party/ashmem/patches/0004-Fixup-ashmem_get_prot_region-for-memfd.patch
 create mode 100644 third_party/cardboard/src_overrides/patches/0001-Adjust-Cardboard-JNI-Util-for-Chrome-build-config.patch
 create mode 100644 third_party/cardboard/src_overrides/patches/0002-Adapt-QRCode-activity-to-edge-to-edge.patch
 create mode 100644 third_party/dpkg-shlibdeps/patches/0001-dkpg-shlibdeps-add-option-to-ignore-weak-undefined-symbols.patch
 create mode 100644 third_party/dpkg-shlibdeps/patches/0002-fix-compatibility-for-chromium.patch
 create mode 100644 third_party/expat/0001-Do-not-claim-getrandom.patch
 create mode 100644 third_party/fdlibm/chromium/0001-Import-a-copy-of-V8-s-fdlibm-fork-into-Chromium-thir.patch
 create mode 100644 third_party/grpc/patches/0001-Remove-absl-Flag.patch
 create mode 100644 third_party/grpc/patches/0002-Replace-LOG-CHECK.patch
 create mode 100644 third_party/grpc/patches/0003-fucshia-Drop-CreateDirectoryReloaderCrlProvider.patch
 create mode 100644 third_party/hunspell/google.patch
 create mode 100644 third_party/iaccessible2/set_selection_ranges.patch
 create mode 100644 third_party/jacoco/3pp/patches/0001-hardcode-properties.patch
 create mode 100644 third_party/jacoco/3pp/patches/0002-dont-use-injected-class-runtime.patch
 create mode 100644 third_party/jacoco/3pp/patches/0003-dont-use-condy-probe-array-strategy.patch
 create mode 100644 third_party/libtess2/patches/0000-leq-cfi.patch
 create mode 100644 third_party/libusb/assign-endpoints-checks.patch
 create mode 100644 third_party/libusb/composite-hid-close.patch
 create mode 100644 third_party/libusb/darwin-sigfpe.patch
 create mode 100644 third_party/libusb/linux-udev.patch
 create mode 100644 third_party/libusb/open-fd.patch
 create mode 100644 third_party/libusb/os-priv-alignment.patch
 create mode 100644 third_party/libusb/unsigned-shifts.patch
 create mode 100644 third_party/libusb/upstream-tick147.patch
 create mode 100644 third_party/libusb/windows-build.patch
 create mode 100644 third_party/libxml/chromium/chromium-issue-894933.patch
 create mode 100644 third_party/libxml/chromium/counted_by.patch
 create mode 100644 third_party/libxml/chromium/remove-getentropy.patch
 create mode 100644 third_party/libxml/chromium/undo-sax-deprecation.patch
 create mode 100644 third_party/libxslt/chromium/xslt-locale.patch
 create mode 100644 third_party/libzip/patches/0001-Replace-usage-of-sprintf-with-snprintf.patch
 create mode 100644 third_party/libzip/patches/0001-add-built-config.h.patch
 create mode 100644 third_party/libzip/patches/0001-add-built-zip_err_str.c.patch
 create mode 100644 third_party/libzip/patches/0001-add-built-zipconf.h.patch
 create mode 100644 third_party/libzip/patches/0001-patch-configs.patch
 create mode 100644 third_party/lzma_sdk/chromium.patch
 create mode 100644 third_party/mediapipe/patches/0001-Fix-sentencepiece-include.patch
 create mode 100644 third_party/mediapipe/patches/compile-with-gpu-on-windows.patch
 create mode 100644 third_party/mediapipe/patches/dont-use-dedicated-context-for-some-calculators.patch
 create mode 100644 third_party/mediapipe/patches/fix-FormatMessage-win-api-usage.patch
 create mode 100644 third_party/mediapipe/patches/make-matrix-string-functions-conditional.patch
 create mode 100644 third_party/mediapipe/patches/matrix_undefine_exceptions.patch
 create mode 100644 third_party/mediapipe/patches/no-consume.patch
 create mode 100644 third_party/mediapipe/patches/remove-absl-flag-in-inference_calculator_utils.patch
 create mode 100644 third_party/mediapipe/patches/remove-absl-flag-in-resource_util_default.cc.patch
 create mode 100644 third_party/mediapipe/patches/remove-mediapipe-op-resolver-default-value.patch
 create mode 100644 third_party/mediapipe/patches/remove-resource_util_windows.cc-functionality.patch
 create mode 100644 third_party/mediapipe/patches/remove-unused-absl-check-include.patch
 create mode 100644 third_party/mediapipe/patches/remove-unused-absl-debugging-include.patch
 create mode 100644 third_party/mediapipe/patches/remove-xnnpack-from-cpu-delegate.patch
 create mode 100644 third_party/mediapipe/patches/replace-absl-log-usages.patch
 create mode 100644 third_party/mediapipe/patches/set-executable-bit-for-files-with-shebang.patch
 create mode 100644 third_party/mediapipe/patches/type-map-fix-unused-variable-warning.patch
 create mode 100644 third_party/mediapipe/patches/unnecessary-const.patch
 create mode 100644 third_party/mediapipe/patches/update-any-usage.patch
 create mode 100644 third_party/mediapipe/patches/use-re2-instead-of-std-regex.patch
 create mode 100644 third_party/node/patches/chromium_d3_types_index.patch
 create mode 100644 third_party/node/patches/html_minifier.patch
 create mode 100644 third_party/node/patches/lit_html.patch
 create mode 100644 third_party/node/patches/types_chai.patch
 create mode 100644 third_party/node/patches/typescript.patch
 create mode 100644 third_party/openxr/src_overrides/patches/0001-Ignore-Android-Content-Provider-Paths.patch
 create mode 100644 third_party/opus/src/doc/opus_update.patch
 create mode 100644 third_party/ply/license.patch
 create mode 100644 third_party/polymer/v3_0/chromium.patch
 create mode 100644 third_party/polymer/v3_0/chromium_dts.patch
 create mode 100644 third_party/polymer/v3_0/iron_icon.patch
 create mode 100644 third_party/polymer/v3_0/iron_iconset_svg.patch
 create mode 100644 third_party/polymer/v3_0/iron_list.patch
 create mode 100644 third_party/polymer/v3_0/iron_overlay_backdrop.patch
 create mode 100644 third_party/polymer/v3_0/paper_progress.patch
 create mode 100644 third_party/polymer/v3_0/paper_spinner.patch
 create mode 100644 third_party/polymer/v3_0/paper_tooltip.patch
 create mode 100644 third_party/polymer/v3_0/polymer.patch
 create mode 100644 third_party/private_membership/patches/0001-Chromium-fixes-for-PSM-client-library.patch
 create mode 100644 third_party/protobuf/patches/0004-fix-shared-library-exports.patch
 create mode 100644 third_party/protobuf/patches/0008-uninline_get_empty_string.patch
 create mode 100644 third_party/protobuf/patches/0010-uninline-generated-code.patch
 create mode 100644 third_party/protobuf/patches/0022-Allow-deprecated-fields.patch
 create mode 100644 third_party/protobuf/patches/0029-make-initializers-optimizable.patch
 create mode 100644 third_party/protobuf/patches/0030-workaround-windows-constinit.patch
 create mode 100644 third_party/protobuf/patches/0031-workaround-cfi-unrelated-cast.patch
 create mode 100644 third_party/protobuf/patches/0039-generate-mediapipe-anylite.patch
 create mode 100644 third_party/protobuf/patches/0042-fix-undefined-protobuf-custom-vtable.patch
 create mode 100644 third_party/protobuf/patches/0043-unreachable-code-return.patch
 create mode 100644 third_party/protobuf/patches/0044-trim-protoc-main.patch
 create mode 100644 third_party/protobuf/patches/0045-string-resize.patch
 create mode 100644 third_party/protobuf/patches/0046-absl-log.patch
 create mode 100644 third_party/protobuf/patches/0047-perfetto-backcompat.patch
 create mode 100644 third_party/protobuf/patches/0048-csharp-names-redirect.patch
 create mode 100644 third_party/protobuf/patches/0049-deprecated-declarations-pragma.patch
 create mode 100644 third_party/protobuf/patches/0050-remove-unreachable-code.patch
 create mode 100644 third_party/protobuf/patches/0051-export-template-define.patch
 create mode 100644 third_party/protobuf/patches/0052-remove-dynamic-annotations.patch
 create mode 100644 third_party/protobuf/patches/0053-ignore-compatibility-dir.patch
 create mode 100644 third_party/protobuf/patches/0054-remove-usage-if-absl-internal-if_constexpr.patch
 create mode 100644 third_party/protobuf/third_party/rules_fuzzing.patch
 create mode 100644 third_party/rapidhash/patches/0001-clang-format.patch
 create mode 100644 third_party/rust/chromium_crates_io/patches/cxx/0002-Remove-executable-bit-from-build.js.patch
 create mode 100644 third_party/rust/chromium_crates_io/patches/cxx/0003-Change-cxx-header-include-to-be-an-absolute-path.patch
 create mode 100644 third_party/rust/chromium_crates_io/patches/cxx/0004-Define-exported-cxx-symbols.patch
 create mode 100644 third_party/rust/chromium_crates_io/patches/memoffset/0001-Remove-executable-bit-from-miri.sh.patch
 create mode 100644 third_party/rust/chromium_crates_io/patches/png/0201-trimmed-down-Treat-most-auxiliary-chunk-errors-as-be.patch
 create mode 100644 third_party/sentencepiece/patches/0001-Remove-config-include.patch
 create mode 100644 third_party/sentencepiece/patches/0002-Fix-absl-includes.patch
 create mode 100644 third_party/sentencepiece/patches/0003-Remove-absl-flags.patch
 create mode 100644 third_party/sentencepiece/patches/0004-Remove-util-Status.patch
 create mode 100644 third_party/sentencepiece/patches/0005-Fix-utf8towide.patch
 create mode 100644 third_party/sentencepiece/patches/0006-Fix-gn-check-in-sentencepiece.patch
 create mode 100644 third_party/sentencepiece/patches/0007-SentencePiece-introduce-no-exceptions-mode.patch
 create mode 100644 third_party/shell-encryption/patches/0001-Support-SHELL-in-chromium.patch
 create mode 100644 third_party/shell-encryption/patches/0003-Support-SHELL-tests-in-chromium.patch
 create mode 100644 third_party/shell-encryption/patches/0004-Support-SHELL-component-build.patch
 create mode 100644 third_party/shell-encryption/patches/0005-Add-SHELL-go-package.patch
 create mode 100644 third_party/shell-encryption/patches/0006-Quit-using-ValueOrDie.patch
 create mode 100644 third_party/shell-encryption/patches/0007-Fix-Wunused-function-Wunused-local-typedef.patch
 create mode 100644 third_party/shell-encryption/patches/0008-Fix-Wsign-compare.patch
 create mode 100644 third_party/tensorflow-text/patches/0001-Add-score-as-a-possible-BERT-model-output-tensor-nam.patch
 create mode 100644 third_party/tensorflow-text/patches/0001-Implement-the-GetDependencyHeads-method-for-Dependen.patch
 create mode 100644 third_party/tensorflow_models/patches/0001-add-int8-quantization-support-to-seq_flow_lite-ops.patch
 create mode 100644 third_party/tensorflow_models/patches/0002-Add-int8-quantization-support-to-the-denylist-op.patch
 create mode 100644 third_party/tflite_support/patches/0001-sentencepiece-tokenization-not-supported.patch
 create mode 100644 third_party/tflite_support/patches/0002-rm-noop-deprecated-attribute.patch
 create mode 100644 third_party/tflite_support/patches/0003-do-not-use-absl-any.patch
 create mode 100644 third_party/tflite_support/patches/0004-rm-stdio-static-init.patch
 create mode 100644 third_party/tflite_support/patches/0005-check-cancel-flag-before-calling-invoke.patch
 create mode 100644 third_party/tflite_support/patches/0006-Fix-TFLite-build-errors-on-linux-when-using-the-syst.patch
 create mode 100644 third_party/tflite_support/patches/0007-Use-SysNSStringToUTF8-to-convert-NSString.patch
 create mode 100644 third_party/tflite_support/patches/0008-set-executable-bit-for-common_win.bat.patch
 create mode 100644 third_party/tflite_support/patches/0009-Remove-whitespace-tokenizer.patch
 create mode 100644 third_party/tflite_support/patches/0010-Prefix-ASSIGN_OR_RETURN-and-RETURN_IF_ERROR-macros-w.patch
 create mode 100644 third_party/tflite_support/src/third_party/pybind11_protobuf/com_google_protobuf.patch
 create mode 100644 third_party/tflite_support/src/third_party/tensorflow_lite_ios_build.patch
 create mode 100644 third_party/tflite_support/src/third_party/tensorflow_text_a0f49e63.patch
 create mode 100644 third_party/tflite_support/src/third_party/tensorflow_text_remove_tf_deps.patch
 create mode 100644 third_party/tflite_support/src/third_party/zlib.patch
 create mode 100644 third_party/unrar/patches/chromium_changes.patch
 create mode 100644 third_party/utf/patches/0001-adding-CJK-ideograph-to-isalpha.patch
 create mode 100644 third_party/utf/patches/0001-adding-awk-built-files.patch
 create mode 100644 third_party/utf/patches/0001-adding-korean-characters-to-ranges.patch
 create mode 100644 third_party/utf/patches/0001-utftab-refactor.patch
 create mode 100644 third_party/wtl/wtl10.patch
 create mode 100644 third_party/zlib/patches/0000-build.patch
 create mode 100644 third_party/zlib/patches/0001-simd.patch
 create mode 100644 third_party/zlib/patches/0002-uninitializedcheck.patch
 create mode 100644 third_party/zlib/patches/0003-uninitializedjump.patch
 create mode 100644 third_party/zlib/patches/0004-fix-uwp.patch
 create mode 100644 third_party/zlib/patches/0005-infcover-gtest.patch
 create mode 100644 third_party/zlib/patches/0006-fix-check_match.patch
 create mode 100644 third_party/zlib/patches/0007-zero-init-deflate-window.patch
 create mode 100644 third_party/zlib/patches/0008-minizip-zip-unzip-tools.patch
 create mode 100644 third_party/zlib/patches/0009-infcover-oob.patch
 create mode 100644 third_party/zlib/patches/0010-cmake-enable-simd.patch
 create mode 100644 third_party/zlib/patches/0011-avx512.patch
 create mode 100644 third_party/zlib/patches/0012-lfs-open64.patch
 create mode 100644 third_party/zlib/patches/0013-cpu-feature-detection-for-arm.patch
 create mode 100644 third_party/zlib/patches/0014-minizip-unzip-with-incorrect-size.patch
 create mode 100644 third_party/zlib/patches/0015-minizip-unzip-enable-decryption.patch
 create mode 100644 third_party/zlib/patches/0016-minizip-parse-unicode-path-extra-field.patch
 create mode 100644 third_party/zxcvbn-cpp/google.patch
 create mode 100644 tools/binary_size/libsupersize/viewer/caspian/wasmbuild.patch
 create mode 100644 tools/vscode/bazel_lsp/0001-Make-it-work-for-chromium-s-infra-configs.patch

diff --git a/ash/webui/camera_app_ui/resources/js/lib/ffmpeg.patch b/ash/webui/camera_app_ui/resources/js/lib/ffmpeg.patch
new file mode 100644
index 0000000000000..7b6253a8c1da8
--- /dev/null
+++ b/ash/webui/camera_app_ui/resources/js/lib/ffmpeg.patch
@@ -0,0 +1,112 @@
+diff --git a/fftools/cmdutils.c b/fftools/cmdutils.c
+index 18e768b386..359936744d 100644
+--- a/fftools/cmdutils.c
++++ b/fftools/cmdutils.c
+@@ -19,6 +19,8 @@
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+  */
+ 
++#include <emscripten.h>
++
+ #include <string.h>
+ #include <stdint.h>
+ #include <stdlib.h>
+@@ -95,7 +97,7 @@ void exit_program(int ret)
+     if (program_exit)
+         program_exit(ret);
+ 
+-    exit(ret);
++    emscripten_force_exit(ret);
+ }
+ 
+ double parse_number_or_die(const char *context, const char *numstr, int type,
+diff --git a/lib.js b/lib.js
+new file mode 100644
+index 0000000000..b7f8092dbf
+--- /dev/null
++++ b/lib.js
+@@ -0,0 +1,8 @@
++mergeInto(LibraryManager.library, {
++  // Returns 0 if the processing is canceled.
++  wait_readable: function() {
++    return Asyncify.handleSleep(function(wakeUp) {
++      Module["waitReadable"](wakeUp);
++    });
++  }
++});
+\ No newline at end of file
+diff --git a/libavformat/file.c b/libavformat/file.c
+index 98c9e81bcb..a7ec30252d 100644
+--- a/libavformat/file.c
++++ b/libavformat/file.c
+@@ -19,6 +19,8 @@
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+  */
+ 
++#include <emscripten.h>
++
+ #include "config_components.h"
+ 
+ #include "libavutil/avstring.h"
+@@ -108,11 +110,17 @@ static const AVClass pipe_class = {
+     .version    = LIBAVUTIL_VERSION_INT,
+ };
+ 
++extern int wait_readable(void);
++
+ static int file_read(URLContext *h, unsigned char *buf, int size)
+ {
+     FileContext *c = h->priv_data;
+     int ret;
+     size = FFMIN(size, c->blocksize);
++    if (wait_readable() == 0) {
++        // Quit ffmpeg if the processing is canceled.
++        emscripten_force_exit(0);
++    }
+     ret = read(c->fd, buf, size);
+     if (ret == 0 && c->follow)
+         return AVERROR(EAGAIN);
+@@ -395,6 +403,10 @@ static int pipe_open(URLContext *h, const char *filename, int flags)
+ #endif
+     c->fd = fd;
+     h->is_streamed = 1;
++
++    // increase the packet size since file operations in WASM is emulated in
++    // JavaScript, and the context switching is expensive.
++    h->max_packet_size = 256 << 10;
+     return 0;
+ }
+ 
+diff --git a/libavformat/rawdec.c b/libavformat/rawdec.c
+index 17649bc077..38b5d80f90 100644
+--- a/libavformat/rawdec.c
++++ b/libavformat/rawdec.c
+@@ -86,6 +86,8 @@ int ff_raw_video_read_header(AVFormatContext *s)
+ 
+     st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
+     st->codecpar->codec_id = s->iformat->raw_codec_id;
++    st->codecpar->width  = s1->width;
++    st->codecpar->height = s1->height;
+     sti->need_parsing = AVSTREAM_PARSE_FULL_RAW;
+ 
+     sti->avctx->framerate = s1->framerate;
+@@ -124,6 +126,7 @@ static int raw_data_read_header(AVFormatContext *s)
+ static const AVOption rawvideo_options[] = {
+     { "framerate", "", OFFSET(framerate), AV_OPT_TYPE_VIDEO_RATE, {.str = "25"}, 0, INT_MAX, DEC},
+     { "raw_packet_size", "", OFFSET(raw_packet_size), AV_OPT_TYPE_INT, {.i64 = RAW_PACKET_SIZE }, 1, INT_MAX, DEC},
++    { "video_size", "set frame size", OFFSET(width), AV_OPT_TYPE_IMAGE_SIZE, {.str = NULL}, 0, 0, DEC },
+     { NULL },
+ };
+ #undef OFFSET
+diff --git a/libavformat/rawdec.h b/libavformat/rawdec.h
+index f843fe5a2e..152663145e 100644
+--- a/libavformat/rawdec.h
++++ b/libavformat/rawdec.h
+@@ -31,6 +31,7 @@ typedef struct FFRawVideoDemuxerContext {
+     char *video_size;         /**< String describing video size, set by a private option. */
+     char *pixel_format;       /**< Set by a private option. */
+     AVRational framerate;     /**< AVRational describing framerate, set by a private option. */
++    int width, height;        /**< Integers describing video size, set by a private option. */
+ } FFRawVideoDemuxerContext;
+ 
+ typedef struct FFRawDemuxerContext {
diff --git a/base/third_party/cityhash/patches/0000-build-bots-jumbo.patch b/base/third_party/cityhash/patches/0000-build-bots-jumbo.patch
new file mode 100644
index 0000000000000..d5a62faf77f1f
--- /dev/null
+++ b/base/third_party/cityhash/patches/0000-build-bots-jumbo.patch
@@ -0,0 +1,265 @@
+diff --git a/base/third_party/cityhash/city.cc b/base/third_party/cityhash/city.cc
+index 41cd5ee16993..22e3b4981ff5 100644
+--- a/base/third_party/cityhash/city.cc
++++ b/base/third_party/cityhash/city.cc
+@@ -27,25 +27,13 @@
+ // possible hash functions, by using SIMD instructions, or by
+ // compromising on hash quality.
+ 
+-#include "config.h"
+-#include <city.h>
++#include "city.h"
+ 
+ #include <algorithm>
+ #include <string.h>  // for memcpy and memset
+ 
+-using namespace std;
+-
+-static uint64 UNALIGNED_LOAD64(const char *p) {
+-  uint64 result;
+-  memcpy(&result, p, sizeof(result));
+-  return result;
+-}
+-
+-static uint32 UNALIGNED_LOAD32(const char *p) {
+-  uint32 result;
+-  memcpy(&result, p, sizeof(result));
+-  return result;
+-}
++using std::make_pair;
++using std::pair;
+ 
+ #ifdef _MSC_VER
+ 
+@@ -89,10 +77,19 @@ static uint32 UNALIGNED_LOAD32(const char *p) {
+ 
+ #else
+ 
+-#include <byteswap.h>
++// XXX(cavalcanti): building 'native_client' fails with this header.
++//#include <byteswap.h>
++
++// Falling back to compiler builtins instead.
++#define bswap_32(x) __builtin_bswap32(x)
++#define bswap_64(x) __builtin_bswap64(x)
+ 
+ #endif
+ 
++namespace base {
++namespace internal {
++namespace cityhash_v111 {
++
+ #ifdef WORDS_BIGENDIAN
+ #define uint32_in_expected_order(x) (bswap_32(x))
+ #define uint64_in_expected_order(x) (bswap_64(x))
+@@ -109,6 +106,18 @@ static uint32 UNALIGNED_LOAD32(const char *p) {
+ #endif
+ #endif
+ 
++static uint64 UNALIGNED_LOAD64(const char *p) {
++  uint64 result;
++  memcpy(&result, p, sizeof(result));
++  return result;
++}
++
++static uint32 UNALIGNED_LOAD32(const char *p) {
++  uint32 result;
++  memcpy(&result, p, sizeof(result));
++  return result;
++}
++
+ static uint64 Fetch64(const char *p) {
+   return uint64_in_expected_order(UNALIGNED_LOAD64(p));
+ }
+@@ -217,11 +226,11 @@ uint32 CityHash32(const char *s, size_t len) {
+   f = f * 5 + 0xe6546b64;
+   size_t iters = (len - 1) / 20;
+   do {
+-    uint32 a0 = Rotate32(Fetch32(s) * c1, 17) * c2;
+-    uint32 a1 = Fetch32(s + 4);
+-    uint32 a2 = Rotate32(Fetch32(s + 8) * c1, 17) * c2;
+-    uint32 a3 = Rotate32(Fetch32(s + 12) * c1, 17) * c2;
+-    uint32 a4 = Fetch32(s + 16);
++    a0 = Rotate32(Fetch32(s) * c1, 17) * c2;
++    a1 = Fetch32(s + 4);
++    a2 = Rotate32(Fetch32(s + 8) * c1, 17) * c2;
++    a3 = Rotate32(Fetch32(s + 12) * c1, 17) * c2;
++    a4 = Fetch32(s + 16);
+     h ^= a0;
+     h = Rotate32(h, 18);
+     h = h * 5 + 0xe6546b64;
+@@ -512,135 +521,7 @@ uint128 CityHash128(const char *s, size_t len) {
+       CityHash128WithSeed(s, len, uint128(k0, k1));
+ }
+ 
+-#ifdef __SSE4_2__
+-#include <citycrc.h>
+-#include <nmmintrin.h>
+-
+-// Requires len >= 240.
+-static void CityHashCrc256Long(const char *s, size_t len,
+-                               uint32 seed, uint64 *result) {
+-  uint64 a = Fetch64(s + 56) + k0;
+-  uint64 b = Fetch64(s + 96) + k0;
+-  uint64 c = result[0] = HashLen16(b, len);
+-  uint64 d = result[1] = Fetch64(s + 120) * k0 + len;
+-  uint64 e = Fetch64(s + 184) + seed;
+-  uint64 f = 0;
+-  uint64 g = 0;
+-  uint64 h = c + d;
+-  uint64 x = seed;
+-  uint64 y = 0;
+-  uint64 z = 0;
+-
+-  // 240 bytes of input per iter.
+-  size_t iters = len / 240;
+-  len -= iters * 240;
+-  do {
+-#undef CHUNK
+-#define CHUNK(r)                                \
+-    PERMUTE3(x, z, y);                          \
+-    b += Fetch64(s);                            \
+-    c += Fetch64(s + 8);                        \
+-    d += Fetch64(s + 16);                       \
+-    e += Fetch64(s + 24);                       \
+-    f += Fetch64(s + 32);                       \
+-    a += b;                                     \
+-    h += f;                                     \
+-    b += c;                                     \
+-    f += d;                                     \
+-    g += e;                                     \
+-    e += z;                                     \
+-    g += x;                                     \
+-    z = _mm_crc32_u64(z, b + g);                \
+-    y = _mm_crc32_u64(y, e + h);                \
+-    x = _mm_crc32_u64(x, f + a);                \
+-    e = Rotate(e, r);                           \
+-    c += e;                                     \
+-    s += 40
+-
+-    CHUNK(0); PERMUTE3(a, h, c);
+-    CHUNK(33); PERMUTE3(a, h, f);
+-    CHUNK(0); PERMUTE3(b, h, f);
+-    CHUNK(42); PERMUTE3(b, h, d);
+-    CHUNK(0); PERMUTE3(b, h, e);
+-    CHUNK(33); PERMUTE3(a, h, e);
+-  } while (--iters > 0);
+-
+-  while (len >= 40) {
+-    CHUNK(29);
+-    e ^= Rotate(a, 20);
+-    h += Rotate(b, 30);
+-    g ^= Rotate(c, 40);
+-    f += Rotate(d, 34);
+-    PERMUTE3(c, h, g);
+-    len -= 40;
+-  }
+-  if (len > 0) {
+-    s = s + len - 40;
+-    CHUNK(33);
+-    e ^= Rotate(a, 43);
+-    h += Rotate(b, 42);
+-    g ^= Rotate(c, 41);
+-    f += Rotate(d, 40);
+-  }
+-  result[0] ^= h;
+-  result[1] ^= g;
+-  g += h;
+-  a = HashLen16(a, g + z);
+-  x += y << 32;
+-  b += x;
+-  c = HashLen16(c, z) + h;
+-  d = HashLen16(d, e + result[0]);
+-  g += e;
+-  h += HashLen16(x, f);
+-  e = HashLen16(a, d) + g;
+-  z = HashLen16(b, c) + a;
+-  y = HashLen16(g, h) + c;
+-  result[0] = e + z + y + x;
+-  a = ShiftMix((a + y) * k0) * k0 + b;
+-  result[1] += a + result[0];
+-  a = ShiftMix(a * k0) * k0 + c;
+-  result[2] = a + result[1];
+-  a = ShiftMix((a + e) * k0) * k0;
+-  result[3] = a + result[2];
+-}
+-
+-// Requires len < 240.
+-static void CityHashCrc256Short(const char *s, size_t len, uint64 *result) {
+-  char buf[240];
+-  memcpy(buf, s, len);
+-  memset(buf + len, 0, 240 - len);
+-  CityHashCrc256Long(buf, 240, ~static_cast<uint32>(len), result);
+-}
++}  // namespace cityhash_v111
++}  // namespace internal
++}  // namespace base
+ 
+-void CityHashCrc256(const char *s, size_t len, uint64 *result) {
+-  if (LIKELY(len >= 240)) {
+-    CityHashCrc256Long(s, len, 0, result);
+-  } else {
+-    CityHashCrc256Short(s, len, result);
+-  }
+-}
+-
+-uint128 CityHashCrc128WithSeed(const char *s, size_t len, uint128 seed) {
+-  if (len <= 900) {
+-    return CityHash128WithSeed(s, len, seed);
+-  } else {
+-    uint64 result[4];
+-    CityHashCrc256(s, len, result);
+-    uint64 u = Uint128High64(seed) + result[0];
+-    uint64 v = Uint128Low64(seed) + result[1];
+-    return uint128(HashLen16(u, v + result[2]),
+-                   HashLen16(Rotate(v, 32), u * k0 + result[3]));
+-  }
+-}
+-
+-uint128 CityHashCrc128(const char *s, size_t len) {
+-  if (len <= 900) {
+-    return CityHash128(s, len);
+-  } else {
+-    uint64 result[4];
+-    CityHashCrc256(s, len, result);
+-    return uint128(result[2], result[3]);
+-  }
+-}
+-
+-#endif
+diff --git a/base/third_party/cityhash/city.h b/base/third_party/cityhash/city.h
+index 94499ce419c7..e4672f6d44da 100644
+--- a/base/third_party/cityhash/city.h
++++ b/base/third_party/cityhash/city.h
+@@ -59,13 +59,20 @@
+ // of a+b is easily derived from the hashes of a and b.  This property
+ // doesn't hold for any hash functions in this file.
+ 
+-#ifndef CITY_HASH_H_
+-#define CITY_HASH_H_
++#ifndef BASE_THIRD_PARTY_CITYHASH_CITY_H_
++#define BASE_THIRD_PARTY_CITYHASH_CITY_H_
+ 
+ #include <stdlib.h>  // for size_t.
+ #include <stdint.h>
+ #include <utility>
+ 
++// XXX(cavalcantii): Declaring it inside of the 'base' namespace allows to
++// handle linker symbol clash error with deprecated CityHash from
++// third_party/smhasher in a few unit tests.
++namespace base {
++namespace internal {
++namespace cityhash_v111 {
++
+ typedef uint8_t uint8;
+ typedef uint32_t uint32;
+ typedef uint64_t uint64;
+@@ -109,4 +116,8 @@ inline uint64 Hash128to64(const uint128& x) {
+   return b;
+ }
+ 
++}  // namespace cityhash_v111
++}  // namespace internal
++}  // namespace base
++
+ #endif  // CITY_HASH_H_
diff --git a/base/third_party/cityhash/patches/0001-bswap-clang.patch b/base/third_party/cityhash/patches/0001-bswap-clang.patch
new file mode 100644
index 0000000000000..1fe4043118445
--- /dev/null
+++ b/base/third_party/cityhash/patches/0001-bswap-clang.patch
@@ -0,0 +1,20 @@
+diff --git a/base/third_party/cityhash/city.cc b/base/third_party/cityhash/city.cc
+index b0d2294aabb3..2ab3db20f4fa 100644
+--- a/base/third_party/cityhash/city.cc
++++ b/base/third_party/cityhash/city.cc
+@@ -35,7 +35,14 @@
+ using std::make_pair;
+ using std::pair;
+ 
+-#ifdef _MSC_VER
++#if defined(__clang__)
++
++// Use builtins where possible. On Windows for instance, this may prevent a
++// function call instead of emitting a single instruction.
++#define bswap_32(x) __builtin_bswap32(x)
++#define bswap_64(x) __builtin_bswap64(x)
++
++#elif _MSC_VER
+ 
+ #include <stdlib.h>
+ #define bswap_32(x) _byteswap_ulong(x)
diff --git a/base/third_party/cityhash/patches/0002-warnings.patch b/base/third_party/cityhash/patches/0002-warnings.patch
new file mode 100644
index 0000000000000..7d63d8b5932b1
--- /dev/null
+++ b/base/third_party/cityhash/patches/0002-warnings.patch
@@ -0,0 +1,86 @@
+diff --git a/base/third_party/cityhash/city.cc b/base/third_party/cityhash/city.cc
+index 2ab3db20f4fa1..913d91f4c9a1b 100644
+--- a/base/third_party/cityhash/city.cc
++++ b/base/third_party/cityhash/city.cc
+@@ -181,7 +181,7 @@ static uint32 Hash32Len13to24(const char* s, size_t len) {
+   uint32 d = Fetch32(s + (len >> 1));
+   uint32 e = Fetch32(s);
+   uint32 f = Fetch32(s + len - 4);
+-  uint32 h = len;
++  uint32 h = static_cast<uint32>(len);
+ 
+   return fmix(Mur(f, Mur(e, Mur(d, Mur(c, Mur(b, Mur(a, h)))))));
+ }
+@@ -191,14 +191,14 @@ static uint32 Hash32Len0to4(const char* s, size_t len) {
+   uint32 c = 9;
+   for (size_t i = 0; i < len; i++) {
+     signed char v = s[i];
+-    b = b * c1 + v;
++    b = b * c1 + static_cast<uint32>(v);
+     c ^= b;
+   }
+-  return fmix(Mur(b, Mur(len, c)));
++  return fmix(Mur(b, Mur(static_cast<uint32>(len), c)));
+ }
+ 
+ static uint32 Hash32Len5to12(const char* s, size_t len) {
+-  uint32 a = len, b = len * 5, c = 9, d = b;
++  uint32 a = static_cast<uint32>(len), b = a * 5, c = 9, d = b;
+   a += Fetch32(s);
+   b += Fetch32(s + len - 4);
+   c += Fetch32(s + ((len >> 1) & 4));
+@@ -213,7 +213,7 @@ uint32 CityHash32(const char* s, size_t len) {
+   }
+ 
+   // len > 24
+-  uint32 h = len, g = c1 * len, f = g;
++  uint32 h = static_cast<uint32>(len), g = c1 * h, f = g;
+   uint32 a0 = Rotate32(Fetch32(s + len - 4) * c1, 17) * c2;
+   uint32 a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
+   uint32 a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
+@@ -314,11 +314,11 @@ static uint64 HashLen0to16(const char* s, size_t len) {
+     return HashLen16(len + (a << 3), Fetch32(s + len - 4), mul);
+   }
+   if (len > 0) {
+-    uint8 a = s[0];
+-    uint8 b = s[len >> 1];
+-    uint8 c = s[len - 1];
++    uint8 a = static_cast<uint8>(s[0]);
++    uint8 b = static_cast<uint8>(s[len >> 1]);
++    uint8 c = static_cast<uint8>(s[len - 1]);
+     uint32 y = static_cast<uint32>(a) + (static_cast<uint32>(b) << 8);
+-    uint32 z = len + (static_cast<uint32>(c) << 2);
++    uint32 z = static_cast<uint32>(len) + (static_cast<uint32>(c) << 2);
+     return ShiftMix(y * k2 ^ z * k0) * k2;
+   }
+   return k2;
+@@ -439,15 +439,15 @@ static uint128 CityMurmur(const char* s, size_t len, uint128 seed) {
+   uint64 b = Uint128High64(seed);
+   uint64 c = 0;
+   uint64 d = 0;
+-  signed long l = len - 16;
+-  if (l <= 0) {  // len <= 16
++  if (len <= 16) {
+     a = ShiftMix(a * k1) * k1;
+     c = b * k1 + HashLen0to16(s, len);
+     d = ShiftMix(a + (len >= 8 ? Fetch64(s) : c));
+-  } else {  // len > 16
++  } else {
+     c = HashLen16(Fetch64(s + len - 8) + k1, a);
+     d = HashLen16(b + len, c + Fetch64(s + len - 16));
+     a += d;
++    // len > 16 here, so do...while is safe
+     do {
+       a ^= ShiftMix(Fetch64(s) * k1) * k1;
+       a *= k1;
+@@ -456,8 +456,8 @@ static uint128 CityMurmur(const char* s, size_t len, uint128 seed) {
+       c *= k1;
+       d ^= c;
+       s += 16;
+-      l -= 16;
+-    } while (l > 0);
++      len -= 16;
++    } while (len > 16);
+   }
+   a = HashLen16(a, c);
+   b = HashLen16(d, b);
diff --git a/base/third_party/cityhash_v103/patches/000-remove-crc.patch b/base/third_party/cityhash_v103/patches/000-remove-crc.patch
new file mode 100644
index 0000000000000..18ed9f8430d81
--- /dev/null
+++ b/base/third_party/cityhash_v103/patches/000-remove-crc.patch
@@ -0,0 +1,122 @@
+diff --git a/base/third_party/cityhash_v103/src/city_v103.cc b/base/third_party/cityhash_v103/src/city_v103.cc
+index f1301ce49b67..0de3e16a4c0c 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.cc
++++ b/base/third_party/cityhash_v103/src/city_v103.cc
+@@ -351,117 +351,3 @@ uint128 CityHash128(const char *s, size_t len) {
+     return CityHash128WithSeed(s, len, uint128(k0, k1));
+   }
+ }
+-
+-#ifdef __SSE4_2__
+-#include <citycrc.h>
+-#include <nmmintrin.h>
+-
+-// Requires len >= 240.
+-static void CityHashCrc256Long(const char *s, size_t len,
+-                               uint32 seed, uint64 *result) {
+-  uint64 a = Fetch64(s + 56) + k0;
+-  uint64 b = Fetch64(s + 96) + k0;
+-  uint64 c = result[0] = HashLen16(b, len);
+-  uint64 d = result[1] = Fetch64(s + 120) * k0 + len;
+-  uint64 e = Fetch64(s + 184) + seed;
+-  uint64 f = seed;
+-  uint64 g = 0;
+-  uint64 h = 0;
+-  uint64 i = 0;
+-  uint64 j = 0;
+-  uint64 t = c + d;
+-
+-  // 240 bytes of input per iter.
+-  size_t iters = len / 240;
+-  len -= iters * 240;
+-  do {
+-#define CHUNK(multiplier, z)                                    \
+-    {                                                           \
+-      uint64 old_a = a;                                         \
+-      a = Rotate(b, 41 ^ z) * multiplier + Fetch64(s);          \
+-      b = Rotate(c, 27 ^ z) * multiplier + Fetch64(s + 8);      \
+-      c = Rotate(d, 41 ^ z) * multiplier + Fetch64(s + 16);     \
+-      d = Rotate(e, 33 ^ z) * multiplier + Fetch64(s + 24);     \
+-      e = Rotate(t, 25 ^ z) * multiplier + Fetch64(s + 32);     \
+-      t = old_a;                                                \
+-    }                                                           \
+-    f = _mm_crc32_u64(f, a);                                    \
+-    g = _mm_crc32_u64(g, b);                                    \
+-    h = _mm_crc32_u64(h, c);                                    \
+-    i = _mm_crc32_u64(i, d);                                    \
+-    j = _mm_crc32_u64(j, e);                                    \
+-    s += 40
+-
+-    CHUNK(1, 1); CHUNK(k0, 0);
+-    CHUNK(1, 1); CHUNK(k0, 0);
+-    CHUNK(1, 1); CHUNK(k0, 0);
+-  } while (--iters > 0);
+-
+-  while (len >= 40) {
+-    CHUNK(k0, 0);
+-    len -= 40;
+-  }
+-  if (len > 0) {
+-    s = s + len - 40;
+-    CHUNK(k0, 0);
+-  }
+-  j += i << 32;
+-  a = HashLen16(a, j);
+-  h += g << 32;
+-  b += h;
+-  c = HashLen16(c, f) + i;
+-  d = HashLen16(d, e + result[0]);
+-  j += e;
+-  i += HashLen16(h, t);
+-  e = HashLen16(a, d) + j;
+-  f = HashLen16(b, c) + a;
+-  g = HashLen16(j, i) + c;
+-  result[0] = e + f + g + h;
+-  a = ShiftMix((a + g) * k0) * k0 + b;
+-  result[1] += a + result[0];
+-  a = ShiftMix(a * k0) * k0 + c;
+-  result[2] = a + result[1];
+-  a = ShiftMix((a + e) * k0) * k0;
+-  result[3] = a + result[2];
+-}
+-
+-// Requires len < 240.
+-static void CityHashCrc256Short(const char *s, size_t len, uint64 *result) {
+-  char buf[240];
+-  memcpy(buf, s, len);
+-  memset(buf + len, 0, 240 - len);
+-  CityHashCrc256Long(buf, 240, ~static_cast<uint32>(len), result);
+-}
+-
+-void CityHashCrc256(const char *s, size_t len, uint64 *result) {
+-  if (LIKELY(len >= 240)) {
+-    CityHashCrc256Long(s, len, 0, result);
+-  } else {
+-    CityHashCrc256Short(s, len, result);
+-  }
+-}
+-
+-uint128 CityHashCrc128WithSeed(const char *s, size_t len, uint128 seed) {
+-  if (len <= 900) {
+-    return CityHash128WithSeed(s, len, seed);
+-  } else {
+-    uint64 result[4];
+-    CityHashCrc256(s, len, result);
+-    uint64 u = Uint128High64(seed) + result[0];
+-    uint64 v = Uint128Low64(seed) + result[1];
+-    return uint128(HashLen16(u, v + result[2]),
+-                   HashLen16(Rotate(v, 32), u * k0 + result[3]));
+-  }
+-}
+-
+-uint128 CityHashCrc128(const char *s, size_t len) {
+-  if (len <= 900) {
+-    return CityHash128(s, len);
+-  } else {
+-    uint64 result[4];
+-    CityHashCrc256(s, len, result);
+-    return uint128(result[2], result[3]);
+-  }
+-}
+-
+-#endif
diff --git a/base/third_party/cityhash_v103/patches/001-fix-include-paths.patch b/base/third_party/cityhash_v103/patches/001-fix-include-paths.patch
new file mode 100644
index 0000000000000..d91f3accec35a
--- /dev/null
+++ b/base/third_party/cityhash_v103/patches/001-fix-include-paths.patch
@@ -0,0 +1,14 @@
+diff --git a/base/third_party/cityhash_v103/src/city_v103.cc b/base/third_party/cityhash_v103/src/city_v103.cc
+index bd6bc1aa2c8c..e02d20fbbaf7 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.cc
++++ b/base/third_party/cityhash_v103/src/city_v103.cc
+@@ -27,8 +27,7 @@
+ // possible hash functions, by using SIMD instructions, or by
+ // compromising on hash quality.
+ 
+-#include "config.h"
+-#include <city.h>
++#include "base/third_party/cityhash_v103/src/city_v103.h"
+ 
+ #include <algorithm>
+ #include <string.h>  // for memcpy and memset
diff --git a/base/third_party/cityhash_v103/patches/002-fix-include-guards.patch b/base/third_party/cityhash_v103/patches/002-fix-include-guards.patch
new file mode 100644
index 0000000000000..0318f36d3f3f9
--- /dev/null
+++ b/base/third_party/cityhash_v103/patches/002-fix-include-guards.patch
@@ -0,0 +1,21 @@
+diff --git a/base/third_party/cityhash_v103/src/city_v103.h b/base/third_party/cityhash_v103/src/city_v103.h
+index c2ab352cb56c..398de9b6e303 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.h
++++ b/base/third_party/cityhash_v103/src/city_v103.h
+@@ -40,8 +40,8 @@
+ // of a+b is easily derived from the hashes of a and b.  This property
+ // doesn't hold for any hash functions in this file.
+ 
+-#ifndef CITY_HASH_H_
+-#define CITY_HASH_H_
++#ifndef BASE_THIRD_PARTY_CITYHASH_V103_SRC_CITY_V103_H_
++#define BASE_THIRD_PARTY_CITYHASH_V103_SRC_CITY_V103_H_
+ 
+ #include <stdlib.h>  // for size_t.
+ #include <stdint.h>
+@@ -87,4 +87,4 @@ inline uint64 Hash128to64(const uint128& x) {
+   return b;
+ }
+ 
+-#endif  // CITY_HASH_H_
++#endif  // BASE_THIRD_PARTY_CITYHASH_V103_SRC_CITY_V103_H_
diff --git a/base/third_party/cityhash_v103/patches/003-use-base.patch b/base/third_party/cityhash_v103/patches/003-use-base.patch
new file mode 100644
index 0000000000000..8649d63262d53
--- /dev/null
+++ b/base/third_party/cityhash_v103/patches/003-use-base.patch
@@ -0,0 +1,68 @@
+diff --git a/base/third_party/cityhash_v103/src/city_v103.cc b/base/third_party/cityhash_v103/src/city_v103.cc
+index 8248068209cf..1f99751c1a60 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.cc
++++ b/base/third_party/cityhash_v103/src/city_v103.cc
+@@ -32,6 +32,13 @@
+ #include <algorithm>
+ #include <string.h>  // for memcpy and memset
+ 
++#include "base/compiler_specific.h"
++#include "build/build_config.h"
++
++namespace base {
++namespace internal {
++namespace cityhash_v103 {
++
+ using namespace std;
+ 
+ static uint64 UNALIGNED_LOAD64(const char *p) {
+@@ -46,7 +53,7 @@ static uint32 UNALIGNED_LOAD32(const char *p) {
+   return result;
+ }
+ 
+-#if !defined(WORDS_BIGENDIAN)
++#if defined(ARCH_CPU_LITTLE_ENDIAN)
+ 
+ #define uint32_in_expected_order(x) (x)
+ #define uint64_in_expected_order(x) (x)
+@@ -71,7 +78,7 @@ static uint32 UNALIGNED_LOAD32(const char *p) {
+ #define uint32_in_expected_order(x) (bswap_32(x))
+ #define uint64_in_expected_order(x) (bswap_64(x))
+ 
+-#endif  // WORDS_BIGENDIAN
++#endif  // defined(ARCH_CPU_LITTLE_ENDIAN)
+ 
+ #if !defined(LIKELY)
+ #if HAVE_BUILTIN_EXPECT
+@@ -350,3 +357,7 @@ uint128 CityHash128(const char *s, size_t len) {
+     return CityHash128WithSeed(s, len, uint128(k0, k1));
+   }
+ }
++
++}  // namespace cityhash_v103
++}  // namespace internal
++}  // namespace base
+diff --git a/base/third_party/cityhash_v103/src/city_v103.h b/base/third_party/cityhash_v103/src/city_v103.h
+index 7a827fbea4ff..3828a78feb54 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.h
++++ b/base/third_party/cityhash_v103/src/city_v103.h
+@@ -47,6 +47,10 @@
+ #include <stdint.h>
+ #include <utility>
+ 
++namespace base {
++namespace internal {
++namespace cityhash_v103 {
++
+ typedef uint8_t uint8;
+ typedef uint32_t uint32;
+ typedef uint64_t uint64;
+@@ -87,4 +91,8 @@ inline uint64 Hash128to64(const uint128& x) {
+   return b;
+ }
+ 
++}  // namespace cityhash_v103
++}  // namespace internal
++}  // namespace base
++
+ #endif  // BASE_THIRD_PARTY_CITYHASH_V103_SRC_CITY_V103_H_
diff --git a/base/third_party/cityhash_v103/patches/004-google-style.patch b/base/third_party/cityhash_v103/patches/004-google-style.patch
new file mode 100644
index 0000000000000..1017031090557
--- /dev/null
+++ b/base/third_party/cityhash_v103/patches/004-google-style.patch
@@ -0,0 +1,65 @@
+diff --git a/base/third_party/cityhash_v103/src/city_v103.cc b/base/third_party/cityhash_v103/src/city_v103.cc
+index 1f99751c1a60..3451b6ffec14 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.cc
++++ b/base/third_party/cityhash_v103/src/city_v103.cc
+@@ -39,8 +39,6 @@ namespace base {
+ namespace internal {
+ namespace cityhash_v103 {
+ 
+-using namespace std;
+-
+ static uint64 UNALIGNED_LOAD64(const char *p) {
+   uint64 result;
+   memcpy(&result, p, sizeof(result));
+@@ -158,7 +156,7 @@ static uint64 HashLen17to32(const char *s, size_t len) {
+ 
+ // Return a 16-byte hash for 48 bytes.  Quick and dirty.
+ // Callers do best to use "random-looking" values for a and b.
+-static pair<uint64, uint64> WeakHashLen32WithSeeds(
++static std::pair<uint64, uint64> WeakHashLen32WithSeeds(
+     uint64 w, uint64 x, uint64 y, uint64 z, uint64 a, uint64 b) {
+   a += w;
+   b = Rotate(b + a + z, 21);
+@@ -166,11 +164,11 @@ static pair<uint64, uint64> WeakHashLen32WithSeeds(
+   a += x;
+   a += y;
+   b += Rotate(a, 44);
+-  return make_pair(a + z, b + c);
++  return std::make_pair(a + z, b + c);
+ }
+ 
+ // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
+-static pair<uint64, uint64> WeakHashLen32WithSeeds(
++static std::pair<uint64, uint64> WeakHashLen32WithSeeds(
+     const char* s, uint64 a, uint64 b) {
+   return WeakHashLen32WithSeeds(Fetch64(s),
+                                 Fetch64(s + 8),
+@@ -220,8 +218,8 @@ uint64 CityHash64(const char *s, size_t len) {
+   uint64 x = Fetch64(s + len - 40);
+   uint64 y = Fetch64(s + len - 16) + Fetch64(s + len - 56);
+   uint64 z = HashLen16(Fetch64(s + len - 48) + len, Fetch64(s + len - 24));
+-  pair<uint64, uint64> v = WeakHashLen32WithSeeds(s + len - 64, len, z);
+-  pair<uint64, uint64> w = WeakHashLen32WithSeeds(s + len - 32, y + k1, x);
++  std::pair<uint64, uint64> v = WeakHashLen32WithSeeds(s + len - 64, len, z);
++  std::pair<uint64, uint64> w = WeakHashLen32WithSeeds(s + len - 32, y + k1, x);
+   x = x * k1 + Fetch64(s);
+ 
+   // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.
+@@ -290,7 +288,7 @@ uint128 CityHash128WithSeed(const char *s, size_t len, uint128 seed) {
+ 
+   // We expect len >= 128 to be the common case.  Keep 56 bytes of state:
+   // v, w, x, y, and z.
+-  pair<uint64, uint64> v, w;
++  std::pair<uint64, uint64> v, w;
+   uint64 x = Uint128Low64(seed);
+   uint64 y = Uint128High64(seed);
+   uint64 z = len * k1;
+@@ -349,7 +347,7 @@ uint128 CityHash128(const char *s, size_t len) {
+                                uint128(Fetch64(s) ^ k3,
+                                        Fetch64(s + 8)));
+   } else if (len >= 8) {
+-    return CityHash128WithSeed(NULL,
++    return CityHash128WithSeed(nullptr,
+                                0,
+                                uint128(Fetch64(s) ^ (len * k0),
+                                        Fetch64(s + len - 8) ^ k1));
diff --git a/base/third_party/cityhash_v103/patches/005-bswap-clang.patch b/base/third_party/cityhash_v103/patches/005-bswap-clang.patch
new file mode 100644
index 0000000000000..4dd083717a988
--- /dev/null
+++ b/base/third_party/cityhash_v103/patches/005-bswap-clang.patch
@@ -0,0 +1,20 @@
+diff --git b/base/third_party/cityhash_v103/src/city_v103.cc a/base/third_party/cityhash_v103/src/city_v103.cc
+index b01f42925afe5..e2d276fabf784 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.cc
++++ b/base/third_party/cityhash_v103/src/city_v103.cc
+@@ -58,7 +58,14 @@ static uint32 UNALIGNED_LOAD32(const char* p) {
+ 
+ #else
+ 
+-#ifdef _MSC_VER
++#if defined(__clang__)
++
++// Use builtins where possible. On Windows for instance, this may prevent a
++// function call instead of emitting a single instruction.
++#define bswap_32(x) __builtin_bswap32(x)
++#define bswap_64(x) __builtin_bswap64(x)
++
++#elif _MSC_VER
+ #include <stdlib.h>
+ #define bswap_32(x) _byteswap_ulong(x)
+ #define bswap_64(x) _byteswap_uint64(x)
diff --git a/base/third_party/cityhash_v103/patches/006-warnings.patch b/base/third_party/cityhash_v103/patches/006-warnings.patch
new file mode 100644
index 0000000000000..6a0a6f0c35cff
--- /dev/null
+++ b/base/third_party/cityhash_v103/patches/006-warnings.patch
@@ -0,0 +1,59 @@
+diff --git a/base/third_party/cityhash_v103/src/city_v103.cc b/base/third_party/cityhash_v103/src/city_v103.cc
+index 4aa37301088b4..7866e6cee8187 100644
+--- a/base/third_party/cityhash_v103/src/city_v103.cc
++++ b/base/third_party/cityhash_v103/src/city_v103.cc
+@@ -117,7 +117,7 @@ static uint64 Rotate(uint64 val, int shift) {
+ // Equivalent to Rotate(), but requires the second arg to be non-zero.
+ // On x86-64, and probably others, it's possible for this to compile
+ // to a single instruction if both args are already in registers.
+-static uint64 RotateByAtLeast1(uint64 val, int shift) {
++static uint64 RotateByAtLeast1(uint64 val, size_t shift) {
+   return (val >> shift) | (val << (64 - shift));
+ }
+ 
+@@ -140,11 +140,11 @@ static uint64 HashLen0to16(const char* s, size_t len) {
+     return HashLen16(len + (a << 3), Fetch32(s + len - 4));
+   }
+   if (len > 0) {
+-    uint8 a = s[0];
+-    uint8 b = s[len >> 1];
+-    uint8 c = s[len - 1];
++    uint8 a = static_cast<uint8>(s[0]);
++    uint8 b = static_cast<uint8>(s[len >> 1]);
++    uint8 c = static_cast<uint8>(s[len - 1]);
+     uint32 y = static_cast<uint32>(a) + (static_cast<uint32>(b) << 8);
+-    uint32 z = len + (static_cast<uint32>(c) << 2);
++    uint32 z = static_cast<uint32>(len) + (static_cast<uint32>(c) << 2);
+     return ShiftMix(y * k2 ^ z * k3) * k2;
+   }
+   return k2;
+@@ -266,15 +266,15 @@ static uint128 CityMurmur(const char* s, size_t len, uint128 seed) {
+   uint64 b = Uint128High64(seed);
+   uint64 c = 0;
+   uint64 d = 0;
+-  signed long l = len - 16;
+-  if (l <= 0) {  // len <= 16
++  if (len <= 16) {
+     a = ShiftMix(a * k1) * k1;
+     c = b * k1 + HashLen0to16(s, len);
+     d = ShiftMix(a + (len >= 8 ? Fetch64(s) : c));
+-  } else {  // len > 16
++  } else {
+     c = HashLen16(Fetch64(s + len - 8) + k1, a);
+     d = HashLen16(b + len, c + Fetch64(s + len - 16));
+     a += d;
++    // len > 16 here, so do...while is safe
+     do {
+       a ^= ShiftMix(Fetch64(s) * k1) * k1;
+       a *= k1;
+@@ -283,8 +283,8 @@ static uint128 CityMurmur(const char* s, size_t len, uint128 seed) {
+       c *= k1;
+       d ^= c;
+       s += 16;
+-      l -= 16;
+-    } while (l > 0);
++      len -= 16;
++    } while (len > 16);
+   }
+   a = HashLen16(a, c);
+   b = HashLen16(d, b);
diff --git a/base/third_party/symbolize/patches/001-fix-up-includes.patch b/base/third_party/symbolize/patches/001-fix-up-includes.patch
new file mode 100644
index 0000000000000..3c6b828104750
--- /dev/null
+++ b/base/third_party/symbolize/patches/001-fix-up-includes.patch
@@ -0,0 +1,56 @@
+diff --git a/base/third_party/symbolize/demangle.h b/base/third_party/symbolize/demangle.h
+index f347b98148fb1..416f7ee153560 100644
+--- a/base/third_party/symbolize/demangle.h
++++ b/base/third_party/symbolize/demangle.h
+@@ -71,7 +71,7 @@
+ #define BASE_DEMANGLE_H_
+ 
+ #include "config.h"
+-#include <glog/logging.h>
++#include "glog/logging.h"
+ 
+ _START_GOOGLE_NAMESPACE_
+ 
+diff --git a/base/third_party/symbolize/symbolize.cc b/base/third_party/symbolize/symbolize.cc
+index f56e97c99332a..2cfd4c490cc94 100644
+--- a/base/third_party/symbolize/symbolize.cc
++++ b/base/third_party/symbolize/symbolize.cc
+@@ -132,7 +132,7 @@ _END_GOOGLE_NAMESPACE_
+ 
+ #include "symbolize.h"
+ #include "config.h"
+-#include <glog/raw_logging.h>
++#include "glog/raw_logging.h"
+ 
+ // Re-runs fn until it doesn't cause EINTR.
+ #define NO_INTR(fn)   do {} while ((fn) < 0 && errno == EINTR)
+diff --git a/base/third_party/symbolize/symbolize.h b/base/third_party/symbolize/symbolize.h
+index dcbb194c4b37e..5959e579ffc93 100644
+--- a/base/third_party/symbolize/symbolize.h
++++ b/base/third_party/symbolize/symbolize.h
+@@ -56,7 +56,7 @@
+ 
+ #include "utilities.h"
+ #include "config.h"
+-#include <glog/logging.h>
++#include "glog/logging.h"
+ 
+ #ifdef HAVE_SYMBOLIZE
+ 
+diff --git a/base/third_party/symbolize/utilities.h b/base/third_party/symbolize/utilities.h
+index 760c142c09e18..efa3a8d99856e 100644
+--- a/base/third_party/symbolize/utilities.h
++++ b/base/third_party/symbolize/utilities.h
+@@ -52,11 +52,9 @@
+ #define PRIXS __PRIS_PREFIX "X"
+ #define PRIoS __PRIS_PREFIX "o"
+ 
+-#include "base/mutex.h"  // This must go first so we get _XOPEN_SOURCE
+-
+ #include <string>
+ 
+-#include <glog/logging.h>
++#include "glog/logging.h"
+ 
+ #if defined(GLOG_OS_WINDOWS)
+ # include "port.h"
diff --git a/base/third_party/symbolize/patches/002-minimal-logging.patch b/base/third_party/symbolize/patches/002-minimal-logging.patch
new file mode 100644
index 0000000000000..2c37a4356892f
--- /dev/null
+++ b/base/third_party/symbolize/patches/002-minimal-logging.patch
@@ -0,0 +1,2135 @@
+diff --git a/base/third_party/symbolize/glog/logging.h b/base/third_party/symbolize/glog/logging.h
+index 3c9253d829d7f..46869226024da 100644
+--- a/base/third_party/symbolize/glog/logging.h
++++ b/base/third_party/symbolize/glog/logging.h
+@@ -36,1979 +36,6 @@
+ #ifndef GLOG_LOGGING_H
+ #define GLOG_LOGGING_H
+ 
+-#if 1 && __cplusplus >= 201103L
+-#include <chrono>
+-#endif
+-
+-#include <cerrno>
+-#include <cstddef>
+-#include <cstdlib>
+-#include <cstring>
+-#include <ctime>
+-#include <iosfwd>
+-#include <ostream>
+-#include <sstream>
+-#include <string>
+-#if 1
+-# include <unistd.h>
+-#endif
+-#include <vector>
+-
+-#if defined(_MSC_VER)
+-#define GLOG_MSVC_PUSH_DISABLE_WARNING(n) __pragma(warning(push)) \
+-                                     __pragma(warning(disable:n))
+-#define GLOG_MSVC_POP_WARNING() __pragma(warning(pop))
+-#else
+-#define GLOG_MSVC_PUSH_DISABLE_WARNING(n)
+-#define GLOG_MSVC_POP_WARNING()
+-#endif
+-
+-#include <glog/platform.h>
+-
+-#if 1
+-#include <glog/export.h>
+-#endif
+-
+-// We care a lot about number of bits things take up.  Unfortunately,
+-// systems define their bit-specific ints in a lot of different ways.
+-// We use our own way, and have a typedef to get there.
+-// Note: these commands below may look like "#if 1" or "#if 0", but
+-// that's because they were constructed that way at ./configure time.
+-// Look at logging.h.in to see how they're calculated (based on your config).
+-#if 1
+-#include <stdint.h>             // the normal place uint16_t is defined
+-#endif
+-#if 1
+-#include <sys/types.h>          // the normal place u_int16_t is defined
+-#endif
+-#if 1
+-#include <inttypes.h>           // a third place for uint16_t or u_int16_t
+-#endif
+-
+-#if 0
+-#include <gflags/gflags.h>
+-#endif
+-
+-#if 1 && __cplusplus >= 201103L
+-#include <atomic>
+-#elif defined(GLOG_OS_WINDOWS)
+-#include <Windows.h>
+-#endif
+-
+-namespace google {
+-
+-#if 1      // the C99 format
+-typedef int32_t int32;
+-typedef uint32_t uint32;
+-typedef int64_t int64;
+-typedef uint64_t uint64;
+-#elif 1   // the BSD format
+-typedef int32_t int32;
+-typedef u_int32_t uint32;
+-typedef int64_t int64;
+-typedef u_int64_t uint64;
+-#elif 0    // the windows (vc7) format
+-typedef __int32 int32;
+-typedef unsigned __int32 uint32;
+-typedef __int64 int64;
+-typedef unsigned __int64 uint64;
+-#else
+-#error Do not know how to define a 32-bit integer quantity on your system
+-#endif
+-
+-#if !(1)
+-typedef ptrdiff_t ssize_t;
+-#endif
+-
+-#if !(1)
+-typedef int mode_t;
+-#endif
+-
+-typedef double WallTime;
+-
+-struct GLOG_EXPORT LogMessageTime {
+-  LogMessageTime();
+-  LogMessageTime(std::tm t);
+-  LogMessageTime(std::time_t timestamp, WallTime now);
+-
+-  const time_t& timestamp() const { return timestamp_; }
+-  const int& sec() const { return time_struct_.tm_sec; }
+-  const int32_t& usec() const { return usecs_; }
+-  const int&(min)() const { return time_struct_.tm_min; }
+-  const int& hour() const { return time_struct_.tm_hour; }
+-  const int& day() const { return time_struct_.tm_mday; }
+-  const int& month() const { return time_struct_.tm_mon; }
+-  const int& year() const { return time_struct_.tm_year; }
+-  const int& dayOfWeek() const { return time_struct_.tm_wday; }
+-  const int& dayInYear() const { return time_struct_.tm_yday; }
+-  const int& dst() const { return time_struct_.tm_isdst; }
+-  const long int& gmtoff() const { return gmtoffset_; }
+-  const std::tm& tm() const { return time_struct_; }
+-
+- private:
+-  void init(const std::tm& t, std::time_t timestamp, WallTime now);
+-  std::tm time_struct_;  // Time of creation of LogMessage
+-  time_t timestamp_;     // Time of creation of LogMessage in seconds
+-  int32_t usecs_;        // Time of creation of LogMessage - microseconds part
+-  long int gmtoffset_;
+-
+-  void CalcGmtOffset();
+-};
+-
+-#ifdef GLOG_CUSTOM_PREFIX_SUPPORT
+-struct LogMessageInfo {
+-  explicit LogMessageInfo(const char* const severity_,
+-                          const char* const filename_,
+-                          const int& line_number_,
+-                          const int& thread_id_,
+-                          const LogMessageTime& time_):
+-      severity(severity_), filename(filename_), line_number(line_number_),
+-      thread_id(thread_id_), time(time_)
+-  {}
+-
+-  const char* const severity;
+-  const char* const filename;
+-  const int &line_number;
+-  const int &thread_id;
+-  const LogMessageTime& time;
+-};
+-
+-typedef void(*CustomPrefixCallback)(std::ostream& s, const LogMessageInfo& l, void* data);
+-
+-#endif
+-
+-}
+-
+-
+-// The global value of GOOGLE_STRIP_LOG. All the messages logged to
+-// LOG(XXX) with severity less than GOOGLE_STRIP_LOG will not be displayed.
+-// If it can be determined at compile time that the message will not be
+-// printed, the statement will be compiled out.
+-//
+-// Example: to strip out all INFO and WARNING messages, use the value
+-// of 2 below. To make an exception for WARNING messages from a single
+-// file, add "#define GOOGLE_STRIP_LOG 1" to that file _before_ including
+-// base/logging.h
+-#ifndef GOOGLE_STRIP_LOG
+-#define GOOGLE_STRIP_LOG 0
+-#endif
+-
+-// GCC can be told that a certain branch is not likely to be taken (for
+-// instance, a CHECK failure), and use that information in static analysis.
+-// Giving it this information can help it optimize for the common case in
+-// the absence of better information (ie. -fprofile-arcs).
+-//
+-#ifndef GOOGLE_PREDICT_BRANCH_NOT_TAKEN
+-#if 1
+-#define GOOGLE_PREDICT_BRANCH_NOT_TAKEN(x) (__builtin_expect(x, 0))
+-#else
+-#define GOOGLE_PREDICT_BRANCH_NOT_TAKEN(x) x
+-#endif
+-#endif
+-
+-#ifndef GOOGLE_PREDICT_FALSE
+-#if 1
+-#define GOOGLE_PREDICT_FALSE(x) (__builtin_expect(x, 0))
+-#else
+-#define GOOGLE_PREDICT_FALSE(x) x
+-#endif
+-#endif
+-
+-#ifndef GOOGLE_PREDICT_TRUE
+-#if 1
+-#define GOOGLE_PREDICT_TRUE(x) (__builtin_expect(!!(x), 1))
+-#else
+-#define GOOGLE_PREDICT_TRUE(x) x
+-#endif
+-#endif
+-
+-
+-// Make a bunch of macros for logging.  The way to log things is to stream
+-// things to LOG(<a particular severity level>).  E.g.,
+-//
+-//   LOG(INFO) << "Found " << num_cookies << " cookies";
+-//
+-// You can capture log messages in a string, rather than reporting them
+-// immediately:
+-//
+-//   vector<string> errors;
+-//   LOG_STRING(ERROR, &errors) << "Couldn't parse cookie #" << cookie_num;
+-//
+-// This pushes back the new error onto 'errors'; if given a NULL pointer,
+-// it reports the error via LOG(ERROR).
+-//
+-// You can also do conditional logging:
+-//
+-//   LOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
+-//
+-// You can also do occasional logging (log every n'th occurrence of an
+-// event):
+-//
+-//   LOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th cookie";
+-//
+-// The above will cause log messages to be output on the 1st, 11th, 21st, ...
+-// times it is executed.  Note that the special google::COUNTER value is used
+-// to identify which repetition is happening.
+-//
+-// You can also do occasional conditional logging (log every n'th
+-// occurrence of an event, when condition is satisfied):
+-//
+-//   LOG_IF_EVERY_N(INFO, (size > 1024), 10) << "Got the " << google::COUNTER
+-//                                           << "th big cookie";
+-//
+-// You can log messages the first N times your code executes a line. E.g.
+-//
+-//   LOG_FIRST_N(INFO, 20) << "Got the " << google::COUNTER << "th cookie";
+-//
+-// Outputs log messages for the first 20 times it is executed.
+-//
+-// Analogous SYSLOG, SYSLOG_IF, and SYSLOG_EVERY_N macros are available.
+-// These log to syslog as well as to the normal logs.  If you use these at
+-// all, you need to be aware that syslog can drastically reduce performance,
+-// especially if it is configured for remote logging!  Don't use these
+-// unless you fully understand this and have a concrete need to use them.
+-// Even then, try to minimize your use of them.
+-//
+-// There are also "debug mode" logging macros like the ones above:
+-//
+-//   DLOG(INFO) << "Found cookies";
+-//
+-//   DLOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
+-//
+-//   DLOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th cookie";
+-//
+-// All "debug mode" logging is compiled away to nothing for non-debug mode
+-// compiles.
+-//
+-// We also have
+-//
+-//   LOG_ASSERT(assertion);
+-//   DLOG_ASSERT(assertion);
+-//
+-// which is syntactic sugar for {,D}LOG_IF(FATAL, assert fails) << assertion;
+-//
+-// There are "verbose level" logging macros.  They look like
+-//
+-//   VLOG(1) << "I'm printed when you run the program with --v=1 or more";
+-//   VLOG(2) << "I'm printed when you run the program with --v=2 or more";
+-//
+-// These always log at the INFO log level (when they log at all).
+-// The verbose logging can also be turned on module-by-module.  For instance,
+-//    --vmodule=mapreduce=2,file=1,gfs*=3 --v=0
+-// will cause:
+-//   a. VLOG(2) and lower messages to be printed from mapreduce.{h,cc}
+-//   b. VLOG(1) and lower messages to be printed from file.{h,cc}
+-//   c. VLOG(3) and lower messages to be printed from files prefixed with "gfs"
+-//   d. VLOG(0) and lower messages to be printed from elsewhere
+-//
+-// The wildcarding functionality shown by (c) supports both '*' (match
+-// 0 or more characters) and '?' (match any single character) wildcards.
+-//
+-// There's also VLOG_IS_ON(n) "verbose level" condition macro. To be used as
+-//
+-//   if (VLOG_IS_ON(2)) {
+-//     // do some logging preparation and logging
+-//     // that can't be accomplished with just VLOG(2) << ...;
+-//   }
+-//
+-// There are also VLOG_IF, VLOG_EVERY_N and VLOG_IF_EVERY_N "verbose level"
+-// condition macros for sample cases, when some extra computation and
+-// preparation for logs is not needed.
+-//   VLOG_IF(1, (size > 1024))
+-//      << "I'm printed when size is more than 1024 and when you run the "
+-//         "program with --v=1 or more";
+-//   VLOG_EVERY_N(1, 10)
+-//      << "I'm printed every 10th occurrence, and when you run the program "
+-//         "with --v=1 or more. Present occurence is " << google::COUNTER;
+-//   VLOG_IF_EVERY_N(1, (size > 1024), 10)
+-//      << "I'm printed on every 10th occurence of case when size is more "
+-//         " than 1024, when you run the program with --v=1 or more. ";
+-//         "Present occurence is " << google::COUNTER;
+-//
+-// The supported severity levels for macros that allow you to specify one
+-// are (in increasing order of severity) INFO, WARNING, ERROR, and FATAL.
+-// Note that messages of a given severity are logged not only in the
+-// logfile for that severity, but also in all logfiles of lower severity.
+-// E.g., a message of severity FATAL will be logged to the logfiles of
+-// severity FATAL, ERROR, WARNING, and INFO.
+-//
+-// There is also the special severity of DFATAL, which logs FATAL in
+-// debug mode, ERROR in normal mode.
+-//
+-// Very important: logging a message at the FATAL severity level causes
+-// the program to terminate (after the message is logged).
+-//
+-// Unless otherwise specified, logs will be written to the filename
+-// "<program name>.<hostname>.<user name>.log.<severity level>.", followed
+-// by the date, time, and pid (you can't prevent the date, time, and pid
+-// from being in the filename).
+-//
+-// The logging code takes two flags:
+-//     --v=#           set the verbose level
+-//     --logtostderr   log all the messages to stderr instead of to logfiles
+-
+-// LOG LINE PREFIX FORMAT
+-//
+-// Log lines have this form:
+-//
+-//     Lyyyymmdd hh:mm:ss.uuuuuu threadid file:line] msg...
+-//
+-// where the fields are defined as follows:
+-//
+-//   L                A single character, representing the log level
+-//                    (eg 'I' for INFO)
+-//   yyyy             The year
+-//   mm               The month (zero padded; ie May is '05')
+-//   dd               The day (zero padded)
+-//   hh:mm:ss.uuuuuu  Time in hours, minutes and fractional seconds
+-//   threadid         The space-padded thread ID as returned by GetTID()
+-//                    (this matches the PID on Linux)
+-//   file             The file name
+-//   line             The line number
+-//   msg              The user-supplied message
+-//
+-// Example:
+-//
+-//   I1103 11:57:31.739339 24395 google.cc:2341] Command line: ./some_prog
+-//   I1103 11:57:31.739403 24395 google.cc:2342] Process id 24395
+-//
+-// NOTE: although the microseconds are useful for comparing events on
+-// a single machine, clocks on different machines may not be well
+-// synchronized.  Hence, use caution when comparing the low bits of
+-// timestamps from different machines.
+-
+-#pragma push_macro("DECLARE_VARIABLE")
+-#pragma push_macro("DECLARE_bool")
+-#pragma push_macro("DECLARE_string")
+-#pragma push_macro("DECLARE_int32")
+-#pragma push_macro("DECLARE_uint32")
+-
+-#ifdef DECLARE_VARIABLE
+-#undef DECLARE_VARIABLE
+-#endif
+-
+-#ifdef DECLARE_bool
+-#undef DECLARE_bool
+-#endif
+-
+-#ifdef DECLARE_string
+-#undef DECLARE_string
+-#endif
+-
+-#ifdef DECLARE_int32
+-#undef DECLARE_int32
+-#endif
+-
+-#ifdef DECLARE_uint32
+-#undef DECLARE_uint32
+-#endif
+-
+-#ifndef DECLARE_VARIABLE
+-#define DECLARE_VARIABLE(type, shorttype, name, tn)                     \
+-  namespace fL##shorttype {                                             \
+-    extern GLOG_EXPORT type FLAGS_##name;                      \
+-  }                                                                     \
+-  using fL##shorttype::FLAGS_##name
+-
+-// bool specialization
+-#define DECLARE_bool(name) \
+-  DECLARE_VARIABLE(bool, B, name, bool)
+-
+-// int32 specialization
+-#define DECLARE_int32(name) \
+-  DECLARE_VARIABLE(google::int32, I, name, int32)
+-
+-#if !defined(DECLARE_uint32)
+-// uint32 specialization
+-#define DECLARE_uint32(name) \
+-  DECLARE_VARIABLE(google::uint32, U, name, uint32)
+-#endif // !defined(DECLARE_uint32) && !(0)
+-
+-// Special case for string, because we have to specify the namespace
+-// std::string, which doesn't play nicely with our FLAG__namespace hackery.
+-#define DECLARE_string(name)                                            \
+-  namespace fLS {                                                       \
+-    extern GLOG_EXPORT std::string& FLAGS_##name;              \
+-  }                                                                     \
+-  using fLS::FLAGS_##name
+-#endif
+-
+-// Set whether appending a timestamp to the log file name
+-DECLARE_bool(timestamp_in_logfile_name);
+-
+-// Set whether log messages go to stdout instead of logfiles
+-DECLARE_bool(logtostdout);
+-
+-// Set color messages logged to stdout (if supported by terminal).
+-DECLARE_bool(colorlogtostdout);
+-
+-// Set whether log messages go to stderr instead of logfiles
+-DECLARE_bool(logtostderr);
+-
+-// Set whether log messages go to stderr in addition to logfiles.
+-DECLARE_bool(alsologtostderr);
+-
+-// Set color messages logged to stderr (if supported by terminal).
+-DECLARE_bool(colorlogtostderr);
+-
+-// Log messages at a level >= this flag are automatically sent to
+-// stderr in addition to log files.
+-DECLARE_int32(stderrthreshold);
+-
+-// Set whether the log file header should be written upon creating a file.
+-DECLARE_bool(log_file_header);
+-
+-// Set whether the log prefix should be prepended to each line of output.
+-DECLARE_bool(log_prefix);
+-
+-// Set whether the year should be included in the log prefix.
+-DECLARE_bool(log_year_in_prefix);
+-
+-// Log messages at a level <= this flag are buffered.
+-// Log messages at a higher level are flushed immediately.
+-DECLARE_int32(logbuflevel);
+-
+-// Sets the maximum number of seconds which logs may be buffered for.
+-DECLARE_int32(logbufsecs);
+-
+-// Log suppression level: messages logged at a lower level than this
+-// are suppressed.
+-DECLARE_int32(minloglevel);
+-
+-// If specified, logfiles are written into this directory instead of the
+-// default logging directory.
+-DECLARE_string(log_dir);
+-
+-// Set the log file mode.
+-DECLARE_int32(logfile_mode);
+-
+-// Sets the path of the directory into which to put additional links
+-// to the log files.
+-DECLARE_string(log_link);
+-
+-DECLARE_int32(v);  // in vlog_is_on.cc
+-
+-DECLARE_string(vmodule); // also in vlog_is_on.cc
+-
+-// Sets the maximum log file size (in MB).
+-DECLARE_uint32(max_log_size);
+-
+-// Sets whether to avoid logging to the disk if the disk is full.
+-DECLARE_bool(stop_logging_if_full_disk);
+-
+-// Use UTC time for logging
+-DECLARE_bool(log_utc_time);
+-
+-// Log messages below the GOOGLE_STRIP_LOG level will be compiled away for
+-// security reasons. See LOG(severtiy) below.
+-
+-// A few definitions of macros that don't generate much code.  Since
+-// LOG(INFO) and its ilk are used all over our code, it's
+-// better to have compact code for these operations.
+-
+-#if GOOGLE_STRIP_LOG == 0
+-#define COMPACT_GOOGLE_LOG_INFO google::LogMessage( \
+-      __FILE__, __LINE__)
+-#define LOG_TO_STRING_INFO(message) google::LogMessage( \
+-      __FILE__, __LINE__, google::GLOG_INFO, message)
+-#else
+-#define COMPACT_GOOGLE_LOG_INFO google::NullStream()
+-#define LOG_TO_STRING_INFO(message) google::NullStream()
+-#endif
+-
+-#if GOOGLE_STRIP_LOG <= 1
+-#define COMPACT_GOOGLE_LOG_WARNING google::LogMessage( \
+-      __FILE__, __LINE__, google::GLOG_WARNING)
+-#define LOG_TO_STRING_WARNING(message) google::LogMessage( \
+-      __FILE__, __LINE__, google::GLOG_WARNING, message)
+-#else
+-#define COMPACT_GOOGLE_LOG_WARNING google::NullStream()
+-#define LOG_TO_STRING_WARNING(message) google::NullStream()
+-#endif
+-
+-#if GOOGLE_STRIP_LOG <= 2
+-#define COMPACT_GOOGLE_LOG_ERROR google::LogMessage( \
+-      __FILE__, __LINE__, google::GLOG_ERROR)
+-#define LOG_TO_STRING_ERROR(message) google::LogMessage( \
+-      __FILE__, __LINE__, google::GLOG_ERROR, message)
+-#else
+-#define COMPACT_GOOGLE_LOG_ERROR google::NullStream()
+-#define LOG_TO_STRING_ERROR(message) google::NullStream()
+-#endif
+-
+-#if GOOGLE_STRIP_LOG <= 3
+-#define COMPACT_GOOGLE_LOG_FATAL google::LogMessageFatal( \
+-      __FILE__, __LINE__)
+-#define LOG_TO_STRING_FATAL(message) google::LogMessage( \
+-      __FILE__, __LINE__, google::GLOG_FATAL, message)
+-#else
+-#define COMPACT_GOOGLE_LOG_FATAL google::NullStreamFatal()
+-#define LOG_TO_STRING_FATAL(message) google::NullStreamFatal()
+-#endif
+-
+-#if defined(NDEBUG) && !defined(DCHECK_ALWAYS_ON)
+-#define DCHECK_IS_ON() 0
+-#else
+-#define DCHECK_IS_ON() 1
+-#endif
+-
+-// For DFATAL, we want to use LogMessage (as opposed to
+-// LogMessageFatal), to be consistent with the original behavior.
+-#if !DCHECK_IS_ON()
+-#define COMPACT_GOOGLE_LOG_DFATAL COMPACT_GOOGLE_LOG_ERROR
+-#elif GOOGLE_STRIP_LOG <= 3
+-#define COMPACT_GOOGLE_LOG_DFATAL google::LogMessage( \
+-      __FILE__, __LINE__, google::GLOG_FATAL)
+-#else
+-#define COMPACT_GOOGLE_LOG_DFATAL google::NullStreamFatal()
+-#endif
+-
+-#define GOOGLE_LOG_INFO(counter) google::LogMessage(__FILE__, __LINE__, google::GLOG_INFO, counter, &google::LogMessage::SendToLog)
+-#define SYSLOG_INFO(counter) \
+-  google::LogMessage(__FILE__, __LINE__, google::GLOG_INFO, counter, \
+-  &google::LogMessage::SendToSyslogAndLog)
+-#define GOOGLE_LOG_WARNING(counter)  \
+-  google::LogMessage(__FILE__, __LINE__, google::GLOG_WARNING, counter, \
+-  &google::LogMessage::SendToLog)
+-#define SYSLOG_WARNING(counter)  \
+-  google::LogMessage(__FILE__, __LINE__, google::GLOG_WARNING, counter, \
+-  &google::LogMessage::SendToSyslogAndLog)
+-#define GOOGLE_LOG_ERROR(counter)  \
+-  google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, counter, \
+-  &google::LogMessage::SendToLog)
+-#define SYSLOG_ERROR(counter)  \
+-  google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, counter, \
+-  &google::LogMessage::SendToSyslogAndLog)
+-#define GOOGLE_LOG_FATAL(counter) \
+-  google::LogMessage(__FILE__, __LINE__, google::GLOG_FATAL, counter, \
+-  &google::LogMessage::SendToLog)
+-#define SYSLOG_FATAL(counter) \
+-  google::LogMessage(__FILE__, __LINE__, google::GLOG_FATAL, counter, \
+-  &google::LogMessage::SendToSyslogAndLog)
+-#define GOOGLE_LOG_DFATAL(counter) \
+-  google::LogMessage(__FILE__, __LINE__, google::DFATAL_LEVEL, counter, \
+-  &google::LogMessage::SendToLog)
+-#define SYSLOG_DFATAL(counter) \
+-  google::LogMessage(__FILE__, __LINE__, google::DFATAL_LEVEL, counter, \
+-  &google::LogMessage::SendToSyslogAndLog)
+-
+-#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__) || defined(__CYGWIN32__)
+-// A very useful logging macro to log windows errors:
+-#define LOG_SYSRESULT(result) \
+-  if (FAILED(HRESULT_FROM_WIN32(result))) { \
+-    LPSTR message = NULL; \
+-    LPSTR msg = reinterpret_cast<LPSTR>(&message); \
+-    DWORD message_length = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | \
+-                         FORMAT_MESSAGE_FROM_SYSTEM | \
+-                         FORMAT_MESSAGE_IGNORE_INSERTS, \
+-                         0, result, 0, msg, 100, NULL); \
+-    if (message_length > 0) { \
+-      google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, 0, \
+-          &google::LogMessage::SendToLog).stream() \
+-          << reinterpret_cast<const char*>(message); \
+-      LocalFree(message); \
+-    } \
+-  }
+-#endif
+-
+-// We use the preprocessor's merging operator, "##", so that, e.g.,
+-// LOG(INFO) becomes the token GOOGLE_LOG_INFO.  There's some funny
+-// subtle difference between ostream member streaming functions (e.g.,
+-// ostream::operator<<(int) and ostream non-member streaming functions
+-// (e.g., ::operator<<(ostream&, string&): it turns out that it's
+-// impossible to stream something like a string directly to an unnamed
+-// ostream. We employ a neat hack by calling the stream() member
+-// function of LogMessage which seems to avoid the problem.
+-#define LOG(severity) COMPACT_GOOGLE_LOG_ ## severity.stream()
+-#define SYSLOG(severity) SYSLOG_ ## severity(0).stream()
+-
+-namespace google {
+-
+-// They need the definitions of integer types.
+-#include <glog/log_severity.h>
+-#include <glog/vlog_is_on.h>
+-
+-// Initialize google's logging library. You will see the program name
+-// specified by argv0 in log outputs.
+-GLOG_EXPORT void InitGoogleLogging(const char* argv0);
+-
+-#ifdef GLOG_CUSTOM_PREFIX_SUPPORT
+-GLOG_EXPORT void InitGoogleLogging(const char* argv0,
+-                                   CustomPrefixCallback prefix_callback,
+-                                   void* prefix_callback_data = NULL);
+-#endif
+-
+-// Check if google's logging library has been initialized.
+-GLOG_EXPORT bool IsGoogleLoggingInitialized();
+-
+-// Shutdown google's logging library.
+-GLOG_EXPORT void ShutdownGoogleLogging();
+-
+-#if defined(__GNUC__)
+-typedef void (*logging_fail_func_t)() __attribute__((noreturn));
+-#else
+-typedef void (*logging_fail_func_t)();
+-#endif
+-
+-// Install a function which will be called after LOG(FATAL).
+-GLOG_EXPORT void InstallFailureFunction(logging_fail_func_t fail_func);
+-
+-// Enable/Disable old log cleaner.
+-GLOG_EXPORT void EnableLogCleaner(unsigned int overdue_days);
+-GLOG_EXPORT void DisableLogCleaner();
+-GLOG_EXPORT void SetApplicationFingerprint(const std::string& fingerprint);
+-
+-class LogSink;  // defined below
+-
+-// If a non-NULL sink pointer is given, we push this message to that sink.
+-// For LOG_TO_SINK we then do normal LOG(severity) logging as well.
+-// This is useful for capturing messages and passing/storing them
+-// somewhere more specific than the global log of the process.
+-// Argument types:
+-//   LogSink* sink;
+-//   LogSeverity severity;
+-// The cast is to disambiguate NULL arguments.
+-#define LOG_TO_SINK(sink, severity) \
+-  google::LogMessage(                                    \
+-      __FILE__, __LINE__,                                               \
+-      google::GLOG_ ## severity,                         \
+-      static_cast<google::LogSink*>(sink), true).stream()
+-#define LOG_TO_SINK_BUT_NOT_TO_LOGFILE(sink, severity)                  \
+-  google::LogMessage(                                    \
+-      __FILE__, __LINE__,                                               \
+-      google::GLOG_ ## severity,                         \
+-      static_cast<google::LogSink*>(sink), false).stream()
+-
+-// If a non-NULL string pointer is given, we write this message to that string.
+-// We then do normal LOG(severity) logging as well.
+-// This is useful for capturing messages and storing them somewhere more
+-// specific than the global log of the process.
+-// Argument types:
+-//   string* message;
+-//   LogSeverity severity;
+-// The cast is to disambiguate NULL arguments.
+-// NOTE: LOG(severity) expands to LogMessage().stream() for the specified
+-// severity.
+-#define LOG_TO_STRING(severity, message) \
+-  LOG_TO_STRING_##severity(static_cast<std::string*>(message)).stream()
+-
+-// If a non-NULL pointer is given, we push the message onto the end
+-// of a vector of strings; otherwise, we report it with LOG(severity).
+-// This is handy for capturing messages and perhaps passing them back
+-// to the caller, rather than reporting them immediately.
+-// Argument types:
+-//   LogSeverity severity;
+-//   vector<string> *outvec;
+-// The cast is to disambiguate NULL arguments.
+-#define LOG_STRING(severity, outvec) \
+-  LOG_TO_STRING_##severity(static_cast<std::vector<std::string>*>(outvec)).stream()
+-
+-#define LOG_IF(severity, condition) \
+-  static_cast<void>(0),             \
+-  !(condition) ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+-#define SYSLOG_IF(severity, condition) \
+-  static_cast<void>(0),                \
+-  !(condition) ? (void) 0 : google::LogMessageVoidify() & SYSLOG(severity)
+-
+-#define LOG_ASSERT(condition)  \
+-  LOG_IF(FATAL, !(condition)) << "Assert failed: " #condition
+-#define SYSLOG_ASSERT(condition) \
+-  SYSLOG_IF(FATAL, !(condition)) << "Assert failed: " #condition
+-
+-// CHECK dies with a fatal error if condition is not true.  It is *not*
+-// controlled by DCHECK_IS_ON(), so the check will be executed regardless of
+-// compilation mode.  Therefore, it is safe to do things like:
+-//    CHECK(fp->Write(x) == 4)
+-#define CHECK(condition)  \
+-      LOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN(!(condition))) \
+-             << "Check failed: " #condition " "
+-
+-// A container for a string pointer which can be evaluated to a bool -
+-// true iff the pointer is NULL.
+-struct CheckOpString {
+-  CheckOpString(std::string* str) : str_(str) { }
+-  // No destructor: if str_ is non-NULL, we're about to LOG(FATAL),
+-  // so there's no point in cleaning up str_.
+-  operator bool() const {
+-    return GOOGLE_PREDICT_BRANCH_NOT_TAKEN(str_ != NULL);
+-  }
+-  std::string* str_;
+-};
+-
+-// Function is overloaded for integral types to allow static const
+-// integrals declared in classes and not defined to be used as arguments to
+-// CHECK* macros. It's not encouraged though.
+-template <class T>
+-inline const T&       GetReferenceableValue(const T&           t) { return t; }
+-inline char           GetReferenceableValue(char               t) { return t; }
+-inline unsigned char  GetReferenceableValue(unsigned char      t) { return t; }
+-inline signed char    GetReferenceableValue(signed char        t) { return t; }
+-inline short          GetReferenceableValue(short              t) { return t; }
+-inline unsigned short GetReferenceableValue(unsigned short     t) { return t; }
+-inline int            GetReferenceableValue(int                t) { return t; }
+-inline unsigned int   GetReferenceableValue(unsigned int       t) { return t; }
+-inline long           GetReferenceableValue(long               t) { return t; }
+-inline unsigned long  GetReferenceableValue(unsigned long      t) { return t; }
+-#if __cplusplus >= 201103L
+-inline long long      GetReferenceableValue(long long          t) { return t; }
+-inline unsigned long long GetReferenceableValue(unsigned long long t) {
+-  return t;
+-}
+-#endif
+-
+-// This is a dummy class to define the following operator.
+-struct DummyClassToDefineOperator {};
+-
+-}
+-
+-// Define global operator<< to declare using ::operator<<.
+-// This declaration will allow use to use CHECK macros for user
+-// defined classes which have operator<< (e.g., stl_logging.h).
+-inline std::ostream& operator<<(
+-    std::ostream& out, const google::DummyClassToDefineOperator&) {
+-  return out;
+-}
+-
+-namespace google {
+-
+-// This formats a value for a failing CHECK_XX statement.  Ordinarily,
+-// it uses the definition for operator<<, with a few special cases below.
+-template <typename T>
+-inline void MakeCheckOpValueString(std::ostream* os, const T& v) {
+-  (*os) << v;
+-}
+-
+-// Overrides for char types provide readable values for unprintable
+-// characters.
+-template <> GLOG_EXPORT
+-void MakeCheckOpValueString(std::ostream* os, const char& v);
+-template <> GLOG_EXPORT
+-void MakeCheckOpValueString(std::ostream* os, const signed char& v);
+-template <> GLOG_EXPORT
+-void MakeCheckOpValueString(std::ostream* os, const unsigned char& v);
+-
+-// This is required because nullptr is only present in c++ 11 and later.
+-#if 1 && __cplusplus >= 201103L
+-// Provide printable value for nullptr_t
+-template <> GLOG_EXPORT
+-void MakeCheckOpValueString(std::ostream* os, const std::nullptr_t& v);
+-#endif
+-
+-// Build the error message string. Specify no inlining for code size.
+-template <typename T1, typename T2>
+-std::string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext)
+-    __attribute__((noinline));
+-
+-namespace base {
+-namespace internal {
+-
+-// If "s" is less than base_logging::INFO, returns base_logging::INFO.
+-// If "s" is greater than base_logging::FATAL, returns
+-// base_logging::ERROR.  Otherwise, returns "s".
+-LogSeverity NormalizeSeverity(LogSeverity s);
+-
+-}  // namespace internal
+-
+-// A helper class for formatting "expr (V1 vs. V2)" in a CHECK_XX
+-// statement.  See MakeCheckOpString for sample usage.  Other
+-// approaches were considered: use of a template method (e.g.,
+-// base::BuildCheckOpString(exprtext, base::Print<T1>, &v1,
+-// base::Print<T2>, &v2), however this approach has complications
+-// related to volatile arguments and function-pointer arguments).
+-class GLOG_EXPORT CheckOpMessageBuilder {
+- public:
+-  // Inserts "exprtext" and " (" to the stream.
+-  explicit CheckOpMessageBuilder(const char *exprtext);
+-  // Deletes "stream_".
+-  ~CheckOpMessageBuilder();
+-  // For inserting the first variable.
+-  std::ostream* ForVar1() { return stream_; }
+-  // For inserting the second variable (adds an intermediate " vs. ").
+-  std::ostream* ForVar2();
+-  // Get the result (inserts the closing ")").
+-  std::string* NewString();
+-
+- private:
+-  std::ostringstream *stream_;
+-};
+-
+-}  // namespace base
+-
+-template <typename T1, typename T2>
+-std::string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {
+-  base::CheckOpMessageBuilder comb(exprtext);
+-  MakeCheckOpValueString(comb.ForVar1(), v1);
+-  MakeCheckOpValueString(comb.ForVar2(), v2);
+-  return comb.NewString();
+-}
+-
+-// Helper functions for CHECK_OP macro.
+-// The (int, int) specialization works around the issue that the compiler
+-// will not instantiate the template version of the function on values of
+-// unnamed enum type - see comment below.
+-#define DEFINE_CHECK_OP_IMPL(name, op) \
+-  template <typename T1, typename T2> \
+-  inline std::string* name##Impl(const T1& v1, const T2& v2,    \
+-                            const char* exprtext) { \
+-    if (GOOGLE_PREDICT_TRUE(v1 op v2)) return NULL; \
+-    else return MakeCheckOpString(v1, v2, exprtext); \
+-  } \
+-  inline std::string* name##Impl(int v1, int v2, const char* exprtext) { \
+-    return name##Impl<int, int>(v1, v2, exprtext); \
+-  }
+-
+-// We use the full name Check_EQ, Check_NE, etc. in case the file including
+-// base/logging.h provides its own #defines for the simpler names EQ, NE, etc.
+-// This happens if, for example, those are used as token names in a
+-// yacc grammar.
+-DEFINE_CHECK_OP_IMPL(Check_EQ, ==)  // Compilation error with CHECK_EQ(NULL, x)?
+-DEFINE_CHECK_OP_IMPL(Check_NE, !=)  // Use CHECK(x == NULL) instead.
+-DEFINE_CHECK_OP_IMPL(Check_LE, <=)
+-DEFINE_CHECK_OP_IMPL(Check_LT, < )
+-DEFINE_CHECK_OP_IMPL(Check_GE, >=)
+-DEFINE_CHECK_OP_IMPL(Check_GT, > )
+-#undef DEFINE_CHECK_OP_IMPL
+-
+-// Helper macro for binary operators.
+-// Don't use this macro directly in your code, use CHECK_EQ et al below.
+-
+-#if defined(STATIC_ANALYSIS)
+-// Only for static analysis tool to know that it is equivalent to assert
+-#define CHECK_OP_LOG(name, op, val1, val2, log) CHECK((val1) op (val2))
+-#elif DCHECK_IS_ON()
+-// In debug mode, avoid constructing CheckOpStrings if possible,
+-// to reduce the overhead of CHECK statments by 2x.
+-// Real DCHECK-heavy tests have seen 1.5x speedups.
+-
+-// The meaning of "string" might be different between now and
+-// when this macro gets invoked (e.g., if someone is experimenting
+-// with other string implementations that get defined after this
+-// file is included).  Save the current meaning now and use it
+-// in the macro.
+-typedef std::string _Check_string;
+-#define CHECK_OP_LOG(name, op, val1, val2, log)                         \
+-  while (google::_Check_string* _result =                \
+-         google::Check##name##Impl(                      \
+-             google::GetReferenceableValue(val1),        \
+-             google::GetReferenceableValue(val2),        \
+-             #val1 " " #op " " #val2))                                  \
+-    log(__FILE__, __LINE__,                                             \
+-        google::CheckOpString(_result)).stream()
+-#else
+-// In optimized mode, use CheckOpString to hint to compiler that
+-// the while condition is unlikely.
+-#define CHECK_OP_LOG(name, op, val1, val2, log)                         \
+-  while (google::CheckOpString _result =                 \
+-         google::Check##name##Impl(                      \
+-             google::GetReferenceableValue(val1),        \
+-             google::GetReferenceableValue(val2),        \
+-             #val1 " " #op " " #val2))                                  \
+-    log(__FILE__, __LINE__, _result).stream()
+-#endif  // STATIC_ANALYSIS, DCHECK_IS_ON()
+-
+-#if GOOGLE_STRIP_LOG <= 3
+-#define CHECK_OP(name, op, val1, val2) \
+-  CHECK_OP_LOG(name, op, val1, val2, google::LogMessageFatal)
+-#else
+-#define CHECK_OP(name, op, val1, val2) \
+-  CHECK_OP_LOG(name, op, val1, val2, google::NullStreamFatal)
+-#endif // STRIP_LOG <= 3
+-
+-// Equality/Inequality checks - compare two values, and log a FATAL message
+-// including the two values when the result is not as expected.  The values
+-// must have operator<<(ostream, ...) defined.
+-//
+-// You may append to the error message like so:
+-//   CHECK_NE(1, 2) << ": The world must be ending!";
+-//
+-// We are very careful to ensure that each argument is evaluated exactly
+-// once, and that anything which is legal to pass as a function argument is
+-// legal here.  In particular, the arguments may be temporary expressions
+-// which will end up being destroyed at the end of the apparent statement,
+-// for example:
+-//   CHECK_EQ(string("abc")[1], 'b');
+-//
+-// WARNING: These don't compile correctly if one of the arguments is a pointer
+-// and the other is NULL. To work around this, simply static_cast NULL to the
+-// type of the desired pointer.
+-
+-#define CHECK_EQ(val1, val2) CHECK_OP(_EQ, ==, val1, val2)
+-#define CHECK_NE(val1, val2) CHECK_OP(_NE, !=, val1, val2)
+-#define CHECK_LE(val1, val2) CHECK_OP(_LE, <=, val1, val2)
+-#define CHECK_LT(val1, val2) CHECK_OP(_LT, < , val1, val2)
+-#define CHECK_GE(val1, val2) CHECK_OP(_GE, >=, val1, val2)
+-#define CHECK_GT(val1, val2) CHECK_OP(_GT, > , val1, val2)
+-
+-// Check that the input is non NULL.  This very useful in constructor
+-// initializer lists.
+-
+-#define CHECK_NOTNULL(val) \
+-  google::CheckNotNull(__FILE__, __LINE__, "'" #val "' Must be non NULL", (val))
+-
+-// Helper functions for string comparisons.
+-// To avoid bloat, the definitions are in logging.cc.
+-#define DECLARE_CHECK_STROP_IMPL(func, expected) \
+-  GLOG_EXPORT std::string* Check##func##expected##Impl( \
+-      const char* s1, const char* s2, const char* names);
+-DECLARE_CHECK_STROP_IMPL(strcmp, true)
+-DECLARE_CHECK_STROP_IMPL(strcmp, false)
+-DECLARE_CHECK_STROP_IMPL(strcasecmp, true)
+-DECLARE_CHECK_STROP_IMPL(strcasecmp, false)
+-#undef DECLARE_CHECK_STROP_IMPL
+-
+-// Helper macro for string comparisons.
+-// Don't use this macro directly in your code, use CHECK_STREQ et al below.
+-#define CHECK_STROP(func, op, expected, s1, s2) \
+-  while (google::CheckOpString _result = \
+-         google::Check##func##expected##Impl((s1), (s2), \
+-                                     #s1 " " #op " " #s2)) \
+-    LOG(FATAL) << *_result.str_
+-
+-
+-// String (char*) equality/inequality checks.
+-// CASE versions are case-insensitive.
+-//
+-// Note that "s1" and "s2" may be temporary strings which are destroyed
+-// by the compiler at the end of the current "full expression"
+-// (e.g. CHECK_STREQ(Foo().c_str(), Bar().c_str())).
+-
+-#define CHECK_STREQ(s1, s2) CHECK_STROP(strcmp, ==, true, s1, s2)
+-#define CHECK_STRNE(s1, s2) CHECK_STROP(strcmp, !=, false, s1, s2)
+-#define CHECK_STRCASEEQ(s1, s2) CHECK_STROP(strcasecmp, ==, true, s1, s2)
+-#define CHECK_STRCASENE(s1, s2) CHECK_STROP(strcasecmp, !=, false, s1, s2)
+-
+-#define CHECK_INDEX(I,A) CHECK(I < (sizeof(A)/sizeof(A[0])))
+-#define CHECK_BOUND(B,A) CHECK(B <= (sizeof(A)/sizeof(A[0])))
+-
+-#define CHECK_DOUBLE_EQ(val1, val2)              \
+-  do {                                           \
+-    CHECK_LE((val1), (val2)+0.000000000000001L); \
+-    CHECK_GE((val1), (val2)-0.000000000000001L); \
+-  } while (0)
+-
+-#define CHECK_NEAR(val1, val2, margin)           \
+-  do {                                           \
+-    CHECK_LE((val1), (val2)+(margin));           \
+-    CHECK_GE((val1), (val2)-(margin));           \
+-  } while (0)
+-
+-// perror()..googly style!
+-//
+-// PLOG() and PLOG_IF() and PCHECK() behave exactly like their LOG* and
+-// CHECK equivalents with the addition that they postpend a description
+-// of the current state of errno to their output lines.
+-
+-#define PLOG(severity) GOOGLE_PLOG(severity, 0).stream()
+-
+-#define GOOGLE_PLOG(severity, counter)  \
+-  google::ErrnoLogMessage( \
+-      __FILE__, __LINE__, google::GLOG_ ## severity, counter, \
+-      &google::LogMessage::SendToLog)
+-
+-#define PLOG_IF(severity, condition) \
+-  static_cast<void>(0),              \
+-  !(condition) ? (void) 0 : google::LogMessageVoidify() & PLOG(severity)
+-
+-// A CHECK() macro that postpends errno if the condition is false. E.g.
+-//
+-// if (poll(fds, nfds, timeout) == -1) { PCHECK(errno == EINTR); ... }
+-#define PCHECK(condition)  \
+-      PLOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN(!(condition))) \
+-              << "Check failed: " #condition " "
+-
+-// A CHECK() macro that lets you assert the success of a function that
+-// returns -1 and sets errno in case of an error. E.g.
+-//
+-// CHECK_ERR(mkdir(path, 0700));
+-//
+-// or
+-//
+-// int fd = open(filename, flags); CHECK_ERR(fd) << ": open " << filename;
+-#define CHECK_ERR(invocation)                                          \
+-PLOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN((invocation) == -1))    \
+-        << #invocation
+-
+-// Use macro expansion to create, for each use of LOG_EVERY_N(), static
+-// variables with the __LINE__ expansion as part of the variable name.
+-#define LOG_EVERY_N_VARNAME(base, line) LOG_EVERY_N_VARNAME_CONCAT(base, line)
+-#define LOG_EVERY_N_VARNAME_CONCAT(base, line) base ## line
+-
+-#define LOG_OCCURRENCES LOG_EVERY_N_VARNAME(occurrences_, __LINE__)
+-#define LOG_OCCURRENCES_MOD_N LOG_EVERY_N_VARNAME(occurrences_mod_n_, __LINE__)
+-
+-#if 1 && __cplusplus >= 201103L
+-#define GLOG_CONSTEXPR constexpr
+-#else
+-#define GLOG_CONSTEXPR const
+-#endif
+-
+-#define LOG_TIME_PERIOD LOG_EVERY_N_VARNAME(timePeriod_, __LINE__)
+-#define LOG_PREVIOUS_TIME_RAW LOG_EVERY_N_VARNAME(previousTimeRaw_, __LINE__)
+-#define LOG_TIME_DELTA LOG_EVERY_N_VARNAME(deltaTime_, __LINE__)
+-#define LOG_CURRENT_TIME LOG_EVERY_N_VARNAME(currentTime_, __LINE__)
+-#define LOG_PREVIOUS_TIME LOG_EVERY_N_VARNAME(previousTime_, __LINE__)
+-
+-#if defined(__has_feature)
+-#  if __has_feature(thread_sanitizer)
+-#    define GLOG_SANITIZE_THREAD 1
+-#  endif
+-#endif
+-
+-#if !defined(GLOG_SANITIZE_THREAD) && defined(__SANITIZE_THREAD__) && __SANITIZE_THREAD__
+-#  define GLOG_SANITIZE_THREAD 1
+-#endif
+-
+-#if defined(GLOG_SANITIZE_THREAD)
+-#define GLOG_IFDEF_THREAD_SANITIZER(X) X
+-#else
+-#define GLOG_IFDEF_THREAD_SANITIZER(X)
+-#endif
+-
+-#if defined(GLOG_SANITIZE_THREAD)
+-} // namespace google
+-
+-// We need to identify the static variables as "benign" races
+-// to avoid noisy reports from TSAN.
+-extern "C" void AnnotateBenignRaceSized(
+-  const char *file,
+-  int line,
+-  const volatile void *mem,
+-  size_t size,
+-  const char *description);
+-
+-namespace google {
+-#endif
+-
+-#if __cplusplus >= 201103L && 1 && 1 // Have <chrono> and <atomic>
+-#define SOME_KIND_OF_LOG_EVERY_T(severity, seconds) \
+-  GLOG_CONSTEXPR std::chrono::nanoseconds LOG_TIME_PERIOD = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::duration<double>(seconds)); \
+-  static std::atomic<google::int64> LOG_PREVIOUS_TIME_RAW; \
+-  GLOG_IFDEF_THREAD_SANITIZER( \
+-          AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_TIME_PERIOD, sizeof(google::int64), "")); \
+-  GLOG_IFDEF_THREAD_SANITIZER( \
+-          AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_PREVIOUS_TIME_RAW, sizeof(google::int64), "")); \
+-  const auto LOG_CURRENT_TIME = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now().time_since_epoch()); \
+-  const auto LOG_PREVIOUS_TIME = LOG_PREVIOUS_TIME_RAW.load(std::memory_order_relaxed); \
+-  const auto LOG_TIME_DELTA = LOG_CURRENT_TIME - std::chrono::nanoseconds(LOG_PREVIOUS_TIME); \
+-  if (LOG_TIME_DELTA > LOG_TIME_PERIOD) \
+-    LOG_PREVIOUS_TIME_RAW.store(std::chrono::duration_cast<std::chrono::nanoseconds>(LOG_CURRENT_TIME).count(), std::memory_order_relaxed); \
+-  if (LOG_TIME_DELTA > LOG_TIME_PERIOD) google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity).stream()
+-#elif defined(GLOG_OS_WINDOWS)
+-#define SOME_KIND_OF_LOG_EVERY_T(severity, seconds) \
+-  GLOG_CONSTEXPR LONGLONG LOG_TIME_PERIOD = (seconds) * LONGLONG(1000000000); \
+-  static LARGE_INTEGER LOG_PREVIOUS_TIME; \
+-  LONGLONG LOG_TIME_DELTA; \
+-  { \
+-    LARGE_INTEGER currTime; \
+-    LARGE_INTEGER freq; \
+-    QueryPerformanceCounter(&currTime); \
+-    QueryPerformanceFrequency(&freq); \
+-    InterlockedCompareExchange64(&LOG_PREVIOUS_TIME.QuadPart, currTime.QuadPart, 0); \
+-    LOG_TIME_DELTA = (currTime.QuadPart - LOG_PREVIOUS_TIME.QuadPart) * LONGLONG(1000000000) / freq.QuadPart; \
+-    if (LOG_TIME_DELTA > LOG_TIME_PERIOD) InterlockedExchange64(&LOG_PREVIOUS_TIME.QuadPart, currTime.QuadPart); \
+-  } \
+-  if (LOG_TIME_DELTA > LOG_TIME_PERIOD) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity).stream()
+-#else
+-#define SOME_KIND_OF_LOG_EVERY_T(severity, seconds) \
+-  GLOG_CONSTEXPR google::int64 LOG_TIME_PERIOD(seconds * 1000000000); \
+-  static google::int64 LOG_PREVIOUS_TIME; \
+-  google::int64 LOG_TIME_DELTA = 0; \
+-  { \
+-    timespec currentTime = {}; \
+-    clock_gettime(CLOCK_MONOTONIC, &currentTime); \
+-    LOG_TIME_DELTA = (currentTime.tv_sec * 1000000000 + currentTime.tv_nsec) - LOG_PREVIOUS_TIME; \
+-  } \
+-  if (LOG_TIME_DELTA > LOG_TIME_PERIOD) __sync_add_and_fetch(&LOG_PREVIOUS_TIME, LOG_TIME_DELTA); \
+-  if (LOG_TIME_DELTA > LOG_TIME_PERIOD) google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity).stream()
+-#endif
+-
+-#if 1 && __cplusplus >= 201103L
+-#define SOME_KIND_OF_LOG_EVERY_N(severity, n, what_to_do) \
+-  static std::atomic<int> LOG_OCCURRENCES(0), LOG_OCCURRENCES_MOD_N(0); \
+-  GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+-  GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES_MOD_N, sizeof(int), "")); \
+-  ++LOG_OCCURRENCES; \
+-  if (++LOG_OCCURRENCES_MOD_N > n) LOG_OCCURRENCES_MOD_N -= n; \
+-  if (LOG_OCCURRENCES_MOD_N == 1) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#define SOME_KIND_OF_LOG_IF_EVERY_N(severity, condition, n, what_to_do) \
+-  static std::atomic<int> LOG_OCCURRENCES(0), LOG_OCCURRENCES_MOD_N(0); \
+-  GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+-  GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES_MOD_N, sizeof(int), "")); \
+-  ++LOG_OCCURRENCES; \
+-  if ((condition) && \
+-      ((LOG_OCCURRENCES_MOD_N=(LOG_OCCURRENCES_MOD_N + 1) % n) == (1 % n))) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-                 &what_to_do).stream()
+-
+-#define SOME_KIND_OF_PLOG_EVERY_N(severity, n, what_to_do) \
+-  static std::atomic<int> LOG_OCCURRENCES(0), LOG_OCCURRENCES_MOD_N(0); \
+-  GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+-  GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES_MOD_N, sizeof(int), "")); \
+-  ++LOG_OCCURRENCES; \
+-  if (++LOG_OCCURRENCES_MOD_N > n) LOG_OCCURRENCES_MOD_N -= n; \
+-  if (LOG_OCCURRENCES_MOD_N == 1) \
+-    google::ErrnoLogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#define SOME_KIND_OF_LOG_FIRST_N(severity, n, what_to_do) \
+-  static std::atomic<int> LOG_OCCURRENCES(0); \
+-  GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+-  if (LOG_OCCURRENCES <= n) \
+-    ++LOG_OCCURRENCES; \
+-  if (LOG_OCCURRENCES <= n) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#elif defined(GLOG_OS_WINDOWS)
+-
+-#define SOME_KIND_OF_LOG_EVERY_N(severity, n, what_to_do) \
+-  static volatile unsigned LOG_OCCURRENCES = 0; \
+-  static volatile unsigned LOG_OCCURRENCES_MOD_N = 0; \
+-  InterlockedIncrement(&LOG_OCCURRENCES); \
+-  if (InterlockedIncrement(&LOG_OCCURRENCES_MOD_N) > n) \
+-    InterlockedExchangeSubtract(&LOG_OCCURRENCES_MOD_N, n); \
+-  if (LOG_OCCURRENCES_MOD_N == 1) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#define SOME_KIND_OF_LOG_IF_EVERY_N(severity, condition, n, what_to_do) \
+-  static volatile unsigned LOG_OCCURRENCES = 0; \
+-  static volatile unsigned LOG_OCCURRENCES_MOD_N = 0; \
+-  InterlockedIncrement(&LOG_OCCURRENCES); \
+-  if ((condition) && \
+-    ((InterlockedIncrement(&LOG_OCCURRENCES_MOD_N), \
+-     (LOG_OCCURRENCES_MOD_N > n && InterlockedExchangeSubtract(&LOG_OCCURRENCES_MOD_N, n))), \
+-     LOG_OCCURRENCES_MOD_N == 1)) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-                 &what_to_do).stream()
+-
+-#define SOME_KIND_OF_PLOG_EVERY_N(severity, n, what_to_do) \
+-  static volatile unsigned LOG_OCCURRENCES = 0; \
+-  static volatile unsigned LOG_OCCURRENCES_MOD_N = 0; \
+-  InterlockedIncrement(&LOG_OCCURRENCES); \
+-  if (InterlockedIncrement(&LOG_OCCURRENCES_MOD_N) > n) \
+-    InterlockedExchangeSubtract(&LOG_OCCURRENCES_MOD_N, n); \
+-  if (LOG_OCCURRENCES_MOD_N == 1) \
+-    google::ErrnoLogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#define SOME_KIND_OF_LOG_FIRST_N(severity, n, what_to_do) \
+-  static volatile unsigned LOG_OCCURRENCES = 0; \
+-  if (LOG_OCCURRENCES <= n) \
+-    InterlockedIncrement(&LOG_OCCURRENCES); \
+-  if (LOG_OCCURRENCES <= n) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#else
+-
+-#define SOME_KIND_OF_LOG_EVERY_N(severity, n, what_to_do) \
+-  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+-  __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+-  if (__sync_add_and_fetch(&LOG_OCCURRENCES_MOD_N, 1) > n) \
+-    __sync_sub_and_fetch(&LOG_OCCURRENCES_MOD_N, n); \
+-  if (LOG_OCCURRENCES_MOD_N == 1) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#define SOME_KIND_OF_LOG_IF_EVERY_N(severity, condition, n, what_to_do) \
+-  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+-  __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+-  if ((condition) && \
+-      (__sync_add_and_fetch(&LOG_OCCURRENCES_MOD_N, 1) || true) && \
+-      ((LOG_OCCURRENCES_MOD_N >= n && __sync_sub_and_fetch(&LOG_OCCURRENCES_MOD_N, n)) || true) && \
+-      LOG_OCCURRENCES_MOD_N == (1 % n)) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-                 &what_to_do).stream()
+-
+-#define SOME_KIND_OF_PLOG_EVERY_N(severity, n, what_to_do) \
+-  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+-  __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+-  if (__sync_add_and_fetch(&LOG_OCCURRENCES_MOD_N, 1) > n) \
+-    __sync_sub_and_fetch(&LOG_OCCURRENCES_MOD_N, n); \
+-  if (LOG_OCCURRENCES_MOD_N == 1) \
+-    google::ErrnoLogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-
+-#define SOME_KIND_OF_LOG_FIRST_N(severity, n, what_to_do) \
+-  static int LOG_OCCURRENCES = 0; \
+-  if (LOG_OCCURRENCES <= n) \
+-    __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+-  if (LOG_OCCURRENCES <= n) \
+-    google::LogMessage( \
+-        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+-        &what_to_do).stream()
+-#endif
+-
+-namespace glog_internal_namespace_ {
+-template <bool>
+-struct CompileAssert {
+-};
+-struct CrashReason;
+-
+-// Returns true if FailureSignalHandler is installed.
+-// Needs to be exported since it's used by the signalhandler_unittest.
+-GLOG_EXPORT bool IsFailureSignalHandlerInstalled();
+-}  // namespace glog_internal_namespace_
+-
+-#define LOG_EVERY_N(severity, n)                                        \
+-  SOME_KIND_OF_LOG_EVERY_N(severity, (n), google::LogMessage::SendToLog)
+-
+-#define LOG_EVERY_T(severity, T) SOME_KIND_OF_LOG_EVERY_T(severity, (T))
+-
+-#define SYSLOG_EVERY_N(severity, n) \
+-  SOME_KIND_OF_LOG_EVERY_N(severity, (n), google::LogMessage::SendToSyslogAndLog)
+-
+-#define PLOG_EVERY_N(severity, n) \
+-  SOME_KIND_OF_PLOG_EVERY_N(severity, (n), google::LogMessage::SendToLog)
+-
+-#define LOG_FIRST_N(severity, n) \
+-  SOME_KIND_OF_LOG_FIRST_N(severity, (n), google::LogMessage::SendToLog)
+-
+-#define LOG_IF_EVERY_N(severity, condition, n) \
+-  SOME_KIND_OF_LOG_IF_EVERY_N(severity, (condition), (n), google::LogMessage::SendToLog)
+-
+-// We want the special COUNTER value available for LOG_EVERY_X()'ed messages
+-enum PRIVATE_Counter {COUNTER};
+-
+-#ifdef GLOG_NO_ABBREVIATED_SEVERITIES
+-// wingdi.h defines ERROR to be 0. When we call LOG(ERROR), it gets
+-// substituted with 0, and it expands to COMPACT_GOOGLE_LOG_0. To allow us
+-// to keep using this syntax, we define this macro to do the same thing
+-// as COMPACT_GOOGLE_LOG_ERROR.
+-#define COMPACT_GOOGLE_LOG_0 COMPACT_GOOGLE_LOG_ERROR
+-#define SYSLOG_0 SYSLOG_ERROR
+-#define LOG_TO_STRING_0 LOG_TO_STRING_ERROR
+-// Needed for LOG_IS_ON(ERROR).
+-const LogSeverity GLOG_0 = GLOG_ERROR;
+-#else
+-// Users may include windows.h after logging.h without
+-// GLOG_NO_ABBREVIATED_SEVERITIES nor WIN32_LEAN_AND_MEAN.
+-// For this case, we cannot detect if ERROR is defined before users
+-// actually use ERROR. Let's make an undefined symbol to warn users.
+-# define GLOG_ERROR_MSG ERROR_macro_is_defined_Define_GLOG_NO_ABBREVIATED_SEVERITIES_before_including_logging_h_See_the_document_for_detail
+-# define COMPACT_GOOGLE_LOG_0 GLOG_ERROR_MSG
+-# define SYSLOG_0 GLOG_ERROR_MSG
+-# define LOG_TO_STRING_0 GLOG_ERROR_MSG
+-# define GLOG_0 GLOG_ERROR_MSG
+-#endif
+-
+-// Plus some debug-logging macros that get compiled to nothing for production
+-
+-#if DCHECK_IS_ON()
+-
+-#define DLOG(severity) LOG(severity)
+-#define DVLOG(verboselevel) VLOG(verboselevel)
+-#define DLOG_IF(severity, condition) LOG_IF(severity, condition)
+-#define DLOG_EVERY_N(severity, n) LOG_EVERY_N(severity, n)
+-#define DLOG_IF_EVERY_N(severity, condition, n) \
+-  LOG_IF_EVERY_N(severity, condition, n)
+-#define DLOG_ASSERT(condition) LOG_ASSERT(condition)
+-
+-// debug-only checking.  executed if DCHECK_IS_ON().
+-#define DCHECK(condition) CHECK(condition)
+-#define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)
+-#define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)
+-#define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)
+-#define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)
+-#define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)
+-#define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)
+-#define DCHECK_NOTNULL(val) CHECK_NOTNULL(val)
+-#define DCHECK_STREQ(str1, str2) CHECK_STREQ(str1, str2)
+-#define DCHECK_STRCASEEQ(str1, str2) CHECK_STRCASEEQ(str1, str2)
+-#define DCHECK_STRNE(str1, str2) CHECK_STRNE(str1, str2)
+-#define DCHECK_STRCASENE(str1, str2) CHECK_STRCASENE(str1, str2)
+-
+-#else  // !DCHECK_IS_ON()
+-
+-#define DLOG(severity)  \
+-  static_cast<void>(0), \
+-  true ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+-
+-#define DVLOG(verboselevel)             \
+-  static_cast<void>(0),                 \
+-  (true || !VLOG_IS_ON(verboselevel)) ? \
+-      (void) 0 : google::LogMessageVoidify() & LOG(INFO)
+-
+-#define DLOG_IF(severity, condition) \
+-  static_cast<void>(0),              \
+-  (true || !(condition)) ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+-
+-#define DLOG_EVERY_N(severity, n) \
+-  static_cast<void>(0),           \
+-  true ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+-
+-#define DLOG_IF_EVERY_N(severity, condition, n) \
+-  static_cast<void>(0),                         \
+-  (true || !(condition))? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+-
+-#define DLOG_ASSERT(condition) \
+-  static_cast<void>(0),        \
+-  true ? (void) 0 : LOG_ASSERT(condition)
+-
+-// MSVC warning C4127: conditional expression is constant
+-#define DCHECK(condition) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK(condition)
+-
+-#define DCHECK_EQ(val1, val2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_EQ(val1, val2)
+-
+-#define DCHECK_NE(val1, val2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_NE(val1, val2)
+-
+-#define DCHECK_LE(val1, val2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_LE(val1, val2)
+-
+-#define DCHECK_LT(val1, val2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_LT(val1, val2)
+-
+-#define DCHECK_GE(val1, val2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_GE(val1, val2)
+-
+-#define DCHECK_GT(val1, val2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_GT(val1, val2)
+-
+-// You may see warnings in release mode if you don't use the return
+-// value of DCHECK_NOTNULL. Please just use DCHECK for such cases.
+-#define DCHECK_NOTNULL(val) (val)
+-
+-#define DCHECK_STREQ(str1, str2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_STREQ(str1, str2)
+-
+-#define DCHECK_STRCASEEQ(str1, str2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_STRCASEEQ(str1, str2)
+-
+-#define DCHECK_STRNE(str1, str2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_STRNE(str1, str2)
+-
+-#define DCHECK_STRCASENE(str1, str2) \
+-  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+-  while (false) \
+-    GLOG_MSVC_POP_WARNING() CHECK_STRCASENE(str1, str2)
+-
+-#endif  // DCHECK_IS_ON()
+-
+-// Log only in verbose mode.
+-
+-#define VLOG(verboselevel) LOG_IF(INFO, VLOG_IS_ON(verboselevel))
+-
+-#define VLOG_IF(verboselevel, condition) \
+-  LOG_IF(INFO, (condition) && VLOG_IS_ON(verboselevel))
+-
+-#define VLOG_EVERY_N(verboselevel, n) \
+-  LOG_IF_EVERY_N(INFO, VLOG_IS_ON(verboselevel), n)
+-
+-#define VLOG_IF_EVERY_N(verboselevel, condition, n) \
+-  LOG_IF_EVERY_N(INFO, (condition) && VLOG_IS_ON(verboselevel), n)
+-
+-namespace base_logging {
+-
+-// LogMessage::LogStream is a std::ostream backed by this streambuf.
+-// This class ignores overflow and leaves two bytes at the end of the
+-// buffer to allow for a '\n' and '\0'.
+-class GLOG_EXPORT LogStreamBuf : public std::streambuf {
+- public:
+-  // REQUIREMENTS: "len" must be >= 2 to account for the '\n' and '\0'.
+-  LogStreamBuf(char *buf, int len) {
+-    setp(buf, buf + len - 2);
+-  }
+-
+-  // This effectively ignores overflow.
+-  int_type overflow(int_type ch) {
+-    return ch;
+-  }
+-
+-  // Legacy public ostrstream method.
+-  size_t pcount() const { return static_cast<size_t>(pptr() - pbase()); }
+-  char* pbase() const { return std::streambuf::pbase(); }
+-};
+-
+-}  // namespace base_logging
+-
+-//
+-// This class more or less represents a particular log message.  You
+-// create an instance of LogMessage and then stream stuff to it.
+-// When you finish streaming to it, ~LogMessage is called and the
+-// full message gets streamed to the appropriate destination.
+-//
+-// You shouldn't actually use LogMessage's constructor to log things,
+-// though.  You should use the LOG() macro (and variants thereof)
+-// above.
+-class GLOG_EXPORT LogMessage {
+-public:
+-  enum {
+-    // Passing kNoLogPrefix for the line number disables the
+-    // log-message prefix. Useful for using the LogMessage
+-    // infrastructure as a printing utility. See also the --log_prefix
+-    // flag for controlling the log-message prefix on an
+-    // application-wide basis.
+-    kNoLogPrefix = -1
+-  };
+-
+-  // LogStream inherit from non-DLL-exported class (std::ostrstream)
+-  // and VC++ produces a warning for this situation.
+-  // However, MSDN says "C4275 can be ignored in Microsoft Visual C++
+-  // 2005 if you are deriving from a type in the Standard C++ Library"
+-  // http://msdn.microsoft.com/en-us/library/3tdb471s(VS.80).aspx
+-  // Let's just ignore the warning.
+-GLOG_MSVC_PUSH_DISABLE_WARNING(4275)
+-  class GLOG_EXPORT LogStream : public std::ostream {
+-GLOG_MSVC_POP_WARNING()
+-  public:
+-    LogStream(char *buf, int len, int64 ctr)
+-        : std::ostream(NULL),
+-          streambuf_(buf, len),
+-          ctr_(ctr),
+-          self_(this) {
+-      rdbuf(&streambuf_);
+-    }
+-
+-    int64 ctr() const { return ctr_; }
+-    void set_ctr(int64 ctr) { ctr_ = ctr; }
+-    LogStream* self() const { return self_; }
+-
+-    // Legacy std::streambuf methods.
+-    size_t pcount() const { return streambuf_.pcount(); }
+-    char* pbase() const { return streambuf_.pbase(); }
+-    char* str() const { return pbase(); }
+-
+-  private:
+-    LogStream(const LogStream&);
+-    LogStream& operator=(const LogStream&);
+-    base_logging::LogStreamBuf streambuf_;
+-    int64 ctr_;  // Counter hack (for the LOG_EVERY_X() macro)
+-    LogStream *self_;  // Consistency check hack
+-  };
+-
+-public:
+-  // icc 8 requires this typedef to avoid an internal compiler error.
+-  typedef void (LogMessage::*SendMethod)();
+-
+-  LogMessage(const char* file, int line, LogSeverity severity, int64 ctr,
+-             SendMethod send_method);
+-
+-  // Two special constructors that generate reduced amounts of code at
+-  // LOG call sites for common cases.
+-
+-  // Used for LOG(INFO): Implied are:
+-  // severity = INFO, ctr = 0, send_method = &LogMessage::SendToLog.
+-  //
+-  // Using this constructor instead of the more complex constructor above
+-  // saves 19 bytes per call site.
+-  LogMessage(const char* file, int line);
+-
+-  // Used for LOG(severity) where severity != INFO.  Implied
+-  // are: ctr = 0, send_method = &LogMessage::SendToLog
+-  //
+-  // Using this constructor instead of the more complex constructor above
+-  // saves 17 bytes per call site.
+-  LogMessage(const char* file, int line, LogSeverity severity);
+-
+-  // Constructor to log this message to a specified sink (if not NULL).
+-  // Implied are: ctr = 0, send_method = &LogMessage::SendToSinkAndLog if
+-  // also_send_to_log is true, send_method = &LogMessage::SendToSink otherwise.
+-  LogMessage(const char* file, int line, LogSeverity severity, LogSink* sink,
+-             bool also_send_to_log);
+-
+-  // Constructor where we also give a vector<string> pointer
+-  // for storing the messages (if the pointer is not NULL).
+-  // Implied are: ctr = 0, send_method = &LogMessage::SaveOrSendToLog.
+-  LogMessage(const char* file, int line, LogSeverity severity,
+-             std::vector<std::string>* outvec);
+-
+-  // Constructor where we also give a string pointer for storing the
+-  // message (if the pointer is not NULL).  Implied are: ctr = 0,
+-  // send_method = &LogMessage::WriteToStringAndLog.
+-  LogMessage(const char* file, int line, LogSeverity severity,
+-             std::string* message);
+-
+-  // A special constructor used for check failures
+-  LogMessage(const char* file, int line, const CheckOpString& result);
+-
+-  ~LogMessage();
+-
+-  // Flush a buffered message to the sink set in the constructor.  Always
+-  // called by the destructor, it may also be called from elsewhere if
+-  // needed.  Only the first call is actioned; any later ones are ignored.
+-  void Flush();
+-
+-  // An arbitrary limit on the length of a single log message.  This
+-  // is so that streaming can be done more efficiently.
+-  static const size_t kMaxLogMessageLen;
+-
+-  // Theses should not be called directly outside of logging.*,
+-  // only passed as SendMethod arguments to other LogMessage methods:
+-  void SendToLog();  // Actually dispatch to the logs
+-  void SendToSyslogAndLog();  // Actually dispatch to syslog and the logs
+-
+-  // Call abort() or similar to perform LOG(FATAL) crash.
+-  static void __attribute__((noreturn)) Fail();
+-
+-  std::ostream& stream();
+-
+-  int preserved_errno() const;
+-
+-  // Must be called without the log_mutex held.  (L < log_mutex)
+-  static int64 num_messages(int severity);
+-
+-  const LogMessageTime& getLogMessageTime() const;
+-
+-  struct LogMessageData;
+-
+-private:
+-  // Fully internal SendMethod cases:
+-  void SendToSinkAndLog();  // Send to sink if provided and dispatch to the logs
+-  void SendToSink();  // Send to sink if provided, do nothing otherwise.
+-
+-  // Write to string if provided and dispatch to the logs.
+-  void WriteToStringAndLog();
+-
+-  void SaveOrSendToLog();  // Save to stringvec if provided, else to logs
+-
+-  void Init(const char* file, int line, LogSeverity severity,
+-            void (LogMessage::*send_method)());
+-
+-  // Used to fill in crash information during LOG(FATAL) failures.
+-  void RecordCrashReason(glog_internal_namespace_::CrashReason* reason);
+-
+-  // Counts of messages sent at each priority:
+-  static int64 num_messages_[NUM_SEVERITIES];  // under log_mutex
+-
+-  // We keep the data in a separate struct so that each instance of
+-  // LogMessage uses less stack space.
+-  LogMessageData* allocated_;
+-  LogMessageData* data_;
+-  LogMessageTime logmsgtime_;
+-
+-  friend class LogDestination;
+-
+-  LogMessage(const LogMessage&);
+-  void operator=(const LogMessage&);
+-};
+-
+-// This class happens to be thread-hostile because all instances share
+-// a single data buffer, but since it can only be created just before
+-// the process dies, we don't worry so much.
+-class GLOG_EXPORT LogMessageFatal : public LogMessage {
+- public:
+-  LogMessageFatal(const char* file, int line);
+-  LogMessageFatal(const char* file, int line, const CheckOpString& result);
+-  __attribute__((noreturn)) ~LogMessageFatal();
+-};
+-
+-// A non-macro interface to the log facility; (useful
+-// when the logging level is not a compile-time constant).
+-inline void LogAtLevel(int const severity, std::string const &msg) {
+-  LogMessage(__FILE__, __LINE__, severity).stream() << msg;
+-}
+-
+-// A macro alternative of LogAtLevel. New code may want to use this
+-// version since there are two advantages: 1. this version outputs the
+-// file name and the line number where this macro is put like other
+-// LOG macros, 2. this macro can be used as C++ stream.
+-#define LOG_AT_LEVEL(severity) google::LogMessage(__FILE__, __LINE__, severity).stream()
+-
+-// Check if it's compiled in C++11 mode.
+-//
+-// GXX_EXPERIMENTAL_CXX0X is defined by gcc and clang up to at least
+-// gcc-4.7 and clang-3.1 (2011-12-13).  __cplusplus was defined to 1
+-// in gcc before 4.7 (Crosstool 16) and clang before 3.1, but is
+-// defined according to the language version in effect thereafter.
+-// Microsoft Visual Studio 14 (2015) sets __cplusplus==199711 despite
+-// reasonably good C++11 support, so we set LANG_CXX for it and
+-// newer versions (_MSC_VER >= 1900).
+-#if (defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L || \
+-     (defined(_MSC_VER) && _MSC_VER >= 1900)) && !defined(__UCLIBCXX_MAJOR__)
+-// Helper for CHECK_NOTNULL().
+-//
+-// In C++11, all cases can be handled by a single function. Since the value
+-// category of the argument is preserved (also for rvalue references),
+-// member initializer lists like the one below will compile correctly:
+-//
+-//   Foo()
+-//     : x_(CHECK_NOTNULL(MethodReturningUniquePtr())) {}
+-template <typename T>
+-T CheckNotNull(const char* file, int line, const char* names, T&& t) {
+- if (t == nullptr) {
+-   LogMessageFatal(file, line, new std::string(names));
+- }
+- return std::forward<T>(t);
+-}
+-
+-#else
+-
+-// A small helper for CHECK_NOTNULL().
+-template <typename T>
+-T* CheckNotNull(const char *file, int line, const char *names, T* t) {
+-  if (t == NULL) {
+-    LogMessageFatal(file, line, new std::string(names));
+-  }
+-  return t;
+-}
+-#endif
+-
+-// Allow folks to put a counter in the LOG_EVERY_X()'ed messages. This
+-// only works if ostream is a LogStream. If the ostream is not a
+-// LogStream you'll get an assert saying as much at runtime.
+-GLOG_EXPORT std::ostream& operator<<(std::ostream &os,
+-                                              const PRIVATE_Counter&);
+-
+-
+-// Derived class for PLOG*() above.
+-class GLOG_EXPORT ErrnoLogMessage : public LogMessage {
+- public:
+-  ErrnoLogMessage(const char* file, int line, LogSeverity severity, int64 ctr,
+-                  void (LogMessage::*send_method)());
+-
+-  // Postpends ": strerror(errno) [errno]".
+-  ~ErrnoLogMessage();
+-
+- private:
+-  ErrnoLogMessage(const ErrnoLogMessage&);
+-  void operator=(const ErrnoLogMessage&);
+-};
+-
+-
+-// This class is used to explicitly ignore values in the conditional
+-// logging macros.  This avoids compiler warnings like "value computed
+-// is not used" and "statement has no effect".
+-
+-class GLOG_EXPORT LogMessageVoidify {
+- public:
+-  LogMessageVoidify() { }
+-  // This has to be an operator with a precedence lower than << but
+-  // higher than ?:
+-  void operator&(std::ostream&) { }
+-};
+-
+-
+-// Flushes all log files that contains messages that are at least of
+-// the specified severity level.  Thread-safe.
+-GLOG_EXPORT void FlushLogFiles(LogSeverity min_severity);
+-
+-// Flushes all log files that contains messages that are at least of
+-// the specified severity level. Thread-hostile because it ignores
+-// locking -- used for catastrophic failures.
+-GLOG_EXPORT void FlushLogFilesUnsafe(LogSeverity min_severity);
+-
+-//
+-// Set the destination to which a particular severity level of log
+-// messages is sent.  If base_filename is "", it means "don't log this
+-// severity".  Thread-safe.
+-//
+-GLOG_EXPORT void SetLogDestination(LogSeverity severity,
+-                                            const char* base_filename);
+-
+-//
+-// Set the basename of the symlink to the latest log file at a given
+-// severity.  If symlink_basename is empty, do not make a symlink.  If
+-// you don't call this function, the symlink basename is the
+-// invocation name of the program.  Thread-safe.
+-//
+-GLOG_EXPORT void SetLogSymlink(LogSeverity severity,
+-                                        const char* symlink_basename);
+-
+-//
+-// Used to send logs to some other kind of destination
+-// Users should subclass LogSink and override send to do whatever they want.
+-// Implementations must be thread-safe because a shared instance will
+-// be called from whichever thread ran the LOG(XXX) line.
+-class GLOG_EXPORT LogSink {
+- public:
+-  virtual ~LogSink();
+-
+-  // Sink's logging logic (message_len is such as to exclude '\n' at the end).
+-  // This method can't use LOG() or CHECK() as logging system mutex(s) are held
+-  // during this call.
+-  virtual void send(LogSeverity severity, const char* full_filename,
+-                    const char* base_filename, int line,
+-                    const LogMessageTime& logmsgtime, const char* message,
+-                    size_t message_len);
+-  // Provide an overload for compatibility purposes
+-  GLOG_DEPRECATED
+-  virtual void send(LogSeverity severity, const char* full_filename,
+-                    const char* base_filename, int line, const std::tm* t,
+-                    const char* message, size_t message_len);
+-
+-  // Redefine this to implement waiting for
+-  // the sink's logging logic to complete.
+-  // It will be called after each send() returns,
+-  // but before that LogMessage exits or crashes.
+-  // By default this function does nothing.
+-  // Using this function one can implement complex logic for send()
+-  // that itself involves logging; and do all this w/o causing deadlocks and
+-  // inconsistent rearrangement of log messages.
+-  // E.g. if a LogSink has thread-specific actions, the send() method
+-  // can simply add the message to a queue and wake up another thread that
+-  // handles real logging while itself making some LOG() calls;
+-  // WaitTillSent() can be implemented to wait for that logic to complete.
+-  // See our unittest for an example.
+-  virtual void WaitTillSent();
+-
+-  // Returns the normal text output of the log message.
+-  // Can be useful to implement send().
+-  static std::string ToString(LogSeverity severity, const char* file, int line,
+-                              const LogMessageTime &logmsgtime,
+-                              const char* message, size_t message_len);
+-};
+-
+-// Add or remove a LogSink as a consumer of logging data.  Thread-safe.
+-GLOG_EXPORT void AddLogSink(LogSink *destination);
+-GLOG_EXPORT void RemoveLogSink(LogSink *destination);
+-
+-//
+-// Specify an "extension" added to the filename specified via
+-// SetLogDestination.  This applies to all severity levels.  It's
+-// often used to append the port we're listening on to the logfile
+-// name.  Thread-safe.
+-//
+-GLOG_EXPORT void SetLogFilenameExtension(
+-    const char* filename_extension);
+-
+-//
+-// Make it so that all log messages of at least a particular severity
+-// are logged to stderr (in addition to logging to the usual log
+-// file(s)).  Thread-safe.
+-//
+-GLOG_EXPORT void SetStderrLogging(LogSeverity min_severity);
+-
+-//
+-// Make it so that all log messages go only to stderr.  Thread-safe.
+-//
+-GLOG_EXPORT void LogToStderr();
+-
+-//
+-// Make it so that all log messages of at least a particular severity are
+-// logged via email to a list of addresses (in addition to logging to the
+-// usual log file(s)).  The list of addresses is just a string containing
+-// the email addresses to send to (separated by spaces, say).  Thread-safe.
+-//
+-GLOG_EXPORT void SetEmailLogging(LogSeverity min_severity,
+-                                          const char* addresses);
+-
+-// A simple function that sends email. dest is a commma-separated
+-// list of addressess.  Thread-safe.
+-GLOG_EXPORT bool SendEmail(const char* dest, const char* subject,
+-                           const char* body);
+-
+-GLOG_EXPORT const std::vector<std::string>& GetLoggingDirectories();
+-
+-// For tests only:  Clear the internal [cached] list of logging directories to
+-// force a refresh the next time GetLoggingDirectories is called.
+-// Thread-hostile.
+-void TestOnly_ClearLoggingDirectoriesList();
+-
+-// Returns a set of existing temporary directories, which will be a
+-// subset of the directories returned by GetLoggingDirectories().
+-// Thread-safe.
+-GLOG_EXPORT void GetExistingTempDirectories(
+-    std::vector<std::string>* list);
+-
+-// Print any fatal message again -- useful to call from signal handler
+-// so that the last thing in the output is the fatal message.
+-// Thread-hostile, but a race is unlikely.
+-GLOG_EXPORT void ReprintFatalMessage();
+-
+-// Truncate a log file that may be the append-only output of multiple
+-// processes and hence can't simply be renamed/reopened (typically a
+-// stdout/stderr).  If the file "path" is > "limit" bytes, copy the
+-// last "keep" bytes to offset 0 and truncate the rest. Since we could
+-// be racing with other writers, this approach has the potential to
+-// lose very small amounts of data. For security, only follow symlinks
+-// if the path is /proc/self/fd/*
+-GLOG_EXPORT void TruncateLogFile(const char* path, uint64 limit, uint64 keep);
+-
+-// Truncate stdout and stderr if they are over the value specified by
+-// --max_log_size; keep the final 1MB.  This function has the same
+-// race condition as TruncateLogFile.
+-GLOG_EXPORT void TruncateStdoutStderr();
+-
+-// Return the string representation of the provided LogSeverity level.
+-// Thread-safe.
+-GLOG_EXPORT const char* GetLogSeverityName(LogSeverity severity);
+-
+-// ---------------------------------------------------------------------
+-// Implementation details that are not useful to most clients
+-// ---------------------------------------------------------------------
+-
+-// A Logger is the interface used by logging modules to emit entries
+-// to a log.  A typical implementation will dump formatted data to a
+-// sequence of files.  We also provide interfaces that will forward
+-// the data to another thread so that the invoker never blocks.
+-// Implementations should be thread-safe since the logging system
+-// will write to them from multiple threads.
+-
+-namespace base {
+-
+-class GLOG_EXPORT Logger {
+- public:
+-  virtual ~Logger();
+-
+-  // Writes "message[0,message_len-1]" corresponding to an event that
+-  // occurred at "timestamp".  If "force_flush" is true, the log file
+-  // is flushed immediately.
+-  //
+-  // The input message has already been formatted as deemed
+-  // appropriate by the higher level logging facility.  For example,
+-  // textual log messages already contain timestamps, and the
+-  // file:linenumber header.
+-  virtual void Write(bool force_flush,
+-                     time_t timestamp,
+-                     const char* message,
+-                     size_t message_len) = 0;
+-
+-  // Flush any buffered messages
+-  virtual void Flush() = 0;
+-
+-  // Get the current LOG file size.
+-  // The returned value is approximate since some
+-  // logged data may not have been flushed to disk yet.
+-  virtual uint32 LogSize() = 0;
+-};
+-
+-// Get the logger for the specified severity level.  The logger
+-// remains the property of the logging module and should not be
+-// deleted by the caller.  Thread-safe.
+-extern GLOG_EXPORT Logger* GetLogger(LogSeverity level);
+-
+-// Set the logger for the specified severity level.  The logger
+-// becomes the property of the logging module and should not
+-// be deleted by the caller.  Thread-safe.
+-extern GLOG_EXPORT void SetLogger(LogSeverity level, Logger* logger);
+-
+-}
+-
+-// glibc has traditionally implemented two incompatible versions of
+-// strerror_r(). There is a poorly defined convention for picking the
+-// version that we want, but it is not clear whether it even works with
+-// all versions of glibc.
+-// So, instead, we provide this wrapper that automatically detects the
+-// version that is in use, and then implements POSIX semantics.
+-// N.B. In addition to what POSIX says, we also guarantee that "buf" will
+-// be set to an empty string, if this function failed. This means, in most
+-// cases, you do not need to check the error code and you can directly
+-// use the value of "buf". It will never have an undefined value.
+-// DEPRECATED: Use StrError(int) instead.
+-GLOG_EXPORT int posix_strerror_r(int err, char *buf, size_t len);
+-
+-// A thread-safe replacement for strerror(). Returns a string describing the
+-// given POSIX error code.
+-GLOG_EXPORT std::string StrError(int err);
+-
+-// A class for which we define operator<<, which does nothing.
+-class GLOG_EXPORT NullStream : public LogMessage::LogStream {
+- public:
+-  // Initialize the LogStream so the messages can be written somewhere
+-  // (they'll never be actually displayed). This will be needed if a
+-  // NullStream& is implicitly converted to LogStream&, in which case
+-  // the overloaded NullStream::operator<< will not be invoked.
+-  NullStream() : LogMessage::LogStream(message_buffer_, 1, 0) { }
+-  NullStream(const char* /*file*/, int /*line*/,
+-             const CheckOpString& /*result*/) :
+-      LogMessage::LogStream(message_buffer_, 1, 0) { }
+-  NullStream &stream() { return *this; }
+- private:
+-  // A very short buffer for messages (which we discard anyway). This
+-  // will be needed if NullStream& converted to LogStream& (e.g. as a
+-  // result of a conditional expression).
+-  char message_buffer_[2];
+-};
+-
+-// Do nothing. This operator is inline, allowing the message to be
+-// compiled away. The message will not be compiled away if we do
+-// something like (flag ? LOG(INFO) : LOG(ERROR)) << message; when
+-// SKIP_LOG=WARNING. In those cases, NullStream will be implicitly
+-// converted to LogStream and the message will be computed and then
+-// quietly discarded.
+-template<class T>
+-inline NullStream& operator<<(NullStream &str, const T &) { return str; }
+-
+-// Similar to NullStream, but aborts the program (without stack
+-// trace), like LogMessageFatal.
+-class GLOG_EXPORT NullStreamFatal : public NullStream {
+- public:
+-  NullStreamFatal() { }
+-  NullStreamFatal(const char* file, int line, const CheckOpString& result) :
+-      NullStream(file, line, result) { }
+-#if defined(_MSC_VER)
+-#pragma warning(push)
+-#pragma warning(disable : 4722)
+-#endif // _MSC_VER
+-  __attribute__((noreturn)) ~NullStreamFatal() throw () { _exit(EXIT_FAILURE); }
+-#if defined(_MSC_VER)
+-#pragma warning(pop)
+-#endif // _MSC_VER
+-};
+-
+-// Install a signal handler that will dump signal information and a stack
+-// trace when the program crashes on certain signals.  We'll install the
+-// signal handler for the following signals.
+-//
+-// SIGSEGV, SIGILL, SIGFPE, SIGABRT, SIGBUS, and SIGTERM.
+-//
+-// By default, the signal handler will write the failure dump to the
+-// standard error.  You can customize the destination by installing your
+-// own writer function by InstallFailureWriter() below.
+-//
+-// Note on threading:
+-//
+-// The function should be called before threads are created, if you want
+-// to use the failure signal handler for all threads.  The stack trace
+-// will be shown only for the thread that receives the signal.  In other
+-// words, stack traces of other threads won't be shown.
+-GLOG_EXPORT void InstallFailureSignalHandler();
+-
+-// Installs a function that is used for writing the failure dump.  "data"
+-// is the pointer to the beginning of a message to be written, and "size"
+-// is the size of the message.  You should not expect the data is
+-// terminated with '\0'.
+-GLOG_EXPORT void InstallFailureWriter(
+-    void (*writer)(const char* data, size_t size));
+-
+-}
+-
+-#pragma pop_macro("DECLARE_VARIABLE")
+-#pragma pop_macro("DECLARE_bool")
+-#pragma pop_macro("DECLARE_string")
+-#pragma pop_macro("DECLARE_int32")
+-#pragma pop_macro("DECLARE_uint32")
++// Not needed in Chrome.
+ 
+ #endif // GLOG_LOGGING_H
+diff --git a/base/third_party/symbolize/glog/raw_logging.h b/base/third_party/symbolize/glog/raw_logging.h
+index eda5fb456aee1..74619b9a0be7d 100644
+--- a/base/third_party/symbolize/glog/raw_logging.h
++++ b/base/third_party/symbolize/glog/raw_logging.h
+@@ -36,144 +36,6 @@
+ #ifndef GLOG_RAW_LOGGING_H
+ #define GLOG_RAW_LOGGING_H
+ 
+-#include <ctime>
+-
+-namespace google {
+-
+-#include <glog/log_severity.h>
+-#include <glog/logging.h>
+-#include <glog/vlog_is_on.h>
+-
+-#if defined(__GNUC__)
+-#pragma GCC diagnostic push
+-#pragma GCC diagnostic ignored "-Wvariadic-macros"
+-#endif
+-
+-// This is similar to LOG(severity) << format... and VLOG(level) << format..,
+-// but
+-// * it is to be used ONLY by low-level modules that can't use normal LOG()
+-// * it is desiged to be a low-level logger that does not allocate any
+-//   memory and does not need any locks, hence:
+-// * it logs straight and ONLY to STDERR w/o buffering
+-// * it uses an explicit format and arguments list
+-// * it will silently chop off really long message strings
+-// Usage example:
+-//   RAW_LOG(ERROR, "Failed foo with %i: %s", status, error);
+-//   RAW_VLOG(3, "status is %i", status);
+-// These will print an almost standard log lines like this to stderr only:
+-//   E20200821 211317 file.cc:123] RAW: Failed foo with 22: bad_file
+-//   I20200821 211317 file.cc:142] RAW: status is 20
+-#define RAW_LOG(severity, ...) \
+-  do { \
+-    switch (google::GLOG_ ## severity) {  \
+-      case 0: \
+-        RAW_LOG_INFO(__VA_ARGS__); \
+-        break; \
+-      case 1: \
+-        RAW_LOG_WARNING(__VA_ARGS__); \
+-        break; \
+-      case 2: \
+-        RAW_LOG_ERROR(__VA_ARGS__); \
+-        break; \
+-      case 3: \
+-        RAW_LOG_FATAL(__VA_ARGS__); \
+-        break; \
+-      default: \
+-        break; \
+-    } \
+-  } while (0)
+-
+-// The following STRIP_LOG testing is performed in the header file so that it's
+-// possible to completely compile out the logging code and the log messages.
+-#if !defined(STRIP_LOG) || STRIP_LOG == 0
+-#define RAW_VLOG(verboselevel, ...) \
+-  do { \
+-    if (VLOG_IS_ON(verboselevel)) { \
+-      RAW_LOG_INFO(__VA_ARGS__); \
+-    } \
+-  } while (0)
+-#else
+-#define RAW_VLOG(verboselevel, ...) RawLogStub__(0, __VA_ARGS__)
+-#endif // STRIP_LOG == 0
+-
+-#if !defined(STRIP_LOG) || STRIP_LOG == 0
+-#define RAW_LOG_INFO(...) google::RawLog__(google::GLOG_INFO, \
+-                                   __FILE__, __LINE__, __VA_ARGS__)
+-#else
+-#define RAW_LOG_INFO(...) google::RawLogStub__(0, __VA_ARGS__)
+-#endif // STRIP_LOG == 0
+-
+-#if !defined(STRIP_LOG) || STRIP_LOG <= 1
+-#define RAW_LOG_WARNING(...) google::RawLog__(google::GLOG_WARNING,   \
+-                                      __FILE__, __LINE__, __VA_ARGS__)
+-#else
+-#define RAW_LOG_WARNING(...) google::RawLogStub__(0, __VA_ARGS__)
+-#endif // STRIP_LOG <= 1
+-
+-#if !defined(STRIP_LOG) || STRIP_LOG <= 2
+-#define RAW_LOG_ERROR(...) google::RawLog__(google::GLOG_ERROR,       \
+-                                    __FILE__, __LINE__, __VA_ARGS__)
+-#else
+-#define RAW_LOG_ERROR(...) google::RawLogStub__(0, __VA_ARGS__)
+-#endif // STRIP_LOG <= 2
+-
+-#if !defined(STRIP_LOG) || STRIP_LOG <= 3
+-#define RAW_LOG_FATAL(...) google::RawLog__(google::GLOG_FATAL,       \
+-                                    __FILE__, __LINE__, __VA_ARGS__)
+-#else
+-#define RAW_LOG_FATAL(...) \
+-  do { \
+-    google::RawLogStub__(0, __VA_ARGS__);        \
+-    exit(EXIT_FAILURE); \
+-  } while (0)
+-#endif // STRIP_LOG <= 3
+-
+-// Similar to CHECK(condition) << message,
+-// but for low-level modules: we use only RAW_LOG that does not allocate memory.
+-// We do not want to provide args list here to encourage this usage:
+-//   if (!cond)  RAW_LOG(FATAL, "foo ...", hard_to_compute_args);
+-// so that the args are not computed when not needed.
+-#define RAW_CHECK(condition, message)                                   \
+-  do {                                                                  \
+-    if (!(condition)) {                                                 \
+-      RAW_LOG(FATAL, "Check %s failed: %s", #condition, message);       \
+-    }                                                                   \
+-  } while (0)
+-
+-// Debug versions of RAW_LOG and RAW_CHECK
+-#ifndef NDEBUG
+-
+-#define RAW_DLOG(severity, ...) RAW_LOG(severity, __VA_ARGS__)
+-#define RAW_DCHECK(condition, message) RAW_CHECK(condition, message)
+-
+-#else  // NDEBUG
+-
+-#define RAW_DLOG(severity, ...)                                 \
+-  while (false)                                                 \
+-    RAW_LOG(severity, __VA_ARGS__)
+-#define RAW_DCHECK(condition, message) \
+-  while (false) \
+-    RAW_CHECK(condition, message)
+-
+-#endif  // NDEBUG
+-
+-#if defined(__GNUC__)
+-#pragma GCC diagnostic pop
+-#endif
+-
+-// Stub log function used to work around for unused variable warnings when
+-// building with STRIP_LOG > 0.
+-static inline void RawLogStub__(int /* ignored */, ...) {
+-}
+-
+-// Helper function to implement RAW_LOG and RAW_VLOG
+-// Logs format... at "severity" level, reporting it
+-// as called from file:line.
+-// This does not allocate memory or acquire locks.
+-GLOG_EXPORT void RawLog__(LogSeverity severity, const char* file, int line,
+-                          const char* format, ...)
+-    __attribute__((__format__(__printf__, 4, 5)));
+-
+-}
++#define RAW_LOG(...)  // Do nothing.
+ 
+ #endif  // GLOG_RAW_LOGGING_H
diff --git a/base/third_party/symbolize/patches/003-minimal-utilities.patch b/base/third_party/symbolize/patches/003-minimal-utilities.patch
new file mode 100644
index 0000000000000..53c65a431b829
--- /dev/null
+++ b/base/third_party/symbolize/patches/003-minimal-utilities.patch
@@ -0,0 +1,184 @@
+diff --git a/base/third_party/symbolize/utilities.h b/base/third_party/symbolize/utilities.h
+index efa3a8d99856e..8c61380fad159 100644
+--- a/base/third_party/symbolize/utilities.h
++++ b/base/third_party/symbolize/utilities.h
+@@ -34,102 +34,6 @@
+ #ifndef UTILITIES_H__
+ #define UTILITIES_H__
+ 
+-// printf macros for size_t, in the style of inttypes.h
+-#ifdef _LP64
+-#define __PRIS_PREFIX "z"
+-#else
+-#define __PRIS_PREFIX
+-#endif
+-
+-// Use these macros after a % in a printf format string
+-// to get correct 32/64 bit behavior, like this:
+-// size_t size = records.size();
+-// printf("%"PRIuS"\n", size);
+-
+-#define PRIdS __PRIS_PREFIX "d"
+-#define PRIxS __PRIS_PREFIX "x"
+-#define PRIuS __PRIS_PREFIX "u"
+-#define PRIXS __PRIS_PREFIX "X"
+-#define PRIoS __PRIS_PREFIX "o"
+-
+-#include <string>
+-
+-#include "glog/logging.h"
+-
+-#if defined(GLOG_OS_WINDOWS)
+-# include "port.h"
+-#endif
+-
+-#include "config.h"
+-
+-// There are three different ways we can try to get the stack trace:
+-//
+-// 1) The libunwind library.  This is still in development, and as a
+-//    separate library adds a new dependency, but doesn't need a frame
+-//    pointer.  It also doesn't call malloc.
+-//
+-// 2) Our hand-coded stack-unwinder.  This depends on a certain stack
+-//    layout, which is used by gcc (and those systems using a
+-//    gcc-compatible ABI) on x86 systems, at least since gcc 2.95.
+-//    It uses the frame pointer to do its work.
+-//
+-// 3) The gdb unwinder -- also the one used by the c++ exception code.
+-//    It's obviously well-tested, but has a fatal flaw: it can call
+-//    malloc() from the unwinder.  This is a problem because we're
+-//    trying to use the unwinder to instrument malloc().
+-//
+-// 4) The Windows API CaptureStackTrace.
+-//
+-// Note: if you add a new implementation here, make sure it works
+-// correctly when GetStackTrace() is called with max_depth == 0.
+-// Some code may do that.
+-
+-#if defined(HAVE_LIB_UNWIND)
+-# define STACKTRACE_H "stacktrace_libunwind-inl.h"
+-#elif defined(HAVE__UNWIND_BACKTRACE) && defined(HAVE__UNWIND_GETIP)
+-# define STACKTRACE_H "stacktrace_unwind-inl.h"
+-#elif !defined(NO_FRAME_POINTER)
+-# if defined(__i386__) && __GNUC__ >= 2
+-#  define STACKTRACE_H "stacktrace_x86-inl.h"
+-# elif (defined(__ppc__) || defined(__PPC__)) && __GNUC__ >= 2
+-#  define STACKTRACE_H "stacktrace_powerpc-inl.h"
+-# elif defined(GLOG_OS_WINDOWS)
+-#  define STACKTRACE_H "stacktrace_windows-inl.h"
+-# endif
+-#endif
+-
+-#if !defined(STACKTRACE_H) && defined(HAVE_EXECINFO_BACKTRACE)
+-# define STACKTRACE_H "stacktrace_generic-inl.h"
+-#endif
+-
+-#if defined(STACKTRACE_H)
+-# define HAVE_STACKTRACE
+-#endif
+-
+-#ifndef GLOG_NO_SYMBOLIZE_DETECTION
+-#ifndef HAVE_SYMBOLIZE
+-// defined by gcc
+-#if defined(__ELF__) && defined(GLOG_OS_LINUX)
+-# define HAVE_SYMBOLIZE
+-#elif defined(GLOG_OS_MACOSX) && defined(HAVE_DLADDR)
+-// Use dladdr to symbolize.
+-# define HAVE_SYMBOLIZE
+-#elif defined(GLOG_OS_WINDOWS)
+-// Use DbgHelp to symbolize
+-# define HAVE_SYMBOLIZE
+-#endif
+-#endif // !defined(HAVE_SYMBOLIZE)
+-#endif // !defined(GLOG_NO_SYMBOLIZE_DETECTION)
+-
+-#ifndef ARRAYSIZE
+-// There is a better way, but this is good enough for our purpose.
+-# define ARRAYSIZE(a) (sizeof(a) / sizeof(*(a)))
+-#endif
+-
+-_START_GOOGLE_NAMESPACE_
+-
+-namespace glog_internal_namespace_ {
+-
+ #ifdef HAVE___ATTRIBUTE__
+ # define ATTRIBUTE_NOINLINE __attribute__ ((noinline))
+ # define HAVE_ATTRIBUTE_NOINLINE
+@@ -140,76 +44,4 @@ namespace glog_internal_namespace_ {
+ # define ATTRIBUTE_NOINLINE
+ #endif
+ 
+-const char* ProgramInvocationShortName();
+-
+-int64 CycleClock_Now();
+-
+-int64 UsecToCycles(int64 usec);
+-WallTime WallTime_Now();
+-
+-int32 GetMainThreadPid();
+-bool PidHasChanged();
+-
+-pid_t GetTID();
+-
+-const std::string& MyUserName();
+-
+-// Get the part of filepath after the last path separator.
+-// (Doesn't modify filepath, contrary to basename() in libgen.h.)
+-const char* const_basename(const char* filepath);
+-
+-// Wrapper of __sync_val_compare_and_swap. If the GCC extension isn't
+-// defined, we try the CPU specific logics (we only support x86 and
+-// x86_64 for now) first, then use a naive implementation, which has a
+-// race condition.
+-template<typename T>
+-inline T sync_val_compare_and_swap(T* ptr, T oldval, T newval) {
+-#if defined(HAVE___SYNC_VAL_COMPARE_AND_SWAP)
+-  return __sync_val_compare_and_swap(ptr, oldval, newval);
+-#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+-  T ret;
+-  __asm__ __volatile__("lock; cmpxchg %1, (%2);"
+-                       :"=a"(ret)
+-                        // GCC may produces %sil or %dil for
+-                        // constraint "r", but some of apple's gas
+-                        // dosn't know the 8 bit registers.
+-                        // We use "q" to avoid these registers.
+-                       :"q"(newval), "q"(ptr), "a"(oldval)
+-                       :"memory", "cc");
+-  return ret;
+-#else
+-  T ret = *ptr;
+-  if (ret == oldval) {
+-    *ptr = newval;
+-  }
+-  return ret;
+-#endif
+-}
+-
+-void DumpStackTraceToString(std::string* stacktrace);
+-
+-struct CrashReason {
+-  CrashReason() : filename(0), line_number(0), message(0), depth(0) {}
+-
+-  const char* filename;
+-  int line_number;
+-  const char* message;
+-
+-  // We'll also store a bit of stack trace context at the time of crash as
+-  // it may not be available later on.
+-  void* stack[32];
+-  int depth;
+-};
+-
+-void SetCrashReason(const CrashReason* r);
+-
+-void InitGoogleLoggingUtilities(const char* argv0);
+-void ShutdownGoogleLoggingUtilities();
+-
+-}  // namespace glog_internal_namespace_
+-
+-_END_GOOGLE_NAMESPACE_
+-
+-using namespace GOOGLE_NAMESPACE::glog_internal_namespace_;
+-
+ #endif  // UTILITIES_H__
diff --git a/base/third_party/symbolize/patches/004-add-missing-symbolize-header.patch b/base/third_party/symbolize/patches/004-add-missing-symbolize-header.patch
new file mode 100644
index 0000000000000..8bbddc2141be2
--- /dev/null
+++ b/base/third_party/symbolize/patches/004-add-missing-symbolize-header.patch
@@ -0,0 +1,13 @@
+diff --git a/base/third_party/symbolize/symbolize.cc b/base/third_party/symbolize/symbolize.cc
+index 2cfd4c490cc94..e2f99a647bf88 100644
+--- a/base/third_party/symbolize/symbolize.cc
++++ b/base/third_party/symbolize/symbolize.cc
+@@ -52,6 +52,8 @@
+ #include GLOG_BUILD_CONFIG_INCLUDE
+ #endif  // GLOG_BUILD_CONFIG_INCLUDE
+ 
++#include "symbolize.h"
++
+ #include "utilities.h"
+ 
+ #if defined(HAVE_SYMBOLIZE)
diff --git a/base/third_party/symbolize/patches/005-expose-file-helpers.patch b/base/third_party/symbolize/patches/005-expose-file-helpers.patch
new file mode 100644
index 0000000000000..fe768c52f9e79
--- /dev/null
+++ b/base/third_party/symbolize/patches/005-expose-file-helpers.patch
@@ -0,0 +1,135 @@
+diff --git a/base/third_party/symbolize/symbolize.cc b/base/third_party/symbolize/symbolize.cc
+index e2f99a647bf88..3c72fd1183f48 100644
+--- a/base/third_party/symbolize/symbolize.cc
++++ b/base/third_party/symbolize/symbolize.cc
+@@ -141,12 +141,16 @@ _END_GOOGLE_NAMESPACE_
+ 
+ _START_GOOGLE_NAMESPACE_
+ 
+-// Read up to "count" bytes from "offset" in the file pointed by file
+-// descriptor "fd" into the buffer starting at "buf" while handling short reads
+-// and EINTR.  On success, return the number of bytes read.  Otherwise, return
+-// -1.
+-static ssize_t ReadFromOffset(const int fd, void *buf, const size_t count,
+-                              const size_t offset) {
++FileDescriptor::~FileDescriptor() {
++  if (fd_ >= 0) {
++    close(fd_);
++  }
++}
++
++ssize_t ReadFromOffset(const int fd,
++                       void* buf,
++                       const size_t count,
++                       const size_t offset) {
+   SAFE_ASSERT(fd >= 0);
+   SAFE_ASSERT(count <= static_cast<size_t>(std::numeric_limits<ssize_t>::max()));
+   char *buf0 = reinterpret_cast<char *>(buf);
+@@ -371,22 +375,6 @@ static bool GetSymbolFromObjectFile(const int fd,
+ }
+ 
+ namespace {
+-// Thin wrapper around a file descriptor so that the file descriptor
+-// gets closed for sure.
+-struct FileDescriptor {
+-  const int fd_;
+-  explicit FileDescriptor(int fd) : fd_(fd) {}
+-  ~FileDescriptor() {
+-    if (fd_ >= 0) {
+-      close(fd_);
+-    }
+-  }
+-  int get() { return fd_; }
+-
+- private:
+-  FileDescriptor(const FileDescriptor &);
+-  void operator=(const FileDescriptor&);
+-};
+ 
+ // Helper class for reading lines from file.
+ //
+@@ -503,20 +491,11 @@ static char *GetHex(const char *start, const char *end, uint64_t *hex) {
+   return const_cast<char *>(p);
+ }
+ 
+-// Searches for the object file (from /proc/self/maps) that contains
+-// the specified pc.  If found, sets |start_address| to the start address
+-// of where this object file is mapped in memory, sets the module base
+-// address into |base_address|, copies the object file name into
+-// |out_file_name|, and attempts to open the object file.  If the object
+-// file is opened successfully, returns the file descriptor.  Otherwise,
+-// returns -1.  |out_file_name_size| is the size of the file name buffer
+-// (including the null-terminator).
+-static ATTRIBUTE_NOINLINE int
+-OpenObjectFileContainingPcAndGetStartAddress(uint64_t pc,
+-                                             uint64_t &start_address,
+-                                             uint64_t &base_address,
+-                                             char *out_file_name,
+-                                             size_t out_file_name_size) {
++int OpenObjectFileContainingPcAndGetStartAddress(uint64_t pc,
++                                                 uint64_t& start_address,
++                                                 uint64_t& base_address,
++                                                 char* out_file_name,
++                                                 size_t out_file_name_size) {
+   int object_fd;
+ 
+   int maps_fd;
+diff --git a/base/third_party/symbolize/symbolize.h b/base/third_party/symbolize/symbolize.h
+index 5959e579ffc93..11b24fbd06f5c 100644
+--- a/base/third_party/symbolize/symbolize.h
++++ b/base/third_party/symbolize/symbolize.h
+@@ -94,17 +94,54 @@
+ 
+ _START_GOOGLE_NAMESPACE_
+ 
++// Read up to "count" bytes from "offset" in the file pointed by file
++// descriptor "fd" into the buffer starting at "buf" while handling short reads
++// and EINTR.  On success, return the number of bytes read.  Otherwise, return
++// -1.
++ssize_t ReadFromOffset(const int fd,
++                       void* buf,
++                       const size_t count,
++                       const size_t offset);
++
+ // Gets the section header for the given name, if it exists. Returns true on
+ // success. Otherwise, returns false.
+ bool GetSectionHeaderByName(int fd, const char *name, size_t name_len,
+                             ElfW(Shdr) *out);
+ 
++// Searches for the object file (from /proc/self/maps) that contains
++// the specified pc.  If found, sets |start_address| to the start address
++// of where this object file is mapped in memory, sets the module base
++// address into |base_address|, copies the object file name into
++// |out_file_name|, and attempts to open the object file.  If the object
++// file is opened successfully, returns the file descriptor.  Otherwise,
++// returns -1.  |out_file_name_size| is the size of the file name buffer
++// (including the null-terminator).
++ATTRIBUTE_NOINLINE int OpenObjectFileContainingPcAndGetStartAddress(
++    uint64_t pc,
++    uint64_t& start_address,
++    uint64_t& base_address,
++    char* out_file_name,
++    size_t out_file_name_size);
++
+ _END_GOOGLE_NAMESPACE_
+ 
+ #endif  /* __ELF__ */
+ 
+ _START_GOOGLE_NAMESPACE_
+ 
++// Thin wrapper around a file descriptor so that the file descriptor
++// gets closed for sure.
++struct FileDescriptor {
++  const int fd_;
++  explicit FileDescriptor(int fd) : fd_(fd) {}
++  ~FileDescriptor();
++  int get() { return fd_; }
++
++ private:
++  FileDescriptor(const FileDescriptor &);
++  void operator=(const FileDescriptor&);
++};
++
+ // Restrictions on the callbacks that follow:
+ //  - The callbacks must not use heaps but only use stacks.
+ //  - The callbacks must be async-signal-safe.
diff --git a/base/third_party/symbolize/patches/006-use-sandbox-hook-for-open-object-file.patch b/base/third_party/symbolize/patches/006-use-sandbox-hook-for-open-object-file.patch
new file mode 100644
index 0000000000000..0081801aaa417
--- /dev/null
+++ b/base/third_party/symbolize/patches/006-use-sandbox-hook-for-open-object-file.patch
@@ -0,0 +1,70 @@
+diff --git a/base/third_party/symbolize/symbolize.cc b/base/third_party/symbolize/symbolize.cc
+index 3c72fd1183f48..20d4d4106d65b 100644
+--- a/base/third_party/symbolize/symbolize.cc
++++ b/base/third_party/symbolize/symbolize.cc
+@@ -491,11 +491,12 @@ static char *GetHex(const char *start, const char *end, uint64_t *hex) {
+   return const_cast<char *>(p);
+ }
+ 
+-int OpenObjectFileContainingPcAndGetStartAddress(uint64_t pc,
+-                                                 uint64_t& start_address,
+-                                                 uint64_t& base_address,
+-                                                 char* out_file_name,
+-                                                 size_t out_file_name_size) {
++static int OpenObjectFileContainingPcAndGetStartAddressNoHook(
++    uint64_t pc,
++    uint64_t& start_address,
++    uint64_t& base_address,
++    char* out_file_name,
++    size_t out_file_name_size) {
+   int object_fd;
+ 
+   int maps_fd;
+@@ -645,6 +646,20 @@ int OpenObjectFileContainingPcAndGetStartAddress(uint64_t pc,
+   }
+ }
+ 
++int OpenObjectFileContainingPcAndGetStartAddress(
++    uint64_t pc,
++    uint64_t& start_address,
++    uint64_t& base_address,
++    char* out_file_name,
++    size_t out_file_name_size) {
++  if (g_symbolize_open_object_file_callback) {
++    return g_symbolize_open_object_file_callback(
++        pc, start_address, base_address, out_file_name, out_file_name_size);
++  }
++  return OpenObjectFileContainingPcAndGetStartAddressNoHook(
++      pc, start_address, base_address, out_file_name, out_file_name_size);
++}
++
+ // POSIX doesn't define any async-signal safe function for converting
+ // an integer to ASCII. We'll have to define our own version.
+ // itoa_r() converts an (unsigned) integer to ASCII. It returns "buf", if the
+@@ -734,7 +749,6 @@ static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void *pc, char *out,
+   uint64_t pc0 = reinterpret_cast<uintptr_t>(pc);
+   uint64_t start_address = 0;
+   uint64_t base_address = 0;
+-  int object_fd = -1;
+ 
+   if (out_size < 1) {
+     return false;
+@@ -742,16 +756,8 @@ static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void *pc, char *out,
+   out[0] = '\0';
+   SafeAppendString("(", out, out_size);
+ 
+-  if (g_symbolize_open_object_file_callback) {
+-    object_fd = g_symbolize_open_object_file_callback(pc0, start_address,
+-                                                      base_address, out + 1,
+-                                                      out_size - 1);
+-  } else {
+-    object_fd = OpenObjectFileContainingPcAndGetStartAddress(pc0, start_address,
+-                                                             base_address,
+-                                                             out + 1,
+-                                                             out_size - 1);
+-  }
++  int object_fd = OpenObjectFileContainingPcAndGetStartAddress(
++      pc0, start_address, base_address, out + 1, out_size - 1);
+ 
+   FileDescriptor wrapped_object_fd(object_fd);
+ 
diff --git a/base/third_party/symbolize/patches/007-sys-types-h.patch b/base/third_party/symbolize/patches/007-sys-types-h.patch
new file mode 100644
index 0000000000000..cc47bd445acea
--- /dev/null
+++ b/base/third_party/symbolize/patches/007-sys-types-h.patch
@@ -0,0 +1,13 @@
+diff --git a/base/third_party/symbolize/symbolize.h b/base/third_party/symbolize/symbolize.h
+index 2a55c688aedfb..987569fdde67f 100644
+--- a/base/third_party/symbolize/symbolize.h
++++ b/base/third_party/symbolize/symbolize.h
+@@ -54,6 +54,8 @@
+ #ifndef BASE_SYMBOLIZE_H_
+ #define BASE_SYMBOLIZE_H_
+ 
++#include <sys/types.h>  // for ssize_t
++
+ #include "utilities.h"
+ #include "config.h"
+ #include "glog/logging.h"
diff --git a/base/third_party/symbolize/patches/008-include-cstdlib.patch b/base/third_party/symbolize/patches/008-include-cstdlib.patch
new file mode 100644
index 0000000000000..ffa9edccf438b
--- /dev/null
+++ b/base/third_party/symbolize/patches/008-include-cstdlib.patch
@@ -0,0 +1,12 @@
+diff --git a/base/third_party/symbolize/symbolize.cc b/base/third_party/symbolize/symbolize.cc
+index 5287e5bb11007..a3b8399f411bf 100644
+--- a/base/third_party/symbolize/symbolize.cc
++++ b/base/third_party/symbolize/symbolize.cc
+@@ -59,6 +59,7 @@
+ #if defined(HAVE_SYMBOLIZE)
+ 
+ #include <cstring>
++#include <cstdlib>
+ 
+ #include <algorithm>
+ #include <limits>
diff --git a/base/third_party/symbolize/patches/009-clone-absl-demangle.patch b/base/third_party/symbolize/patches/009-clone-absl-demangle.patch
new file mode 100644
index 0000000000000..3adae987c0157
--- /dev/null
+++ b/base/third_party/symbolize/patches/009-clone-absl-demangle.patch
@@ -0,0 +1,2388 @@
+diff --git a/base/third_party/symbolize/demangle.cc b/base/third_party/symbolize/demangle.cc
+index 9276c5b879a8c..2632646dd4072 100644
+--- a/base/third_party/symbolize/demangle.cc
++++ b/base/third_party/symbolize/demangle.cc
+@@ -34,13 +34,14 @@
+ //
+ // Note that we only have partial C++0x support yet.
+ 
+-#include <cstdio>  // for NULL
+-
+ #include "demangle.h"
+-#include "utilities.h"
+ 
+ #if defined(GLOG_OS_WINDOWS)
+ #include <dbghelp.h>
++#else
++#include <cstdint>
++#include <cstdio>
++#include <limits>
+ #endif
+ 
+ _START_GOOGLE_NAMESPACE_
+@@ -49,117 +50,199 @@ _START_GOOGLE_NAMESPACE_
+ typedef struct {
+   const char *abbrev;
+   const char *real_name;
++  // Number of arguments in <expression> context, or 0 if disallowed.
++  int arity;
+ } AbbrevPair;
+ 
+ // List of operators from Itanium C++ ABI.
+ static const AbbrevPair kOperatorList[] = {
+-  { "nw", "new" },
+-  { "na", "new[]" },
+-  { "dl", "delete" },
+-  { "da", "delete[]" },
+-  { "ps", "+" },
+-  { "ng", "-" },
+-  { "ad", "&" },
+-  { "de", "*" },
+-  { "co", "~" },
+-  { "pl", "+" },
+-  { "mi", "-" },
+-  { "ml", "*" },
+-  { "dv", "/" },
+-  { "rm", "%" },
+-  { "an", "&" },
+-  { "or", "|" },
+-  { "eo", "^" },
+-  { "aS", "=" },
+-  { "pL", "+=" },
+-  { "mI", "-=" },
+-  { "mL", "*=" },
+-  { "dV", "/=" },
+-  { "rM", "%=" },
+-  { "aN", "&=" },
+-  { "oR", "|=" },
+-  { "eO", "^=" },
+-  { "ls", "<<" },
+-  { "rs", ">>" },
+-  { "lS", "<<=" },
+-  { "rS", ">>=" },
+-  { "eq", "==" },
+-  { "ne", "!=" },
+-  { "lt", "<" },
+-  { "gt", ">" },
+-  { "le", "<=" },
+-  { "ge", ">=" },
+-  { "nt", "!" },
+-  { "aa", "&&" },
+-  { "oo", "||" },
+-  { "pp", "++" },
+-  { "mm", "--" },
+-  { "cm", "," },
+-  { "pm", "->*" },
+-  { "pt", "->" },
+-  { "cl", "()" },
+-  { "ix", "[]" },
+-  { "qu", "?" },
+-  { "st", "sizeof" },
+-  { "sz", "sizeof" },
+-  { NULL, NULL },
++    // New has special syntax (not currently supported).
++    {"nw", "new", 0},
++    {"na", "new[]", 0},
++
++    // Works except that the 'gs' prefix is not supported.
++    {"dl", "delete", 1},
++    {"da", "delete[]", 1},
++
++    {"ps", "+", 1},  // "positive"
++    {"ng", "-", 1},  // "negative"
++    {"ad", "&", 1},  // "address-of"
++    {"de", "*", 1},  // "dereference"
++    {"co", "~", 1},
++
++    {"pl", "+", 2},
++    {"mi", "-", 2},
++    {"ml", "*", 2},
++    {"dv", "/", 2},
++    {"rm", "%", 2},
++    {"an", "&", 2},
++    {"or", "|", 2},
++    {"eo", "^", 2},
++    {"aS", "=", 2},
++    {"pL", "+=", 2},
++    {"mI", "-=", 2},
++    {"mL", "*=", 2},
++    {"dV", "/=", 2},
++    {"rM", "%=", 2},
++    {"aN", "&=", 2},
++    {"oR", "|=", 2},
++    {"eO", "^=", 2},
++    {"ls", "<<", 2},
++    {"rs", ">>", 2},
++    {"lS", "<<=", 2},
++    {"rS", ">>=", 2},
++    {"eq", "==", 2},
++    {"ne", "!=", 2},
++    {"lt", "<", 2},
++    {"gt", ">", 2},
++    {"le", "<=", 2},
++    {"ge", ">=", 2},
++    {"nt", "!", 1},
++    {"aa", "&&", 2},
++    {"oo", "||", 2},
++    {"pp", "++", 1},
++    {"mm", "--", 1},
++    {"cm", ",", 2},
++    {"pm", "->*", 2},
++    {"pt", "->", 0},  // Special syntax
++    {"cl", "()", 0},  // Special syntax
++    {"ix", "[]", 2},
++    {"qu", "?", 3},
++    {"st", "sizeof", 0},  // Special syntax
++    {"sz", "sizeof", 1},  // Not a real operator name, but used in expressions.
++    {nullptr, nullptr, 0},
+ };
+ 
+ // List of builtin types from Itanium C++ ABI.
++//
++// Invariant: only one- or two-character type abbreviations here.
+ static const AbbrevPair kBuiltinTypeList[] = {
+-  { "v", "void" },
+-  { "w", "wchar_t" },
+-  { "b", "bool" },
+-  { "c", "char" },
+-  { "a", "signed char" },
+-  { "h", "unsigned char" },
+-  { "s", "short" },
+-  { "t", "unsigned short" },
+-  { "i", "int" },
+-  { "j", "unsigned int" },
+-  { "l", "long" },
+-  { "m", "unsigned long" },
+-  { "x", "long long" },
+-  { "y", "unsigned long long" },
+-  { "n", "__int128" },
+-  { "o", "unsigned __int128" },
+-  { "f", "float" },
+-  { "d", "double" },
+-  { "e", "long double" },
+-  { "g", "__float128" },
+-  { "z", "ellipsis" },
+-  { NULL, NULL }
++    {"v", "void", 0},
++    {"w", "wchar_t", 0},
++    {"b", "bool", 0},
++    {"c", "char", 0},
++    {"a", "signed char", 0},
++    {"h", "unsigned char", 0},
++    {"s", "short", 0},
++    {"t", "unsigned short", 0},
++    {"i", "int", 0},
++    {"j", "unsigned int", 0},
++    {"l", "long", 0},
++    {"m", "unsigned long", 0},
++    {"x", "long long", 0},
++    {"y", "unsigned long long", 0},
++    {"n", "__int128", 0},
++    {"o", "unsigned __int128", 0},
++    {"f", "float", 0},
++    {"d", "double", 0},
++    {"e", "long double", 0},
++    {"g", "__float128", 0},
++    {"z", "ellipsis", 0},
++
++    {"De", "decimal128", 0},      // IEEE 754r decimal floating point (128 bits)
++    {"Dd", "decimal64", 0},       // IEEE 754r decimal floating point (64 bits)
++    {"Dc", "decltype(auto)", 0},
++    {"Da", "auto", 0},
++    {"Dn", "std::nullptr_t", 0},  // i.e., decltype(nullptr)
++    {"Df", "decimal32", 0},       // IEEE 754r decimal floating point (32 bits)
++    {"Di", "char32_t", 0},
++    {"Du", "char8_t", 0},
++    {"Ds", "char16_t", 0},
++    {"Dh", "float16", 0},         // IEEE 754r half-precision float (16 bits)
++    {nullptr, nullptr, 0},
+ };
+ 
+ // List of substitutions Itanium C++ ABI.
+ static const AbbrevPair kSubstitutionList[] = {
+-  { "St", "" },
+-  { "Sa", "allocator" },
+-  { "Sb", "basic_string" },
+-  // std::basic_string<char, std::char_traits<char>,std::allocator<char> >
+-  { "Ss", "string"},
+-  // std::basic_istream<char, std::char_traits<char> >
+-  { "Si", "istream" },
+-  // std::basic_ostream<char, std::char_traits<char> >
+-  { "So", "ostream" },
+-  // std::basic_iostream<char, std::char_traits<char> >
+-  { "Sd", "iostream" },
+-  { NULL, NULL }
++    {"St", "", 0},
++    {"Sa", "allocator", 0},
++    {"Sb", "basic_string", 0},
++    // std::basic_string<char, std::char_traits<char>,std::allocator<char> >
++    {"Ss", "string", 0},
++    // std::basic_istream<char, std::char_traits<char> >
++    {"Si", "istream", 0},
++    // std::basic_ostream<char, std::char_traits<char> >
++    {"So", "ostream", 0},
++    // std::basic_iostream<char, std::char_traits<char> >
++    {"Sd", "iostream", 0},
++    {nullptr, nullptr, 0},
+ };
+ 
+-// State needed for demangling.
++// State needed for demangling.  This struct is copied in almost every stack
++// frame, so every byte counts.
++typedef struct {
++  int mangled_idx;                     // Cursor of mangled name.
++  int out_cur_idx;                     // Cursor of output string.
++  int prev_name_idx;                   // For constructors/destructors.
++  unsigned int prev_name_length : 16;  // For constructors/destructors.
++  signed int nest_level : 15;          // For nested names.
++  unsigned int append : 1;             // Append flag.
++  // Note: for some reason MSVC can't pack "bool append : 1" into the same int
++  // with the above two fields, so we use an int instead.  Amusingly it can pack
++  // "signed bool" as expected, but relying on that to continue to be a legal
++  // type seems ill-advised (as it's illegal in at least clang).
++} ParseState;
++
++static_assert(sizeof(ParseState) == 4 * sizeof(int),
++              "unexpected size of ParseState");
++
++// One-off state for demangling that's not subject to backtracking -- either
++// constant data, data that's intentionally immune to backtracking (steps), or
++// data that would never be changed by backtracking anyway (recursion_depth).
++//
++// Only one copy of this exists for each call to Demangle, so the size of this
++// struct is nearly inconsequential.
+ typedef struct {
+-  const char *mangled_cur;   // Cursor of mangled name.
+-  char *out_cur;             // Cursor of output string.
+-  const char *out_begin;     // Beginning of output string.
+-  const char *out_end;       // End of output string.
+-  const char *prev_name;     // For constructors/destructors.
+-  ssize_t prev_name_length;  // For constructors/destructors.
+-  short nest_level;          // For nested names.
+-  bool append;               // Append flag.
+-  bool overflowed;           // True if output gets overflowed.
++  const char *mangled_begin;  // Beginning of input string.
++  char *out;                  // Beginning of output string.
++  int out_end_idx;            // One past last allowed output character.
++  int recursion_depth;        // For stack exhaustion prevention.
++  int steps;               // Cap how much work we'll do, regardless of depth.
++  ParseState parse_state;  // Backtrackable state copied for most frames.
+ } State;
+ 
++namespace {
++// Prevent deep recursion / stack exhaustion.
++// Also prevent unbounded handling of complex inputs.
++class ComplexityGuard {
++ public:
++  explicit ComplexityGuard(State *state) : state_(state) {
++    ++state->recursion_depth;
++    ++state->steps;
++  }
++  ~ComplexityGuard() { --state_->recursion_depth; }
++
++  // 256 levels of recursion seems like a reasonable upper limit on depth.
++  // 128 is not enough to demagle synthetic tests from demangle_unittest.txt:
++  // "_ZaaZZZZ..." and "_ZaaZcvZcvZ..."
++  static constexpr int kRecursionDepthLimit = 256;
++
++  // We're trying to pick a charitable upper-limit on how many parse steps are
++  // necessary to handle something that a human could actually make use of.
++  // This is mostly in place as a bound on how much work we'll do if we are
++  // asked to demangle an mangled name from an untrusted source, so it should be
++  // much larger than the largest expected symbol, but much smaller than the
++  // amount of work we can do in, e.g., a second.
++  //
++  // Some real-world symbols from an arbitrary binary started failing between
++  // 2^12 and 2^13, so we multiply the latter by an extra factor of 16 to set
++  // the limit.
++  //
++  // Spending one second on 2^17 parse steps would require each step to take
++  // 7.6us, or ~30000 clock cycles, so it's safe to say this can be done in
++  // under a second.
++  static constexpr int kParseStepsLimit = 1 << 17;
++
++  bool IsTooComplex() const {
++    return state_->recursion_depth > kRecursionDepthLimit ||
++           state_->steps > kParseStepsLimit;
++  }
++
++ private:
++  State *state_;
++};
++}  // namespace
++
+ // We don't use strlen() in libc since it's not guaranteed to be async
+ // signal safe.
+ static size_t StrLen(const char *str) {
+@@ -172,8 +255,8 @@ static size_t StrLen(const char *str) {
+ }
+ 
+ // Returns true if "str" has at least "n" characters remaining.
+-static bool AtLeastNumCharsRemaining(const char *str, ssize_t n) {
+-  for (ssize_t i = 0; i < n; ++i) {
++static bool AtLeastNumCharsRemaining(const char *str, size_t n) {
++  for (size_t i = 0; i < n; ++i) {
+     if (str[i] == '\0') {
+       return false;
+     }
+@@ -184,32 +267,42 @@ static bool AtLeastNumCharsRemaining(const char *str, ssize_t n) {
+ // Returns true if "str" has "prefix" as a prefix.
+ static bool StrPrefix(const char *str, const char *prefix) {
+   size_t i = 0;
+-  while (str[i] != '\0' && prefix[i] != '\0' &&
+-         str[i] == prefix[i]) {
++  while (str[i] != '\0' && prefix[i] != '\0' && str[i] == prefix[i]) {
+     ++i;
+   }
+   return prefix[i] == '\0';  // Consumed everything in "prefix".
+ }
+ 
+-static void InitState(State *state, const char *mangled,
+-                      char *out, size_t out_size) {
+-  state->mangled_cur = mangled;
+-  state->out_cur = out;
+-  state->out_begin = out;
+-  state->out_end = out + out_size;
+-  state->prev_name  = NULL;
+-  state->prev_name_length = -1;
+-  state->nest_level = -1;
+-  state->append = true;
+-  state->overflowed = false;
++static void InitState(State* state,
++                      const char* mangled,
++                      char* out,
++                      size_t out_size) {
++  state->mangled_begin = mangled;
++  state->out = out;
++  state->out_end_idx = static_cast<int>(out_size);
++  state->recursion_depth = 0;
++  state->steps = 0;
++
++  state->parse_state.mangled_idx = 0;
++  state->parse_state.out_cur_idx = 0;
++  state->parse_state.prev_name_idx = 0;
++  state->parse_state.prev_name_length = 0;
++  state->parse_state.nest_level = -1;
++  state->parse_state.append = true;
++}
++
++static inline const char *RemainingInput(State *state) {
++  return &state->mangled_begin[state->parse_state.mangled_idx];
+ }
+ 
+-// Returns true and advances "mangled_cur" if we find "one_char_token"
+-// at "mangled_cur" position.  It is assumed that "one_char_token" does
++// Returns true and advances "mangled_idx" if we find "one_char_token"
++// at "mangled_idx" position.  It is assumed that "one_char_token" does
+ // not contain '\0'.
+ static bool ParseOneCharToken(State *state, const char one_char_token) {
+-  if (state->mangled_cur[0] == one_char_token) {
+-    ++state->mangled_cur;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  if (RemainingInput(state)[0] == one_char_token) {
++    ++state->parse_state.mangled_idx;
+     return true;
+   }
+   return false;
+@@ -219,9 +312,11 @@ static bool ParseOneCharToken(State *state, const char one_char_token) {
+ // at "mangled_cur" position.  It is assumed that "two_char_token" does
+ // not contain '\0'.
+ static bool ParseTwoCharToken(State *state, const char *two_char_token) {
+-  if (state->mangled_cur[0] == two_char_token[0] &&
+-      state->mangled_cur[1] == two_char_token[1]) {
+-    state->mangled_cur += 2;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  if (RemainingInput(state)[0] == two_char_token[0] &&
++      RemainingInput(state)[1] == two_char_token[1]) {
++    state->parse_state.mangled_idx += 2;
+     return true;
+   }
+   return false;
+@@ -230,21 +325,35 @@ static bool ParseTwoCharToken(State *state, const char *two_char_token) {
+ // Returns true and advances "mangled_cur" if we find any character in
+ // "char_class" at "mangled_cur" position.
+ static bool ParseCharClass(State *state, const char *char_class) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  if (RemainingInput(state)[0] == '\0') {
++    return false;
++  }
+   const char *p = char_class;
+   for (; *p != '\0'; ++p) {
+-    if (state->mangled_cur[0] == *p) {
+-      ++state->mangled_cur;
++    if (RemainingInput(state)[0] == *p) {
++      ++state->parse_state.mangled_idx;
+       return true;
+     }
+   }
+   return false;
+ }
+ 
+-// This function is used for handling an optional non-terminal.
+-static bool Optional(bool) {
+-  return true;
++static bool ParseDigit(State *state, int *digit) {
++  char c = RemainingInput(state)[0];
++  if (ParseCharClass(state, "0123456789")) {
++    if (digit != nullptr) {
++      *digit = c - '0';
++    }
++    return true;
++  }
++  return false;
+ }
+ 
++// This function is used for handling an optional non-terminal.
++static bool Optional(bool /*status*/) { return true; }
++
+ // This function is used for handling <non-terminal>+ syntax.
+ typedef bool (*ParseFunc)(State *);
+ static bool OneOrMore(ParseFunc parse_func, State *state) {
+@@ -266,146 +375,179 @@ static bool ZeroOrMore(ParseFunc parse_func, State *state) {
+   return true;
+ }
+ 
+-// Append "str" at "out_cur".  If there is an overflow, "overflowed"
+-// is set to true for later use.  The output string is ensured to
++// Append "str" at "out_cur_idx".  If there is an overflow, out_cur_idx is
++// set to out_end_idx+1.  The output string is ensured to
+ // always terminate with '\0' as long as there is no overflow.
+-static void Append(State *state, const char * const str, ssize_t length) {
+-  for (ssize_t i = 0; i < length; ++i) {
+-    if (state->out_cur + 1 < state->out_end) {  // +1 for '\0'
+-      *state->out_cur = str[i];
+-      ++state->out_cur;
++static void Append(State *state, const char *const str, const size_t length) {
++  for (size_t i = 0; i < length; ++i) {
++    if (state->parse_state.out_cur_idx + 1 <
++        state->out_end_idx) {  // +1 for '\0'
++      state->out[state->parse_state.out_cur_idx++] = str[i];
+     } else {
+-      state->overflowed = true;
++      // signal overflow
++      state->parse_state.out_cur_idx = state->out_end_idx + 1;
+       break;
+     }
+   }
+-  if (!state->overflowed) {
+-    *state->out_cur = '\0';  // Terminate it with '\0'
++  if (state->parse_state.out_cur_idx < state->out_end_idx) {
++    state->out[state->parse_state.out_cur_idx] =
++        '\0';  // Terminate it with '\0'
+   }
+ }
+ 
+ // We don't use equivalents in libc to avoid locale issues.
+-static bool IsLower(char c) {
+-  return c >= 'a' && c <= 'z';
+-}
++static bool IsLower(char c) { return c >= 'a' && c <= 'z'; }
+ 
+ static bool IsAlpha(char c) {
+   return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
+ }
+ 
+-static bool IsDigit(char c) {
+-  return c >= '0' && c <= '9';
+-}
++static bool IsDigit(char c) { return c >= '0' && c <= '9'; }
+ 
+ // Returns true if "str" is a function clone suffix.  These suffixes are used
+-// by GCC 4.5.x and later versions to indicate functions which have been
+-// cloned during optimization.  We treat any sequence (.<alpha>+.<digit>+)+ as
+-// a function clone suffix.
++// by GCC 4.5.x and later versions (and our locally-modified version of GCC
++// 4.4.x) to indicate functions which have been cloned during optimization.
++// We treat any sequence (.<alpha>+.<digit>+)+ as a function clone suffix.
++// Additionally, '_' is allowed along with the alphanumeric sequence.
+ static bool IsFunctionCloneSuffix(const char *str) {
+   size_t i = 0;
+   while (str[i] != '\0') {
+-    // Consume a single .<alpha>+.<digit>+ sequence.
+-    if (str[i] != '.' || !IsAlpha(str[i + 1])) {
+-      return false;
++    bool parsed = false;
++    // Consume a single [.<alpha> | _]*[.<digit>]* sequence.
++    if (str[i] == '.' && (IsAlpha(str[i + 1]) || str[i + 1] == '_')) {
++      parsed = true;
++      i += 2;
++      while (IsAlpha(str[i]) || str[i] == '_') {
++        ++i;
++      }
+     }
+-    i += 2;
+-    while (IsAlpha(str[i])) {
+-      ++i;
++    if (str[i] == '.' && IsDigit(str[i + 1])) {
++      parsed = true;
++      i += 2;
++      while (IsDigit(str[i])) {
++        ++i;
++      }
+     }
+-    if (str[i] != '.' || !IsDigit(str[i + 1])) {
++    if (!parsed)
+       return false;
+-    }
+-    i += 2;
+-    while (IsDigit(str[i])) {
+-      ++i;
+-    }
+   }
+   return true;  // Consumed everything in "str".
+ }
+ 
++static bool EndsWith(State *state, const char chr) {
++  return state->parse_state.out_cur_idx > 0 &&
++         state->parse_state.out_cur_idx < state->out_end_idx &&
++         chr == state->out[state->parse_state.out_cur_idx - 1];
++}
++
+ // Append "str" with some tweaks, iff "append" state is true.
+-// Returns true so that it can be placed in "if" conditions.
+-static void MaybeAppendWithLength(State *state, const char * const str,
+-                                  ssize_t length) {
+-  if (state->append && length > 0) {
++static void MaybeAppendWithLength(State *state, const char *const str,
++                                  const size_t length) {
++  if (state->parse_state.append && length > 0) {
+     // Append a space if the output buffer ends with '<' and "str"
+     // starts with '<' to avoid <<<.
+-    if (str[0] == '<' && state->out_begin < state->out_cur  &&
+-        state->out_cur[-1] == '<') {
++    if (str[0] == '<' && EndsWith(state, '<')) {
+       Append(state, " ", 1);
+     }
+-    // Remember the last identifier name for ctors/dtors.
+-    if (IsAlpha(str[0]) || str[0] == '_') {
+-      state->prev_name = state->out_cur;
+-      state->prev_name_length = length;
++    // Remember the last identifier name for ctors/dtors,
++    // but only if we haven't yet overflown the buffer.
++    if (state->parse_state.out_cur_idx < state->out_end_idx &&
++        (IsAlpha(str[0]) || str[0] == '_')) {
++      state->parse_state.prev_name_idx = state->parse_state.out_cur_idx;
++      state->parse_state.prev_name_length = static_cast<unsigned int>(length);
+     }
+     Append(state, str, length);
+   }
+ }
+ 
+-// A convenient wrapper arount MaybeAppendWithLength().
+-static bool MaybeAppend(State *state, const char * const str) {
+-  if (state->append) {
++// Appends a positive decimal number to the output if appending is enabled.
++static bool MaybeAppendDecimal(State *state, int val) {
++  // Max {32-64}-bit unsigned int is 20 digits.
++  constexpr size_t kMaxLength = 20;
++  char buf[kMaxLength];
++
++  // We can't use itoa or sprintf as neither is specified to be
++  // async-signal-safe.
++  if (state->parse_state.append) {
++    // We can't have a one-before-the-beginning pointer, so instead start with
++    // one-past-the-end and manipulate one character before the pointer.
++    char *p = &buf[kMaxLength];
++    do {  // val=0 is the only input that should write a leading zero digit.
++      *--p = static_cast<char>((val % 10) + '0');
++      val /= 10;
++    } while (p > buf && val != 0);
++
++    // 'p' landed on the last character we set.  How convenient.
++    Append(state, p, kMaxLength - static_cast<size_t>(p - buf));
++  }
++
++  return true;
++}
++
++// A convenient wrapper around MaybeAppendWithLength().
++// Returns true so that it can be placed in "if" conditions.
++static bool MaybeAppend(State *state, const char *const str) {
++  if (state->parse_state.append) {
+     size_t length = StrLen(str);
+-    MaybeAppendWithLength(state, str, static_cast<ssize_t>(length));
++    MaybeAppendWithLength(state, str, length);
+   }
+   return true;
+ }
+ 
+ // This function is used for handling nested names.
+ static bool EnterNestedName(State *state) {
+-  state->nest_level = 0;
++  state->parse_state.nest_level = 0;
+   return true;
+ }
+ 
+ // This function is used for handling nested names.
+-static bool LeaveNestedName(State *state, short prev_value) {
+-  state->nest_level = prev_value;
++static bool LeaveNestedName(State *state, int16_t prev_value) {
++  state->parse_state.nest_level = prev_value;
+   return true;
+ }
+ 
+ // Disable the append mode not to print function parameters, etc.
+ static bool DisableAppend(State *state) {
+-  state->append = false;
++  state->parse_state.append = false;
+   return true;
+ }
+ 
+ // Restore the append mode to the previous state.
+ static bool RestoreAppend(State *state, bool prev_value) {
+-  state->append = prev_value;
++  state->parse_state.append = prev_value;
+   return true;
+ }
+ 
+ // Increase the nest level for nested names.
+ static void MaybeIncreaseNestLevel(State *state) {
+-  if (state->nest_level > -1) {
+-    ++state->nest_level;
++  if (state->parse_state.nest_level > -1) {
++    ++state->parse_state.nest_level;
+   }
+ }
+ 
+ // Appends :: for nested names if necessary.
+ static void MaybeAppendSeparator(State *state) {
+-  if (state->nest_level >= 1) {
++  if (state->parse_state.nest_level >= 1) {
+     MaybeAppend(state, "::");
+   }
+ }
+ 
+ // Cancel the last separator if necessary.
+ static void MaybeCancelLastSeparator(State *state) {
+-  if (state->nest_level >= 1 && state->append &&
+-      state->out_begin <= state->out_cur - 2) {
+-    state->out_cur -= 2;
+-    *state->out_cur = '\0';
++  if (state->parse_state.nest_level >= 1 && state->parse_state.append &&
++      state->parse_state.out_cur_idx >= 2) {
++    state->parse_state.out_cur_idx -= 2;
++    state->out[state->parse_state.out_cur_idx] = '\0';
+   }
+ }
+ 
+ // Returns true if the identifier of the given length pointed to by
+ // "mangled_cur" is anonymous namespace.
+-static bool IdentifierIsAnonymousNamespace(State *state, ssize_t length) {
++static bool IdentifierIsAnonymousNamespace(State *state, size_t length) {
++  // Returns true if "anon_prefix" is a proper prefix of "mangled_cur".
+   static const char anon_prefix[] = "_GLOBAL__N_";
+-  return (length > static_cast<ssize_t>(sizeof(anon_prefix)) -
+-                       1 &&  // Should be longer.
+-          StrPrefix(state->mangled_cur, anon_prefix));
++  return (length > (sizeof(anon_prefix) - 1) &&
++          StrPrefix(RemainingInput(state), anon_prefix));
+ }
+ 
+ // Forward declarations of our parsing functions.
+@@ -413,24 +555,24 @@ static bool ParseMangledName(State *state);
+ static bool ParseEncoding(State *state);
+ static bool ParseName(State *state);
+ static bool ParseUnscopedName(State *state);
+-static bool ParseUnscopedTemplateName(State *state);
+ static bool ParseNestedName(State *state);
+ static bool ParsePrefix(State *state);
+ static bool ParseUnqualifiedName(State *state);
+ static bool ParseSourceName(State *state);
+ static bool ParseLocalSourceName(State *state);
++static bool ParseUnnamedTypeName(State *state);
+ static bool ParseNumber(State *state, int *number_out);
+ static bool ParseFloatNumber(State *state);
+ static bool ParseSeqId(State *state);
+-static bool ParseIdentifier(State *state, ssize_t length);
+-static bool ParseAbiTags(State *state);
+-static bool ParseAbiTag(State *state);
+-static bool ParseOperatorName(State *state);
++static bool ParseIdentifier(State *state, size_t length);
++static bool ParseOperatorName(State *state, int *arity);
+ static bool ParseSpecialName(State *state);
+ static bool ParseCallOffset(State *state);
+ static bool ParseNVOffset(State *state);
+ static bool ParseVOffset(State *state);
++static bool ParseAbiTags(State *state);
+ static bool ParseCtorDtorName(State *state);
++static bool ParseDecltype(State *state);
+ static bool ParseType(State *state);
+ static bool ParseCVQualifiers(State *state);
+ static bool ParseBuiltinType(State *state);
+@@ -443,11 +585,15 @@ static bool ParseTemplateParam(State *state);
+ static bool ParseTemplateTemplateParam(State *state);
+ static bool ParseTemplateArgs(State *state);
+ static bool ParseTemplateArg(State *state);
++static bool ParseBaseUnresolvedName(State *state);
++static bool ParseUnresolvedName(State *state);
+ static bool ParseExpression(State *state);
+ static bool ParseExprPrimary(State *state);
++static bool ParseExprCastValue(State *state);
+ static bool ParseLocalName(State *state);
++static bool ParseLocalNameSuffix(State *state);
+ static bool ParseDiscriminator(State *state);
+-static bool ParseSubstitution(State *state);
++static bool ParseSubstitution(State *state, bool accept_std);
+ 
+ // Implementation note: the following code is a straightforward
+ // translation of the Itanium C++ ABI defined in BNF with a couple of
+@@ -459,11 +605,12 @@ static bool ParseSubstitution(State *state);
+ // - Reorder patterns to give greedier functions precedence
+ //   We'll mark "Less greedy than" for these cases in the code
+ //
+-// Each parsing function changes the state and returns true on
+-// success.  Otherwise, don't change the state and returns false.  To
+-// ensure that the state isn't changed in the latter case, we save the
+-// original state before we call more than one parsing functions
+-// consecutively with &&, and restore the state if unsuccessful.  See
++// Each parsing function changes the parse state and returns true on
++// success, or returns false and doesn't change the parse state (note:
++// the parse-steps counter increases regardless of success or failure).
++// To ensure that the parse state isn't changed in the latter case, we
++// save the original state before we call multiple parsing functions
++// consecutively with &&, and restore it if unsuccessful.  See
+ // ParseEncoding() as an example of this convention.  We follow the
+ // convention throughout the code.
+ //
+@@ -477,10 +624,12 @@ static bool ParseSubstitution(State *state);
+ //
+ // Reference:
+ // - Itanium C++ ABI
+-//   <http://www.codesourcery.com/cxx-abi/abi.html#mangling>
++//   <https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling>
+ 
+ // <mangled-name> ::= _Z <encoding>
+ static bool ParseMangledName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   return ParseTwoCharToken(state, "_Z") && ParseEncoding(state);
+ }
+ 
+@@ -488,13 +637,18 @@ static bool ParseMangledName(State *state) {
+ //            ::= <(data) name>
+ //            ::= <special-name>
+ static bool ParseEncoding(State *state) {
+-  State copy = *state;
+-  if (ParseName(state) && ParseBareFunctionType(state)) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  // Implementing the first two productions together as <name>
++  // [<bare-function-type>] avoids exponential blowup of backtracking.
++  //
++  // Since Optional(...) can't fail, there's no need to copy the state for
++  // backtracking.
++  if (ParseName(state) && Optional(ParseBareFunctionType(state))) {
+     return true;
+   }
+-  *state = copy;
+ 
+-  if (ParseName(state) || ParseSpecialName(state)) {
++  if (ParseSpecialName(state)) {
+     return true;
+   }
+   return false;
+@@ -505,60 +659,73 @@ static bool ParseEncoding(State *state) {
+ //        ::= <unscoped-name>
+ //        ::= <local-name>
+ static bool ParseName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   if (ParseNestedName(state) || ParseLocalName(state)) {
+     return true;
+   }
+ 
+-  State copy = *state;
+-  if (ParseUnscopedTemplateName(state) &&
++  // We reorganize the productions to avoid re-parsing unscoped names.
++  // - Inline <unscoped-template-name> productions:
++  //   <name> ::= <substitution> <template-args>
++  //          ::= <unscoped-name> <template-args>
++  //          ::= <unscoped-name>
++  // - Merge the two productions that start with unscoped-name:
++  //   <name> ::= <unscoped-name> [<template-args>]
++
++  ParseState copy = state->parse_state;
++  // "std<...>" isn't a valid name.
++  if (ParseSubstitution(state, /*accept_std=*/false) &&
+       ParseTemplateArgs(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  // Less greedy than <unscoped-template-name> <template-args>.
+-  if (ParseUnscopedName(state)) {
+-    return true;
+-  }
+-  return false;
++  // Note there's no need to restore state after this since only the first
++  // subparser can fail.
++  return ParseUnscopedName(state) && Optional(ParseTemplateArgs(state));
+ }
+ 
+ // <unscoped-name> ::= <unqualified-name>
+ //                 ::= St <unqualified-name>
+ static bool ParseUnscopedName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   if (ParseUnqualifiedName(state)) {
+     return true;
+   }
+ 
+-  State copy = *state;
+-  if (ParseTwoCharToken(state, "St") &&
+-      MaybeAppend(state, "std::") &&
++  ParseState copy = state->parse_state;
++  if (ParseTwoCharToken(state, "St") && MaybeAppend(state, "std::") &&
+       ParseUnqualifiedName(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+-// <unscoped-template-name> ::= <unscoped-name>
+-//                          ::= <substitution>
+-static bool ParseUnscopedTemplateName(State *state) {
+-  return ParseUnscopedName(state) || ParseSubstitution(state);
++// <ref-qualifer> ::= R // lvalue method reference qualifier
++//                ::= O // rvalue method reference qualifier
++static inline bool ParseRefQualifier(State *state) {
++  return ParseCharClass(state, "OR");
+ }
+ 
+-// <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E
+-//               ::= N [<CV-qualifiers>] <template-prefix> <template-args> E
++// <nested-name> ::= N [<CV-qualifiers>] [<ref-qualifier>] <prefix>
++//                   <unqualified-name> E
++//               ::= N [<CV-qualifiers>] [<ref-qualifier>] <template-prefix>
++//                   <template-args> E
+ static bool ParseNestedName(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'N') &&
+-      EnterNestedName(state) &&
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'N') && EnterNestedName(state) &&
+       Optional(ParseCVQualifiers(state)) &&
+-      ParsePrefix(state) &&
++      Optional(ParseRefQualifier(state)) && ParsePrefix(state) &&
+       LeaveNestedName(state, copy.nest_level) &&
+       ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+@@ -574,12 +741,15 @@ static bool ParseNestedName(State *state) {
+ //                   ::= <template-param>
+ //                   ::= <substitution>
+ static bool ParsePrefix(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   bool has_something = false;
+   while (true) {
+     MaybeAppendSeparator(state);
+     if (ParseTemplateParam(state) ||
+-        ParseSubstitution(state) ||
+-        ParseUnscopedName(state)) {
++        ParseSubstitution(state, /*accept_std=*/true) ||
++        ParseUnscopedName(state) ||
++        (ParseOneCharToken(state, 'M') && ParseUnnamedTypeName(state))) {
+       has_something = true;
+       MaybeIncreaseNestLevel(state);
+       continue;
+@@ -594,40 +764,112 @@ static bool ParsePrefix(State *state) {
+   return true;
+ }
+ 
+-// <unqualified-name> ::= <operator-name>
+-//                    ::= <ctor-dtor-name>
++// <unqualified-name> ::= <operator-name> [<abi-tags>]
++//                    ::= <ctor-dtor-name> [<abi-tags>]
+ //                    ::= <source-name> [<abi-tags>]
+ //                    ::= <local-source-name> [<abi-tags>]
++//                    ::= <unnamed-type-name> [<abi-tags>]
++//
++// <local-source-name> is a GCC extension; see below.
+ static bool ParseUnqualifiedName(State *state) {
+-  return (ParseOperatorName(state) ||
+-          ParseCtorDtorName(state) ||
+-          (ParseSourceName(state) && Optional(ParseAbiTags(state))) ||
+-          (ParseLocalSourceName(state) && Optional(ParseAbiTags(state))));
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  if (ParseOperatorName(state, nullptr) || ParseCtorDtorName(state) ||
++      ParseSourceName(state) || ParseLocalSourceName(state) ||
++      ParseUnnamedTypeName(state)) {
++    return ParseAbiTags(state);
++  }
++  return false;
++}
++
++// <abi-tags> ::= <abi-tag> [<abi-tags>]
++// <abi-tag>  ::= B <source-name>
++static bool ParseAbiTags(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++
++  while (ParseOneCharToken(state, 'B')) {
++    ParseState copy = state->parse_state;
++    MaybeAppend(state, "[abi:");
++
++    if (!ParseSourceName(state)) {
++      state->parse_state = copy;
++      return false;
++    }
++    MaybeAppend(state, "]");
++  }
++
++  return true;
+ }
+ 
+ // <source-name> ::= <positive length number> <identifier>
+ static bool ParseSourceName(State *state) {
+-  State copy = *state;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
+   int length = -1;
+-  if (ParseNumber(state, &length) && ParseIdentifier(state, length)) {
++  if (ParseNumber(state, &length) &&
++      ParseIdentifier(state, static_cast<size_t>(length))) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <local-source-name> ::= L <source-name> [<discriminator>]
+ //
+ // References:
+-//   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=31775
+-//   http://gcc.gnu.org/viewcvs?view=rev&revision=124467
++//   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=31775
++//   https://gcc.gnu.org/viewcvs?view=rev&revision=124467
+ static bool ParseLocalSourceName(State *state) {
+-  State copy = *state;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'L') && ParseSourceName(state) &&
+       Optional(ParseDiscriminator(state))) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
++  return false;
++}
++
++// <unnamed-type-name> ::= Ut [<(nonnegative) number>] _
++//                     ::= <closure-type-name>
++// <closure-type-name> ::= Ul <lambda-sig> E [<(nonnegative) number>] _
++// <lambda-sig>        ::= <(parameter) type>+
++static bool ParseUnnamedTypeName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  // Type's 1-based index n is encoded as { "", n == 1; itoa(n-2), otherwise }.
++  // Optionally parse the encoded value into 'which' and add 2 to get the index.
++  int which = -1;
++
++  // Unnamed type local to function or class.
++  if (ParseTwoCharToken(state, "Ut") && Optional(ParseNumber(state, &which)) &&
++      which <= std::numeric_limits<int>::max() - 2 &&  // Don't overflow.
++      ParseOneCharToken(state, '_')) {
++    MaybeAppend(state, "{unnamed type#");
++    MaybeAppendDecimal(state, 2 + which);
++    MaybeAppend(state, "}");
++    return true;
++  }
++  state->parse_state = copy;
++
++  // Closure type.
++  which = -1;
++  if (ParseTwoCharToken(state, "Ul") && DisableAppend(state) &&
++      OneOrMore(ParseType, state) && RestoreAppend(state, copy.append) &&
++      ParseOneCharToken(state, 'E') && Optional(ParseNumber(state, &which)) &&
++      which <= std::numeric_limits<int>::max() - 2 &&  // Don't overflow.
++      ParseOneCharToken(state, '_')) {
++    MaybeAppend(state, "{lambda()#");
++    MaybeAppendDecimal(state, 2 + which);
++    MaybeAppend(state, "}");
++    return true;
++  }
++  state->parse_state = copy;
++
+   return false;
+ }
+ 
+@@ -635,23 +877,32 @@ static bool ParseLocalSourceName(State *state) {
+ // If "number_out" is non-null, then *number_out is set to the value of the
+ // parsed number on success.
+ static bool ParseNumber(State *state, int *number_out) {
+-  int sign = 1;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  bool negative = false;
+   if (ParseOneCharToken(state, 'n')) {
+-    sign = -1;
++    negative = true;
+   }
+-  const char *p = state->mangled_cur;
+-  int number = 0;
+-  for (;*p != '\0'; ++p) {
++  const char *p = RemainingInput(state);
++  uint64_t number = 0;
++  for (; *p != '\0'; ++p) {
+     if (IsDigit(*p)) {
+-      number = number * 10 + (*p - '0');
++      number = number * 10 + static_cast<uint64_t>(*p - '0');
+     } else {
+       break;
+     }
+   }
+-  if (p != state->mangled_cur) {  // Conversion succeeded.
+-    state->mangled_cur = p;
+-    if (number_out != NULL) {
+-      *number_out = number * sign;
++  // Apply the sign with uint64_t arithmetic so overflows aren't UB.  Gives
++  // "incorrect" results for out-of-range inputs, but negative values only
++  // appear for literals, which aren't printed.
++  if (negative) {
++    number = ~number + 1;
++  }
++  if (p != RemainingInput(state)) {  // Conversion succeeded.
++    state->parse_state.mangled_idx += p - RemainingInput(state);
++    if (number_out != nullptr) {
++      // Note: possibly truncate "number".
++      *number_out = static_cast<int>(number);
+     }
+     return true;
+   }
+@@ -661,14 +912,16 @@ static bool ParseNumber(State *state, int *number_out) {
+ // Floating-point literals are encoded using a fixed-length lowercase
+ // hexadecimal string.
+ static bool ParseFloatNumber(State *state) {
+-  const char *p = state->mangled_cur;
+-  for (;*p != '\0'; ++p) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  const char *p = RemainingInput(state);
++  for (; *p != '\0'; ++p) {
+     if (!IsDigit(*p) && !(*p >= 'a' && *p <= 'f')) {
+       break;
+     }
+   }
+-  if (p != state->mangled_cur) {  // Conversion succeeded.
+-    state->mangled_cur = p;
++  if (p != RemainingInput(state)) {  // Conversion succeeded.
++    state->parse_state.mangled_idx += p - RemainingInput(state);
+     return true;
+   }
+   return false;
+@@ -677,93 +930,85 @@ static bool ParseFloatNumber(State *state) {
+ // The <seq-id> is a sequence number in base 36,
+ // using digits and upper case letters
+ static bool ParseSeqId(State *state) {
+-  const char *p = state->mangled_cur;
+-  for (;*p != '\0'; ++p) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  const char *p = RemainingInput(state);
++  for (; *p != '\0'; ++p) {
+     if (!IsDigit(*p) && !(*p >= 'A' && *p <= 'Z')) {
+       break;
+     }
+   }
+-  if (p != state->mangled_cur) {  // Conversion succeeded.
+-    state->mangled_cur = p;
++  if (p != RemainingInput(state)) {  // Conversion succeeded.
++    state->parse_state.mangled_idx += p - RemainingInput(state);
+     return true;
+   }
+   return false;
+ }
+ 
+ // <identifier> ::= <unqualified source code identifier> (of given length)
+-static bool ParseIdentifier(State *state, ssize_t length) {
+-  if (length == -1 ||
+-      !AtLeastNumCharsRemaining(state->mangled_cur, length)) {
++static bool ParseIdentifier(State *state, size_t length) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  if (!AtLeastNumCharsRemaining(RemainingInput(state), length)) {
+     return false;
+   }
+   if (IdentifierIsAnonymousNamespace(state, length)) {
+     MaybeAppend(state, "(anonymous namespace)");
+   } else {
+-    MaybeAppendWithLength(state, state->mangled_cur, length);
++    MaybeAppendWithLength(state, RemainingInput(state), length);
+   }
+-  state->mangled_cur += length;
++  state->parse_state.mangled_idx += length;
+   return true;
+ }
+ 
+-// <abi-tags> ::= <abi-tag> [<abi-tags>]
+-static bool ParseAbiTags(State *state) {
+-  State copy = *state;
+-  DisableAppend(state);
+-  if (OneOrMore(ParseAbiTag, state)) {
+-    RestoreAppend(state, copy.append);
+-    return true;
+-  }
+-  *state = copy;
+-  return false;
+-}
+-
+-// <abi-tag> ::= B <source-name>
+-static bool ParseAbiTag(State *state) {
+-  return ParseOneCharToken(state, 'B') && ParseSourceName(state);
+-}
+-
+ // <operator-name> ::= nw, and other two letters cases
+ //                 ::= cv <type>  # (cast)
+ //                 ::= v  <digit> <source-name> # vendor extended operator
+-static bool ParseOperatorName(State *state) {
+-  if (!AtLeastNumCharsRemaining(state->mangled_cur, 2)) {
++static bool ParseOperatorName(State *state, int *arity) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  if (!AtLeastNumCharsRemaining(RemainingInput(state), 2)) {
+     return false;
+   }
+   // First check with "cv" (cast) case.
+-  State copy = *state;
+-  if (ParseTwoCharToken(state, "cv") &&
+-      MaybeAppend(state, "operator ") &&
+-      EnterNestedName(state) &&
+-      ParseType(state) &&
++  ParseState copy = state->parse_state;
++  if (ParseTwoCharToken(state, "cv") && MaybeAppend(state, "operator ") &&
++      EnterNestedName(state) && ParseType(state) &&
+       LeaveNestedName(state, copy.nest_level)) {
++    if (arity != nullptr) {
++      *arity = 1;
++    }
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   // Then vendor extended operators.
+-  if (ParseOneCharToken(state, 'v') && ParseCharClass(state, "0123456789") &&
++  if (ParseOneCharToken(state, 'v') && ParseDigit(state, arity) &&
+       ParseSourceName(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   // Other operator names should start with a lower alphabet followed
+   // by a lower/upper alphabet.
+-  if (!(IsLower(state->mangled_cur[0]) &&
+-        IsAlpha(state->mangled_cur[1]))) {
++  if (!(IsLower(RemainingInput(state)[0]) &&
++        IsAlpha(RemainingInput(state)[1]))) {
+     return false;
+   }
+   // We may want to perform a binary search if we really need speed.
+   const AbbrevPair *p;
+-  for (p = kOperatorList; p->abbrev != NULL; ++p) {
+-    if (state->mangled_cur[0] == p->abbrev[0] &&
+-        state->mangled_cur[1] == p->abbrev[1]) {
++  for (p = kOperatorList; p->abbrev != nullptr; ++p) {
++    if (RemainingInput(state)[0] == p->abbrev[0] &&
++        RemainingInput(state)[1] == p->abbrev[1]) {
++      if (arity != nullptr) {
++        *arity = p->arity;
++      }
+       MaybeAppend(state, "operator");
+       if (IsLower(*p->real_name)) {  // new, delete, etc.
+         MaybeAppend(state, " ");
+       }
+       MaybeAppend(state, p->real_name);
+-      state->mangled_cur += 2;
++      state->parse_state.mangled_idx += 2;
+       return true;
+     }
+   }
+@@ -774,6 +1019,7 @@ static bool ParseOperatorName(State *state) {
+ //                ::= TT <type>
+ //                ::= TI <type>
+ //                ::= TS <type>
++//                ::= TH <type>  # thread-local
+ //                ::= Tc <call-offset> <call-offset> <(base) encoding>
+ //                ::= GV <(object) name>
+ //                ::= T <call-offset> <(base) encoding>
+@@ -789,123 +1035,156 @@ static bool ParseOperatorName(State *state) {
+ // Note: we don't care much about them since they don't appear in
+ // stack traces.  The are special data.
+ static bool ParseSpecialName(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'T') &&
+-      ParseCharClass(state, "VTIS") &&
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "VTISH") &&
+       ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseTwoCharToken(state, "Tc") && ParseCallOffset(state) &&
+       ParseCallOffset(state) && ParseEncoding(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseTwoCharToken(state, "GV") &&
+-      ParseName(state)) {
++  if (ParseTwoCharToken(state, "GV") && ParseName(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'T') && ParseCallOffset(state) &&
+       ParseEncoding(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   // G++ extensions
+   if (ParseTwoCharToken(state, "TC") && ParseType(state) &&
+-      ParseNumber(state, NULL) && ParseOneCharToken(state, '_') &&
+-      DisableAppend(state) &&
+-      ParseType(state)) {
++      ParseNumber(state, nullptr) && ParseOneCharToken(state, '_') &&
++      DisableAppend(state) && ParseType(state)) {
+     RestoreAppend(state, copy.append);
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "FJ") &&
+       ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseTwoCharToken(state, "GR") && ParseName(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseTwoCharToken(state, "GA") && ParseEncoding(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "hv") &&
+       ParseCallOffset(state) && ParseEncoding(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <call-offset> ::= h <nv-offset> _
+ //               ::= v <v-offset> _
+ static bool ParseCallOffset(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'h') &&
+-      ParseNVOffset(state) && ParseOneCharToken(state, '_')) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'h') && ParseNVOffset(state) &&
++      ParseOneCharToken(state, '_')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseOneCharToken(state, 'v') &&
+-      ParseVOffset(state) && ParseOneCharToken(state, '_')) {
++  if (ParseOneCharToken(state, 'v') && ParseVOffset(state) &&
++      ParseOneCharToken(state, '_')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   return false;
+ }
+ 
+ // <nv-offset> ::= <(offset) number>
+ static bool ParseNVOffset(State *state) {
+-  return ParseNumber(state, NULL);
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  return ParseNumber(state, nullptr);
+ }
+ 
+ // <v-offset>  ::= <(offset) number> _ <(virtual offset) number>
+ static bool ParseVOffset(State *state) {
+-  State copy = *state;
+-  if (ParseNumber(state, NULL) && ParseOneCharToken(state, '_') &&
+-      ParseNumber(state, NULL)) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseNumber(state, nullptr) && ParseOneCharToken(state, '_') &&
++      ParseNumber(state, nullptr)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+-// <ctor-dtor-name> ::= C1 | C2 | C3
++// <ctor-dtor-name> ::= C1 | C2 | C3 | CI1 <base-class-type> | CI2
++// <base-class-type>
+ //                  ::= D0 | D1 | D2
++// # GCC extensions: "unified" constructor/destructor.  See
++// #
++// https://github.com/gcc-mirror/gcc/blob/7ad17b583c3643bd4557f29b8391ca7ef08391f5/gcc/cp/mangle.c#L1847
++//                  ::= C4 | D4
+ static bool ParseCtorDtorName(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'C') &&
+-      ParseCharClass(state, "123")) {
+-    const char * const prev_name = state->prev_name;
+-    const ssize_t prev_name_length = state->prev_name_length;
+-    MaybeAppendWithLength(state, prev_name, prev_name_length);
+-    return true;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'C')) {
++    if (ParseCharClass(state, "1234")) {
++      const char *const prev_name =
++          state->out + state->parse_state.prev_name_idx;
++      MaybeAppendWithLength(state, prev_name,
++                            state->parse_state.prev_name_length);
++      return true;
++    } else if (ParseOneCharToken(state, 'I') && ParseCharClass(state, "12") &&
++               ParseClassEnumType(state)) {
++      return true;
++    }
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseOneCharToken(state, 'D') &&
+-      ParseCharClass(state, "012")) {
+-    const char * const prev_name = state->prev_name;
+-    const ssize_t prev_name_length = state->prev_name_length;
++  if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "0124")) {
++    const char *const prev_name = state->out + state->parse_state.prev_name_idx;
+     MaybeAppend(state, "~");
+-    MaybeAppendWithLength(state, prev_name, prev_name_length);
++    MaybeAppendWithLength(state, prev_name,
++                          state->parse_state.prev_name_length);
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
++  return false;
++}
++
++// <decltype> ::= Dt <expression> E  # decltype of an id-expression or class
++//                                   # member access (C++0x)
++//            ::= DT <expression> E  # decltype of an expression (C++0x)
++static bool ParseDecltype(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "tT") &&
++      ParseExpression(state) && ParseOneCharToken(state, 'E')) {
++    return true;
++  }
++  state->parse_state = copy;
++
+   return false;
+ }
+ 
+@@ -918,67 +1197,87 @@ static bool ParseCtorDtorName(State *state) {
+ //        ::= U <source-name> <type>  # vendor extended type qualifier
+ //        ::= <builtin-type>
+ //        ::= <function-type>
+-//        ::= <class-enum-type>
++//        ::= <class-enum-type>  # note: just an alias for <name>
+ //        ::= <array-type>
+ //        ::= <pointer-to-member-type>
+ //        ::= <template-template-param> <template-args>
+ //        ::= <template-param>
++//        ::= <decltype>
+ //        ::= <substitution>
+ //        ::= Dp <type>          # pack expansion of (C++0x)
+-//        ::= Dt <expression> E  # decltype of an id-expression or class
+-//                               # member access (C++0x)
+-//        ::= DT <expression> E  # decltype of an expression (C++0x)
++//        ::= Dv <num-elems> _   # GNU vector extension
+ //
+ static bool ParseType(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++
+   // We should check CV-qualifers, and PRGC things first.
+-  State copy = *state;
+-  if (ParseCVQualifiers(state) && ParseType(state)) {
+-    return true;
++  //
++  // CV-qualifiers overlap with some operator names, but an operator name is not
++  // valid as a type.  To avoid an ambiguity that can lead to exponential time
++  // complexity, refuse to backtrack the CV-qualifiers.
++  //
++  // _Z4aoeuIrMvvE
++  //  => _Z 4aoeuI        rM  v     v   E
++  //         aoeu<operator%=, void, void>
++  //  => _Z 4aoeuI r Mv v              E
++  //         aoeu<void void::* restrict>
++  //
++  // By consuming the CV-qualifiers first, the former parse is disabled.
++  if (ParseCVQualifiers(state)) {
++    const bool result = ParseType(state);
++    if (!result) state->parse_state = copy;
++    return result;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseCharClass(state, "OPRCG") && ParseType(state)) {
+-    return true;
++  // Similarly, these tag characters can overlap with other <name>s resulting in
++  // two different parse prefixes that land on <template-args> in the same
++  // place, such as "C3r1xI...".  So, disable the "ctor-name = C3" parse by
++  // refusing to backtrack the tag characters.
++  if (ParseCharClass(state, "OPRCG")) {
++    const bool result = ParseType(state);
++    if (!result) state->parse_state = copy;
++    return result;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseTwoCharToken(state, "Dp") && ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
+-
+-  if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "tT") &&
+-      ParseExpression(state) && ParseOneCharToken(state, 'E')) {
+-    return true;
+-  }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'U') && ParseSourceName(state) &&
+       ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseBuiltinType(state) ||
+-      ParseFunctionType(state) ||
+-      ParseClassEnumType(state) ||
+-      ParseArrayType(state) ||
+-      ParsePointerToMemberType(state) ||
+-      ParseSubstitution(state)) {
++  if (ParseBuiltinType(state) || ParseFunctionType(state) ||
++      ParseClassEnumType(state) || ParseArrayType(state) ||
++      ParsePointerToMemberType(state) || ParseDecltype(state) ||
++      // "std" on its own isn't a type.
++      ParseSubstitution(state, /*accept_std=*/false)) {
+     return true;
+   }
+ 
+-  if (ParseTemplateTemplateParam(state) &&
+-      ParseTemplateArgs(state)) {
++  if (ParseTemplateTemplateParam(state) && ParseTemplateArgs(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   // Less greedy than <template-template-param> <template-args>.
+   if (ParseTemplateParam(state)) {
+     return true;
+   }
+ 
++  if (ParseTwoCharToken(state, "Dv") && ParseNumber(state, nullptr) &&
++      ParseOneCharToken(state, '_')) {
++    return true;
++  }
++  state->parse_state = copy;
++
+   return false;
+ }
+ 
+@@ -986,6 +1285,8 @@ static bool ParseType(State *state) {
+ // We don't allow empty <CV-qualifiers> to avoid infinite loop in
+ // ParseType().
+ static bool ParseCVQualifiers(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   int num_cv_qualifiers = 0;
+   num_cv_qualifiers += ParseOneCharToken(state, 'r');
+   num_cv_qualifiers += ParseOneCharToken(state, 'V');
+@@ -993,208 +1294,499 @@ static bool ParseCVQualifiers(State *state) {
+   return num_cv_qualifiers > 0;
+ }
+ 
+-// <builtin-type> ::= v, etc.
++// <builtin-type> ::= v, etc.  # single-character builtin types
+ //                ::= u <source-name>
++//                ::= Dd, etc.  # two-character builtin types
++//
++// Not supported:
++//                ::= DF <number> _ # _FloatN (N bits)
++//
+ static bool ParseBuiltinType(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   const AbbrevPair *p;
+-  for (p = kBuiltinTypeList; p->abbrev != NULL; ++p) {
+-    if (state->mangled_cur[0] == p->abbrev[0]) {
++  for (p = kBuiltinTypeList; p->abbrev != nullptr; ++p) {
++    // Guaranteed only 1- or 2-character strings in kBuiltinTypeList.
++    if (p->abbrev[1] == '\0') {
++      if (ParseOneCharToken(state, p->abbrev[0])) {
++        MaybeAppend(state, p->real_name);
++        return true;
++      }
++    } else if (p->abbrev[2] == '\0' && ParseTwoCharToken(state, p->abbrev)) {
+       MaybeAppend(state, p->real_name);
+-      ++state->mangled_cur;
+       return true;
+     }
+   }
+ 
+-  State copy = *state;
++  ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'u') && ParseSourceName(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+-// <function-type> ::= F [Y] <bare-function-type> E
++//  <exception-spec> ::= Do                # non-throwing
++//                                           exception-specification (e.g.,
++//                                           noexcept, throw())
++//                   ::= DO <expression> E # computed (instantiation-dependent)
++//                                           noexcept
++//                   ::= Dw <type>+ E      # dynamic exception specification
++//                                           with instantiation-dependent types
++static bool ParseExceptionSpec(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++
++  if (ParseTwoCharToken(state, "Do")) return true;
++
++  ParseState copy = state->parse_state;
++  if (ParseTwoCharToken(state, "DO") && ParseExpression(state) &&
++      ParseOneCharToken(state, 'E')) {
++    return true;
++  }
++  state->parse_state = copy;
++  if (ParseTwoCharToken(state, "Dw") && OneOrMore(ParseType, state) &&
++      ParseOneCharToken(state, 'E')) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  return false;
++}
++
++// <function-type> ::= [exception-spec] F [Y] <bare-function-type> [O] E
+ static bool ParseFunctionType(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'F') &&
+-      Optional(ParseOneCharToken(state, 'Y')) &&
+-      ParseBareFunctionType(state) && ParseOneCharToken(state, 'E')) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (Optional(ParseExceptionSpec(state)) && ParseOneCharToken(state, 'F') &&
++      Optional(ParseOneCharToken(state, 'Y')) && ParseBareFunctionType(state) &&
++      Optional(ParseOneCharToken(state, 'O')) &&
++      ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <bare-function-type> ::= <(signature) type>+
+ static bool ParseBareFunctionType(State *state) {
+-  State copy = *state;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
+   DisableAppend(state);
+   if (OneOrMore(ParseType, state)) {
+     RestoreAppend(state, copy.append);
+     MaybeAppend(state, "()");
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <class-enum-type> ::= <name>
+ static bool ParseClassEnumType(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   return ParseName(state);
+ }
+ 
+ // <array-type> ::= A <(positive dimension) number> _ <(element) type>
+ //              ::= A [<(dimension) expression>] _ <(element) type>
+ static bool ParseArrayType(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'A') && ParseNumber(state, NULL) &&
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'A') && ParseNumber(state, nullptr) &&
+       ParseOneCharToken(state, '_') && ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'A') && Optional(ParseExpression(state)) &&
+       ParseOneCharToken(state, '_') && ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <pointer-to-member-type> ::= M <(class) type> <(member) type>
+ static bool ParsePointerToMemberType(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'M') && ParseType(state) &&
+-      ParseType(state)) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'M') && ParseType(state) && ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <template-param> ::= T_
+ //                  ::= T <parameter-2 non-negative number> _
+ static bool ParseTemplateParam(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   if (ParseTwoCharToken(state, "T_")) {
+     MaybeAppend(state, "?");  // We don't support template substitutions.
+     return true;
+   }
+ 
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'T') && ParseNumber(state, NULL) &&
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'T') && ParseNumber(state, nullptr) &&
+       ParseOneCharToken(state, '_')) {
+     MaybeAppend(state, "?");  // We don't support template substitutions.
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+-
+ // <template-template-param> ::= <template-param>
+ //                           ::= <substitution>
+ static bool ParseTemplateTemplateParam(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   return (ParseTemplateParam(state) ||
+-          ParseSubstitution(state));
++          // "std" on its own isn't a template.
++          ParseSubstitution(state, /*accept_std=*/false));
+ }
+ 
+ // <template-args> ::= I <template-arg>+ E
+ static bool ParseTemplateArgs(State *state) {
+-  State copy = *state;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
+   DisableAppend(state);
+-  if (ParseOneCharToken(state, 'I') &&
+-      OneOrMore(ParseTemplateArg, state) &&
++  if (ParseOneCharToken(state, 'I') && OneOrMore(ParseTemplateArg, state) &&
+       ParseOneCharToken(state, 'E')) {
+     RestoreAppend(state, copy.append);
+     MaybeAppend(state, "<>");
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <template-arg>  ::= <type>
+ //                 ::= <expr-primary>
+-//                 ::= I <template-arg>* E        # argument pack
+ //                 ::= J <template-arg>* E        # argument pack
+ //                 ::= X <expression> E
+ static bool ParseTemplateArg(State *state) {
+-  State copy = *state;
+-  if ((ParseOneCharToken(state, 'I') || ParseOneCharToken(state, 'J')) &&
+-      ZeroOrMore(ParseTemplateArg, state) &&
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, 'J') && ZeroOrMore(ParseTemplateArg, state) &&
+       ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
++
++  // There can be significant overlap between the following leading to
++  // exponential backtracking:
++  //
++  //   <expr-primary> ::= L <type> <expr-cast-value> E
++  //                 e.g. L 2xxIvE 1                 E
++  //   <type>         ==> <local-source-name> <template-args>
++  //                 e.g. L 2xx               IvE
++  //
++  // This means parsing an entire <type> twice, and <type> can contain
++  // <template-arg>, so this can generate exponential backtracking.  There is
++  // only overlap when the remaining input starts with "L <source-name>", so
++  // parse all cases that can start this way jointly to share the common prefix.
++  //
++  // We have:
++  //
++  //   <template-arg> ::= <type>
++  //                  ::= <expr-primary>
++  //
++  // First, drop all the productions of <type> that must start with something
++  // other than 'L'.  All that's left is <class-enum-type>; inline it.
++  //
++  //   <type> ::= <nested-name> # starts with 'N'
++  //          ::= <unscoped-name>
++  //          ::= <unscoped-template-name> <template-args>
++  //          ::= <local-name> # starts with 'Z'
++  //
++  // Drop and inline again:
++  //
++  //   <type> ::= <unscoped-name>
++  //          ::= <unscoped-name> <template-args>
++  //          ::= <substitution> <template-args> # starts with 'S'
++  //
++  // Merge the first two, inline <unscoped-name>, drop last:
++  //
++  //   <type> ::= <unqualified-name> [<template-args>]
++  //          ::= St <unqualified-name> [<template-args>] # starts with 'S'
++  //
++  // Drop and inline:
++  //
++  //   <type> ::= <operator-name> [<template-args>] # starts with lowercase
++  //          ::= <ctor-dtor-name> [<template-args>] # starts with 'C' or 'D'
++  //          ::= <source-name> [<template-args>] # starts with digit
++  //          ::= <local-source-name> [<template-args>]
++  //          ::= <unnamed-type-name> [<template-args>] # starts with 'U'
++  //
++  // One more time:
++  //
++  //   <type> ::= L <source-name> [<template-args>]
++  //
++  // Likewise with <expr-primary>:
++  //
++  //   <expr-primary> ::= L <type> <expr-cast-value> E
++  //                  ::= LZ <encoding> E # cannot overlap; drop
++  //                  ::= L <mangled_name> E # cannot overlap; drop
++  //
++  // By similar reasoning as shown above, the only <type>s starting with
++  // <source-name> are "<source-name> [<template-args>]".  Inline this.
++  //
++  //   <expr-primary> ::= L <source-name> [<template-args>] <expr-cast-value> E
++  //
++  // Now inline both of these into <template-arg>:
++  //
++  //   <template-arg> ::= L <source-name> [<template-args>]
++  //                  ::= L <source-name> [<template-args>] <expr-cast-value> E
++  //
++  // Merge them and we're done:
++  //   <template-arg>
++  //     ::= L <source-name> [<template-args>] [<expr-cast-value> E]
++  if (ParseLocalSourceName(state) && Optional(ParseTemplateArgs(state))) {
++    copy = state->parse_state;
++    if (ParseExprCastValue(state) && ParseOneCharToken(state, 'E')) {
++      return true;
++    }
++    state->parse_state = copy;
++    return true;
++  }
+ 
+-  if (ParseType(state) ||
+-      ParseExprPrimary(state)) {
++  // Now that the overlapping cases can't reach this code, we can safely call
++  // both of these.
++  if (ParseType(state) || ParseExprPrimary(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'X') && ParseExpression(state) &&
+       ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+-// <expression> ::= <template-param>
+-//              ::= <expr-primary>
+-//              ::= <unary operator-name> <expression>
+-//              ::= <binary operator-name> <expression> <expression>
+-//              ::= <trinary operator-name> <expression> <expression>
+-//                  <expression>
++// <unresolved-type> ::= <template-param> [<template-args>]
++//                   ::= <decltype>
++//                   ::= <substitution>
++static inline bool ParseUnresolvedType(State *state) {
++  // No ComplexityGuard because we don't copy the state in this stack frame.
++  return (ParseTemplateParam(state) && Optional(ParseTemplateArgs(state))) ||
++         ParseDecltype(state) || ParseSubstitution(state, /*accept_std=*/false);
++}
++
++// <simple-id> ::= <source-name> [<template-args>]
++static inline bool ParseSimpleId(State *state) {
++  // No ComplexityGuard because we don't copy the state in this stack frame.
++
++  // Note: <simple-id> cannot be followed by a parameter pack; see comment in
++  // ParseUnresolvedType.
++  return ParseSourceName(state) && Optional(ParseTemplateArgs(state));
++}
++
++// <base-unresolved-name> ::= <source-name> [<template-args>]
++//                        ::= on <operator-name> [<template-args>]
++//                        ::= dn <destructor-name>
++static bool ParseBaseUnresolvedName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++
++  if (ParseSimpleId(state)) {
++    return true;
++  }
++
++  ParseState copy = state->parse_state;
++  if (ParseTwoCharToken(state, "on") && ParseOperatorName(state, nullptr) &&
++      Optional(ParseTemplateArgs(state))) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  if (ParseTwoCharToken(state, "dn") &&
++      (ParseUnresolvedType(state) || ParseSimpleId(state))) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  return false;
++}
++
++// <unresolved-name> ::= [gs] <base-unresolved-name>
++//                   ::= sr <unresolved-type> <base-unresolved-name>
++//                   ::= srN <unresolved-type> <unresolved-qualifier-level>+ E
++//                         <base-unresolved-name>
++//                   ::= [gs] sr <unresolved-qualifier-level>+ E
++//                         <base-unresolved-name>
++static bool ParseUnresolvedName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++
++  ParseState copy = state->parse_state;
++  if (Optional(ParseTwoCharToken(state, "gs")) &&
++      ParseBaseUnresolvedName(state)) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  if (ParseTwoCharToken(state, "sr") && ParseUnresolvedType(state) &&
++      ParseBaseUnresolvedName(state)) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  if (ParseTwoCharToken(state, "sr") && ParseOneCharToken(state, 'N') &&
++      ParseUnresolvedType(state) &&
++      OneOrMore(/* <unresolved-qualifier-level> ::= */ ParseSimpleId, state) &&
++      ParseOneCharToken(state, 'E') && ParseBaseUnresolvedName(state)) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  if (Optional(ParseTwoCharToken(state, "gs")) &&
++      ParseTwoCharToken(state, "sr") &&
++      OneOrMore(/* <unresolved-qualifier-level> ::= */ ParseSimpleId, state) &&
++      ParseOneCharToken(state, 'E') && ParseBaseUnresolvedName(state)) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  return false;
++}
++
++// <expression> ::= <1-ary operator-name> <expression>
++//              ::= <2-ary operator-name> <expression> <expression>
++//              ::= <3-ary operator-name> <expression> <expression> <expression>
++//              ::= cl <expression>+ E
++//              ::= cp <simple-id> <expression>* E # Clang-specific.
++//              ::= cv <type> <expression>      # type (expression)
++//              ::= cv <type> _ <expression>* E # type (expr-list)
+ //              ::= st <type>
++//              ::= <template-param>
++//              ::= <function-param>
++//              ::= <expr-primary>
++//              ::= dt <expression> <unresolved-name> # expr.name
++//              ::= pt <expression> <unresolved-name> # expr->name
++//              ::= sp <expression>         # argument pack expansion
+ //              ::= sr <type> <unqualified-name> <template-args>
+ //              ::= sr <type> <unqualified-name>
++// <function-param> ::= fp <(top-level) CV-qualifiers> _
++//                  ::= fp <(top-level) CV-qualifiers> <number> _
++//                  ::= fL <number> p <(top-level) CV-qualifiers> _
++//                  ::= fL <number> p <(top-level) CV-qualifiers> <number> _
+ static bool ParseExpression(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   if (ParseTemplateParam(state) || ParseExprPrimary(state)) {
+     return true;
+   }
+ 
+-  State copy = *state;
+-  if (ParseOperatorName(state) &&
+-      ParseExpression(state) &&
+-      ParseExpression(state) &&
+-      ParseExpression(state)) {
++  ParseState copy = state->parse_state;
++
++  // Object/function call expression.
++  if (ParseTwoCharToken(state, "cl") && OneOrMore(ParseExpression, state) &&
++      ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseOperatorName(state) &&
+-      ParseExpression(state) &&
+-      ParseExpression(state)) {
++  // Clang-specific "cp <simple-id> <expression>* E"
++  //   https://clang.llvm.org/doxygen/ItaniumMangle_8cpp_source.html#l04338
++  if (ParseTwoCharToken(state, "cp") && ParseSimpleId(state) &&
++      ZeroOrMore(ParseExpression, state) && ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseOperatorName(state) &&
+-      ParseExpression(state)) {
++  // Function-param expression (level 0).
++  if (ParseTwoCharToken(state, "fp") && Optional(ParseCVQualifiers(state)) &&
++      Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
++  // Function-param expression (level 1+).
++  if (ParseTwoCharToken(state, "fL") && Optional(ParseNumber(state, nullptr)) &&
++      ParseOneCharToken(state, 'p') && Optional(ParseCVQualifiers(state)) &&
++      Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  // Parse the conversion expressions jointly to avoid re-parsing the <type> in
++  // their common prefix.  Parsed as:
++  // <expression> ::= cv <type> <conversion-args>
++  // <conversion-args> ::= _ <expression>* E
++  //                   ::= <expression>
++  //
++  // Also don't try ParseOperatorName after seeing "cv", since ParseOperatorName
++  // also needs to accept "cv <type>" in other contexts.
++  if (ParseTwoCharToken(state, "cv")) {
++    if (ParseType(state)) {
++      ParseState copy2 = state->parse_state;
++      if (ParseOneCharToken(state, '_') && ZeroOrMore(ParseExpression, state) &&
++          ParseOneCharToken(state, 'E')) {
++        return true;
++      }
++      state->parse_state = copy2;
++      if (ParseExpression(state)) {
++        return true;
++      }
++    }
++  } else {
++    // Parse unary, binary, and ternary operator expressions jointly, taking
++    // care not to re-parse subexpressions repeatedly. Parse like:
++    //   <expression> ::= <operator-name> <expression>
++    //                    [<one-to-two-expressions>]
++    //   <one-to-two-expressions> ::= <expression> [<expression>]
++    int arity = -1;
++    if (ParseOperatorName(state, &arity) &&
++        arity > 0 &&  // 0 arity => disabled.
++        (arity < 3 || ParseExpression(state)) &&
++        (arity < 2 || ParseExpression(state)) &&
++        (arity < 1 || ParseExpression(state))) {
++      return true;
++    }
++  }
++  state->parse_state = copy;
++
++  // sizeof type
+   if (ParseTwoCharToken(state, "st") && ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseTwoCharToken(state, "sr") && ParseType(state) &&
+-      ParseUnqualifiedName(state) &&
+-      ParseTemplateArgs(state)) {
++  // Object and pointer member access expressions.
++  if ((ParseTwoCharToken(state, "dt") || ParseTwoCharToken(state, "pt")) &&
++      ParseExpression(state) && ParseType(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseTwoCharToken(state, "sr") && ParseType(state) &&
+-      ParseUnqualifiedName(state)) {
++  // Pointer-to-member access expressions.  This parses the same as a binary
++  // operator, but it's implemented separately because "ds" shouldn't be
++  // accepted in other contexts that parse an operator name.
++  if (ParseTwoCharToken(state, "ds") && ParseExpression(state) &&
++      ParseExpression(state)) {
+     return true;
+   }
+-  *state = copy;
+-  return false;
++  state->parse_state = copy;
++
++  // Parameter pack expansion
++  if (ParseTwoCharToken(state, "sp") && ParseExpression(state)) {
++    return true;
++  }
++  state->parse_state = copy;
++
++  return ParseUnresolvedName(state);
+ }
+ 
+ // <expr-primary> ::= L <type> <(value) number> E
+@@ -1202,116 +1794,194 @@ static bool ParseExpression(State *state) {
+ //                ::= L <mangled-name> E
+ //                // A bug in g++'s C++ ABI version 2 (-fabi-version=2).
+ //                ::= LZ <encoding> E
++//
++// Warning, subtle: the "bug" LZ production above is ambiguous with the first
++// production where <type> starts with <local-name>, which can lead to
++// exponential backtracking in two scenarios:
++//
++// - When whatever follows the E in the <local-name> in the first production is
++//   not a name, we backtrack the whole <encoding> and re-parse the whole thing.
++//
++// - When whatever follows the <local-name> in the first production is not a
++//   number and this <expr-primary> may be followed by a name, we backtrack the
++//   <name> and re-parse it.
++//
++// Moreover this ambiguity isn't always resolved -- for example, the following
++// has two different parses:
++//
++//   _ZaaILZ4aoeuE1x1EvE
++//   => operator&&<aoeu, x, E, void>
++//   => operator&&<(aoeu::x)(1), void>
++//
++// To resolve this, we just do what GCC's demangler does, and refuse to parse
++// casts to <local-name> types.
+ static bool ParseExprPrimary(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'L') && ParseType(state) &&
+-      ParseNumber(state, NULL) &&
+-      ParseOneCharToken(state, 'E')) {
+-    return true;
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++
++  // The "LZ" special case: if we see LZ, we commit to accept "LZ <encoding> E"
++  // or fail, no backtracking.
++  if (ParseTwoCharToken(state, "LZ")) {
++    if (ParseEncoding(state) && ParseOneCharToken(state, 'E')) {
++      return true;
++    }
++
++    state->parse_state = copy;
++    return false;
+   }
+-  *state = copy;
+ 
++  // The merged cast production.
+   if (ParseOneCharToken(state, 'L') && ParseType(state) &&
+-      ParseFloatNumber(state) &&
+-      ParseOneCharToken(state, 'E')) {
++      ParseExprCastValue(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'L') && ParseMangledName(state) &&
+       ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+-  if (ParseTwoCharToken(state, "LZ") && ParseEncoding(state) &&
+-      ParseOneCharToken(state, 'E')) {
++  return false;
++}
++
++// <number> or <float>, followed by 'E', as described above ParseExprPrimary.
++static bool ParseExprCastValue(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  // We have to be able to backtrack after accepting a number because we could
++  // have e.g. "7fffE", which will accept "7" as a number but then fail to find
++  // the 'E'.
++  ParseState copy = state->parse_state;
++  if (ParseNumber(state, nullptr) && ParseOneCharToken(state, 'E')) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
++
++  if (ParseFloatNumber(state) && ParseOneCharToken(state, 'E')) {
++    return true;
++  }
++  state->parse_state = copy;
+ 
+   return false;
+ }
+ 
+-// <local-name> := Z <(function) encoding> E <(entity) name>
+-//                 [<discriminator>]
+-//              := Z <(function) encoding> E s [<discriminator>]
+-static bool ParseLocalName(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, 'Z') && ParseEncoding(state) &&
+-      ParseOneCharToken(state, 'E') && MaybeAppend(state, "::") &&
+-      ParseName(state) && Optional(ParseDiscriminator(state))) {
++// <local-name> ::= Z <(function) encoding> E <(entity) name> [<discriminator>]
++//              ::= Z <(function) encoding> E s [<discriminator>]
++//
++// Parsing a common prefix of these two productions together avoids an
++// exponential blowup of backtracking.  Parse like:
++//   <local-name> := Z <encoding> E <local-name-suffix>
++//   <local-name-suffix> ::= s [<discriminator>]
++//                       ::= <name> [<discriminator>]
++
++static bool ParseLocalNameSuffix(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++
++  if (MaybeAppend(state, "::") && ParseName(state) &&
++      Optional(ParseDiscriminator(state))) {
+     return true;
+   }
+-  *state = copy;
+ 
++  // Since we're not going to overwrite the above "::" by re-parsing the
++  // <encoding> (whose trailing '\0' byte was in the byte now holding the
++  // first ':'), we have to rollback the "::" if the <name> parse failed.
++  if (state->parse_state.append) {
++    state->out[state->parse_state.out_cur_idx - 2] = '\0';
++  }
++
++  return ParseOneCharToken(state, 's') && Optional(ParseDiscriminator(state));
++}
++
++static bool ParseLocalName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'Z') && ParseEncoding(state) &&
+-      ParseTwoCharToken(state, "Es") && Optional(ParseDiscriminator(state))) {
++      ParseOneCharToken(state, 'E') && ParseLocalNameSuffix(state)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <discriminator> := _ <(non-negative) number>
+ static bool ParseDiscriminator(State *state) {
+-  State copy = *state;
+-  if (ParseOneCharToken(state, '_') && ParseNumber(state, NULL)) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
++  ParseState copy = state->parse_state;
++  if (ParseOneCharToken(state, '_') && ParseNumber(state, nullptr)) {
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // <substitution> ::= S_
+ //                ::= S <seq-id> _
+ //                ::= St, etc.
+-static bool ParseSubstitution(State *state) {
++//
++// "St" is special in that it's not valid as a standalone name, and it *is*
++// allowed to precede a name without being wrapped in "N...E".  This means that
++// if we accept it on its own, we can accept "St1a" and try to parse
++// template-args, then fail and backtrack, accept "St" on its own, then "1a" as
++// an unqualified name and re-parse the same template-args.  To block this
++// exponential backtracking, we disable it with 'accept_std=false' in
++// problematic contexts.
++static bool ParseSubstitution(State *state, bool accept_std) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   if (ParseTwoCharToken(state, "S_")) {
+     MaybeAppend(state, "?");  // We don't support substitutions.
+     return true;
+   }
+ 
+-  State copy = *state;
++  ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'S') && ParseSeqId(state) &&
+       ParseOneCharToken(state, '_')) {
+     MaybeAppend(state, "?");  // We don't support substitutions.
+     return true;
+   }
+-  *state = copy;
++  state->parse_state = copy;
+ 
+   // Expand abbreviations like "St" => "std".
+   if (ParseOneCharToken(state, 'S')) {
+     const AbbrevPair *p;
+-    for (p = kSubstitutionList; p->abbrev != NULL; ++p) {
+-      if (state->mangled_cur[0] == p->abbrev[1]) {
++    for (p = kSubstitutionList; p->abbrev != nullptr; ++p) {
++      if (RemainingInput(state)[0] == p->abbrev[1] &&
++          (accept_std || p->abbrev[1] != 't')) {
+         MaybeAppend(state, "std");
+         if (p->real_name[0] != '\0') {
+           MaybeAppend(state, "::");
+           MaybeAppend(state, p->real_name);
+         }
+-        ++state->mangled_cur;
++        ++state->parse_state.mangled_idx;
+         return true;
+       }
+     }
+   }
+-  *state = copy;
++  state->parse_state = copy;
+   return false;
+ }
+ 
+ // Parse <mangled-name>, optionally followed by either a function-clone suffix
+ // or version suffix.  Returns true only if all of "mangled_cur" was consumed.
+ static bool ParseTopLevelMangledName(State *state) {
++  ComplexityGuard guard(state);
++  if (guard.IsTooComplex()) return false;
+   if (ParseMangledName(state)) {
+-    if (state->mangled_cur[0] != '\0') {
++    if (RemainingInput(state)[0] != '\0') {
+       // Drop trailing function clone suffix, if any.
+-      if (IsFunctionCloneSuffix(state->mangled_cur)) {
++      if (IsFunctionCloneSuffix(RemainingInput(state))) {
+         return true;
+       }
+       // Append trailing version suffix if any.
+       // ex. _Z3foo@@GLIBCXX_3.4
+-      if (state->mangled_cur[0] == '@') {
+-        MaybeAppend(state, state->mangled_cur);
++      if (RemainingInput(state)[0] == '@') {
++        MaybeAppend(state, RemainingInput(state));
+         return true;
+       }
+       return false;  // Unconsumed suffix.
+@@ -1320,6 +1990,10 @@ static bool ParseTopLevelMangledName(State *state) {
+   }
+   return false;
+ }
++
++static bool Overflowed(const State *state) {
++  return state->parse_state.out_cur_idx >= state->out_end_idx;
++}
+ #endif
+ 
+ // The demangler entry point.
+@@ -1356,7 +2030,8 @@ bool Demangle(const char *mangled, char *out, size_t out_size) {
+ #else
+   State state;
+   InitState(&state, mangled, out, out_size);
+-  return ParseTopLevelMangledName(&state) && !state.overflowed;
++  return ParseTopLevelMangledName(&state) && !Overflowed(&state) &&
++         state.parse_state.out_cur_idx > 0;
+ #endif
+ }
+ 
+diff --git a/base/third_party/symbolize/demangle.h b/base/third_party/symbolize/demangle.h
+index 416f7ee153560..26e821a53c2cb 100644
+--- a/base/third_party/symbolize/demangle.h
++++ b/base/third_party/symbolize/demangle.h
+@@ -70,6 +70,8 @@
+ #ifndef BASE_DEMANGLE_H_
+ #define BASE_DEMANGLE_H_
+ 
++#include <stddef.h>
++
+ #include "config.h"
+ #include "glog/logging.h"
+ 
diff --git a/base/third_party/symbolize/patches/010-clang-format.patch b/base/third_party/symbolize/patches/010-clang-format.patch
new file mode 100644
index 0000000000000..3e786f08677fa
--- /dev/null
+++ b/base/third_party/symbolize/patches/010-clang-format.patch
@@ -0,0 +1,1184 @@
+diff --git a/base/third_party/symbolize/demangle.cc b/base/third_party/symbolize/demangle.cc
+index 2632646dd4072..8db75f01071e2 100644
+--- a/base/third_party/symbolize/demangle.cc
++++ b/base/third_party/symbolize/demangle.cc
+@@ -139,8 +139,8 @@ static const AbbrevPair kBuiltinTypeList[] = {
+     {"g", "__float128", 0},
+     {"z", "ellipsis", 0},
+ 
+-    {"De", "decimal128", 0},      // IEEE 754r decimal floating point (128 bits)
+-    {"Dd", "decimal64", 0},       // IEEE 754r decimal floating point (64 bits)
++    {"De", "decimal128", 0},  // IEEE 754r decimal floating point (128 bits)
++    {"Dd", "decimal64", 0},   // IEEE 754r decimal floating point (64 bits)
+     {"Dc", "decltype(auto)", 0},
+     {"Da", "auto", 0},
+     {"Dn", "std::nullptr_t", 0},  // i.e., decltype(nullptr)
+@@ -148,7 +148,7 @@ static const AbbrevPair kBuiltinTypeList[] = {
+     {"Di", "char32_t", 0},
+     {"Du", "char8_t", 0},
+     {"Ds", "char16_t", 0},
+-    {"Dh", "float16", 0},         // IEEE 754r half-precision float (16 bits)
++    {"Dh", "float16", 0},  // IEEE 754r half-precision float (16 bits)
+     {nullptr, nullptr, 0},
+ };
+ 
+@@ -193,8 +193,8 @@ static_assert(sizeof(ParseState) == 4 * sizeof(int),
+ // Only one copy of this exists for each call to Demangle, so the size of this
+ // struct is nearly inconsequential.
+ typedef struct {
+-  const char *mangled_begin;  // Beginning of input string.
+-  char *out;                  // Beginning of output string.
++  const char* mangled_begin;  // Beginning of input string.
++  char* out;                  // Beginning of output string.
+   int out_end_idx;            // One past last allowed output character.
+   int recursion_depth;        // For stack exhaustion prevention.
+   int steps;               // Cap how much work we'll do, regardless of depth.
+@@ -206,7 +206,7 @@ namespace {
+ // Also prevent unbounded handling of complex inputs.
+ class ComplexityGuard {
+  public:
+-  explicit ComplexityGuard(State *state) : state_(state) {
++  explicit ComplexityGuard(State* state) : state_(state) {
+     ++state->recursion_depth;
+     ++state->steps;
+   }
+@@ -239,7 +239,7 @@ class ComplexityGuard {
+   }
+ 
+  private:
+-  State *state_;
++  State* state_;
+ };
+ }  // namespace
+ 
+@@ -255,7 +255,7 @@ static size_t StrLen(const char *str) {
+ }
+ 
+ // Returns true if "str" has at least "n" characters remaining.
+-static bool AtLeastNumCharsRemaining(const char *str, size_t n) {
++static bool AtLeastNumCharsRemaining(const char* str, size_t n) {
+   for (size_t i = 0; i < n; ++i) {
+     if (str[i] == '\0') {
+       return false;
+@@ -291,7 +291,7 @@ static void InitState(State* state,
+   state->parse_state.append = true;
+ }
+ 
+-static inline const char *RemainingInput(State *state) {
++static inline const char* RemainingInput(State* state) {
+   return &state->mangled_begin[state->parse_state.mangled_idx];
+ }
+ 
+@@ -300,7 +300,9 @@ static inline const char *RemainingInput(State *state) {
+ // not contain '\0'.
+ static bool ParseOneCharToken(State *state, const char one_char_token) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (RemainingInput(state)[0] == one_char_token) {
+     ++state->parse_state.mangled_idx;
+     return true;
+@@ -313,7 +315,9 @@ static bool ParseOneCharToken(State *state, const char one_char_token) {
+ // not contain '\0'.
+ static bool ParseTwoCharToken(State *state, const char *two_char_token) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (RemainingInput(state)[0] == two_char_token[0] &&
+       RemainingInput(state)[1] == two_char_token[1]) {
+     state->parse_state.mangled_idx += 2;
+@@ -326,7 +330,9 @@ static bool ParseTwoCharToken(State *state, const char *two_char_token) {
+ // "char_class" at "mangled_cur" position.
+ static bool ParseCharClass(State *state, const char *char_class) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (RemainingInput(state)[0] == '\0') {
+     return false;
+   }
+@@ -340,7 +346,7 @@ static bool ParseCharClass(State *state, const char *char_class) {
+   return false;
+ }
+ 
+-static bool ParseDigit(State *state, int *digit) {
++static bool ParseDigit(State* state, int* digit) {
+   char c = RemainingInput(state)[0];
+   if (ParseCharClass(state, "0123456789")) {
+     if (digit != nullptr) {
+@@ -352,7 +358,9 @@ static bool ParseDigit(State *state, int *digit) {
+ }
+ 
+ // This function is used for handling an optional non-terminal.
+-static bool Optional(bool /*status*/) { return true; }
++static bool Optional(bool /*status*/) {
++  return true;
++}
+ 
+ // This function is used for handling <non-terminal>+ syntax.
+ typedef bool (*ParseFunc)(State *);
+@@ -378,7 +386,7 @@ static bool ZeroOrMore(ParseFunc parse_func, State *state) {
+ // Append "str" at "out_cur_idx".  If there is an overflow, out_cur_idx is
+ // set to out_end_idx+1.  The output string is ensured to
+ // always terminate with '\0' as long as there is no overflow.
+-static void Append(State *state, const char *const str, const size_t length) {
++static void Append(State* state, const char* const str, const size_t length) {
+   for (size_t i = 0; i < length; ++i) {
+     if (state->parse_state.out_cur_idx + 1 <
+         state->out_end_idx) {  // +1 for '\0'
+@@ -396,13 +404,17 @@ static void Append(State *state, const char *const str, const size_t length) {
+ }
+ 
+ // We don't use equivalents in libc to avoid locale issues.
+-static bool IsLower(char c) { return c >= 'a' && c <= 'z'; }
++static bool IsLower(char c) {
++  return c >= 'a' && c <= 'z';
++}
+ 
+ static bool IsAlpha(char c) {
+   return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
+ }
+ 
+-static bool IsDigit(char c) { return c >= '0' && c <= '9'; }
++static bool IsDigit(char c) {
++  return c >= '0' && c <= '9';
++}
+ 
+ // Returns true if "str" is a function clone suffix.  These suffixes are used
+ // by GCC 4.5.x and later versions (and our locally-modified version of GCC
+@@ -428,20 +440,22 @@ static bool IsFunctionCloneSuffix(const char *str) {
+         ++i;
+       }
+     }
+-    if (!parsed)
++    if (!parsed) {
+       return false;
++    }
+   }
+   return true;  // Consumed everything in "str".
+ }
+ 
+-static bool EndsWith(State *state, const char chr) {
++static bool EndsWith(State* state, const char chr) {
+   return state->parse_state.out_cur_idx > 0 &&
+          state->parse_state.out_cur_idx < state->out_end_idx &&
+          chr == state->out[state->parse_state.out_cur_idx - 1];
+ }
+ 
+ // Append "str" with some tweaks, iff "append" state is true.
+-static void MaybeAppendWithLength(State *state, const char *const str,
++static void MaybeAppendWithLength(State* state,
++                                  const char* const str,
+                                   const size_t length) {
+   if (state->parse_state.append && length > 0) {
+     // Append a space if the output buffer ends with '<' and "str"
+@@ -461,7 +475,7 @@ static void MaybeAppendWithLength(State *state, const char *const str,
+ }
+ 
+ // Appends a positive decimal number to the output if appending is enabled.
+-static bool MaybeAppendDecimal(State *state, int val) {
++static bool MaybeAppendDecimal(State* state, int val) {
+   // Max {32-64}-bit unsigned int is 20 digits.
+   constexpr size_t kMaxLength = 20;
+   char buf[kMaxLength];
+@@ -471,7 +485,7 @@ static bool MaybeAppendDecimal(State *state, int val) {
+   if (state->parse_state.append) {
+     // We can't have a one-before-the-beginning pointer, so instead start with
+     // one-past-the-end and manipulate one character before the pointer.
+-    char *p = &buf[kMaxLength];
++    char* p = &buf[kMaxLength];
+     do {  // val=0 is the only input that should write a leading zero digit.
+       *--p = static_cast<char>((val % 10) + '0');
+       val /= 10;
+@@ -486,7 +500,7 @@ static bool MaybeAppendDecimal(State *state, int val) {
+ 
+ // A convenient wrapper around MaybeAppendWithLength().
+ // Returns true so that it can be placed in "if" conditions.
+-static bool MaybeAppend(State *state, const char *const str) {
++static bool MaybeAppend(State* state, const char* const str) {
+   if (state->parse_state.append) {
+     size_t length = StrLen(str);
+     MaybeAppendWithLength(state, str, length);
+@@ -501,7 +515,7 @@ static bool EnterNestedName(State *state) {
+ }
+ 
+ // This function is used for handling nested names.
+-static bool LeaveNestedName(State *state, int16_t prev_value) {
++static bool LeaveNestedName(State* state, int16_t prev_value) {
+   state->parse_state.nest_level = prev_value;
+   return true;
+ }
+@@ -543,7 +557,7 @@ static void MaybeCancelLastSeparator(State *state) {
+ 
+ // Returns true if the identifier of the given length pointed to by
+ // "mangled_cur" is anonymous namespace.
+-static bool IdentifierIsAnonymousNamespace(State *state, size_t length) {
++static bool IdentifierIsAnonymousNamespace(State* state, size_t length) {
+   // Returns true if "anon_prefix" is a proper prefix of "mangled_cur".
+   static const char anon_prefix[] = "_GLOBAL__N_";
+   return (length > (sizeof(anon_prefix) - 1) &&
+@@ -554,25 +568,25 @@ static bool IdentifierIsAnonymousNamespace(State *state, size_t length) {
+ static bool ParseMangledName(State *state);
+ static bool ParseEncoding(State *state);
+ static bool ParseName(State *state);
+-static bool ParseUnscopedName(State *state);
++static bool ParseUnscopedName(State* state);
+ static bool ParseNestedName(State *state);
+ static bool ParsePrefix(State *state);
+ static bool ParseUnqualifiedName(State *state);
+ static bool ParseSourceName(State *state);
+ static bool ParseLocalSourceName(State *state);
+-static bool ParseUnnamedTypeName(State *state);
++static bool ParseUnnamedTypeName(State* state);
+ static bool ParseNumber(State *state, int *number_out);
+ static bool ParseFloatNumber(State *state);
+ static bool ParseSeqId(State *state);
+-static bool ParseIdentifier(State *state, size_t length);
+-static bool ParseOperatorName(State *state, int *arity);
++static bool ParseIdentifier(State* state, size_t length);
++static bool ParseOperatorName(State* state, int* arity);
+ static bool ParseSpecialName(State *state);
+ static bool ParseCallOffset(State *state);
+ static bool ParseNVOffset(State *state);
+ static bool ParseVOffset(State *state);
+-static bool ParseAbiTags(State *state);
++static bool ParseAbiTags(State* state);
+ static bool ParseCtorDtorName(State *state);
+-static bool ParseDecltype(State *state);
++static bool ParseDecltype(State* state);
+ static bool ParseType(State *state);
+ static bool ParseCVQualifiers(State *state);
+ static bool ParseBuiltinType(State *state);
+@@ -585,15 +599,15 @@ static bool ParseTemplateParam(State *state);
+ static bool ParseTemplateTemplateParam(State *state);
+ static bool ParseTemplateArgs(State *state);
+ static bool ParseTemplateArg(State *state);
+-static bool ParseBaseUnresolvedName(State *state);
+-static bool ParseUnresolvedName(State *state);
++static bool ParseBaseUnresolvedName(State* state);
++static bool ParseUnresolvedName(State* state);
+ static bool ParseExpression(State *state);
+ static bool ParseExprPrimary(State *state);
+-static bool ParseExprCastValue(State *state);
++static bool ParseExprCastValue(State* state);
+ static bool ParseLocalName(State *state);
+-static bool ParseLocalNameSuffix(State *state);
++static bool ParseLocalNameSuffix(State* state);
+ static bool ParseDiscriminator(State *state);
+-static bool ParseSubstitution(State *state, bool accept_std);
++static bool ParseSubstitution(State* state, bool accept_std);
+ 
+ // Implementation note: the following code is a straightforward
+ // translation of the Itanium C++ ABI defined in BNF with a couple of
+@@ -629,7 +643,9 @@ static bool ParseSubstitution(State *state, bool accept_std);
+ // <mangled-name> ::= _Z <encoding>
+ static bool ParseMangledName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   return ParseTwoCharToken(state, "_Z") && ParseEncoding(state);
+ }
+ 
+@@ -638,7 +654,9 @@ static bool ParseMangledName(State *state) {
+ //            ::= <special-name>
+ static bool ParseEncoding(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   // Implementing the first two productions together as <name>
+   // [<bare-function-type>] avoids exponential blowup of backtracking.
+   //
+@@ -660,7 +678,9 @@ static bool ParseEncoding(State *state) {
+ //        ::= <local-name>
+ static bool ParseName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (ParseNestedName(state) || ParseLocalName(state)) {
+     return true;
+   }
+@@ -690,7 +710,9 @@ static bool ParseName(State *state) {
+ //                 ::= St <unqualified-name>
+ static bool ParseUnscopedName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (ParseUnqualifiedName(state)) {
+     return true;
+   }
+@@ -706,7 +728,7 @@ static bool ParseUnscopedName(State *state) {
+ 
+ // <ref-qualifer> ::= R // lvalue method reference qualifier
+ //                ::= O // rvalue method reference qualifier
+-static inline bool ParseRefQualifier(State *state) {
++static inline bool ParseRefQualifier(State* state) {
+   return ParseCharClass(state, "OR");
+ }
+ 
+@@ -716,7 +738,9 @@ static inline bool ParseRefQualifier(State *state) {
+ //                   <template-args> E
+ static bool ParseNestedName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'N') && EnterNestedName(state) &&
+       Optional(ParseCVQualifiers(state)) &&
+@@ -742,7 +766,9 @@ static bool ParseNestedName(State *state) {
+ //                   ::= <substitution>
+ static bool ParsePrefix(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   bool has_something = false;
+   while (true) {
+     MaybeAppendSeparator(state);
+@@ -773,7 +799,9 @@ static bool ParsePrefix(State *state) {
+ // <local-source-name> is a GCC extension; see below.
+ static bool ParseUnqualifiedName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (ParseOperatorName(state, nullptr) || ParseCtorDtorName(state) ||
+       ParseSourceName(state) || ParseLocalSourceName(state) ||
+       ParseUnnamedTypeName(state)) {
+@@ -784,9 +812,11 @@ static bool ParseUnqualifiedName(State *state) {
+ 
+ // <abi-tags> ::= <abi-tag> [<abi-tags>]
+ // <abi-tag>  ::= B <source-name>
+-static bool ParseAbiTags(State *state) {
++static bool ParseAbiTags(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+ 
+   while (ParseOneCharToken(state, 'B')) {
+     ParseState copy = state->parse_state;
+@@ -805,7 +835,9 @@ static bool ParseAbiTags(State *state) {
+ // <source-name> ::= <positive length number> <identifier>
+ static bool ParseSourceName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   int length = -1;
+   if (ParseNumber(state, &length) &&
+@@ -823,7 +855,9 @@ static bool ParseSourceName(State *state) {
+ //   https://gcc.gnu.org/viewcvs?view=rev&revision=124467
+ static bool ParseLocalSourceName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'L') && ParseSourceName(state) &&
+       Optional(ParseDiscriminator(state))) {
+@@ -837,9 +871,11 @@ static bool ParseLocalSourceName(State *state) {
+ //                     ::= <closure-type-name>
+ // <closure-type-name> ::= Ul <lambda-sig> E [<(nonnegative) number>] _
+ // <lambda-sig>        ::= <(parameter) type>+
+-static bool ParseUnnamedTypeName(State *state) {
++static bool ParseUnnamedTypeName(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   // Type's 1-based index n is encoded as { "", n == 1; itoa(n-2), otherwise }.
+   // Optionally parse the encoded value into 'which' and add 2 to get the index.
+@@ -878,12 +914,14 @@ static bool ParseUnnamedTypeName(State *state) {
+ // parsed number on success.
+ static bool ParseNumber(State *state, int *number_out) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   bool negative = false;
+   if (ParseOneCharToken(state, 'n')) {
+     negative = true;
+   }
+-  const char *p = RemainingInput(state);
++  const char* p = RemainingInput(state);
+   uint64_t number = 0;
+   for (; *p != '\0'; ++p) {
+     if (IsDigit(*p)) {
+@@ -913,8 +951,10 @@ static bool ParseNumber(State *state, int *number_out) {
+ // hexadecimal string.
+ static bool ParseFloatNumber(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
+-  const char *p = RemainingInput(state);
++  if (guard.IsTooComplex()) {
++    return false;
++  }
++  const char* p = RemainingInput(state);
+   for (; *p != '\0'; ++p) {
+     if (!IsDigit(*p) && !(*p >= 'a' && *p <= 'f')) {
+       break;
+@@ -931,8 +971,10 @@ static bool ParseFloatNumber(State *state) {
+ // using digits and upper case letters
+ static bool ParseSeqId(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
+-  const char *p = RemainingInput(state);
++  if (guard.IsTooComplex()) {
++    return false;
++  }
++  const char* p = RemainingInput(state);
+   for (; *p != '\0'; ++p) {
+     if (!IsDigit(*p) && !(*p >= 'A' && *p <= 'Z')) {
+       break;
+@@ -946,9 +988,11 @@ static bool ParseSeqId(State *state) {
+ }
+ 
+ // <identifier> ::= <unqualified source code identifier> (of given length)
+-static bool ParseIdentifier(State *state, size_t length) {
++static bool ParseIdentifier(State* state, size_t length) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (!AtLeastNumCharsRemaining(RemainingInput(state), length)) {
+     return false;
+   }
+@@ -964,9 +1008,11 @@ static bool ParseIdentifier(State *state, size_t length) {
+ // <operator-name> ::= nw, and other two letters cases
+ //                 ::= cv <type>  # (cast)
+ //                 ::= v  <digit> <source-name> # vendor extended operator
+-static bool ParseOperatorName(State *state, int *arity) {
++static bool ParseOperatorName(State* state, int* arity) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (!AtLeastNumCharsRemaining(RemainingInput(state), 2)) {
+     return false;
+   }
+@@ -1036,7 +1082,9 @@ static bool ParseOperatorName(State *state, int *arity) {
+ // stack traces.  The are special data.
+ static bool ParseSpecialName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "VTISH") &&
+       ParseType(state)) {
+@@ -1098,7 +1146,9 @@ static bool ParseSpecialName(State *state) {
+ //               ::= v <v-offset> _
+ static bool ParseCallOffset(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'h') && ParseNVOffset(state) &&
+       ParseOneCharToken(state, '_')) {
+@@ -1118,14 +1168,18 @@ static bool ParseCallOffset(State *state) {
+ // <nv-offset> ::= <(offset) number>
+ static bool ParseNVOffset(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   return ParseNumber(state, nullptr);
+ }
+ 
+ // <v-offset>  ::= <(offset) number> _ <(virtual offset) number>
+ static bool ParseVOffset(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseNumber(state, nullptr) && ParseOneCharToken(state, '_') &&
+       ParseNumber(state, nullptr)) {
+@@ -1144,11 +1198,13 @@ static bool ParseVOffset(State *state) {
+ //                  ::= C4 | D4
+ static bool ParseCtorDtorName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'C')) {
+     if (ParseCharClass(state, "1234")) {
+-      const char *const prev_name =
++      const char* const prev_name =
+           state->out + state->parse_state.prev_name_idx;
+       MaybeAppendWithLength(state, prev_name,
+                             state->parse_state.prev_name_length);
+@@ -1161,7 +1217,7 @@ static bool ParseCtorDtorName(State *state) {
+   state->parse_state = copy;
+ 
+   if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "0124")) {
+-    const char *const prev_name = state->out + state->parse_state.prev_name_idx;
++    const char* const prev_name = state->out + state->parse_state.prev_name_idx;
+     MaybeAppend(state, "~");
+     MaybeAppendWithLength(state, prev_name,
+                           state->parse_state.prev_name_length);
+@@ -1174,9 +1230,11 @@ static bool ParseCtorDtorName(State *state) {
+ // <decltype> ::= Dt <expression> E  # decltype of an id-expression or class
+ //                                   # member access (C++0x)
+ //            ::= DT <expression> E  # decltype of an expression (C++0x)
+-static bool ParseDecltype(State *state) {
++static bool ParseDecltype(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+ 
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "tT") &&
+@@ -1209,7 +1267,9 @@ static bool ParseDecltype(State *state) {
+ //
+ static bool ParseType(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+ 
+   // We should check CV-qualifers, and PRGC things first.
+@@ -1227,7 +1287,9 @@ static bool ParseType(State *state) {
+   // By consuming the CV-qualifiers first, the former parse is disabled.
+   if (ParseCVQualifiers(state)) {
+     const bool result = ParseType(state);
+-    if (!result) state->parse_state = copy;
++    if (!result) {
++      state->parse_state = copy;
++    }
+     return result;
+   }
+   state->parse_state = copy;
+@@ -1238,7 +1300,9 @@ static bool ParseType(State *state) {
+   // refusing to backtrack the tag characters.
+   if (ParseCharClass(state, "OPRCG")) {
+     const bool result = ParseType(state);
+-    if (!result) state->parse_state = copy;
++    if (!result) {
++      state->parse_state = copy;
++    }
+     return result;
+   }
+   state->parse_state = copy;
+@@ -1286,7 +1350,9 @@ static bool ParseType(State *state) {
+ // ParseType().
+ static bool ParseCVQualifiers(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   int num_cv_qualifiers = 0;
+   num_cv_qualifiers += ParseOneCharToken(state, 'r');
+   num_cv_qualifiers += ParseOneCharToken(state, 'V');
+@@ -1303,7 +1369,9 @@ static bool ParseCVQualifiers(State *state) {
+ //
+ static bool ParseBuiltinType(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   const AbbrevPair *p;
+   for (p = kBuiltinTypeList; p->abbrev != nullptr; ++p) {
+     // Guaranteed only 1- or 2-character strings in kBuiltinTypeList.
+@@ -1333,11 +1401,15 @@ static bool ParseBuiltinType(State *state) {
+ //                                           noexcept
+ //                   ::= Dw <type>+ E      # dynamic exception specification
+ //                                           with instantiation-dependent types
+-static bool ParseExceptionSpec(State *state) {
++static bool ParseExceptionSpec(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+ 
+-  if (ParseTwoCharToken(state, "Do")) return true;
++  if (ParseTwoCharToken(state, "Do")) {
++    return true;
++  }
+ 
+   ParseState copy = state->parse_state;
+   if (ParseTwoCharToken(state, "DO") && ParseExpression(state) &&
+@@ -1357,7 +1429,9 @@ static bool ParseExceptionSpec(State *state) {
+ // <function-type> ::= [exception-spec] F [Y] <bare-function-type> [O] E
+ static bool ParseFunctionType(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (Optional(ParseExceptionSpec(state)) && ParseOneCharToken(state, 'F') &&
+       Optional(ParseOneCharToken(state, 'Y')) && ParseBareFunctionType(state) &&
+@@ -1372,7 +1446,9 @@ static bool ParseFunctionType(State *state) {
+ // <bare-function-type> ::= <(signature) type>+
+ static bool ParseBareFunctionType(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   DisableAppend(state);
+   if (OneOrMore(ParseType, state)) {
+@@ -1387,7 +1463,9 @@ static bool ParseBareFunctionType(State *state) {
+ // <class-enum-type> ::= <name>
+ static bool ParseClassEnumType(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   return ParseName(state);
+ }
+ 
+@@ -1395,7 +1473,9 @@ static bool ParseClassEnumType(State *state) {
+ //              ::= A [<(dimension) expression>] _ <(element) type>
+ static bool ParseArrayType(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'A') && ParseNumber(state, nullptr) &&
+       ParseOneCharToken(state, '_') && ParseType(state)) {
+@@ -1414,7 +1494,9 @@ static bool ParseArrayType(State *state) {
+ // <pointer-to-member-type> ::= M <(class) type> <(member) type>
+ static bool ParsePointerToMemberType(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'M') && ParseType(state) && ParseType(state)) {
+     return true;
+@@ -1427,7 +1509,9 @@ static bool ParsePointerToMemberType(State *state) {
+ //                  ::= T <parameter-2 non-negative number> _
+ static bool ParseTemplateParam(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (ParseTwoCharToken(state, "T_")) {
+     MaybeAppend(state, "?");  // We don't support template substitutions.
+     return true;
+@@ -1447,7 +1531,9 @@ static bool ParseTemplateParam(State *state) {
+ //                           ::= <substitution>
+ static bool ParseTemplateTemplateParam(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   return (ParseTemplateParam(state) ||
+           // "std" on its own isn't a template.
+           ParseSubstitution(state, /*accept_std=*/false));
+@@ -1456,7 +1542,9 @@ static bool ParseTemplateTemplateParam(State *state) {
+ // <template-args> ::= I <template-arg>+ E
+ static bool ParseTemplateArgs(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   DisableAppend(state);
+   if (ParseOneCharToken(state, 'I') && OneOrMore(ParseTemplateArg, state) &&
+@@ -1475,7 +1563,9 @@ static bool ParseTemplateArgs(State *state) {
+ //                 ::= X <expression> E
+ static bool ParseTemplateArg(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'J') && ZeroOrMore(ParseTemplateArg, state) &&
+       ParseOneCharToken(state, 'E')) {
+@@ -1578,14 +1668,14 @@ static bool ParseTemplateArg(State *state) {
+ // <unresolved-type> ::= <template-param> [<template-args>]
+ //                   ::= <decltype>
+ //                   ::= <substitution>
+-static inline bool ParseUnresolvedType(State *state) {
++static inline bool ParseUnresolvedType(State* state) {
+   // No ComplexityGuard because we don't copy the state in this stack frame.
+   return (ParseTemplateParam(state) && Optional(ParseTemplateArgs(state))) ||
+          ParseDecltype(state) || ParseSubstitution(state, /*accept_std=*/false);
+ }
+ 
+ // <simple-id> ::= <source-name> [<template-args>]
+-static inline bool ParseSimpleId(State *state) {
++static inline bool ParseSimpleId(State* state) {
+   // No ComplexityGuard because we don't copy the state in this stack frame.
+ 
+   // Note: <simple-id> cannot be followed by a parameter pack; see comment in
+@@ -1596,9 +1686,11 @@ static inline bool ParseSimpleId(State *state) {
+ // <base-unresolved-name> ::= <source-name> [<template-args>]
+ //                        ::= on <operator-name> [<template-args>]
+ //                        ::= dn <destructor-name>
+-static bool ParseBaseUnresolvedName(State *state) {
++static bool ParseBaseUnresolvedName(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+ 
+   if (ParseSimpleId(state)) {
+     return true;
+@@ -1626,9 +1718,11 @@ static bool ParseBaseUnresolvedName(State *state) {
+ //                         <base-unresolved-name>
+ //                   ::= [gs] sr <unresolved-qualifier-level>+ E
+ //                         <base-unresolved-name>
+-static bool ParseUnresolvedName(State *state) {
++static bool ParseUnresolvedName(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+ 
+   ParseState copy = state->parse_state;
+   if (Optional(ParseTwoCharToken(state, "gs")) &&
+@@ -1684,7 +1778,9 @@ static bool ParseUnresolvedName(State *state) {
+ //                  ::= fL <number> p <(top-level) CV-qualifiers> <number> _
+ static bool ParseExpression(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (ParseTemplateParam(state) || ParseExprPrimary(state)) {
+     return true;
+   }
+@@ -1817,7 +1913,9 @@ static bool ParseExpression(State *state) {
+ // casts to <local-name> types.
+ static bool ParseExprPrimary(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+ 
+   // The "LZ" special case: if we see LZ, we commit to accept "LZ <encoding> E"
+@@ -1848,9 +1946,11 @@ static bool ParseExprPrimary(State *state) {
+ }
+ 
+ // <number> or <float>, followed by 'E', as described above ParseExprPrimary.
+-static bool ParseExprCastValue(State *state) {
++static bool ParseExprCastValue(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   // We have to be able to backtrack after accepting a number because we could
+   // have e.g. "7fffE", which will accept "7" as a number but then fail to find
+   // the 'E'.
+@@ -1877,9 +1977,11 @@ static bool ParseExprCastValue(State *state) {
+ //   <local-name-suffix> ::= s [<discriminator>]
+ //                       ::= <name> [<discriminator>]
+ 
+-static bool ParseLocalNameSuffix(State *state) {
++static bool ParseLocalNameSuffix(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+ 
+   if (MaybeAppend(state, "::") && ParseName(state) &&
+       Optional(ParseDiscriminator(state))) {
+@@ -1896,9 +1998,11 @@ static bool ParseLocalNameSuffix(State *state) {
+   return ParseOneCharToken(state, 's') && Optional(ParseDiscriminator(state));
+ }
+ 
+-static bool ParseLocalName(State *state) {
++static bool ParseLocalName(State* state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, 'Z') && ParseEncoding(state) &&
+       ParseOneCharToken(state, 'E') && ParseLocalNameSuffix(state)) {
+@@ -1911,7 +2015,9 @@ static bool ParseLocalName(State *state) {
+ // <discriminator> := _ <(non-negative) number>
+ static bool ParseDiscriminator(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   ParseState copy = state->parse_state;
+   if (ParseOneCharToken(state, '_') && ParseNumber(state, nullptr)) {
+     return true;
+@@ -1931,9 +2037,11 @@ static bool ParseDiscriminator(State *state) {
+ // an unqualified name and re-parse the same template-args.  To block this
+ // exponential backtracking, we disable it with 'accept_std=false' in
+ // problematic contexts.
+-static bool ParseSubstitution(State *state, bool accept_std) {
++static bool ParseSubstitution(State* state, bool accept_std) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (ParseTwoCharToken(state, "S_")) {
+     MaybeAppend(state, "?");  // We don't support substitutions.
+     return true;
+@@ -1971,7 +2079,9 @@ static bool ParseSubstitution(State *state, bool accept_std) {
+ // or version suffix.  Returns true only if all of "mangled_cur" was consumed.
+ static bool ParseTopLevelMangledName(State *state) {
+   ComplexityGuard guard(state);
+-  if (guard.IsTooComplex()) return false;
++  if (guard.IsTooComplex()) {
++    return false;
++  }
+   if (ParseMangledName(state)) {
+     if (RemainingInput(state)[0] != '\0') {
+       // Drop trailing function clone suffix, if any.
+@@ -1991,13 +2101,13 @@ static bool ParseTopLevelMangledName(State *state) {
+   return false;
+ }
+ 
+-static bool Overflowed(const State *state) {
++static bool Overflowed(const State* state) {
+   return state->parse_state.out_cur_idx >= state->out_end_idx;
+ }
+ #endif
+ 
+ // The demangler entry point.
+-bool Demangle(const char *mangled, char *out, size_t out_size) {
++bool Demangle(const char* mangled, char* out, size_t out_size) {
+ #if defined(GLOG_OS_WINDOWS)
+ #if defined(HAVE_DBGHELP)
+   // When built with incremental linking, the Windows debugger
+diff --git a/base/third_party/symbolize/demangle.h b/base/third_party/symbolize/demangle.h
+index 26e821a53c2cb..7d5cfaaabf0dd 100644
+--- a/base/third_party/symbolize/demangle.h
++++ b/base/third_party/symbolize/demangle.h
+@@ -80,7 +80,7 @@ _START_GOOGLE_NAMESPACE_
+ // Demangle "mangled".  On success, return true and write the
+ // demangled symbol name to "out".  Otherwise, return false.
+ // "out" is modified even if demangling is unsuccessful.
+-bool GLOG_EXPORT Demangle(const char *mangled, char *out, size_t out_size);
++bool GLOG_EXPORT Demangle(const char* mangled, char* out, size_t out_size);
+ 
+ _END_GOOGLE_NAMESPACE_
+ 
+diff --git a/base/third_party/symbolize/glog/logging.h b/base/third_party/symbolize/glog/logging.h
+index 46869226024da..b935e3ec9cded 100644
+--- a/base/third_party/symbolize/glog/logging.h
++++ b/base/third_party/symbolize/glog/logging.h
+@@ -38,4 +38,4 @@
+ 
+ // Not needed in Chrome.
+ 
+-#endif // GLOG_LOGGING_H
++#endif  // GLOG_LOGGING_H
+diff --git a/base/third_party/symbolize/symbolize.cc b/base/third_party/symbolize/symbolize.cc
+index b6ddc85d57185..a3b8399f411bf 100644
+--- a/base/third_party/symbolize/symbolize.cc
++++ b/base/third_party/symbolize/symbolize.cc
+@@ -97,7 +97,7 @@ void InstallSymbolizeOpenObjectFileCallback(
+ // where the input symbol is demangled in-place.
+ // To keep stack consumption low, we would like this function to not
+ // get inlined.
+-static ATTRIBUTE_NOINLINE void DemangleInplace(char *out, size_t out_size) {
++static ATTRIBUTE_NOINLINE void DemangleInplace(char* out, size_t out_size) {
+   char demangled[256];  // Big enough for sane demangled symbols.
+   if (Demangle(out, demangled, sizeof(demangled))) {
+     // Demangling succeeded. Copy to out if the space allows.
+@@ -121,17 +121,17 @@ _END_GOOGLE_NAMESPACE_
+ #else
+ #include <elf.h>
+ #endif
++#include <fcntl.h>
++#include <stdint.h>
++#include <sys/stat.h>
++#include <sys/types.h>
++#include <unistd.h>
+ #include <cerrno>
+ #include <climits>
+ #include <cstddef>
+ #include <cstdio>
+ #include <cstdlib>
+ #include <cstring>
+-#include <fcntl.h>
+-#include <stdint.h>
+-#include <sys/stat.h>
+-#include <sys/types.h>
+-#include <unistd.h>
+ 
+ #include "symbolize.h"
+ #include "config.h"
+@@ -153,7 +153,8 @@ ssize_t ReadFromOffset(const int fd,
+                        const size_t count,
+                        const size_t offset) {
+   SAFE_ASSERT(fd >= 0);
+-  SAFE_ASSERT(count <= static_cast<size_t>(std::numeric_limits<ssize_t>::max()));
++  SAFE_ASSERT(count <=
++              static_cast<size_t>(std::numeric_limits<ssize_t>::max()));
+   char *buf0 = reinterpret_cast<char *>(buf);
+   size_t num_bytes = 0;
+   while (num_bytes < count) {
+@@ -176,8 +177,10 @@ ssize_t ReadFromOffset(const int fd,
+ // pointed by "fd" into the buffer starting at "buf" while handling
+ // short reads and EINTR.  On success, return true. Otherwise, return
+ // false.
+-static bool ReadFromOffsetExact(const int fd, void *buf,
+-                                const size_t count, const size_t offset) {
++static bool ReadFromOffsetExact(const int fd,
++                                void* buf,
++                                const size_t count,
++                                const size_t offset) {
+   ssize_t len = ReadFromOffset(fd, buf, count, offset);
+   return static_cast<size_t>(len) == count;
+ }
+@@ -199,9 +202,11 @@ static int FileGetElfType(const int fd) {
+ // and return true.  Otherwise, return false.
+ // To keep stack consumption low, we would like this function to not get
+ // inlined.
+-static ATTRIBUTE_NOINLINE bool
+-GetSectionHeaderByType(const int fd, ElfW(Half) sh_num, const size_t sh_offset,
+-                       ElfW(Word) type, ElfW(Shdr) *out) {
++static ATTRIBUTE_NOINLINE bool GetSectionHeaderByType(const int fd,
++                                                      ElfW(Half) sh_num,
++                                                      const size_t sh_offset,
++                                                      ElfW(Word) type,
++                                                      ElfW(Shdr) * out) {
+   // Read at most 16 section headers at a time to save read calls.
+   ElfW(Shdr) buf[16];
+   for (size_t i = 0; i < sh_num;) {
+@@ -248,8 +253,8 @@ bool GetSectionHeaderByName(int fd, const char *name, size_t name_len,
+   }
+ 
+   for (size_t i = 0; i < elf_header.e_shnum; ++i) {
+-    size_t section_header_offset = (elf_header.e_shoff +
+-                                   elf_header.e_shentsize * i);
++    size_t section_header_offset =
++        (elf_header.e_shoff + elf_header.e_shentsize * i);
+     if (!ReadFromOffsetExact(fd, out, sizeof(*out), section_header_offset)) {
+       return false;
+     }
+@@ -281,10 +286,13 @@ bool GetSectionHeaderByName(int fd, const char *name, size_t name_len,
+ // to out.  Otherwise, return false.
+ // To keep stack consumption low, we would like this function to not get
+ // inlined.
+-static ATTRIBUTE_NOINLINE bool
+-FindSymbol(uint64_t pc, const int fd, char *out, size_t out_size,
+-           uint64_t symbol_offset, const ElfW(Shdr) *strtab,
+-           const ElfW(Shdr) *symtab) {
++static ATTRIBUTE_NOINLINE bool FindSymbol(uint64_t pc,
++                                          const int fd,
++                                          char* out,
++                                          size_t out_size,
++                                          uint64_t symbol_offset,
++                                          const ElfW(Shdr) * strtab,
++                                          const ElfW(Shdr) * symtab) {
+   if (symtab == NULL) {
+     return false;
+   }
+@@ -384,7 +392,7 @@ namespace {
+ // and snprintf().
+ class LineReader {
+  public:
+-  explicit LineReader(int fd, char *buf, size_t buf_len, size_t offset)
++  explicit LineReader(int fd, char* buf, size_t buf_len, size_t offset)
+       : fd_(fd),
+         buf_(buf),
+         buf_len_(buf_len),
+@@ -449,11 +457,12 @@ class LineReader {
+   }
+ 
+  private:
+-  LineReader(const LineReader &);
++  LineReader(const LineReader&);
+   void operator=(const LineReader&);
+ 
+   char *FindLineFeed() {
+-    return reinterpret_cast<char *>(memchr(bol_, '\n', static_cast<size_t>(eod_ - bol_)));
++    return reinterpret_cast<char*>(
++        memchr(bol_, '\n', static_cast<size_t>(eod_ - bol_)));
+   }
+ 
+   bool BufferIsEmpty() {
+@@ -483,7 +492,8 @@ static char *GetHex(const char *start, const char *end, uint64_t *hex) {
+     int ch = *p;
+     if ((ch >= '0' && ch <= '9') ||
+         (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f')) {
+-      *hex = (*hex << 4U) | (ch < 'A' ? static_cast<uint64_t>(ch - '0') : (ch & 0xF) + 9U);
++      *hex = (*hex << 4U) |
++             (ch < 'A' ? static_cast<uint64_t>(ch - '0') : (ch & 0xF) + 9U);
+     } else {  // Encountered the first non-hex character.
+       break;
+     }
+@@ -647,12 +657,11 @@ static int OpenObjectFileContainingPcAndGetStartAddressNoHook(
+   }
+ }
+ 
+-int OpenObjectFileContainingPcAndGetStartAddress(
+-    uint64_t pc,
+-    uint64_t& start_address,
+-    uint64_t& base_address,
+-    char* out_file_name,
+-    size_t out_file_name_size) {
++int OpenObjectFileContainingPcAndGetStartAddress(uint64_t pc,
++                                                 uint64_t& start_address,
++                                                 uint64_t& base_address,
++                                                 char* out_file_name,
++                                                 size_t out_file_name_size) {
+   if (g_symbolize_open_object_file_callback) {
+     return g_symbolize_open_object_file_callback(
+         pc, start_address, base_address, out_file_name, out_file_name_size);
+@@ -668,7 +677,11 @@ int OpenObjectFileContainingPcAndGetStartAddress(
+ // bytes. Output will be truncated as needed, and a NUL character is always
+ // appended.
+ // NOTE: code from sandbox/linux/seccomp-bpf/demo.cc.
+-static char *itoa_r(uintptr_t i, char *buf, size_t sz, unsigned base, size_t padding) {
++static char* itoa_r(uintptr_t i,
++                    char* buf,
++                    size_t sz,
++                    unsigned base,
++                    size_t padding) {
+   // Make sure we can write at least one NUL byte.
+   size_t n = 1;
+   if (n > sz) {
+@@ -745,7 +758,8 @@ static void SafeAppendHexNumber(uint64_t value, char* dest, size_t dest_size) {
+ // and "out" is used as its output.
+ // To keep stack consumption low, we would like this function to not
+ // get inlined.
+-static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void *pc, char *out,
++static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void* pc,
++                                                    char* out,
+                                                     size_t out_size) {
+   uint64_t pc0 = reinterpret_cast<uintptr_t>(pc);
+   uint64_t start_address = 0;
+@@ -822,14 +836,16 @@ static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void *pc, char *out,
+ 
+ _END_GOOGLE_NAMESPACE_
+ 
+-#elif (defined(GLOG_OS_MACOSX) || defined(GLOG_OS_EMSCRIPTEN)) && defined(HAVE_DLADDR)
++#elif (defined(GLOG_OS_MACOSX) || defined(GLOG_OS_EMSCRIPTEN)) && \
++    defined(HAVE_DLADDR)
+ 
+ #include <dlfcn.h>
+ #include <cstring>
+ 
+ _START_GOOGLE_NAMESPACE_
+ 
+-static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void *pc, char *out,
++static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void* pc,
++                                                    char* out,
+                                                     size_t out_size) {
+   Dl_info info;
+   if (dladdr(pc, &info)) {
+@@ -883,7 +899,8 @@ private:
+   SymInitializer& operator=(const SymInitializer&);
+ };
+ 
+-static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void *pc, char *out,
++static ATTRIBUTE_NOINLINE bool SymbolizeAndDemangle(void* pc,
++                                                    char* out,
+                                                     size_t out_size) {
+   const static SymInitializer symInitializer;
+   if (!symInitializer.ready) {
+@@ -918,7 +935,7 @@ _END_GOOGLE_NAMESPACE_
+ 
+ _START_GOOGLE_NAMESPACE_
+ 
+-bool Symbolize(void *pc, char *out, size_t out_size) {
++bool Symbolize(void* pc, char* out, size_t out_size) {
+   return SymbolizeAndDemangle(pc, out, out_size);
+ }
+ 
+diff --git a/base/third_party/symbolize/symbolize.h b/base/third_party/symbolize/symbolize.h
+index 64ff0509ce57d..987569fdde67f 100644
+--- a/base/third_party/symbolize/symbolize.h
++++ b/base/third_party/symbolize/symbolize.h
+@@ -127,7 +127,7 @@ ATTRIBUTE_NOINLINE int OpenObjectFileContainingPcAndGetStartAddress(
+ 
+ _END_GOOGLE_NAMESPACE_
+ 
+-#endif  /* __ELF__ */
++#endif /* __ELF__ */
+ 
+ _START_GOOGLE_NAMESPACE_
+ 
+@@ -140,7 +140,7 @@ struct FileDescriptor {
+   int get() { return fd_; }
+ 
+  private:
+-  FileDescriptor(const FileDescriptor &);
++  FileDescriptor(const FileDescriptor&);
+   void operator=(const FileDescriptor&);
+ };
+ 
+diff --git a/base/third_party/symbolize/utilities.h b/base/third_party/symbolize/utilities.h
+index 8c61380fad159..bb206a8020315 100644
+--- a/base/third_party/symbolize/utilities.h
++++ b/base/third_party/symbolize/utilities.h
+@@ -35,13 +35,13 @@
+ #define UTILITIES_H__
+ 
+ #ifdef HAVE___ATTRIBUTE__
+-# define ATTRIBUTE_NOINLINE __attribute__ ((noinline))
+-# define HAVE_ATTRIBUTE_NOINLINE
++#define ATTRIBUTE_NOINLINE __attribute__((noinline))
++#define HAVE_ATTRIBUTE_NOINLINE
+ #elif defined(GLOG_OS_WINDOWS)
+-# define ATTRIBUTE_NOINLINE __declspec(noinline)
+-# define HAVE_ATTRIBUTE_NOINLINE
++#define ATTRIBUTE_NOINLINE __declspec(noinline)
++#define HAVE_ATTRIBUTE_NOINLINE
+ #else
+-# define ATTRIBUTE_NOINLINE
++#define ATTRIBUTE_NOINLINE
+ #endif
+ 
+ #endif  // UTILITIES_H__
diff --git a/buildtools/third_party/eu-strip/fix-elf-size.patch b/buildtools/third_party/eu-strip/fix-elf-size.patch
new file mode 100644
index 0000000000000..e3fdc8ac55011
--- /dev/null
+++ b/buildtools/third_party/eu-strip/fix-elf-size.patch
@@ -0,0 +1,61 @@
+diff --git a/libelf/elf32_updatenull.c b/libelf/elf32_updatenull.c
+index d83c0b3f..507e707b 100644
+--- a/libelf/elf32_updatenull.c
++++ b/libelf/elf32_updatenull.c
+@@ -137,7 +137,7 @@ __elfw2(LIBELFBITS,updatenull_wrlock) (Elf *elf, int *change_bop, size_t shnum)
+     return -1;
+ 
+   /* At least the ELF header is there.  */
+-  off_t size = elf_typesize (LIBELFBITS, ELF_T_EHDR, 1);
++  ElfW2(LIBELFBITS,Off) size = elf_typesize (LIBELFBITS, ELF_T_EHDR, 1);
+ 
+   /* Set the program header position.  */
+   if (elf->state.ELFW(elf,LIBELFBITS).phdr == NULL)
+@@ -152,7 +152,7 @@ __elfw2(LIBELFBITS,updatenull_wrlock) (Elf *elf, int *change_bop, size_t shnum)
+ 	{
+ 	  /* The user is supposed to fill out e_phoff.  Use it and
+ 	     e_phnum to determine the maximum extend.  */
+-	  size = MAX ((size_t) size,
++	  size = MAX (size,
+ 		      ehdr->e_phoff
+ 		      + elf_typesize (LIBELFBITS, ELF_T_PHDR, phnum));
+ 	}
+@@ -330,7 +330,7 @@ __elfw2(LIBELFBITS,updatenull_wrlock) (Elf *elf, int *change_bop, size_t shnum)
+ 
+ 	      if (elf->flags & ELF_F_LAYOUT)
+ 		{
+-		  size = MAX ((GElf_Word) size,
++		  size = MAX (size,
+ 			      (shdr->sh_type != SHT_NOBITS
+ 			       ? shdr->sh_offset + shdr->sh_size : 0));
+ 
+@@ -352,9 +352,9 @@ __elfw2(LIBELFBITS,updatenull_wrlock) (Elf *elf, int *change_bop, size_t shnum)
+ 		  update_if_changed (shdr->sh_addralign, sh_align,
+ 				     scn->shdr_flags);
+ 
+-		  size = (size + sh_align - 1) & ~(sh_align - 1);
++		  size = (size + sh_align - 1) & ~(ElfW2(LIBELFBITS,Off))(sh_align - 1);
+ 		  int offset_changed = 0;
+-		  update_if_changed (shdr->sh_offset, (GElf_Word) size,
++		  update_if_changed (shdr->sh_offset, size,
+ 				     offset_changed);
+ 		  changed |= offset_changed;
+ 
+@@ -416,7 +416,7 @@ __elfw2(LIBELFBITS,updatenull_wrlock) (Elf *elf, int *change_bop, size_t shnum)
+ 	  /* The user is supposed to fill out e_shoff.  Use it and
+ 	     e_shnum (or sh_size of the dummy, first section header)
+ 	     to determine the maximum extend.  */
+-	  size = MAX ((GElf_Word) size,
++	  size = MAX (size,
+ 		      (ehdr->e_shoff
+ 		       + (elf_typesize (LIBELFBITS, ELF_T_SHDR, shnum))));
+ 	}
+@@ -430,7 +430,7 @@ __elfw2(LIBELFBITS,updatenull_wrlock) (Elf *elf, int *change_bop, size_t shnum)
+ #define SHDR_ALIGN sizeof (ElfW2(LIBELFBITS,Off))
+ 	  size = (size + SHDR_ALIGN - 1) & ~(SHDR_ALIGN - 1);
+ 
+-	  update_if_changed (ehdr->e_shoff, (GElf_Word) size, elf->flags);
++	  update_if_changed (ehdr->e_shoff, size, elf->flags);
+ 
+ 	  /* Account for the section header size.  */
+ 	  size += elf_typesize (LIBELFBITS, ELF_T_SHDR, shnum);
diff --git a/chrome/test/data/dromaeo/patches/librefs.patch b/chrome/test/data/dromaeo/patches/librefs.patch
new file mode 100644
index 0000000000000..734c2b1ce41d7
--- /dev/null
+++ b/chrome/test/data/dromaeo/patches/librefs.patch
@@ -0,0 +1,318 @@
+diff --git a/chrome/test/data/dromaeo/tests/cssquery-dojo.html b/chrome/test/data/dromaeo/tests/cssquery-dojo.html
+index b27c95b..fd8e4aa 100644
+--- a/chrome/test/data/dromaeo/tests/cssquery-dojo.html
++++ b/chrome/test/data/dromaeo/tests/cssquery-dojo.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="http://ajax.googleapis.com/ajax/libs/dojo/1.6.1/dojo/dojo.xd.js"></script>
++<script src="../lib/dojo.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("cssquery-dojo", '5477d2ae');
+diff --git a/chrome/test/data/dromaeo/tests/cssquery-ext.html b/chrome/test/data/dromaeo/tests/cssquery-ext.html
+index acb35c1..11a8413 100644
+--- a/chrome/test/data/dromaeo/tests/cssquery-ext.html
++++ b/chrome/test/data/dromaeo/tests/cssquery-ext.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/ext-core/3.1.0/ext-core.js"></script>
++<script src="../lib/ext-core.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("cssquery-ext", '5bc05a17');
+diff --git a/chrome/test/data/dromaeo/tests/cssquery-jquery-2.x.html b/chrome/test/data/dromaeo/tests/cssquery-jquery-2.x.html
+index 6b95fee..b180f5a 100644
+--- a/chrome/test/data/dromaeo/tests/cssquery-jquery-2.x.html
++++ b/chrome/test/data/dromaeo/tests/cssquery-jquery-2.x.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
++<script src="../lib/jquery.2.0.3.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("cssquery-jquery", '5dfe1a12');
+diff --git a/chrome/test/data/dromaeo/tests/cssquery-jquery.html b/chrome/test/data/dromaeo/tests/cssquery-jquery.html
+index a83ef5c..6e552f1 100644
+--- a/chrome/test/data/dromaeo/tests/cssquery-jquery.html
++++ b/chrome/test/data/dromaeo/tests/cssquery-jquery.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
++<script src="../lib/jquery.10.1.2.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("cssquery-jquery", 'de808e5f');
+diff --git a/chrome/test/data/dromaeo/tests/cssquery-mootools.html b/chrome/test/data/dromaeo/tests/cssquery-mootools.html
+index 5009efc..1422b2a 100644
+--- a/chrome/test/data/dromaeo/tests/cssquery-mootools.html
++++ b/chrome/test/data/dromaeo/tests/cssquery-mootools.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/mootools/1.4.1/mootools-yui-compressed.js"></script>
++<script src="../lib/mootools-yui-compressed.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("cssquery-mootools", 'c5ac656b');
+diff --git a/chrome/test/data/dromaeo/tests/cssquery-prototype.html b/chrome/test/data/dromaeo/tests/cssquery-prototype.html
+index 324d4ed..28bada1 100644
+--- a/chrome/test/data/dromaeo/tests/cssquery-prototype.html
++++ b/chrome/test/data/dromaeo/tests/cssquery-prototype.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/prototype/1.7.0.0/prototype.js"></script>
++<script src="../lib/prototype.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("cssquery-prototype", 'd151161f');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-attr-jquery-2.x.html b/chrome/test/data/dromaeo/tests/jslib-attr-jquery-2.x.html
+index ca6d338..867938a 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-attr-jquery-2.x.html
++++ b/chrome/test/data/dromaeo/tests/jslib-attr-jquery-2.x.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
++<script src="../lib/jquery.2.0.3.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-attr-jquery", 'aeb3b2c1');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-attr-jquery.html b/chrome/test/data/dromaeo/tests/jslib-attr-jquery.html
+index 70f8fdc..f089b52 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-attr-jquery.html
++++ b/chrome/test/data/dromaeo/tests/jslib-attr-jquery.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
++<script src="../lib/jquery.10.1.2.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-attr-jquery", '675a354f');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-attr-prototype.html b/chrome/test/data/dromaeo/tests/jslib-attr-prototype.html
+index c0e8006..998b990 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-attr-prototype.html
++++ b/chrome/test/data/dromaeo/tests/jslib-attr-prototype.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/prototype/1.7.0.0/prototype.js"></script>
++<script src="../lib/prototype.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-attr-prototype", '4fb93c6a');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-event-jquery-2.x.html b/chrome/test/data/dromaeo/tests/jslib-event-jquery-2.x.html
+index 4e5abef..db65510 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-event-jquery-2.x.html
++++ b/chrome/test/data/dromaeo/tests/jslib-event-jquery-2.x.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
++<script src="../lib/jquery.2.0.3.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-event-jquery", '161a447c');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-event-jquery.html b/chrome/test/data/dromaeo/tests/jslib-event-jquery.html
+index 22ae395..bfaf354 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-event-jquery.html
++++ b/chrome/test/data/dromaeo/tests/jslib-event-jquery.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
++<script src="../lib/jquery.10.1.2.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-event-jquery", '690f881e');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-event-prototype.html b/chrome/test/data/dromaeo/tests/jslib-event-prototype.html
+index c601a89..78d4626 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-event-prototype.html
++++ b/chrome/test/data/dromaeo/tests/jslib-event-prototype.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/prototype/1.7.0.0/prototype.js"></script>
++<script src="../lib/prototype.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-event-prototype", '03b86d96');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-modify-jquery-2.x.html b/chrome/test/data/dromaeo/tests/jslib-modify-jquery-2.x.html
+index d03d56b..2c8323d 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-modify-jquery-2.x.html
++++ b/chrome/test/data/dromaeo/tests/jslib-modify-jquery-2.x.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
++<script src="../lib/jquery.2.0.3.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-modify-jquery", 'ed2c7ef2');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-modify-jquery.html b/chrome/test/data/dromaeo/tests/jslib-modify-jquery.html
+index 12c6a35..34fa179 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-modify-jquery.html
++++ b/chrome/test/data/dromaeo/tests/jslib-modify-jquery.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
++<script src="../lib/jquery.10.1.2.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-modify-jquery", '950aaaa1');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-modify-prototype.html b/chrome/test/data/dromaeo/tests/jslib-modify-prototype.html
+index e5e2a4d..866fd35 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-modify-prototype.html
++++ b/chrome/test/data/dromaeo/tests/jslib-modify-prototype.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/prototype/1.7.0.0/prototype.js"></script>
++<script src="../lib/prototype.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-modify-prototype", '6693b3a5');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-style-jquery-2.x.html b/chrome/test/data/dromaeo/tests/jslib-style-jquery-2.x.html
+index ce477b8..72c19c6 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-style-jquery-2.x.html
++++ b/chrome/test/data/dromaeo/tests/jslib-style-jquery-2.x.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
++<script src="../lib/jquery.2.0.3.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-style-jquery", '08bc6988');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-style-jquery.html b/chrome/test/data/dromaeo/tests/jslib-style-jquery.html
+index 35697967..3c99a70 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-style-jquery.html
++++ b/chrome/test/data/dromaeo/tests/jslib-style-jquery.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
++<script src="../lib/jquery.10.1.2.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-style-jquery", 'a803790a');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-style-prototype.html b/chrome/test/data/dromaeo/tests/jslib-style-prototype.html
+index 2762401..9ba6e48 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-style-prototype.html
++++ b/chrome/test/data/dromaeo/tests/jslib-style-prototype.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/prototype/1.7.0.0/prototype.js"></script>
++<script src="../lib/prototype.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-style-prototype", 'c41174f0');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-traverse-jquery-2.x.html b/chrome/test/data/dromaeo/tests/jslib-traverse-jquery-2.x.html
+index afc5b3d6..9e9792c 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-traverse-jquery-2.x.html
++++ b/chrome/test/data/dromaeo/tests/jslib-traverse-jquery-2.x.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
++<script src="../lib/jquery.2.0.3.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-traverse-jquery", '66e690c0');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-traverse-jquery.html b/chrome/test/data/dromaeo/tests/jslib-traverse-jquery.html
+index 910e2e6..19b6741 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-traverse-jquery.html
++++ b/chrome/test/data/dromaeo/tests/jslib-traverse-jquery.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
++<script src="../lib/jquery.10.1.2.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-traverse-jquery", 'bc5b18f3');
+diff --git a/chrome/test/data/dromaeo/tests/jslib-traverse-prototype.html b/chrome/test/data/dromaeo/tests/jslib-traverse-prototype.html
+index 37c28d6..68fe3bc 100644
+--- a/chrome/test/data/dromaeo/tests/jslib-traverse-prototype.html
++++ b/chrome/test/data/dromaeo/tests/jslib-traverse-prototype.html
+@@ -1,7 +1,7 @@
+ <html>
+ <head>
+ <script src="../htmlrunner.js"></script>
+-<script src="https://ajax.googleapis.com/ajax/libs/prototype/1.7.0.0/prototype.js"></script>
++<script src="../lib/prototype.js"></script>
+ <script>
+ window.onload = function(){
+ startTest("jslib-traverse-prototype", 'd46d3eab');
+-- 
+2.8.0.rc3.226.g39d4020
+
+
+From 677579e646af497d7e1625c85d8a7cffaf62aa13 Mon Sep 17 00:00:00 2001
+From: David Vallet <dvallet@google.com>
+Date: Thu, 17 Nov 2016 16:38:01 +1100
+Subject: [PATCH 2/4] change readme
+
+---
+ chrome/test/data/dromaeo/README.chromium | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+diff --git a/chrome/test/data/dromaeo/README.chromium b/chrome/test/data/dromaeo/README.chromium
+index 8f036bf..c57c79f 100644
+--- a/chrome/test/data/dromaeo/README.chromium
++++ b/chrome/test/data/dromaeo/README.chromium
+@@ -2,7 +2,10 @@ This directory contains Dromaeo, a JavaScript and DOM performance benchmark.
+ 
+ Dromaeo was developed and released by John Resig (jresig at mozilla.com)/
+ 
+-This benchmark was slightly modified to enable Chromium automation.
++This benchmark was slightly modified to: 
++ - Enable Chromium automation.
++ - Avoid grabbing javascript libraries from the Web.
++
+ 
+ How to update:
+ 
+@@ -11,3 +14,4 @@ How to update:
+ directory;
+ 2) run 'make web' to build standalone version;
+ 3) copy all the files from web dir into this directory.
++4) modify links to libraries and keep automation changes.
+-- 
+2.8.0.rc3.226.g39d4020
+
+
+From cb8e4fa9f308c17dada9e7aefb6122429cf61654 Mon Sep 17 00:00:00 2001
+From: David Vallet <dvallet@google.com>
+Date: Thu, 17 Nov 2016 16:41:15 +1100
+Subject: [PATCH 3/4] added fix for median calcualtion
+-- 
+2.8.0.rc3.226.g39d4020
+
diff --git a/chrome/test/data/dromaeo/patches/webrunner.patch b/chrome/test/data/dromaeo/patches/webrunner.patch
new file mode 100644
index 0000000000000..a273425dca4ab
--- /dev/null
+++ b/chrome/test/data/dromaeo/patches/webrunner.patch
@@ -0,0 +1,156 @@
+diff --git a/chrome/test/data/dromaeo/webrunner.js b/chrome/test/data/dromaeo/webrunner.js
+index 63d777b..598998b 100644
+--- a/chrome/test/data/dromaeo/webrunner.js
++++ b/chrome/test/data/dromaeo/webrunner.js
+@@ -230,6 +230,8 @@
+ 	var time = 0;
+ 	var title, testName, testID, testSummary = {} , testSummaryNum = {}, maxTotal = 0, maxTotalNum = 0;
+ 	var nameDone = {};
++	var automated = false;
++	var post_json = false;
+ 	
+ 	// Query String Parsing
+ 	var search = window.limitSearch || (window.location.search || "?").substr(1);
+@@ -269,6 +271,11 @@
+ 		m = /^numTests=(\d+)$/.exec(parts[i]);
+ 		if (m)
+ 			numTests = Number(m[1]);
++
++		if (/^automated$/.exec(parts[i]))
++			automated = true;
++		if (/^post_json$/.exec(parts[i]))
++			post_json = true;
+ 	}
+ 
+ 	jQuery(function(){
+@@ -377,17 +384,28 @@
+ 				}
+ 	
+ 			} else if ( dataStore && dataStore.length ) {
+-				$("body").addClass("alldone");
+-				var div = jQuery("<div class='results'>Saving...</div>").insertBefore("#overview");
+-				jQuery.ajax({
+-					type: "POST",
+-					url: "store.php",
+-					data: "data=" + encodeURIComponent(JSON.stringify(dataStore)) + "&style=" + runStyle,
+-					success: function(id){
+-						var url = window.location.href.replace(/\?.*$/, "") + "?id=" + id;
+-						div.html("Results saved. You can access them at a later time at the following URL:<br/><strong><a href='" + url + "'>" + url + "</a></strong></div>");
+-					}
+-				});
++				if (!automated) {
++					$("body").addClass("alldone");
++					var div = jQuery("<div class='results'>Saving...</div>").insertBefore("#overview");
++					jQuery.ajax({
++						type: "POST",
++						url: "store.php",
++						data: "data=" + encodeURIComponent(JSON.stringify(dataStore)) + "&style=" + runStyle,
++						success: function(id){
++							var url = window.location.href.replace(/\?.*$/, "") + "?id=" + id;
++							div.html("Results saved. You can access them at a later time at the following URL:<br/><strong><a href='" + url + "'>" + url + "</a></strong></div>");
++						}
++					});
++				} else if (post_json) {
++					jQuery.ajax({
++						type: "POST",
++						url: "store.php",
++						data: "data=" + encodeURIComponent(JSON.stringify(window.automation.GetResults()))
++					});
++				}
++				else {
++					window.automation.SetDone();
++				}
+ 			}
+ 		}
+ 	}
+@@ -406,20 +424,28 @@
+ 		time += timePerTest;
+ 		updateTime();
+ 		
+-		$("#pause")
+-			.val("Run")
+-			.click(function(){
+-				if ( interval ) {
+-					interval = null;
+-					this.value = "Run";
+-				} else {
+-					if ( !interval ) {
+-						interval = true;
+-						dequeue();
++		if (!automated) {
++			$("#pause")
++				.val("Run")
++				.click(function(){
++					if ( interval ) {
++						interval = null;
++						this.value = "Run";
++					} else {
++						if ( !interval ) {
++							interval = true;
++							dequeue();
++						}
++						this.value = "Pause";
+ 					}
+-					this.value = "Pause";
+-				}
+-			});
++				});
++		} else {
++			$("#pause")
++				.val("Automated")
++				.click(function(){});
++			interval = true;
++			dequeue();
++		}
+ 
+ 		if ( window.limitSearch ) {
+ 			$("#pause").click();
+@@ -778,4 +804,45 @@
+ 
+ 		updateTestPos({curID: testID, collection: tests[testID] ? tests[testID].name : testID, version: testVersions[testID]}, true);
+ 	}
++
++	if (automated) {
++		// Add some more stuff if running in automated mode.
++		window.automation = {}
++		window.automation.SetDone = function() {
++			console.log("Total: " + this.GetScore());
++			window.document.cookie = "__done=1; path=/";
++		}
++		window.automation.GetScore = function() {
++			return (runStyle === "runs/s" ? Math.pow(Math.E, maxTotal / maxTotalNum) : maxTotal).toString();
++		}
++		window.automation.GetResults = function() {
++			var results = {};
++			var aggregated = {};
++			function normalizeName(name) {
++				// At least for ui_tests, dots are not allowed.
++				return name.replace(".", "_");
++			}
++			function appendToAggregated(name, value) {
++				name = normalizeName(name);
++				(aggregated[name] || (aggregated[name] = [])).push(Math.log(value));
++			}
++
++			for (var i = 0; i < dataStore.length; i++) {
++				var data = dataStore[i];
++				var topName = data.collection.split("-", 1)[0];
++				appendToAggregated(topName, data.mean);
++				appendToAggregated(data.collection, data.mean);
++				results[normalizeName(data.collection + "/" + data.name)] = data.mean.toString();
++			}
++
++			for (var name in aggregated) {
++				var means = aggregated[name];
++				var sum = 0;
++				for (var i = 0; i < means.length; i++) sum += means[i];
++				results[name] = Math.pow(Math.E, sum/means.length).toString();
++			}
++
++			return results;
++		}
++	}
+ })();
+-- 
+2.8.0.rc3.226.g39d4020
+
diff --git a/third_party/abseil-cpp/patches/0001-Turn-on-hardened-mode.patch b/third_party/abseil-cpp/patches/0001-Turn-on-hardened-mode.patch
new file mode 100644
index 0000000000000..20c5693e66de3
--- /dev/null
+++ b/third_party/abseil-cpp/patches/0001-Turn-on-hardened-mode.patch
@@ -0,0 +1,24 @@
+From 15f51edf989cc47588c3d8635a62c255cdeb0072 Mon Sep 17 00:00:00 2001
+From: Daniel Cheng <dcheng@chromium.org>
+Date: Wed, 6 Oct 2021 03:23:23 -0700
+Subject: [PATCH] Turn on hardened mode and alias absl types to STL types..
+
+Enable various hardening checks in absl which would otherwise be UB.
+---
+ third_party/abseil-cpp/absl/base/options.h | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/third_party/abseil-cpp/absl/base/options.h b/third_party/abseil-cpp/absl/base/options.h
+index 230bf1eecc4a4..1641271cd3ff9 100644
+--- a/third_party/abseil-cpp/absl/base/options.h
++++ b/third_party/abseil-cpp/absl/base/options.h
+@@ -233,6 +233,6 @@
+ // checks enabled by this option may abort the program in a different way and
+ // log additional information when `NDEBUG` is not defined.
+ 
+-#define ABSL_OPTION_HARDENED 0
++#define ABSL_OPTION_HARDENED 1
+ 
+ #endif  // ABSL_BASE_OPTIONS_H_
+-- 
+2.33.0.882.g93a45727a2-goog
diff --git a/third_party/abseil-cpp/patches/0002-delete-unprefixed-annotations.patch b/third_party/abseil-cpp/patches/0002-delete-unprefixed-annotations.patch
new file mode 100644
index 0000000000000..4eb0c0b588452
--- /dev/null
+++ b/third_party/abseil-cpp/patches/0002-delete-unprefixed-annotations.patch
@@ -0,0 +1,55 @@
+TODO: b/145122732 - Remove unprefixed dynamic annotation macros from abseil
+---
+diff --git a/third_party/abseil-cpp/absl/base/dynamic_annotations.h b/third_party/abseil-cpp/absl/base/dynamic_annotations.h
+index 1444dc48e283..6687291cade3 100644
+--- a/third_party/abseil-cpp/absl/base/dynamic_annotations.h
++++ b/third_party/abseil-cpp/absl/base/dynamic_annotations.h
+@@ -49,9 +49,6 @@
+ 
+ #include "absl/base/config.h"
+ 
+-// TODO(rogeeff): Remove after the backward compatibility period.
+-#include "absl/base/internal/dynamic_annotations.h"  // IWYU pragma: export
+-
+ // -------------------------------------------------------------------------
+ // Decide which features are enabled
+ 
+diff --git a/third_party/abseil-cpp/absl/base/BUILD.bazel b/third_party/abseil-cpp/absl/base/BUILD.bazel
+index 65ff0ddef9fd..d6fbf3581158 100644
+--- a/third_party/abseil-cpp/absl/base/BUILD.bazel
++++ b/third_party/abseil-cpp/absl/base/BUILD.bazel
+@@ -115,9 +115,6 @@ cc_library(
+
+ cc_library(
+     name = "dynamic_annotations",
+-    srcs = [
+-        "internal/dynamic_annotations.h",
+-    ],
+     hdrs = [
+         "dynamic_annotations.h",
+     ],
+diff --git a/third_party/abseil-cpp/CMake/AbseilDll.cmake b/third_party/abseil-cpp/CMake/AbseilDll.cmake
+index 00cddb84c6b7f..a2b8b103885a6 100644
+--- a/third_party/abseil-cpp/CMake/AbseilDll.cmake
++++ b/third_party/abseil-cpp/CMake/AbseilDll.cmake
+@@ -14,7 +14,6 @@ set(ABSL_INTERNAL_DLL_FILES
+   "base/internal/cycleclock.cc"
+   "base/internal/cycleclock.h"
+   "base/internal/direct_mmap.h"
+-  "base/internal/dynamic_annotations.h"
+   "base/internal/endian.h"
+   "base/internal/errno_saver.h"
+   "base/internal/fast_type_id.h"
+diff --git a/third_party/abseil-cpp/absl/base/CMakeLists.txt b/third_party/abseil-cpp/absl/base/CMakeLists.txt
+index ed55093abe80f..6908182e97c86 100644
+--- a/third_party/abseil-cpp/absl/base/CMakeLists.txt
++++ b/third_party/abseil-cpp/absl/base/CMakeLists.txt
+@@ -109,8 +109,6 @@ absl_cc_library(
+     dynamic_annotations
+   HDRS
+     "dynamic_annotations.h"
+-  SRCS
+-    "internal/dynamic_annotations.h"
+   COPTS
+     ${ABSL_DEFAULT_COPTS}
+   DEPS
diff --git a/third_party/abseil-cpp/patches/0003-delete-static-initializer-in-stacktrace.patch b/third_party/abseil-cpp/patches/0003-delete-static-initializer-in-stacktrace.patch
new file mode 100644
index 0000000000000..ad3f5ab8a77d8
--- /dev/null
+++ b/third_party/abseil-cpp/patches/0003-delete-static-initializer-in-stacktrace.patch
@@ -0,0 +1,33 @@
+TODO: crbug.com/40148384, b/156075691#comment18 - Remove this static initializer upstream
+---
+diff --git a/third_party/abseil-cpp/absl/debugging/internal/stacktrace_generic-inl.inc b/third_party/abseil-cpp/absl/debugging/internal/stacktrace_generic-inl.inc
+index b2792a1f3ada..b94c61233ba3 100644
+--- a/third_party/abseil-cpp/absl/debugging/internal/stacktrace_generic-inl.inc
++++ b/third_party/abseil-cpp/absl/debugging/internal/stacktrace_generic-inl.inc
+@@ -43,17 +43,6 @@ static __thread int recursive = 0;
+ // glibc implementation itself will trigger malloc the first time it is called.
+ // As such, we suppress usage of backtrace during this early stage of execution.
+ static std::atomic<bool> disable_stacktraces(true);  // Disabled until healthy.
+-// Waiting until static initializers run seems to be late enough.
+-// This file is included into stacktrace.cc so this will only run once.
+-ABSL_ATTRIBUTE_UNUSED static int stacktraces_enabler = []() {
+-  void* unused_stack[1];
+-  // Force the first backtrace to happen early to get the one-time shared lib
+-  // loading (allocation) out of the way. After the first call it is much safer
+-  // to use backtrace from a signal handler if we crash somewhere later.
+-  backtrace(unused_stack, 1);
+-  disable_stacktraces.store(false, std::memory_order_relaxed);
+-  return 0;
+-}();
+ 
+ template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
+ static int UnwindImpl(void** result, int* sizes, int max_depth, int skip_count,
+@@ -99,7 +88,7 @@ namespace absl {
+ ABSL_NAMESPACE_BEGIN
+ namespace debugging_internal {
+ bool StackTraceWorksForTest() {
+-  return true;
++  return false;
+ }
+ }  // namespace debugging_internal
+ ABSL_NAMESPACE_END
diff --git a/third_party/afl/patches/0001-fix-build-with-std-c11.patch b/third_party/afl/patches/0001-fix-build-with-std-c11.patch
new file mode 100644
index 0000000000000..63eb6b54f3450
--- /dev/null
+++ b/third_party/afl/patches/0001-fix-build-with-std-c11.patch
@@ -0,0 +1,27 @@
+diff --git a/afl-fuzz.c b/afl-fuzz.c
+index 01b4afef0ecc..f0d564a33037 100644
+--- a/afl-fuzz.c
++++ b/afl-fuzz.c
+@@ -23,7 +23,9 @@
+ #define AFL_MAIN
+ #define MESSAGES_TO_STDOUT
+ 
++#ifndef _GNU_SOURCE
+ #define _GNU_SOURCE
++#endif
+ #define _FILE_OFFSET_BITS 64
+ 
+ #include "config.h"
+diff --git a/types.h b/types.h
+index 784d3a7a286d..d24d1fdd97e8 100644
+--- a/types.h
++++ b/types.h
+@@ -78,7 +78,7 @@ typedef int64_t  s64;
+ #define STRINGIFY(x) STRINGIFY_INTERNAL(x)
+ 
+ #define MEM_BARRIER() \
+-  asm volatile("" ::: "memory")
++  __asm__ volatile("" ::: "memory")
+ 
+ #define likely(_x)   __builtin_expect(!!(_x), 1)
+ #define unlikely(_x)  __builtin_expect(!!(_x), 0)
diff --git a/third_party/afl/patches/0002-fix-shadow-variables.patch b/third_party/afl/patches/0002-fix-shadow-variables.patch
new file mode 100644
index 0000000000000..231406a2c9248
--- /dev/null
+++ b/third_party/afl/patches/0002-fix-shadow-variables.patch
@@ -0,0 +1,65 @@
+diff --git a/afl-fuzz.c b/afl-fuzz.c
+index f0d564a330373..a787f9a685a69 100644
+--- a/afl-fuzz.c
++++ b/afl-fuzz.c
+@@ -1409,12 +1409,12 @@ static void read_testcases(void) {
+   struct dirent **nl;
+   s32 nl_cnt;
+   u32 i;
+-  u8* fn;
++  u8* queue_fn;
+ 
+   /* Auto-detect non-in-place resumption attempts. */
+ 
+-  fn = alloc_printf("%s/queue", in_dir);
+-  if (!access(fn, F_OK)) in_dir = fn; else ck_free(fn);
++  queue_fn = alloc_printf("%s/queue", in_dir);
++  if (!access(queue_fn, F_OK)) in_dir = queue_fn; else ck_free(queue_fn);
+ 
+   ACTF("Scanning '%s'...", in_dir);
+ 
+@@ -3652,17 +3652,17 @@ static void maybe_delete_out_dir(void) {
+ 
+   if (f) {
+ 
+-    u64 start_time, last_update;
++    u64 cur_start_time, last_update;
+ 
+     if (fscanf(f, "start_time     : %llu\n"
+-                  "last_update    : %llu\n", &start_time, &last_update) != 2)
++                  "last_update    : %llu\n", &cur_start_time, &last_update) != 2)
+       FATAL("Malformed data in '%s'", fn);
+ 
+     fclose(f);
+ 
+     /* Let's see how much work is at stake. */
+ 
+-    if (!in_place_resume && last_update - start_time > OUTPUT_GRACE * 60) {
++    if (!in_place_resume && last_update - cur_start_time > OUTPUT_GRACE * 60) {
+ 
+       SAYF("\n" cLRD "[-] " cRST
+            "The job output directory already exists and contains the results of more\n"
+diff --git a/types.h b/types.h
+index d24d1fdd97e8c..e12ac3e894599 100644
+--- a/types.h
++++ b/types.h
+@@ -57,15 +58,13 @@ typedef int64_t  s64;
+ #endif /* !MIN */
+ 
+ #define SWAP16(_x) ({ \
+-    u16 _ret = (_x); \
+-    (u16)((_ret << 8) | (_ret >> 8)); \
++    (u16)(((u16)(_x) << 8) | ((u16)(_x) >> 8)); \
+   })
+ 
+ #define SWAP32(_x) ({ \
+-    u32 _ret = (_x); \
+-    (u32)((_ret << 24) | (_ret >> 24) | \
+-          ((_ret << 8) & 0x00FF0000) | \
+-          ((_ret >> 8) & 0x0000FF00)); \
++    (u32)(((u32)(_x) << 24) | ((u32)(_x) >> 24) | \
++          (((u32)(_x) << 8) & 0x00FF0000) | \
++          (((u32)(_x) >> 8) & 0x0000FF00)); \
+   })
+ 
+ #ifdef AFL_LLVM_PASS
diff --git a/third_party/afl/src/QuickStartGuide.txt b/third_party/afl/src/QuickStartGuide.txt
deleted file mode 120000
index e1687eb5bea5e..0000000000000
--- a/third_party/afl/src/QuickStartGuide.txt
+++ /dev/null
@@ -1 +0,0 @@
-docs/QuickStartGuide.txt
\ No newline at end of file
diff --git a/third_party/afl/src/QuickStartGuide.txt b/third_party/afl/src/QuickStartGuide.txt
new file mode 100644
index 0000000000000..e1687eb5bea5e
--- /dev/null
+++ b/third_party/afl/src/QuickStartGuide.txt
@@ -0,0 +1 @@
+docs/QuickStartGuide.txt
\ No newline at end of file
diff --git a/third_party/afl/src/experimental/libpng_no_checksum/libpng-nocrc.patch b/third_party/afl/src/experimental/libpng_no_checksum/libpng-nocrc.patch
new file mode 100644
index 0000000000000..0a3793a0202fa
--- /dev/null
+++ b/third_party/afl/src/experimental/libpng_no_checksum/libpng-nocrc.patch
@@ -0,0 +1,15 @@
+--- pngrutil.c.orig	2014-06-12 03:35:16.000000000 +0200
++++ pngrutil.c	2014-07-01 05:08:31.000000000 +0200
+@@ -268,7 +268,11 @@
+    if (need_crc != 0)
+    {
+       crc = png_get_uint_32(crc_bytes);
+-      return ((int)(crc != png_ptr->crc));
++
++      if (crc != png_ptr->crc)
++        fprintf(stderr, "NOTE: CRC in the file is 0x%08x, change to 0x%08x\n", crc, png_ptr->crc);
++
++      return ((int)(1 != 1));
+    }
+ 
+    else
diff --git a/third_party/apache-portable-runtime/diff.patch b/third_party/apache-portable-runtime/diff.patch
new file mode 100644
index 0000000000000..ce2d23ed65538
--- /dev/null
+++ b/third_party/apache-portable-runtime/diff.patch
@@ -0,0 +1,254 @@
+diff -ruN ./original/include/apr.h ./changed/include/apr.h
+--- ./original/include/apr.h	2016-01-04 13:12:47.009354091 -0500
++++ ./changed/include/apr.h	2016-01-04 10:18:31.701765503 -0500
+@@ -80,7 +80,7 @@
+ #define APR_HAVE_LIMITS_H        1
+ #define APR_HAVE_NETDB_H         1
+ #define APR_HAVE_NETINET_IN_H    1
+-#define APR_HAVE_NETINET_SCTP_H  1
++#define APR_HAVE_NETINET_SCTP_H  0
+ #define APR_HAVE_NETINET_SCTP_UIO_H 0
+ #define APR_HAVE_NETINET_TCP_H   1
+ #define APR_HAVE_PROCESS_H       0
+@@ -220,19 +220,19 @@
+ #define APR_USE_SHMEM_MMAP_SHM     0
+ #define APR_USE_SHMEM_MMAP_ZERO    0
+ #define APR_USE_SHMEM_SHMGET_ANON  0
+-#define APR_USE_SHMEM_SHMGET       1
++#define APR_USE_SHMEM_SHMGET       0
+ #define APR_USE_SHMEM_MMAP_ANON    1
+ #define APR_USE_SHMEM_BEOS         0
+ 
+ #define APR_USE_FLOCK_SERIALIZE           0 
+-#define APR_USE_SYSVSEM_SERIALIZE         1
++#define APR_USE_SYSVSEM_SERIALIZE         0
+ #define APR_USE_POSIXSEM_SERIALIZE        0
+ #define APR_USE_FCNTL_SERIALIZE           0
+ #define APR_USE_PROC_PTHREAD_SERIALIZE    0 
+ #define APR_USE_PTHREAD_SERIALIZE         1 
+ 
+ #define APR_HAS_FLOCK_SERIALIZE           1
+-#define APR_HAS_SYSVSEM_SERIALIZE         1
++#define APR_HAS_SYSVSEM_SERIALIZE         0
+ #define APR_HAS_POSIXSEM_SERIALIZE        1
+ #define APR_HAS_FCNTL_SERIALIZE           1
+ #define APR_HAS_PROC_PTHREAD_SERIALIZE    1
+@@ -260,7 +260,7 @@
+ #define APR_HAVE_MEMCHR         1
+ #define APR_HAVE_STRUCT_RLIMIT  1
+ #define APR_HAVE_UNION_SEMUN    0
+-#define APR_HAVE_SCTP           1
++#define APR_HAVE_SCTP           0
+ #define APR_HAVE_IOVEC          1
+ 
+ /*  APR Feature Macros */
+@@ -278,7 +278,7 @@
+ #define APR_HAS_USER              1
+ #define APR_HAS_LARGE_FILES       0
+ #define APR_HAS_XTHREAD_FILES     0
+-#define APR_HAS_OS_UUID           1
++#define APR_HAS_OS_UUID           0
+ 
+ #define APR_PROCATTR_USER_SET_REQUIRES_PASSWORD 0
+ 
+@@ -349,8 +349,8 @@
+  #define UINT64_C(v)  (v ## ULL)
+ #endif
+ #else
+- typedef  long            apr_int64_t;
+- typedef  unsigned long   apr_uint64_t;
++ typedef  long long            apr_int64_t;
++ typedef  unsigned long long   apr_uint64_t;
+ #endif
+ 
+ typedef  size_t          apr_size_t;
+diff -ruN ./original/include/arch/netware/DEPS ./changed/include/arch/netware/DEPS
+--- ./original/include/arch/netware/DEPS	1969-12-31 19:00:00.000000000 -0500
++++ ./changed/include/arch/netware/DEPS	2016-01-04 10:18:31.705765573 -0500
+@@ -0,0 +1,3 @@
++include_rules = [
++    '+../original/apr_private_common.h',
++]
+diff -ruN ./original/include/arch/unix/apr_private.h ./changed/include/arch/unix/apr_private.h
+--- ./original/include/arch/unix/apr_private.h	2016-01-04 13:12:47.193357456 -0500
++++ ./changed/include/arch/unix/apr_private.h	2016-01-04 10:18:31.705765573 -0500
+@@ -31,7 +31,7 @@
+ #define DEV_RANDOM "/dev/urandom"
+ 
+ /* Define if struct dirent has an inode member */
+-#define DIRENT_INODE d_fileno
++/* #define DIRENT_INODE d_fileno */
+ 
+ /* Define if struct dirent has a d_type member */
+ #define DIRENT_TYPE d_type
+@@ -73,7 +73,7 @@
+ /* #undef GETSERVBYNAME_IS_THREAD_SAFE */
+ 
+ /* Define if getservbyname_r has the glibc style */
+-#define GETSERVBYNAME_R_GLIBC2 1
++/* #define GETSERVBYNAME_R_GLIBC2 1 */
+ 
+ /* Define if getservbyname_r has the OSF/1 style */
+ /* #undef GETSERVBYNAME_R_OSF1 */
+@@ -82,7 +82,7 @@
+ /* #undef GETSERVBYNAME_R_SOLARIS */
+ 
+ /* Define if accept4 function is supported */
+-#define HAVE_ACCEPT4 1
++/* #define HAVE_ACCEPT4 1 */
+ 
+ /* Define if async i/o supports message q's */
+ /* #undef HAVE_AIO_MSGQ */
+@@ -141,7 +141,7 @@
+ /* #undef HAVE_DL_H */
+ 
+ /* Define if dup3 function is supported */
+-#define HAVE_DUP3 1
++/* #define HAVE_DUP3 1 */
+ 
+ /* Define if EGD is supported */
+ /* #undef HAVE_EGD */
+@@ -150,7 +150,7 @@
+ #define HAVE_EPOLL 1
+ 
+ /* Define if epoll_create1 function is supported */
+-#define HAVE_EPOLL_CREATE1 1
++/* #define HAVE_EPOLL_CREATE1 1 */
+ 
+@@ -183,10 +183,19 @@
+ #define HAVE_GETENV 1
+ 
+ /* Define to 1 if you have the `getgrgid_r' function. */
+-#define HAVE_GETGRGID_R 1
++// Removed due to incompatability with Android NDK r16
++// On older NDK versions, _POSIX_THREAD_SAFE_FUNCTIONS was unconditionally
++// #undef'd. On newer versions, it is unconditionally defined as the Posix
++// version. This causes issues in
++// user/unix/groupinfo.c, as APR seems to unconditionally define
++// HAVE_GETGRGID_R AND HAVE_GETGRNAM_R, and the only thing that was previously
++// preventing it from using getgrgid_r/getgrnam_r was
++// _POSIX_THREAD_SAFE_FUNCTIONS being undefined.
++// #define HAVE_GETGRGID_R 1
+ 
+ /* Define to 1 if you have the `getgrnam_r' function. */
+-#define HAVE_GETGRNAM_R 1
++// Removed due to incompatability with Android NDK r16
++// #define HAVE_GETGRNAM_R 1
+ 
+ /* Define to 1 if you have the <errno.h> header file. */
+ #define HAVE_ERRNO_H 1
+@@ -195,13 +195,13 @@
+ #define HAVE_GETHOSTBYNAME_R 1
+ 
+ /* Define to 1 if you have the `getifaddrs' function. */
+-#define HAVE_GETIFADDRS 1
++/* #define HAVE_GETIFADDRS 1 */
+ 
+ /* Define if getnameinfo exists */
+ #define HAVE_GETNAMEINFO 1
+ 
+ /* Define to 1 if you have the `getpass' function. */
+-#define HAVE_GETPASS 1
++/* #define HAVE_GETPASS 1 */
+ 
+ /* Define to 1 if you have the `getpassphrase' function. */
+ /* #undef HAVE_GETPASSPHRASE */
+@@ -318,7 +318,7 @@
+ /* #undef HAVE_NET_ERRNO_H */
+ 
+ /* Define to 1 if you have the `nl_langinfo' function. */
+-#define HAVE_NL_LANGINFO 1
++/* #define HAVE_NL_LANGINFO 1 */
+ 
+ /* Define to 1 if you have the <os2.h> header file. */
+ /* #undef HAVE_OS2_H */
+@@ -360,7 +360,7 @@
+ #define HAVE_PTHREAD_MUTEX_RECURSIVE 1
+ 
+ /* Define if cross-process robust mutexes are available */
+-#define HAVE_PTHREAD_MUTEX_ROBUST 1
++/* #define HAVE_PTHREAD_MUTEX_ROBUST 1 */
+ 
+ /* Define if PTHREAD_PROCESS_SHARED is defined in pthread.h */
+ #define HAVE_PTHREAD_PROCESS_SHARED 1
+@@ -372,7 +372,7 @@
+ #define HAVE_PTHREAD_RWLOCK_INIT 1
+ 
+ /* Define to 1 if you have the `pthread_yield' function. */
+-#define HAVE_PTHREAD_YIELD 1
++/* #define HAVE_PTHREAD_YIELD 1 */
+ 
+ /* Define to 1 if you have the `putenv' function. */
+ #define HAVE_PUTENV 1
+@@ -474,7 +474,7 @@
+ #define HAVE_SOCKLEN_T 1
+ 
+ /* Define if the SOCK_CLOEXEC flag is supported */
+-#define HAVE_SOCK_CLOEXEC 1
++/* #define HAVE_SOCK_CLOEXEC 1 */
+ 
+ /* Define if SO_ACCEPTFILTER is defined in sys/socket.h */
+ /* #undef HAVE_SO_ACCEPTFILTER */
+@@ -531,7 +531,7 @@
+ /* #undef HAVE_STRUCT_STAT_ST_ATIME_N */
+ 
+ /* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */
+-#define HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC 1
++/* #define HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC 0 */
+ 
+ /* Define to 1 if `st_blocks' is a member of `struct stat'. */
+ #define HAVE_STRUCT_STAT_ST_BLOCKS 1
+@@ -543,7 +543,7 @@
+ /* #undef HAVE_STRUCT_STAT_ST_CTIME_N */
+ 
+ /* Define to 1 if `st_ctim.tv_nsec' is a member of `struct stat'. */
+-#define HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC 1
++/* #define HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC 1 */
+ 
+ /* Define to 1 if `st_mtimensec' is a member of `struct stat'. */
+ /* #undef HAVE_STRUCT_STAT_ST_MTIMENSEC */
+@@ -552,7 +552,7 @@
+ /* #undef HAVE_STRUCT_STAT_ST_MTIME_N */
+ 
+ /* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
+-#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
++/* #define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1 */
+ 
+ /* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+ #define HAVE_STRUCT_TM_TM_GMTOFF 1
+@@ -594,13 +594,13 @@
+ #define HAVE_SYS_SELECT_H 1
+ 
+ /* Define to 1 if you have the <sys/sem.h> header file. */
+-#define HAVE_SYS_SEM_H 1
++/* #define HAVE_SYS_SEM_H 1 */
+ 
+ /* Define to 1 if you have the <sys/sendfile.h> header file. */
+ #define HAVE_SYS_SENDFILE_H 1
+ 
+ /* Define to 1 if you have the <sys/shm.h> header file. */
+-#define HAVE_SYS_SHM_H 1
++/* #define HAVE_SYS_SHM_H 1 */
+ 
+ /* Define to 1 if you have the <sys/signal.h> header file. */
+ #define HAVE_SYS_SIGNAL_H 1
+@@ -633,7 +633,7 @@
+ #define HAVE_SYS_UN_H 1
+ 
+ /* Define to 1 if you have the <sys/uuid.h> header file. */
+-/* #undef HAVE_SYS_UUID_H */
++#undef HAVE_SYS_UUID_H
+ 
+ /* Define to 1 if you have the <sys/wait.h> header file. */
+ #define HAVE_SYS_WAIT_H 1
+@@ -687,7 +687,7 @@
+ /* #undef HAVE_UUID_H */
+ 
+ /* Define to 1 if you have the <uuid/uuid.h> header file. */
+-#define HAVE_UUID_UUID_H 1
++/* #define HAVE_UUID_UUID_H 1 */
+ 
+ /* Define if C compiler supports VLA */
+ #define HAVE_VLA 1
+
+ 
diff --git a/third_party/apache-win32/ABOUT_APACHE.txt b/third_party/apache-win32/ABOUT_APACHE.txt
deleted file mode 100644
index d013e5b2f65bd..0000000000000
--- a/third_party/apache-win32/ABOUT_APACHE.txt
+++ /dev/null
@@ -1,244 +0,0 @@
-
-                     The Apache HTTP Server Project
-
-                        http://httpd.apache.org/
-
-The Apache HTTP Server Project is a collaborative software development effort
-aimed at creating a robust, commercial-grade, featureful, and freely-available
-source code implementation of an HTTP (Web) server. The project is jointly 
-managed by a group of volunteers located around the world, using the Internet
-and the Web to communicate, plan, and develop the server and its related 
-documentation. In addition, hundreds of users have contributed ideas, code, 
-and documentation to the project.
-
-This file is intended to briefly describe the history of the Apache Group (as 
-it was called in the early days), recognize the many contributors, and explain
-how you can join the fun too.
-
-In February of 1995, the most popular server software on the Web was the
-public domain HTTP daemon developed by Rob McCool at the National Center
-for Supercomputing Applications, University of Illinois, Urbana-Champaign.
-However, development of that httpd had stalled after Rob left NCSA in
-mid-1994, and many webmasters had developed their own extensions and bug
-fixes that were in need of a common distribution. A small group of these
-webmasters, contacted via private e-mail, gathered together for the purpose
-of coordinating their changes (in the form of "patches"). Brian Behlendorf
-and Cliff Skolnick put together a mailing list, shared information space,
-and logins for the core developers on a machine in the California Bay Area,
-with bandwidth and diskspace donated by HotWired and Organic Online.
-By the end of February, eight core contributors formed the foundation
-of the original Apache Group:
-
-   Brian Behlendorf        Roy T. Fielding          Rob Hartill
-   David Robinson          Cliff Skolnick           Randy Terbush
-   Robert S. Thau          Andrew Wilson
-
-with additional contributions from
-
-   Eric Hagberg            Frank Peters             Nicolas Pioch
-
-Using NCSA httpd 1.3 as a base, we added all of the published bug fixes
-and worthwhile enhancements we could find, tested the result on our own
-servers, and made the first official public release (0.6.2) of the Apache
-server in April 1995. By coincidence, NCSA restarted their own development
-during the same period, and Brandon Long and Beth Frank of the NCSA Server
-Development Team joined the list in March as honorary members so that the
-two projects could share ideas and fixes.
-
-The early Apache server was a big hit, but we all knew that the codebase
-needed a general overhaul and redesign. During May-June 1995, while
-Rob Hartill and the rest of the group focused on implementing new features
-for 0.7.x (like pre-forked child processes) and supporting the rapidly growing
-Apache user community, Robert Thau designed a new server architecture
-(code-named Shambhala) which included a modular structure and API for better
-extensibility, pool-based memory allocation, and an adaptive pre-forking
-process model. The group switched to this new server base in July and added
-the features from 0.7.x, resulting in Apache 0.8.8 (and its brethren)
-in August.
-
-After extensive beta testing, many ports to obscure platforms, a new set
-of documentation (by David Robinson), and the addition of many features
-in the form of our standard modules, Apache 1.0 was released on
-December 1, 1995.
-
-Less than a year after the group was formed, the Apache server passed
-NCSA's httpd as the #1 server on the Internet.
-
-The survey by Netcraft (http://www.netcraft.com/survey/) shows that Apache
-is today more widely used than all other web servers combined.
-
- ============================================================================
-
-The current project management committe of the Apache HTTP Server
-project (as of March, 2011) is:
-
-    Aaron Bannert       André Malo              Astrid Stolper
-    Ben Laurie          Bojan Smojver           Brad Nicholes
-    Brian Havard        Brian McCallister       Chris Darroch
-    Chuck Murcko        Colm MacCárthaigh       Dan Poirier
-    Dirk-Willem van Gulik                       Doug MacEachern     
-    Eric Covener        Erik Abele              Graham Dumpleton    
-    Graham Leggett      Greg Ames               Greg Stein 
-    Gregory Trubetskoy  Guenter Knauf           Issac Goldstand     
-    Jeff Trawick        Jim Gallacher           Jim Jagielski      
-    Joe Orton           Joe Schaefer            Joshua Slive
-    Justin Erenkrantz   Ken Coar                Lars Eilebrecht
-    Manoj Kasichainula  Marc Slemko             Mark J. Cox
-    Martin Kraemer      Maxime Petazzoni        Nick Kew
-    Nicolas Lehuen      Noirin Shirley          Paul Querna
-    Philip M. Gollucci  Ralf S. Engelschall     Randy Kobes
-    Rasmus Lerdorf      Rich Bowen              Roy T. Fielding
-    Rüdiger Plüm        Sander Striker          Sander Temm
-    Stefan Fritsch      Tony Stevenson          Victor J. Orlikowski
-    Wilfredo Sanchez    William A. Rowe Jr.     Yoshiki Hayashi     
-
-Other major contributors
-
-   Howard Fear (mod_include), Florent Guillaume (language negotiation),
-   Koen Holtman (rewrite of mod_negotiation),
-   Kevin Hughes (creator of all those nifty icons),
-   Brandon Long and Beth Frank (NCSA Server Development Team, post-1.3),
-   Ambarish Malpani (Beginning of the NT port),
-   Rob McCool (original author of the NCSA httpd 1.3),
-   Paul Richards (convinced the group to use remote CVS after 1.0),
-   Garey Smiley (OS/2 port), Henry Spencer (author of the regex library).
-
-Many 3rd-party modules, frequently used and recommended, are also
-freely-available and linked from the related projects page:
-<http://modules.apache.org/>, and their authors frequently
-contribute ideas, patches, and testing.
-
-Hundreds of people have made individual contributions to the Apache
-project. Patch contributors are listed in the CHANGES file.
-
- ============================================================================
-
-How to become involved in the Apache project
-
-There are several levels of contributing. If you just want to send
-in an occasional suggestion/fix, then you can just use the bug reporting
-form at <http://httpd.apache.org/bug_report.html>. You can also subscribe
-to the announcements mailing list (announce-subscribe@httpd.apache.org) which
-we use to broadcast information about new releases, bugfixes, and upcoming
-events. There's a lot of information about the development process (much of
-it in serious need of updating) to be found at <http://httpd.apache.org/dev/>.
-
-If you'd like to become an active contributor to the Apache project (the
-group of volunteers who vote on changes to the distributed server), then
-you need to start by subscribing to the dev@httpd.apache.org mailing list.
-One warning though: traffic is high, 1000 to 1500 messages/month.
-To subscribe to the list, send an email to dev-subscribe@httpd.apache.org.
-We recommend reading the list for a while before trying to jump in to 
-development.
-
-   NOTE: The developer mailing list (dev@httpd.apache.org) is not
-   a user support forum; it is for people actively working on development
-   of the server code and documentation, and for planning future
-   directions. If you have user/configuration questions, send them
-   to users list <http://httpd.apache.org/userslist> or to the USENET
-   newsgroup "comp.infosystems.www.servers.unix".or for windows users,
-   the newsgroup "comp.infosystems.www.servers.ms-windows".
-
-There is a core group of contributors (informally called the "core")
-which was formed from the project founders and is augmented from time
-to time when core members nominate outstanding contributors and the
-rest of the core members agree. The core group focus is more on
-"business" issues and limited-circulation things like security problems
-than on mainstream code development. The term "The Apache Group"
-technically refers to this core of project contributors.
-
-The Apache project is a meritocracy--the more work you have done, the more
-you are allowed to do. The group founders set the original rules, but
-they can be changed by vote of the active members. There is a group
-of people who have logins on our server (apache.org) and access to the
-svn repository.  Everyone has access to the svn snapshots.  Changes to
-the code are proposed on the mailing list and usually voted on by active
-members--three +1 (yes votes) and no -1 (no votes, or vetoes) are needed
-to commit a code change during a release cycle; docs are usually committed
-first and then changed as needed, with conflicts resolved by majority vote.
-
-Our primary method of communication is our mailing list. Approximately 40
-messages a day flow over the list, and are typically very conversational in
-tone. We discuss new features to add, bug fixes, user problems, developments
-in the web server community, release dates, etc. The actual code development
-takes place on the developers' local machines, with proposed changes
-communicated using a patch (output of a unified "diff -u oldfile newfile"
-command), and committed to the source repository by one of the core
-developers using remote svn.  Anyone on the mailing list can vote on a
-particular issue, but we only count those made by active members or people
-who are known to be experts on that part of the server. Vetoes must be
-accompanied by a convincing explanation.
-
-New members of the Apache Group are added when a frequent contributor is
-nominated by one member and unanimously approved by the voting members.
-In most cases, this "new" member has been actively contributing to the
-group's work for over six months, so it's usually an easy decision.
-
-The above describes our past and current (as of July 2000) guidelines,
-which will probably change over time as the membership of the group
-changes and our development/coordination tools improve.
-
- ============================================================================
-
-The Apache Software Foundation (www.apache.org)
-
-The Apache Software Foundation exists to provide organizational, legal,
-and financial support for the Apache open-source software projects.
-Founded in June 1999 by the Apache Group, the Foundation has been
-incorporated as a membership-based, not-for-profit corporation in order
-to ensure that the Apache projects continue to exist beyond the participation
-of individual volunteers, to enable contributions of intellectual property
-and funds on a sound basis, and to provide a vehicle for limiting legal
-exposure while participating in open-source software projects. 
-
-You are invited to participate in The Apache Software Foundation. We welcome
-contributions in many forms. Our membership consists of those individuals
-who have demonstrated a commitment to collaborative open-source software
-development through sustained participation and contributions within the
-Foundation's projects. Many people and companies have contributed towards
-the success of the Apache projects. 
-
- ============================================================================
-
-Why The Apache HTTP Server Is Free
-
-Apache HTTP Server exists to provide a robust and commercial-grade reference
-implementation of the HTTP protocol. It must remain a platform upon which
-individuals and institutions can build reliable systems, both for
-experimental purposes and for mission-critical purposes. We believe the
-tools of online publishing should be in the hands of everyone, and
-software companies should make their money providing value-added services
-such as specialized modules and support, amongst other things. We realize
-that it is often seen as an economic advantage for one company to "own" a
-market - in the software industry that means to control tightly a
-particular conduit such that all others must pay. This is typically done
-by "owning" the protocols through which companies conduct business, at the
-expense of all those other companies. To the extent that the protocols of
-the World Wide Web remain "unowned" by a single company, the Web will
-remain a level playing field for companies large and small. Thus,
-"ownership" of the protocol must be prevented, and the existence of a
-robust reference implementation of the protocol, available absolutely for
-free to all companies, is a tremendously good thing. 
-
-Furthermore, Apache httpd is an organic entity; those who benefit from it
-by using it often contribute back to it by providing feature enhancements,
-bug fixes, and support for others in public newsgroups. The amount of
-effort expended by any particular individual is usually fairly light, but
-the resulting product is made very strong. This kind of community can
-only happen with freeware--when someone pays for software, they usually
-aren't willing to fix its bugs. One can argue, then, that Apache's
-strength comes from the fact that it's free, and if it were made "not
-free" it would suffer tremendously, even if that money were spent on a
-real development team.
-
-We want to see Apache httpd used very widely--by large companies, small
-companies, research institutions, schools, individuals, in the intranet
-environment, everywhere--even though this may mean that companies who
-could afford commercial software, and would pay for it without blinking,
-might get a "free ride" by using Apache httpd. We would even be happy if 
-some commercial software companies completely dropped their own HTTP server
-development plans and used Apache httpd as a base, with the proper attributions
-as described in the LICENSE file.
-
-Thanks for using Apache HTTP Server!
-
diff --git a/third_party/apache-win32/LICENSE.txt b/third_party/apache-win32/LICENSE.txt
deleted file mode 100644
index 63739125c2125..0000000000000
--- a/third_party/apache-win32/LICENSE.txt
+++ /dev/null
@@ -1,946 +0,0 @@
-                                  Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-
-
-APACHE HTTP SERVER SUBCOMPONENTS: 
-
-The Apache HTTP Server includes a number of subcomponents with
-separate copyright notices and license terms. Your use of the source
-code for the these subcomponents is subject to the terms and
-conditions of the following licenses. 
-
-For the mod_mime_magic component:
-
-/*
- * mod_mime_magic: MIME type lookup via file magic numbers
- * Copyright (c) 1996-1997 Cisco Systems, Inc.
- *
- * This software was submitted by Cisco Systems to the Apache Group in July
- * 1997.  Future revisions and derivatives of this source code must
- * acknowledge Cisco Systems as the original contributor of this module.
- * All other licensing and usage conditions are those of the Apache Group.
- *
- * Some of this code is derived from the free version of the file command
- * originally posted to comp.sources.unix.  Copyright info for that program
- * is included below as required.
- * ---------------------------------------------------------------------------
- * - Copyright (c) Ian F. Darwin, 1987. Written by Ian F. Darwin.
- *
- * This software is not subject to any license of the American Telephone and
- * Telegraph Company or of the Regents of the University of California.
- *
- * Permission is granted to anyone to use this software for any purpose on any
- * computer system, and to alter it and redistribute it freely, subject to
- * the following restrictions:
- *
- * 1. The author is not responsible for the consequences of use of this
- * software, no matter how awful, even if they arise from flaws in it.
- *
- * 2. The origin of this software must not be misrepresented, either by
- * explicit claim or by omission.  Since few users ever read sources, credits
- * must appear in the documentation.
- *
- * 3. Altered versions must be plainly marked as such, and must not be
- * misrepresented as being the original software.  Since few users ever read
- * sources, credits must appear in the documentation.
- *
- * 4. This notice may not be removed or altered.
- * -------------------------------------------------------------------------
- *
- */
-
-
-For the  modules\mappers\mod_imagemap.c component:
-
-  "macmartinized" polygon code copyright 1992 by Eric Haines, erich@eye.com
-
-For the  server\util_md5.c component:
-
-/************************************************************************
- * NCSA HTTPd Server
- * Software Development Group
- * National Center for Supercomputing Applications
- * University of Illinois at Urbana-Champaign
- * 605 E. Springfield, Champaign, IL 61820
- * httpd@ncsa.uiuc.edu
- *
- * Copyright  (C)  1995, Board of Trustees of the University of Illinois
- *
- ************************************************************************
- *
- * md5.c: NCSA HTTPd code which uses the md5c.c RSA Code
- *
- *  Original Code Copyright (C) 1994, Jeff Hostetler, Spyglass, Inc.
- *  Portions of Content-MD5 code Copyright (C) 1993, 1994 by Carnegie Mellon
- *     University (see Copyright below).
- *  Portions of Content-MD5 code Copyright (C) 1991 Bell Communications 
- *     Research, Inc. (Bellcore) (see Copyright below).
- *  Portions extracted from mpack, John G. Myers - jgm+@cmu.edu
- *  Content-MD5 Code contributed by Martin Hamilton (martin@net.lut.ac.uk)
- *
- */
-
-
-/* these portions extracted from mpack, John G. Myers - jgm+@cmu.edu */
-/* (C) Copyright 1993,1994 by Carnegie Mellon University
- * All Rights Reserved.
- *
- * Permission to use, copy, modify, distribute, and sell this software
- * and its documentation for any purpose is hereby granted without
- * fee, provided that the above copyright notice appear in all copies
- * and that both that copyright notice and this permission notice
- * appear in supporting documentation, and that the name of Carnegie
- * Mellon University not be used in advertising or publicity
- * pertaining to distribution of the software without specific,
- * written prior permission.  Carnegie Mellon University makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
- * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
- * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
- * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
- * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
- * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- */
-
-/*
- * Copyright (c) 1991 Bell Communications Research, Inc. (Bellcore)
- *
- * Permission to use, copy, modify, and distribute this material
- * for any purpose and without fee is hereby granted, provided
- * that the above copyright notice and this permission notice
- * appear in all copies, and that the name of Bellcore not be
- * used in advertising or publicity pertaining to this
- * material without the specific, prior written permission
- * of an authorized representative of Bellcore.  BELLCORE
- * MAKES NO REPRESENTATIONS ABOUT THE ACCURACY OR SUITABILITY
- * OF THIS MATERIAL FOR ANY PURPOSE.  IT IS PROVIDED "AS IS",
- * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.  
- */
-
-
-For the util_pcre.c and ap_regex.h components:
-
-           Copyright (c) 1997-2004 University of Cambridge
-
------------------------------------------------------------------------------
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-
-    * Neither the name of the University of Cambridge nor the names of its
-      contributors may be used to endorse or promote products derived from
-      this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
------------------------------------------------------------------------------
-
-
-For the  srclib\apr\include\apr_md5.h component: 
-/*
- * This is work is derived from material Copyright RSA Data Security, Inc.
- *
- * The RSA copyright statement and Licence for that original material is
- * included below. This is followed by the Apache copyright statement and
- * licence for the modifications made to that material.
- */
-
-/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
-   rights reserved.
-
-   License to copy and use this software is granted provided that it
-   is identified as the "RSA Data Security, Inc. MD5 Message-Digest
-   Algorithm" in all material mentioning or referencing this software
-   or this function.
-
-   License is also granted to make and use derivative works provided
-   that such works are identified as "derived from the RSA Data
-   Security, Inc. MD5 Message-Digest Algorithm" in all material
-   mentioning or referencing the derived work.
-
-   RSA Data Security, Inc. makes no representations concerning either
-   the merchantability of this software or the suitability of this
-   software for any particular purpose. It is provided "as is"
-   without express or implied warranty of any kind.
-
-   These notices must be retained in any copies of any part of this
-   documentation and/or software.
- */
-
-For the  srclib\apr\passwd\apr_md5.c component:
-
-/*
- * This is work is derived from material Copyright RSA Data Security, Inc.
- *
- * The RSA copyright statement and Licence for that original material is
- * included below. This is followed by the Apache copyright statement and
- * licence for the modifications made to that material.
- */
-
-/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
- */
-
-/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
-   rights reserved.
-
-   License to copy and use this software is granted provided that it
-   is identified as the "RSA Data Security, Inc. MD5 Message-Digest
-   Algorithm" in all material mentioning or referencing this software
-   or this function.
-
-   License is also granted to make and use derivative works provided
-   that such works are identified as "derived from the RSA Data
-   Security, Inc. MD5 Message-Digest Algorithm" in all material
-   mentioning or referencing the derived work.
-
-   RSA Data Security, Inc. makes no representations concerning either
-   the merchantability of this software or the suitability of this
-   software for any particular purpose. It is provided "as is"
-   without express or implied warranty of any kind.
-
-   These notices must be retained in any copies of any part of this
-   documentation and/or software.
- */
-/*
- * The apr_md5_encode() routine uses much code obtained from the FreeBSD 3.0
- * MD5 crypt() function, which is licenced as follows:
- * ----------------------------------------------------------------------------
- * "THE BEER-WARE LICENSE" (Revision 42):
- * <phk@login.dknet.dk> wrote this file.  As long as you retain this notice you
- * can do whatever you want with this stuff. If we meet some day, and you think
- * this stuff is worth it, you can buy me a beer in return.  Poul-Henning Kamp
- * ----------------------------------------------------------------------------
- */
-
-For the srclib\apr-util\crypto\apr_md4.c component:
-
- * This is derived from material copyright RSA Data Security, Inc.
- * Their notice is reproduced below in its entirety.
- *
- * Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
- * rights reserved.
- *
- * License to copy and use this software is granted provided that it
- * is identified as the "RSA Data Security, Inc. MD4 Message-Digest
- * Algorithm" in all material mentioning or referencing this software
- * or this function.
- *
- * License is also granted to make and use derivative works provided
- * that such works are identified as "derived from the RSA Data
- * Security, Inc. MD4 Message-Digest Algorithm" in all material
- * mentioning or referencing the derived work.
- *
- * RSA Data Security, Inc. makes no representations concerning either
- * the merchantability of this software or the suitability of this
- * software for any particular purpose. It is provided "as is"
- * without express or implied warranty of any kind.
- *
- * These notices must be retained in any copies of any part of this
- * documentation and/or software.
- */
-
-For the srclib\apr-util\include\apr_md4.h component:
-
- *
- * This is derived from material copyright RSA Data Security, Inc.
- * Their notice is reproduced below in its entirety.
- *
- * Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
- * rights reserved.
- *
- * License to copy and use this software is granted provided that it
- * is identified as the "RSA Data Security, Inc. MD4 Message-Digest
- * Algorithm" in all material mentioning or referencing this software
- * or this function.
- *
- * License is also granted to make and use derivative works provided
- * that such works are identified as "derived from the RSA Data
- * Security, Inc. MD4 Message-Digest Algorithm" in all material
- * mentioning or referencing the derived work.
- *
- * RSA Data Security, Inc. makes no representations concerning either
- * the merchantability of this software or the suitability of this
- * software for any particular purpose. It is provided "as is"
- * without express or implied warranty of any kind.
- *
- * These notices must be retained in any copies of any part of this
- * documentation and/or software.
- */
-
-
-For the srclib\apr-util\test\testmd4.c component:
-
- *
- * This is derived from material copyright RSA Data Security, Inc.
- * Their notice is reproduced below in its entirety.
- *
- * Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
- * rights reserved.
- *
- * RSA Data Security, Inc. makes no representations concerning either
- * the merchantability of this software or the suitability of this
- * software for any particular purpose. It is provided "as is"
- * without express or implied warranty of any kind.
- *
- * These notices must be retained in any copies of any part of this
- * documentation and/or software.
- */
-
-For the test\zb.c component:
-
-/*                          ZeusBench V1.01
-			    ===============
-
-This program is Copyright (C) Zeus Technology Limited 1996.
-
-This program may be used and copied freely providing this copyright notice
-is not removed.
-
-This software is provided "as is" and any express or implied waranties, 
-including but not limited to, the implied warranties of merchantability and
-fitness for a particular purpose are disclaimed.  In no event shall 
-Zeus Technology Ltd. be liable for any direct, indirect, incidental, special, 
-exemplary, or consequential damaged (including, but not limited to, 
-procurement of substitute good or services; loss of use, data, or profits;
-or business interruption) however caused and on theory of liability.  Whether
-in contract, strict liability or tort (including negligence or otherwise) 
-arising in any way out of the use of this software, even if advised of the
-possibility of such damage.
-
-     Written by Adam Twiss (adam@zeus.co.uk).  March 1996
-
-Thanks to the following people for their input:
-  Mike Belshe (mbelshe@netscape.com) 
-  Michael Campanella (campanella@stevms.enet.dec.com)
-
-*/
-
-
-For the pcre.dll component:
-
-PCRE LICENCE
-------------
-
-PCRE is a library of functions to support regular expressions whose syntax
-and semantics are as close as possible to those of the Perl 5 language.
-
-Release 8 of PCRE is distributed under the terms of the "BSD" licence, as
-specified below. The documentation for PCRE, supplied in the "doc"
-directory, is distributed under the same terms as the software itself. The data
-in the testdata directory is not copyrighted and is in the public domain.
-
-The basic library functions are written in C and are freestanding. Also
-included in the distribution is a set of C++ wrapper functions, and a
-just-in-time compiler that can be used to optimize pattern matching. These
-are both optional features that can be omitted when the library is built.
-
-
-THE BASIC LIBRARY FUNCTIONS
----------------------------
-
-Written by:       Philip Hazel
-Email local part: ph10
-Email domain:     cam.ac.uk
-
-University of Cambridge Computing Service,
-Cambridge, England.
-
-Copyright (c) 1997-2018 University of Cambridge
-All rights reserved.
-
-
-PCRE JUST-IN-TIME COMPILATION SUPPORT
--------------------------------------
-
-Written by:       Zoltan Herczeg
-Email local part: hzmester
-Emain domain:     freemail.hu
-
-Copyright(c) 2010-2018 Zoltan Herczeg
-All rights reserved.
-
-
-STACK-LESS JUST-IN-TIME COMPILER
---------------------------------
-
-Written by:       Zoltan Herczeg
-Email local part: hzmester
-Emain domain:     freemail.hu
-
-Copyright(c) 2009-2018 Zoltan Herczeg
-All rights reserved.
-
-
-THE C++ WRAPPER FUNCTIONS
--------------------------
-
-Contributed by:   Google Inc.
-
-Copyright (c) 2007-2012, Google Inc.
-All rights reserved.
-
-
-THE "BSD" LICENCE
------------------
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-
-    * Neither the name of the University of Cambridge nor the name of Google
-      Inc. nor the names of their contributors may be used to endorse or
-      promote products derived from this software without specific prior
-      written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
-END OF PCRE LICENSE
-
-For the libeay32.dll, ssleay32.dll and openssl.exe components:
-
-
-  LICENSE ISSUES
-  ==============
-
-  The OpenSSL toolkit stays under a double license, i.e. both the conditions of
-  the OpenSSL License and the original SSLeay license apply to the toolkit.
-  See below for the actual license texts. Actually both licenses are BSD-style
-  Open Source licenses. In case of any license issues related to OpenSSL
-  please contact openssl-core@openssl.org.
-
-  OpenSSL License
-  ---------------
-
-/* ====================================================================
- * Copyright (c) 1998-2018 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    openssl-core@openssl.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (eay@cryptsoft.com).  This product includes software written by Tim
- * Hudson (tjh@cryptsoft.com).
- *
- */
-
- Original SSLeay License
- -----------------------
-
-/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- * 
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * 
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-
-For the mod_deflate zlib compression component:
-
- (C) 1995-2018 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-For the mod_lua language component:
-
-Lua License
------------
-
-Lua is licensed under the terms of the MIT license reproduced below.
-This means that Lua is free software and can be used for both academic
-and commercial purposes at absolutely no cost.
-
-For details and rationale, see http://www.lua.org/license.html .
-
-===============================================================================
-
-Copyright (C) 1994-2012 Lua.org, PUC-Rio.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-===============================================================================
-
-
-For the mod_proxy_html and mod_xml2enc libxml2 C library components:
-
-Except where otherwise noted in the source code (e.g. the files hash.c,
-list.c and the trio files, which are covered by a similar licence but
-with different Copyright notices) all the files are:
-
- Copyright (C) 1998-2012 Daniel Veillard.  All Rights Reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is fur-
-nished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT-
-NESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-For the mod_http2 nghttp2 C library component:
-
-The MIT License
-
-Copyright (c) 2012-2018 Tatsuhiro Tsujikawa
-Copyright (c) 2012-2018 nghttp2 contributors
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-For the mod_brotli Brotli C library component:
-
-Copyright (c) 2009-2018 by the Brotli Authors.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-For the mod_md  Curl C library component:
-
-COPYRIGHT AND PERMISSION NOTICE
-
-Copyright (c) 1996 - 2018, Daniel Stenberg, <daniel@haxx.se>, and many
-contributors.
-
-All rights reserved.
-
-Permission to use, copy, modify, and distribute this software for any purpose
-with or without fee is hereby granted, provided that the above copyright
-notice and this permission notice appear in all copies.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
-NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of a copyright holder shall not
-be used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization of the copyright holder.
-
-For the mod_md Jansson C library component:
-
-Copyright (c) 2009-2018 Petri Lehtinen <petri@digip.org>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-
diff --git a/third_party/apache-win32/NOTICE.txt b/third_party/apache-win32/NOTICE.txt
deleted file mode 100644
index 1e9323171e6f2..0000000000000
--- a/third_party/apache-win32/NOTICE.txt
+++ /dev/null
@@ -1,60 +0,0 @@
-Apache HTTP Server
-Copyright 2018 The Apache Software Foundation.
-
-This product includes software developed at
-The Apache Software Foundation (http://www.apache.org/).
-
-Portions of this software were developed at the National Center
-for Supercomputing Applications (NCSA) at the University of
-Illinois at Urbana-Champaign.
-
-This software contains code derived from the RSA Data Security
-Inc. MD5 Message-Digest Algorithm, including various
-modifications by Spyglass Inc., Carnegie Mellon University, and
-Bell Communications Research, Inc (Bellcore).
-
-This software contains code derived from the PCRE library pcreposix.c
-source code, written by Philip Hazel, Copyright 1997-2004
-by the University of Cambridge, England.
-
-Regular expression support is provided by the PCRE library package,
-which is open source software, written by Philip Hazel, and copyright
-by the University of Cambridge, England. The original software is
-available from
-  ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/
-
-This binary distribution includes cryptographic software written by
-Eric Young (eay@cryptsoft.com), software written by Tim Hudson 
-(tjh@cryptsoft.com), and software developed by the OpenSSL Project 
-for use in the OpenSSL Toolkit <http://www.openssl.org/>.
-
-This binary distribution of mod_deflate.so includes zlib compression code
-<http://www.gzip.org/zlib/> written by Jean-loup Gailly (jloup@gzip.org)
-and Mark Adler (madler@alumni.caltech.edu) .
-
-This binary distribution of mod_lua.so includes the Lua language, 
-developed at Lua.org, a laboratory of the Department of Computer Science 
-of PUC-Rio (the Pontifical Catholic University of Rio de Janeiro in Brazil).
-For complete information, visit Lua's web site at http://www.lua.org/
-
-This binary distributions of mod_proxy_html.so and mod_xml2enc.so include the
-libxml2 C library written by Daniel Veillard (daniel veillard.com), Bjorn 
-Reese (breese users.sourceforge.net) and Gary Pennington (Gary.Pennington 
-uk.sun.com). For complete information, visit LibXML2's web site at 
-https://http://www.xmlsoft.org/
-
-This binary distribution of mod_http2.so includes nghttp2 C library written 
-by Tatsuhiro Tsujikawa. For complete information, visit nghttp2's web site 
-at https://nghttp2.org/
-
-This binary distribution of mod_brotli.so includes Brotli C library written 
-by the Brotli Authors. For complete information, visit Brotli's web site 
-at https://github.com/google/brotli
-
-This binary distribution of mod_md.so includes Curl C library written by 
-Daniel Stenberg and many contributors. For complete information, 
-visit curl's web site at https://curl.haxx.se/
-
-This binary distribution of mod_md.so includes Jansson C library written 
-by the  Petri Lehtinen. For complete information, visit Jansson's web site 
-at http://www.digip.org/jansson/
diff --git a/third_party/apache-win32/OPENSSL-README.txt b/third_party/apache-win32/OPENSSL-README.txt
deleted file mode 100644
index 298b2fa3e98a9..0000000000000
--- a/third_party/apache-win32/OPENSSL-README.txt
+++ /dev/null
@@ -1,127 +0,0 @@
-
- Apache HTTP Server 2.4 Limited OpenSSL Distribution
-
- This binary installation of OpenSSL is a limited distribution of the
- files derived from the OpenSSL project:
-
-   LICENSE.txt (includes openssl LICENSE)
-   OPENSSL-NEWS.txt
-   OPENSSL-README.txt
-   conf\openssl.cnf
-   bin\libeay32.dll
-   bin\ssleay32.dll
-   bin\openssl.exe
-
- These are the minimal libraries and tools required to use mod_ssl as 
- distributed with Apache HTTP Server version 2.4.  No library link files, 
- headers or sources are distributed with this binary distribution.  Please 
- refer to the <http://www.openssl.org/> site for complete source or binary 
- distributions.
-
- These OpenSSL binaries were built for distribution from the U.S. without 
- support for the patented encryption methods IDEA, MDC-2 or RC5.
-
- The Apache HTTP Project only supports the binary distribution of these files
- and development of the mod_ssl module.  We cannot provide support assistance
- for using or configuring the OpenSSL package or these modules.  Please refer
- all installation and configuration questions to the appropriate forum,
- such as the user supported lists, <http://httpd.apache.org/userslist.html> 
- the Apache HTTP Server user's list or <http://www.openssl.org/support/> the
- OpenSSL support page.
-
---------------------------------------------------------------------------------
-
-
- OpenSSL 1.1.1 11 Sep 2018
-
- Copyright (c) 1998-2018 The OpenSSL Project
- Copyright (c) 1995-1998 Eric A. Young, Tim J. Hudson
- All rights reserved.
-
- DESCRIPTION
- -----------
-
- The OpenSSL Project is a collaborative effort to develop a robust,
- commercial-grade, fully featured, and Open Source toolkit implementing the
- Transport Layer Security (TLS) protocols (including SSLv3) as well as a
- full-strength general purpose cryptographic library.
-
- OpenSSL is descended from the SSLeay library developed by Eric A. Young
- and Tim J. Hudson.  The OpenSSL toolkit is licensed under a dual-license (the
- OpenSSL license plus the SSLeay license), which means that you are free to
- get and use it for commercial and non-commercial purposes as long as you
- fulfill the conditions of both licenses.
-
- OVERVIEW
- --------
-
- The OpenSSL toolkit includes:
-
- libssl (with platform specific naming):
-     Provides the client and server-side implementations for SSLv3 and TLS.
-
- libcrypto (with platform specific naming):
-     Provides general cryptographic and X.509 support needed by SSL/TLS but
-     not logically part of it.
-
- openssl:
-     A command line tool that can be used for:
-        Creation of key parameters
-        Creation of X.509 certificates, CSRs and CRLs
-        Calculation of message digests
-        Encryption and decryption
-        SSL/TLS client and server tests
-        Handling of S/MIME signed or encrypted mail
-        And more...
-
- INSTALLATION
- ------------
-
- See the appropriate file:
-        INSTALL         Linux, Unix, Windows, OpenVMS, ...
-        NOTES.*         INSTALL addendums for different platforms
-
- SUPPORT
- -------
-
- See the OpenSSL website www.openssl.org for details on how to obtain
- commercial technical support. Free community support is available through the
- openssl-users email list (see
- https://www.openssl.org/community/mailinglists.html for further details).
-
- If you have any problems with OpenSSL then please take the following steps
- first:
-
-    - Download the latest version from the repository
-      to see if the problem has already been addressed
-    - Configure with no-asm
-    - Remove compiler optimization flags
-
- If you wish to report a bug then please include the following information
- and create an issue on GitHub:
-
-    - OpenSSL version: output of 'openssl version -a'
-    - Configuration data: output of 'perl configdata.pm --dump'
-    - OS Name, Version, Hardware platform
-    - Compiler Details (name, version)
-    - Application Details (name, version)
-    - Problem Description (steps that will reproduce the problem, if known)
-    - Stack Traceback (if the application dumps core)
-
- Just because something doesn't work the way you expect does not mean it
- is necessarily a bug in OpenSSL. Use the openssl-users email list for this type
- of query.
-
- HOW TO CONTRIBUTE TO OpenSSL
- ----------------------------
-
- See CONTRIBUTING
-
- LEGALITIES
- ----------
-
- A number of nations restrict the use or export of cryptography. If you
- are potentially subject to such restrictions you should seek competent
- professional legal advice before attempting to develop or distribute
- cryptographic code.
-
\ No newline at end of file
diff --git a/third_party/apache-win32/README.txt b/third_party/apache-win32/README.txt
deleted file mode 100644
index 603374420f021..0000000000000
--- a/third_party/apache-win32/README.txt
+++ /dev/null
@@ -1,110 +0,0 @@
-
-                          Apache HTTP Server
-
-  What is it?
-  -----------
-
-  The Apache HTTP Server is a powerful and flexible HTTP/1.1 compliant
-  web server.  Originally designed as a replacement for the NCSA HTTP
-  Server, it has grown to be the most popular web server on the
-  Internet.  As a project of the Apache Software Foundation, the
-  developers aim to collaboratively develop and maintain a robust,
-  commercial-grade, standards-based server with freely available
-  source code.
-
-  The Latest Version
-  ------------------
-
-  Details of the latest version can be found on the Apache HTTP
-  server project page under http://httpd.apache.org/.
-
-  Documentation
-  -------------
-
-  The documentation available as of the date of this release is
-  included in HTML format in the docs/manual/ directory.  The most
-  up-to-date documentation can be found at
-  http://httpd.apache.org/docs/2.4/.
-
-  Installation
-  ------------
-
-  Please see the file called INSTALL.  Platform specific notes can be
-  found in README.platforms.
-
-  Licensing
-  ---------
-
-  Please see the file called LICENSE.
-
-  Cryptographic Software Notice
-  -----------------------------
-
-  This distribution may include software that has been designed for use
-  with cryptographic software.  The country in which you currently reside
-  may have restrictions on the import, possession, use, and/or re-export
-  to another country, of encryption software.  BEFORE using any encryption
-  software, please check your country's laws, regulations and policies
-  concerning the import, possession, or use, and re-export of encryption
-  software, to see if this is permitted.  See <http://www.wassenaar.org/>
-  for more information.
-
-  The U.S. Government Department of Commerce, Bureau of Industry and
-  Security (BIS), has classified this software as Export Commodity 
-  Control Number (ECCN) 5D002.C.1, which includes information security
-  software using or performing cryptographic functions with asymmetric
-  algorithms.  The form and manner of this Apache Software Foundation
-  distribution makes it eligible for export under the License Exception
-  ENC Technology Software Unrestricted (TSU) exception (see the BIS 
-  Export Administration Regulations, Section 740.13) for both object 
-  code and source code.
-
-  The following provides more details on the included files that
-  may be subject to export controls on cryptographic software:
-
-    Apache httpd 2.0 and later versions include the mod_ssl module under
-       modules/ssl/
-    for configuring and listening to connections over SSL encrypted
-    network sockets by performing calls to a general-purpose encryption
-    library, such as OpenSSL or the operating system's platform-specific
-    SSL facilities.
-
-    In addition, some versions of apr-util provide an abstract interface
-    for symmetrical cryptographic functions that make use of a
-    general-purpose encryption library, such as OpenSSL, NSS, or the
-    operating system's platform-specific facilities. This interface is
-    known as the apr_crypto interface, with implementation beneath the
-    /crypto directory. The apr_crypto interface is used by the
-    mod_session_crypto module available under
-      modules/session
-    for optional encryption of session information.
-
-    Some object code distributions of Apache httpd, indicated with the
-    word "crypto" in the package name, may include object code for the
-    OpenSSL encryption library as distributed in open source form from
-    <http://www.openssl.org/source/>.
-
-  The above files are optional and may be removed if the cryptographic
-  functionality is not desired or needs to be excluded from redistribution.
-  Distribution packages of Apache httpd that include the word "nossl"
-  in the package name have been created without the above files and are
-  therefore not subject to this notice.
-
-  Contacts
-  --------
-
-     o If you want to be informed about new code releases, bug fixes,
-       security fixes, general news and information about the Apache server
-       subscribe to the apache-announce mailing list as described under
-       <http://httpd.apache.org/lists.html#http-announce>
-
-     o If you want freely available support for running Apache please see the
-       resources at <http://httpd.apache.org/support.html>
-
-     o If you have a concrete bug report for Apache please see the instructions
-       for bug reporting at <http://httpd.apache.org/bug_report.html>
-
-     o If you want to participate in actively developing Apache please
-       subscribe to the `dev@httpd.apache.org' mailing list as described at
-       <http://httpd.apache.org/lists.html#http-dev>
-
diff --git a/third_party/apache-win32/readme-redist-bins.txt b/third_party/apache-win32/readme-redist-bins.txt
deleted file mode 100644
index 0f0bc5d0b6068..0000000000000
--- a/third_party/apache-win32/readme-redist-bins.txt
+++ /dev/null
@@ -1,416 +0,0 @@
-1. libmagic (ext/fileinfo) see ext/fileinfo/libmagic/LICENSE
-2. Oniguruma (ext/mbstring) see ext/mbstring/oniguruma/COPYING
-3. libmbfl (ext/mbstring) see ext/mbstring/libmbfl/LICENSE
-4. pcrelib (ext/pcre) see ext/pcre/pcrelib/LICENCE
-5. ext/standard crypt
-6. ext/standard crypt's blowfish implementation
-7. Sqlite/Sqlite3 ext/sqlite3 ext/sqlite
-8. ext/standard/rand
-9. ext/standard/scanf
-10. ext/standard/strnatcmp.c
-11. ext/standard/uuencode
-12. libxmlrpc ext/xmlrpc
-13. libzip ext/zip
-14. main/snprintf.c
-15. main/strlcat
-16. main/strlcpy
-17. libgd see ext/gd/libgd/COPYING
-
-5. ext/standard crypt
-
-FreeSec: libcrypt for NetBSD
-
-Copyright (c) 1994 David Burren
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-	 notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-	 notice, this list of conditions and the following disclaimer in the
-	 documentation and/or other materials provided with the distribution.
-3. Neither the name of the author nor the names of other contributors
-	 may be used to endorse or promote products derived from this software
-	 without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGE.
-
-
-6. ext/standard crypt's blowfish implementation
-
-The crypt_blowfish homepage is:
-
-http://www.openwall.com/crypt/
-
-This code comes from John the Ripper password cracker, with reentrant
-and crypt(3) interfaces added, but optimizations specific to password
-cracking removed.
-
-Written by Solar Designer <solar at openwall.com> in 1998-2011.
-No copyright is claimed, and the software is hereby placed in the public
-domain. In case this attempt to disclaim copyright and place the software
-in the public domain is deemed null and void, then the software is
-Copyright (c) 1998-2011 Solar Designer and it is hereby released to the
-general public under the following terms:
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted.
-
-There's ABSOLUTELY NO WARRANTY, express or implied.
-
-It is my intent that you should be able to use this on your system,
-as part of a software package, or anywhere else to improve security,
-ensure compatibility, or for any other purpose. I would appreciate
-it if you give credit where it is due and keep your modifications in
-the public domain as well, but I don't require that in order to let
-you place this code and any modifications you make under a license
-of your choice.
-
-This implementation is mostly compatible with OpenBSD's bcrypt.c (prefix
-"$2a$") by Niels Provos <provos at citi.umich.edu>, and uses some of his
-ideas. The password hashing algorithm was designed by David Mazieres
-<dm at lcs.mit.edu>. For more information on the level of compatibility,
-please refer to the comments in BF_set_key() and to the crypt(3) man page
-included in the crypt_blowfish tarball.
-
-There's a paper on the algorithm that explains its design decisions:
-
-http://www.usenix.org/events/usenix99/provos.html
-
-Some of the tricks in BF_ROUND might be inspired by Eric Young's
-Blowfish library (I can't be sure if I would think of something if I
-hadn't seen his code).
-
-
-7. Sqlite/Sqlite3 ext/sqlite3 ext/sqlite
-
-The author disclaims copyright to this source code.  In place of
-a legal notice, here is a blessing:
-  May you do good and not evil.
-  May you find forgiveness for yourself and forgive others.
-  May you share freely, never taking more than you give.
-
-
-8. ext/standard/rand
-The following php_mt_...() functions are based on a C++ class MTRand by
-Richard J. Wagner. For more information see the web page at
-http://www-personal.engin.umich.edu/~wagnerr/MersenneTwister.html
-
-Mersenne Twister random number generator -- a C++ class MTRand
-Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
-Richard J. Wagner  v1.0  15 May 2003  rjwagner@writeme.com
-
-The Mersenne Twister is an algorithm for generating random numbers.  It
-was designed with consideration of the flaws in various other generators.
-The period, 2^19937-1, and the order of equidistribution, 623 dimensions,
-are far greater.  The generator is also fast; it avoids multiplication and
-division, and it benefits from caches and pipelines.  For more information
-see the inventors' web page at http://www.math.keio.ac.jp/~matumoto/emt.html
-
-Reference
-M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-Dimensionally
-Equidistributed Uniform Pseudo-Random Number Generator", ACM Transactions on
-Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.
-
-Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
-Copyright (C) 2000 - 2003, Richard J. Wagner
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-1. Redistributions of source code must retain the above copyright
-	 notice, this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright
-	 notice, this list of conditions and the following disclaimer in the
-	 documentation and/or other materials provided with the distribution.
-
-3. The names of its contributors may not be used to endorse or promote
-	 products derived from this software without specific prior written
-	 permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-9. ext/standard/scanf
-scanf.c --
-
-This file contains the base code which implements sscanf and by extension
-fscanf. Original code is from TCL8.3.0 and bears the following copyright:
-
-This software is copyrighted by the Regents of the University of
-California, Sun Microsystems, Inc., Scriptics Corporation,
-and other parties.  The following terms apply to all files associated
-with the software unless explicitly disclaimed in individual files.
-
-The authors hereby grant permission to use, copy, modify, distribute,
-and license this software and its documentation for any purpose, provided
-that existing copyright notices are retained in all copies and that this
-notice is included verbatim in any distributions. No written agreement,
-license, or royalty fee is required for any of the authorized uses.
-Modifications to this software may be copyrighted by their authors
-and need not follow the licensing terms described here, provided that
-the new terms are clearly indicated on the first page of each file where
-they apply.
-
-IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
-FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
-ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
-DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
-THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
-IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
-NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
-MODIFICATIONS.
-
-GOVERNMENT USE: If you are acquiring this software on behalf of the
-U.S. government, the Government shall have only "Restricted Rights"
-in the software and related documentation as defined in the Federal
-Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
-are acquiring the software on behalf of the Department of Defense, the
-software shall be classified as "Commercial Computer Software" and the
-Government shall have only "Restricted Rights" as defined in Clause
-252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing, the
-authors grant the U.S. Government and others acting in its behalf
-permission to use and distribute the software in accordance with the
-terms specified in this license.
-
-10. ext/standard/strnatcmp.c
-
-strnatcmp.c -- Perform 'natural order' comparisons of strings in C.
-Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
-
-This software is provided 'as-is', without any express or implied
-warranty.  In no event will the authors be held liable for any damages
-arising from the use of this software.
-
-Permission is granted to anyone to use this software for any purpose,
-including commercial applications, and to alter it and redistribute it
-freely, subject to the following restrictions:
-
-1. The origin of this software must not be misrepresented; you must not
-	 claim that you wrote the original software. If you use this software
-	 in a product, an acknowledgment in the product documentation would be
-	 appreciated but is not required.
-2. Altered source versions must be plainly marked as such, and must not be
-	 misrepresented as being the original software.
-3. This notice may not be removed or altered from any source distribution.
-
-11. ext/standard/uuencode
-Portions of this code are based on Berkeley's uuencode/uudecode
-implementation.
-
-Copyright (c) 1983, 1993
-The Regents of the University of California.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-3. All advertising materials mentioning features or use of this software
-	must display the following acknowledgement:
-This product includes software developed by the University of
-California, Berkeley and its contributors.
-4. Neither the name of the University nor the names of its contributors
-	may be used to endorse or promote products derived from this software
-	without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGE.
-
-
-12. libxmlrpc ext/xmlrpc
-
-Copyright 2000 Epinions, Inc.
-
-Subject to the following 3 conditions, Epinions, Inc.  permits you, free
-of charge, to (a) use, copy, distribute, modify, perform and display this
-software and associated documentation files (the "Software"), and (b)
-permit others to whom the Software is furnished to do so as well.
-
-1) The above copyright notice and this permission notice shall be included
-without modification in all copies or substantial portions of the
-Software.
-
-2) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT ANY WARRANTY OR CONDITION OF
-ANY KIND, EXPRESS, IMPLIED OR STATUTORY, INCLUDING WITHOUT LIMITATION ANY
-IMPLIED WARRANTIES OF ACCURACY, MERCHANTABILITY, FITNESS FOR A PARTICULAR
-PURPOSE OR NONINFRINGEMENT.
-
-3) IN NO EVENT SHALL EPINIONS, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,
-SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT
-OF OR IN CONNECTION WITH THE SOFTWARE (HOWEVER ARISING, INCLUDING
-NEGLIGENCE), EVEN IF EPINIONS, INC.  IS AWARE OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-13. libzip ext/zip
-zip.h -- exported declarations.
-Copyright (C) 1999-2009 Dieter Baron and Thomas Klausner
-
-This file is part of libzip, a library to manipulate ZIP archives.
-The authors can be contacted at <libzip@nih.at>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-	 notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-	 notice, this list of conditions and the following disclaimer in
-	 the documentation and/or other materials provided with the
-	 distribution.
-3. The names of the authors may not be used to endorse or promote
-	 products derived from this software without specific prior
-	 written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
-OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
-GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
-IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-14. main/snprintf.c
-Copyright (c) 2002, 2006 Todd C. Miller <Todd.Miller@courtesan.com>
-
-Permission to use, copy, modify, and distribute this software for any
-purpose with or without fee is hereby granted, provided that the above
-copyright notice and this permission notice appear in all copies.
-
-THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-
-Sponsored in part by the Defense Advanced Research Projects
-Agency (DARPA) and Air Force Research Laboratory, Air Force
-Materiel Command, USAF, under agreement number F39502-99-1-0512.
-
-main/spprintf
-Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-1. Redistributions of source code must retain the above copyright
-	 notice, this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright
-	 notice, this list of conditions and the following disclaimer in
-	 the documentation and/or other materials provided with the
-	 distribution.
-
-3. All advertising materials mentioning features or use of this
-	 software must display the following acknowledgment:
-	 "This product includes software developed by the Apache Group
-	 for use in the Apache HTTP server project (http://www.apache.org/)."
-
-4. The names "Apache Server" and "Apache Group" must not be used to
-	 endorse or promote products derived from this software without
-	 prior written permission.
-
-5. Redistributions of any form whatsoever must retain the following
-	 acknowledgment:
-	 "This product includes software developed by the Apache Group
-	 for use in the Apache HTTP server project (http://www.apache.org/)."
-
-THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
-EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
-ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
-OF THE POSSIBILITY OF SUCH DAMAGE.
-====================================================================
-
-This software consists of voluntary contributions made by many
-individuals on behalf of the Apache Group and was originally based
-on public domain software written at the National Center for
-Supercomputing Applications, University of Illinois, Urbana-Champaign.
-For more information on the Apache Group and the Apache HTTP server
-project, please see <http://www.apache.org/>.
-
-This code is based on, and used with the permission of, the
-SIO stdio-replacement strx_* functions by Panos Tsirigotis
-<panos@alumni.cs.colorado.edu> for xinetd.
-
-15. main/strlcat
-16. main/strlcpy
-Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
-THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/third_party/ashmem/patches/0001-Add-ashmem-get-prot-region.patch b/third_party/ashmem/patches/0001-Add-ashmem-get-prot-region.patch
new file mode 100644
index 0000000000000..5bba42dce2db2
--- /dev/null
+++ b/third_party/ashmem/patches/0001-Add-ashmem-get-prot-region.patch
@@ -0,0 +1,28 @@
+diff --git a/third_party/ashmem/ashmem-dev.c b/third_party/ashmem/ashmem-dev.c
+index 2303369d8167..52b3f47eeae0 100644
+--- a/third_party/ashmem/ashmem-dev.c
++++ b/third_party/ashmem/ashmem-dev.c
+@@ -72,6 +72,11 @@ int ashmem_set_prot_region(int fd, int prot)
+ 	return ioctl(fd, ASHMEM_SET_PROT_MASK, prot);
+ }
+ 
++int ashmem_get_prot_region(int fd)
++{
++	return ioctl(fd, ASHMEM_GET_PROT_MASK);
++}
++
+ int ashmem_pin_region(int fd, size_t offset, size_t len)
+ {
+ 	struct ashmem_pin pin = { offset, len };
+diff --git a/third_party/ashmem/ashmem.h b/third_party/ashmem/ashmem.h
+index 7d411cc064ba..d8afccbd2a6e 100644
+--- a/third_party/ashmem/ashmem.h
++++ b/third_party/ashmem/ashmem.h
+@@ -18,6 +18,7 @@ extern "C" {
+ 
+ int ashmem_create_region(const char *name, size_t size);
+ int ashmem_set_prot_region(int fd, int prot);
++int ashmem_get_prot_region(int fd);
+ int ashmem_pin_region(int fd, size_t offset, size_t len);
+ int ashmem_unpin_region(int fd, size_t offset, size_t len);
+ int ashmem_get_size_region(int fd);
diff --git a/third_party/ashmem/patches/0002-Use-ASharedMemory-functions-when-possible.patch b/third_party/ashmem/patches/0002-Use-ASharedMemory-functions-when-possible.patch
new file mode 100644
index 0000000000000..d9580659150a9
--- /dev/null
+++ b/third_party/ashmem/patches/0002-Use-ASharedMemory-functions-when-possible.patch
@@ -0,0 +1,332 @@
+diff --git a/third_party/ashmem/ashmem-dev.c b/third_party/ashmem/ashmem-dev.c
+index 52b3f47eeae0..25a33cdcd0c8 100644
+--- a/third_party/ashmem/ashmem-dev.c
++++ b/third_party/ashmem/ashmem-dev.c
+@@ -14,23 +14,115 @@
+  * limitations under the License.
+  */
+ 
+-/*
+- * Implementation of the user-space ashmem API for devices, which have our
+- * ashmem-enabled kernel. See ashmem-sim.c for the "fake" tmp-based version,
+- * used by the simulator.
+- */
++#include "ashmem.h"
+ 
++#include <dlfcn.h>
++#include <errno.h>
+ #include <unistd.h>
++#include <stdlib.h>
+ #include <string.h>
++#include <sys/mman.h>
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <sys/ioctl.h>
++#include <sys/stat.h>  /* for fdstat() */
+ #include <fcntl.h>
+ 
+ #include <linux/ashmem.h>
+-#include "ashmem.h"
++#include <sys/system_properties.h>
+ 
+-#define ASHMEM_DEVICE	"/dev/ashmem"
++#define ASHMEM_DEVICE  "/dev/ashmem"
++
++/* Technical note regarding reading system properties.
++ *
++ * Try to use the new __system_property_read_callback API that appeared in
++ * Android O / API level 26 when available. Otherwise use the deprecated
++ * __system_property_get function.
++ *
++ * For more technical details from an NDK maintainer, see:
++ * https://bugs.chromium.org/p/chromium/issues/detail?id=392191#c17
++ */
++
++/* Weak symbol import */
++void __system_property_read_callback(
++    const prop_info* info,
++    void (*callback)(
++        void* cookie, const char* name, const char* value, uint32_t serial),
++    void* cookie) __attribute__((weak));
++
++/* Callback used with __system_property_read_callback. */
++static void prop_read_int(void* cookie,
++                          const char* name,
++                          const char* value,
++                          uint32_t serial) {
++  *(int *)cookie = atoi(value);
++  (void)name;
++  (void)serial;
++}
++
++static int system_property_get_int(const char* name) {
++  int result = 0;
++  if (__system_property_read_callback) {
++    const prop_info* info = __system_property_find(name);
++    if (info)
++      __system_property_read_callback(info, &prop_read_int, &result);
++  } else {
++    char value[PROP_VALUE_MAX] = {};
++    if (__system_property_get(name, value) >= 1)
++      result = atoi(value);
++  }
++  return result;
++}
++
++static int device_api_level() {
++  static int s_api_level = -1;
++  if (s_api_level < 0)
++    s_api_level = system_property_get_int("ro.build.version.sdk");
++  return s_api_level;
++}
++
++typedef enum {
++  ASHMEM_STATUS_INIT,
++  ASHMEM_STATUS_NOT_SUPPORTED,
++  ASHMEM_STATUS_SUPPORTED,
++} AshmemStatus;
++
++static AshmemStatus s_ashmem_status = ASHMEM_STATUS_INIT;
++static dev_t s_ashmem_dev;
++
++/* Return the dev_t of a given file path, or 0 if not available, */
++static dev_t ashmem_find_dev(const char* path) {
++  struct stat st;
++  dev_t result = 0;
++  if (stat(path, &st) == 0 && S_ISCHR(st.st_mode))
++    result = st.st_dev;
++  return result;
++}
++
++static AshmemStatus ashmem_get_status(void) {
++  /* NOTE: No need to make this thread-safe, assuming that
++   * all threads will find the same value. */
++  if (s_ashmem_status != ASHMEM_STATUS_INIT)
++    return s_ashmem_status;
++
++  s_ashmem_dev = ashmem_find_dev(ASHMEM_DEVICE);
++  s_ashmem_status = (s_ashmem_dev == 0) ? ASHMEM_STATUS_NOT_SUPPORTED
++                                        : ASHMEM_STATUS_SUPPORTED;
++  return s_ashmem_status;
++}
++
++/* Returns true iff the ashmem device ioctl should be used for a given fd.
++ * NOTE: Try not to use fstat() when possible to avoid performance issues. */
++static int ashmem_dev_fd_check(int fd) {
++  if (device_api_level() <= __ANDROID_API_O_MR1__)
++    return 1;
++  if (ashmem_get_status() == ASHMEM_STATUS_SUPPORTED) {
++    struct stat st;
++    return (fstat(fd, &st) == 0 && S_ISCHR(st.st_mode) &&
++            st.st_dev != 0 && st.st_dev == s_ashmem_dev);
++  }
++  return 0;
++}
+ 
+ /*
+  * ashmem_create_region - creates a new ashmem region and returns the file
+@@ -39,67 +131,133 @@
+  * `name' is an optional label to give the region (visible in /proc/pid/maps)
+  * `size' is the size of the region, in page-aligned bytes
+  */
+-int ashmem_create_region(const char *name, size_t size)
+-{
+-	int fd, ret;
++static int ashmem_dev_create_region(const char *name, size_t size) {
++  int fd = open(ASHMEM_DEVICE, O_RDWR);
++  if (fd < 0)
++    return fd;
+ 
+-	fd = open(ASHMEM_DEVICE, O_RDWR);
+-	if (fd < 0)
+-		return fd;
++  int ret;
++  if (name) {
++    char buf[ASHMEM_NAME_LEN];
++    strlcpy(buf, name, sizeof(buf));
++    ret = ioctl(fd, ASHMEM_SET_NAME, buf);
++    if (ret < 0)
++      goto error;
++  }
++  ret = ioctl(fd, ASHMEM_SET_SIZE, size);
++  if (ret < 0)
++    goto error;
+ 
+-	if (name) {
+-		char buf[ASHMEM_NAME_LEN];
++  return fd;
+ 
+-		strlcpy(buf, name, sizeof(buf));
+-		ret = ioctl(fd, ASHMEM_SET_NAME, buf);
+-		if (ret < 0)
+-			goto error;
+-	}
++error:
++  close(fd);
++  return ret;
++}
+ 
+-	ret = ioctl(fd, ASHMEM_SET_SIZE, size);
+-	if (ret < 0)
+-		goto error;
++static int ashmem_dev_set_prot_region(int fd, int prot) {
++  return ioctl(fd, ASHMEM_SET_PROT_MASK, prot);
++}
+ 
+-	return fd;
++static int ashmem_dev_get_prot_region(int fd) {
++  return ioctl(fd, ASHMEM_GET_PROT_MASK);
++}
+ 
+-error:
+-	close(fd);
+-	return ret;
++static int ashmem_dev_pin_region(int fd, size_t offset, size_t len) {
++  struct ashmem_pin pin = { offset, len };
++  return ioctl(fd, ASHMEM_PIN, &pin);
+ }
+ 
+-int ashmem_set_prot_region(int fd, int prot)
+-{
+-	return ioctl(fd, ASHMEM_SET_PROT_MASK, prot);
++static int ashmem_dev_unpin_region(int fd, size_t offset, size_t len) {
++  struct ashmem_pin pin = { offset, len };
++  return ioctl(fd, ASHMEM_UNPIN, &pin);
+ }
+ 
+-int ashmem_get_prot_region(int fd)
+-{
+-	return ioctl(fd, ASHMEM_GET_PROT_MASK);
++static size_t ashmem_dev_get_size_region(int fd) {
++  return ioctl(fd, ASHMEM_GET_SIZE, NULL);
+ }
+ 
+-int ashmem_pin_region(int fd, size_t offset, size_t len)
+-{
+-	struct ashmem_pin pin = { offset, len };
+-	return ioctl(fd, ASHMEM_PIN, &pin);
++// Starting with API level 26, the following functions from
++// libandroid.so should be used to create shared memory regions.
++typedef int(*ASharedMemory_createFunc)(const char*, size_t);
++typedef size_t(*ASharedMemory_getSizeFunc)(int fd);
++typedef int(*ASharedMemory_setProtFunc)(int fd, int prot);
++
++// Function pointers to shared memory functions.
++typedef struct {
++  ASharedMemory_createFunc create;
++  ASharedMemory_getSizeFunc getSize;
++  ASharedMemory_setProtFunc setProt;
++} ASharedMemoryFuncs;
++
++const ASharedMemoryFuncs* ashmem_get_funcs() {
++  static ASharedMemoryFuncs s_ashmem_funcs = {};
++  ASharedMemoryFuncs* funcs = &s_ashmem_funcs;
++  if (funcs->create == NULL) {
++    if (device_api_level() >= __ANDROID_API_O__) {
++      /* Leaked intentionally! */
++      void* lib = dlopen("libandroid.so", RTLD_NOW);
++      funcs->create = (ASharedMemory_createFunc)
++          dlsym(lib, "ASharedMemory_create");
++      funcs->getSize = (ASharedMemory_getSizeFunc)
++          dlsym(lib, "ASharedMemory_getSize");
++      funcs->setProt = (ASharedMemory_setProtFunc)
++          dlsym(lib, "ASharedMemory_setProt");
++    } else {
++      funcs->create = &ashmem_dev_create_region;
++      funcs->getSize = &ashmem_dev_get_size_region;
++      funcs->setProt = &ashmem_dev_set_prot_region;
++    }
++  }
++  return funcs;
+ }
+ 
+-int ashmem_unpin_region(int fd, size_t offset, size_t len)
+-{
+-	struct ashmem_pin pin = { offset, len };
+-	return ioctl(fd, ASHMEM_UNPIN, &pin);
++int ashmem_create_region(const char* name, size_t size) {
++  return ashmem_get_funcs()->create(name, size);
+ }
+ 
+-int ashmem_get_size_region(int fd)
+-{
+-  return ioctl(fd, ASHMEM_GET_SIZE, NULL);
++int ashmem_set_prot_region(int fd, int prot) {
++  return ashmem_get_funcs()->setProt(fd, prot);
+ }
+ 
+-int ashmem_purge_all(void)
+-{
+-  const int fd = open(ASHMEM_DEVICE, O_RDWR);
+-  if (fd < 0)
+-    return fd;
+-  const int ret = ioctl(fd, ASHMEM_PURGE_ALL_CACHES, 0);
+-  close(fd);
+-  return ret;
++int ashmem_get_prot_region(int fd) {
++  if (ashmem_dev_fd_check(fd))
++    return ashmem_dev_get_prot_region(fd);
++  /* There are only two practical values to return here: either
++   * PROT_READ|PROT_WRITE or just PROT_READ, so try to determine
++   * the flags by trying to mmap() the region read-write first.
++   */
++  int result = PROT_READ;
++  const size_t page_size = (size_t)sysconf(_SC_PAGESIZE);
++  void* m = mmap(NULL, page_size, PROT_READ|PROT_WRITE,
++                 MAP_PRIVATE, fd, 0);
++  if (m != MAP_FAILED) {
++    munmap(m, page_size);
++    result = PROT_READ|PROT_WRITE;
++  }
++  return result;
++}
++
++int ashmem_pin_region(int fd, size_t offset, size_t len) {
++ if (ashmem_dev_fd_check(fd))
++   return ashmem_dev_pin_region(fd, offset, len);
++  return ASHMEM_NOT_PURGED;
++}
++
++int ashmem_unpin_region(int fd, size_t offset, size_t len) {
++  if (ashmem_dev_fd_check(fd))
++    return ashmem_dev_unpin_region(fd, offset, len);
++  /* NOTE: It is not possible to use madvise() here because it requires a
++   * memory address. This could be done in the caller though, instead of
++   * this function. */
++  return 0;
++}
++
++int ashmem_get_size_region(int fd) {
++  /* NOTE: Original API returns an int. Avoid breaking it. */
++  return (int)ashmem_get_funcs()->getSize(fd);
++}
++
++int ashmem_device_is_supported(void) {
++  return ashmem_get_status() == ASHMEM_STATUS_SUPPORTED;
+ }
+diff --git a/third_party/ashmem/ashmem.h b/third_party/ashmem/ashmem.h
+index d8afccbd2a6e..f3675c98b19a 100644
+--- a/third_party/ashmem/ashmem.h
++++ b/third_party/ashmem/ashmem.h
+@@ -16,13 +16,20 @@
+ extern "C" {
+ #endif
+ 
++/* Returns true if the ashmem device is supported on this device.
++ * Not that even if the device is not supported,
++ * ashmem_{create,set_prot,get_prot,get_size}_region() will still work
++ * because they will use the ASharedMemory functions from libandroid.so
++ * instead. But ashmem_{pin,unpin}_region() will be no-ops.
++ */
++int ashmem_device_is_supported(void);
++
+ int ashmem_create_region(const char *name, size_t size);
+ int ashmem_set_prot_region(int fd, int prot);
+ int ashmem_get_prot_region(int fd);
+ int ashmem_pin_region(int fd, size_t offset, size_t len);
+ int ashmem_unpin_region(int fd, size_t offset, size_t len);
+ int ashmem_get_size_region(int fd);
+-int ashmem_purge_all(void);
+ 
+ #ifdef __cplusplus
+ }
diff --git a/third_party/ashmem/patches/0003-Pthread-once-for-funcs-init.patch b/third_party/ashmem/patches/0003-Pthread-once-for-funcs-init.patch
new file mode 100644
index 0000000000000..778a6e4701243
--- /dev/null
+++ b/third_party/ashmem/patches/0003-Pthread-once-for-funcs-init.patch
@@ -0,0 +1,61 @@
+diff --git a/third_party/ashmem/ashmem-dev.c b/third_party/ashmem/ashmem-dev.c
+index 25a33cdcd0c8..399ea36ce382 100644
+--- a/third_party/ashmem/ashmem-dev.c
++++ b/third_party/ashmem/ashmem-dev.c
+@@ -18,6 +18,7 @@
+ 
+ #include <dlfcn.h>
+ #include <errno.h>
++#include <pthread.h>
+ #include <unistd.h>
+ #include <stdlib.h>
+ #include <string.h>
+@@ -190,26 +191,30 @@ typedef struct {
+   ASharedMemory_setProtFunc setProt;
+ } ASharedMemoryFuncs;
+ 
+-const ASharedMemoryFuncs* ashmem_get_funcs() {
+-  static ASharedMemoryFuncs s_ashmem_funcs = {};
++static ASharedMemoryFuncs s_ashmem_funcs = {};
++static pthread_once_t s_ashmem_funcs_once = PTHREAD_ONCE_INIT;
++
++static void ashmem_init_funcs() {
+   ASharedMemoryFuncs* funcs = &s_ashmem_funcs;
+-  if (funcs->create == NULL) {
+-    if (device_api_level() >= __ANDROID_API_O__) {
+-      /* Leaked intentionally! */
+-      void* lib = dlopen("libandroid.so", RTLD_NOW);
+-      funcs->create = (ASharedMemory_createFunc)
+-          dlsym(lib, "ASharedMemory_create");
+-      funcs->getSize = (ASharedMemory_getSizeFunc)
+-          dlsym(lib, "ASharedMemory_getSize");
+-      funcs->setProt = (ASharedMemory_setProtFunc)
+-          dlsym(lib, "ASharedMemory_setProt");
+-    } else {
+-      funcs->create = &ashmem_dev_create_region;
+-      funcs->getSize = &ashmem_dev_get_size_region;
+-      funcs->setProt = &ashmem_dev_set_prot_region;
+-    }
++  if (device_api_level() >= __ANDROID_API_O__) {
++    /* Leaked intentionally! */
++    void* lib = dlopen("libandroid.so", RTLD_NOW);
++    funcs->create =
++        (ASharedMemory_createFunc)dlsym(lib, "ASharedMemory_create");
++    funcs->getSize =
++        (ASharedMemory_getSizeFunc)dlsym(lib, "ASharedMemory_getSize");
++    funcs->setProt =
++        (ASharedMemory_setProtFunc)dlsym(lib, "ASharedMemory_setProt");
++  } else {
++    funcs->create = &ashmem_dev_create_region;
++    funcs->getSize = &ashmem_dev_get_size_region;
++    funcs->setProt = &ashmem_dev_set_prot_region;
+   }
+-  return funcs;
++}
++
++static const ASharedMemoryFuncs* ashmem_get_funcs() {
++  pthread_once(&s_ashmem_funcs_once, ashmem_init_funcs);
++  return &s_ashmem_funcs;
+ }
+ 
+ int ashmem_create_region(const char* name, size_t size) {
diff --git a/third_party/ashmem/patches/0004-Fixup-ashmem_get_prot_region-for-memfd.patch b/third_party/ashmem/patches/0004-Fixup-ashmem_get_prot_region-for-memfd.patch
new file mode 100644
index 0000000000000..feae8beb5938e
--- /dev/null
+++ b/third_party/ashmem/patches/0004-Fixup-ashmem_get_prot_region-for-memfd.patch
@@ -0,0 +1,13 @@
+diff --git a/third_party/ashmem/ashmem-dev.c b/third_party/ashmem/ashmem-dev.c
+index 399ea36ce3826..6bb4977bab28d 100644
+--- a/third_party/ashmem/ashmem-dev.c
++++ b/third_party/ashmem/ashmem-dev.c
+@@ -235,7 +235,7 @@ int ashmem_get_prot_region(int fd) {
+   int result = PROT_READ;
+   const size_t page_size = (size_t)sysconf(_SC_PAGESIZE);
+   void* m = mmap(NULL, page_size, PROT_READ|PROT_WRITE,
+-                 MAP_PRIVATE, fd, 0);
++                 MAP_SHARED, fd, 0);
+   if (m != MAP_FAILED) {
+     munmap(m, page_size);
+     result = PROT_READ|PROT_WRITE;
diff --git a/third_party/cardboard/src_overrides/patches/0001-Adjust-Cardboard-JNI-Util-for-Chrome-build-config.patch b/third_party/cardboard/src_overrides/patches/0001-Adjust-Cardboard-JNI-Util-for-Chrome-build-config.patch
new file mode 100644
index 0000000000000..977c17db1fd40
--- /dev/null
+++ b/third_party/cardboard/src_overrides/patches/0001-Adjust-Cardboard-JNI-Util-for-Chrome-build-config.patch
@@ -0,0 +1,41 @@
+From 3af7b78665624fbf819c87aed65d87dc22921b6c Mon Sep 17 00:00:00 2001
+From: Alexander Cooper <alcooper@chromium.org>
+Date: Thu, 27 Feb 2025 12:59:57 -0800
+Subject: [PATCH 1/2] Adjust Cardboard JNI Util for Chrome build config
+
+---
+ .../src_overrides/sdk/jni_utils/android/jni_utils.cc     | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+diff --git a/third_party/cardboard/src_overrides/sdk/jni_utils/android/jni_utils.cc b/third_party/cardboard/src_overrides/sdk/jni_utils/android/jni_utils.cc
+index fe6c8cd45e577..8a1f29405f42a 100644
+--- a/third_party/cardboard/src_overrides/sdk/jni_utils/android/jni_utils.cc
++++ b/third_party/cardboard/src_overrides/sdk/jni_utils/android/jni_utils.cc
+@@ -13,9 +13,10 @@
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+-#include "jni_utils/android/jni_utils.h"
++#include "third_party/cardboard/src/sdk/jni_utils/android/jni_utils.h"
+ 
+-#include "util/logging.h"
++#include "base/android/jni_android.h"
++#include "third_party/cardboard/src/sdk/util/logging.h"
+ 
+ namespace cardboard::jni {
+ namespace {
+@@ -60,9 +61,9 @@ void LoadJNIEnv(JavaVM* vm, JNIEnv** env) {
+ }
+ 
+ jclass LoadJClass(JNIEnv* env, const char* class_name) {
+-  jclass local = env->FindClass(class_name);
++  auto local_ref = base::android::GetClass(env, class_name);
+   CheckExceptionInJava(env);
+-  return static_cast<jclass>(env->NewGlobalRef(local));
++  return static_cast<jclass>(env->NewGlobalRef(local_ref.obj()));
+ }
+ 
+ void ThrowJavaRuntimeException(JNIEnv* env, const char* msg) {
+-- 
+2.48.1.711.g2feabab25a-goog
+
diff --git a/third_party/cardboard/src_overrides/patches/0002-Adapt-QRCode-activity-to-edge-to-edge.patch b/third_party/cardboard/src_overrides/patches/0002-Adapt-QRCode-activity-to-edge-to-edge.patch
new file mode 100644
index 0000000000000..195eb5e13bee1
--- /dev/null
+++ b/third_party/cardboard/src_overrides/patches/0002-Adapt-QRCode-activity-to-edge-to-edge.patch
@@ -0,0 +1,67 @@
+From 9a23096f9364d9a423323238e3f4548c4d3b6d68 Mon Sep 17 00:00:00 2001
+From: Alexander Cooper <alcooper@chromium.org>
+Date: Thu, 27 Feb 2025 13:01:46 -0800
+Subject: [PATCH 2/2] Adapt QRCode activity to edge-to-edge
+
+---
+ .../cardboard/sdk/QrCodeCaptureActivity.java  | 20 +++++++++++++++++++
+ .../android/res/layout/qr_code_capture.xml    |  1 +
+ 2 files changed, 21 insertions(+)
+
+diff --git a/third_party/cardboard/src_overrides/sdk/qrcode/android/java/com/google/cardboard/sdk/QrCodeCaptureActivity.java b/third_party/cardboard/src_overrides/sdk/qrcode/android/java/com/google/cardboard/sdk/QrCodeCaptureActivity.java
+index 0e51134060e28..e461e72eec5d1 100644
+--- a/third_party/cardboard/src_overrides/sdk/qrcode/android/java/com/google/cardboard/sdk/QrCodeCaptureActivity.java
++++ b/third_party/cardboard/src_overrides/sdk/qrcode/android/java/com/google/cardboard/sdk/QrCodeCaptureActivity.java
+@@ -27,11 +27,15 @@ import android.os.Bundle;
+ import android.provider.Settings;
+ import android.util.Log;
+ import android.view.View;
++import android.view.ViewGroup;
+ import android.widget.Toast;
+ 
+ import androidx.annotation.NonNull;
+ import androidx.appcompat.app.AppCompatActivity;
+ import androidx.core.app.ActivityCompat;
++import androidx.core.graphics.Insets;
++import androidx.core.view.ViewCompat;
++import androidx.core.view.WindowInsetsCompat;
+ 
+ import com.google.android.gms.common.ConnectionResult;
+ import com.google.android.gms.common.GoogleApiAvailability;
+@@ -76,6 +80,22 @@ public class QrCodeCaptureActivity extends AppCompatActivity
+         super.onCreate(icicle);
+         setContentView(R.layout.qr_code_capture);
+ 
++        // Adds margins to the container to account for edge to edge:
++        // https://developer.android.com/develop/ui/views/layout/edge-to-edge
++        View container = findViewById(R.id.container);
++        ViewCompat.setOnApplyWindowInsetsListener(
++                container,
++                (v, windowInsets) -> {
++                    Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars());
++                    ViewGroup.MarginLayoutParams mlp =
++                            (ViewGroup.MarginLayoutParams) v.getLayoutParams();
++                    mlp.leftMargin = insets.left;
++                    mlp.bottomMargin = insets.bottom;
++                    mlp.rightMargin = insets.right;
++                    v.setLayoutParams(mlp);
++                    return WindowInsetsCompat.CONSUMED;
++                });
++
+         cameraSourcePreview = findViewById(R.id.preview);
+     }
+ 
+diff --git a/third_party/cardboard/src_overrides/sdk/qrcode/android/res/layout/qr_code_capture.xml b/third_party/cardboard/src_overrides/sdk/qrcode/android/res/layout/qr_code_capture.xml
+index 8aac5fc960446..0fbe9dac77af1 100644
+--- a/third_party/cardboard/src_overrides/sdk/qrcode/android/res/layout/qr_code_capture.xml
++++ b/third_party/cardboard/src_overrides/sdk/qrcode/android/res/layout/qr_code_capture.xml
+@@ -1,5 +1,6 @@
+ <?xml version="1.0" encoding="utf-8"?>
+ <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
++    android:id="@+id/container"
+     android:layout_width="match_parent"
+     android:layout_height="match_parent"
+     android:orientation="vertical">
+-- 
+2.48.1.711.g2feabab25a-goog
+
diff --git a/third_party/dpkg-shlibdeps/patches/0001-dkpg-shlibdeps-add-option-to-ignore-weak-undefined-symbols.patch b/third_party/dpkg-shlibdeps/patches/0001-dkpg-shlibdeps-add-option-to-ignore-weak-undefined-symbols.patch
new file mode 100644
index 0000000000000..8886d49f26b61
--- /dev/null
+++ b/third_party/dpkg-shlibdeps/patches/0001-dkpg-shlibdeps-add-option-to-ignore-weak-undefined-symbols.patch
@@ -0,0 +1,71 @@
+From 59477dae6f2c68f0ebd9ccca18e737b67408bc11 Mon Sep 17 00:00:00 2001
+From: Tom Anderson <thomasanderson@chromium.org>
+Date: Wed, 8 Jan 2020 10:55:20 -0800
+Subject: [PATCH 1/2] dkpg-shlibdeps: Add option to ignore weak undefined
+ symbols
+
+Weak undefined symbols can be used to test feature support. For example:
+
+__attribute__((weak)) uint64_t gbm_bo_get_modifier(struct gbm_bo* bo);
+void foo(gbm_bo* bo) {
+    // gbm_create_device is a strong undefined symbol. The dynamic linker will
+    // fail if this is not available.
+    gbm_create_device(1234);
+    // gbm_bo_get_modifier is a weak undefined symbol. It will be NULL if it's
+    // not available.
+    if (gbm_bo_get_modifier)
+        gbm_bo_get_modifier(bo);
+}
+
+However currently, dpkg-shlibdeps would consider gbm_bo_get_modifier in the
+example to be a required symbol (and would increase the minimum required library
+version), even though the intention is to use it only if it is available.
+
+To address this, this change skips weak undefined symbols when checking for
+dependencies. Out of an abundance of caution, this behavior is guarded behind a
+new flag: --ignore-weak-undefined.
+---
+ scripts/dpkg-shlibdeps.pl | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/scripts/dpkg-shlibdeps.pl b/scripts/dpkg-shlibdeps.pl
+index 8142c85b4..e3d8c7200 100755
+--- a/scripts/dpkg-shlibdeps.pl
++++ b/scripts/dpkg-shlibdeps.pl
+@@ -67,6 +67,7 @@ my $varlistfile = 'debian/substvars';
+ my $varlistfilenew;
+ my $varnameprefix = 'shlibs';
+ my $ignore_missing_info = 0;
++my $ignore_weak_undefined = 0;
+ my $warnings = WARN_SYM_NOT_FOUND | WARN_DEP_AVOIDABLE;
+ my $debug = 0;
+ my @exclude = ();
+@@ -120,6 +121,8 @@ foreach (@ARGV) {
+ 	}
+     } elsif (m/^--ignore-missing-info$/) {
+ 	$ignore_missing_info = 1;
++    } elsif (m/^--ignore-weak-undefined$/) {
++	$ignore_weak_undefined = 1;
+     } elsif (m/^--warnings=(\d+)$/) {
+ 	$warnings = $1;
+     } elsif (m/^-t(.*)$/) {
+@@ -365,6 +368,7 @@ foreach my $file (keys %exec) {
+     }
+     debug(2, 'Analyzing all undefined symbols');
+     foreach my $sym ($obj->get_undefined_dynamic_symbols()) {
++	next if $ignore_weak_undefined && $sym->{weak};
+ 	my $name = $sym->{name};
+ 	if ($sym->{version}) {
+ 	    $name .= '@' . "$sym->{version}";
+@@ -610,6 +614,8 @@ sub usage {
+                              in the given build directory.
+   -v                       enable verbose mode (can be used multiple times).
+   --ignore-missing-info    don't fail if dependency information can't be found.
++  --ignore-weak-undefined  only allow strong undefined symbols to introduce
++                             dependencies.
+   --warnings=<value>       define set of active warnings (see manual page).
+   --admindir=<directory>   change the administrative directory.
+   -?, --help               show this help message.
+-- 
+2.25.0.rc1.283.g88dfdc4193-goog
+
diff --git a/third_party/dpkg-shlibdeps/patches/0002-fix-compatibility-for-chromium.patch b/third_party/dpkg-shlibdeps/patches/0002-fix-compatibility-for-chromium.patch
new file mode 100644
index 0000000000000..0ff45a0593b5e
--- /dev/null
+++ b/third_party/dpkg-shlibdeps/patches/0002-fix-compatibility-for-chromium.patch
@@ -0,0 +1,77 @@
+From 3f179bf13081f9dde0535a17864ceeba685ab907 Mon Sep 17 00:00:00 2001
+From: Tom Anderson <thomasanderson@chromium.org>
+Date: Wed, 8 Jan 2020 12:11:56 -0800
+Subject: [PATCH 2/2] Fix compatibility for Chromium
+
+* Add debug() and g_() functions in case the system dpkg doesn't have it.
+* Implement List::Util::any and List::Util::none for older versions of perl.
+---
+ scripts/dpkg-shlibdeps.pl | 20 ++++++++++++++------
+ 1 file changed, 14 insertions(+), 6 deletions(-)
+
+diff --git a/scripts/dpkg-shlibdeps.pl b/scripts/dpkg-shlibdeps.pl
+index e3d8c7200..654dfa898 100755
+--- a/scripts/dpkg-shlibdeps.pl
++++ b/scripts/dpkg-shlibdeps.pl
+@@ -21,11 +21,10 @@
+ # You should have received a copy of the GNU General Public License
+ # along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ 
+-use strict;
+ use warnings;
+ use feature qw(state);
+ 
+-use List::Util qw(any none);
++use List::Util qw(reduce);
+ use Cwd qw(realpath);
+ use File::Basename qw(dirname);
+ 
+@@ -51,6 +50,11 @@ use constant {
+     WARN_NOT_NEEDED => 4,
+ };
+ 
++sub none (&@) { my $code=shift; reduce { $a && !$code->(local $_ = $b) } 1, @_; }
++sub any  (&@) { my $code=shift; reduce { $a ||  $code->(local $_ = $b) } 0, @_; }
++
++sub g_ { return shift; }
++
+ # By increasing importance
+ my @depfields = qw(Suggests Recommends Depends Pre-Depends);
+ my $i = 0; my %depstrength = map { $_ => $i++ } @depfields;
+@@ -153,6 +157,11 @@ sub ignore_pkgdir {
+     return any { $path =~ /^\Q$_\E/ } @pkg_dir_to_ignore;
+ }
+ 
++sub debug {
++    my $level = shift;
++    print @_ if $level <= $debug;
++}
++
+ if (-d 'debian') {
+     push @pkg_symbols, grep { !ignore_pkgdir($_) } glob 'debian/*/DEBIAN/symbols';
+     push @pkg_shlibs, grep { !ignore_pkgdir($_) } glob 'debian/*/DEBIAN/shlibs';
+@@ -198,18 +207,17 @@ foreach my $file (keys %exec) {
+     my %soname_notfound;
+     my %alt_soname;
+     foreach my $soname (@sonames) {
+-	my @libs = my_find_library($soname, $obj->{RPATH}, $obj->{exec_abi}, $file);
++	my @libs = my_find_library($soname, $obj->{RPATH}, $obj->{exec_abi} || $obj->{format}, $file);
+ 	unless (scalar @libs) {
+ 	    $soname_notfound{$soname} = 1;
+ 	    $global_soname_notfound{$soname} = 1;
+ 	    my $msg = g_('cannot find library %s needed by %s (ELF ' .
+ 	                 "format: '%s' abi: '%s'; RPATH: '%s')");
+-	    my $exec_abi = unpack 'H*', $obj->{exec_abi};
+ 	    if (scalar(split_soname($soname))) {
+-		errormsg($msg, $soname, $file, $obj->{format}, $exec_abi, join(':', @{$obj->{RPATH}}));
++		errormsg($msg, $soname, $file, $obj->{format}, join(':', @{$obj->{RPATH}}));
+ 		$error_count++;
+ 	    } else {
+-		warning($msg, $soname, $file, $obj->{format}, $exec_abi, join(':', @{$obj->{RPATH}}));
++		warning($msg, $soname, $file, $obj->{format}, join(':', @{$obj->{RPATH}}));
+ 	    }
+ 	    next;
+ 	}
+-- 
+2.25.0.rc1.283.g88dfdc4193-goog
+
diff --git a/third_party/expat/0001-Do-not-claim-getrandom.patch b/third_party/expat/0001-Do-not-claim-getrandom.patch
new file mode 100644
index 0000000000000..34937a450e37f
--- /dev/null
+++ b/third_party/expat/0001-Do-not-claim-getrandom.patch
@@ -0,0 +1,31 @@
+diff --git a/third_party/expat/include/expat_config/expat_config.h b/third_party/expat/include/expat_config/expat_config.h
+index bc83d399214ed..81d6af75a6467 100644
+--- a/third_party/expat/include/expat_config/expat_config.h
++++ b/third_party/expat/include/expat_config/expat_config.h
+@@ -14,7 +14,7 @@
+ /* #undef HAVE_ARC4RANDOM */
+ 
+ /* Define to 1 if you have the `arc4random_buf' function. */
+-#define HAVE_ARC4RANDOM_BUF 1
++/* #define HAVE_ARC4RANDOM_BUF 1 */
+ 
+ /* define if the compiler supports basic C++11 syntax */
+ #define HAVE_CXX11 1
+@@ -29,7 +29,7 @@
+ #define HAVE_GETPAGESIZE 1
+ 
+ /* Define to 1 if you have the `getrandom' function. */
+-#define HAVE_GETRANDOM 1
++/* #define HAVE_GETRANDOM 1 */
+ 
+ /* Define to 1 if you have the <inttypes.h> header file. */
+ #define HAVE_INTTYPES_H 1
+@@ -56,7 +56,7 @@
+ #define HAVE_STRING_H 1
+ 
+ /* Define to 1 if you have `syscall' and `SYS_getrandom'. */
+-#define HAVE_SYSCALL_GETRANDOM 1
++/* #define HAVE_SYSCALL_GETRANDOM 1 */
+ 
+ /* Define to 1 if you have the <sys/param.h> header file. */
+ #define HAVE_SYS_PARAM_H 1
diff --git a/third_party/fdlibm/chromium/0001-Import-a-copy-of-V8-s-fdlibm-fork-into-Chromium-thir.patch b/third_party/fdlibm/chromium/0001-Import-a-copy-of-V8-s-fdlibm-fork-into-Chromium-thir.patch
new file mode 100644
index 0000000000000..9e92af0b6b1d9
--- /dev/null
+++ b/third_party/fdlibm/chromium/0001-Import-a-copy-of-V8-s-fdlibm-fork-into-Chromium-thir.patch
@@ -0,0 +1,469 @@
+diff --git a/third_party/fdlibm/BUILD.gn b/third_party/fdlibm/BUILD.gn
+new file mode 100644
+index 0000000000000..9c70cbdb062c4
+--- /dev/null
++++ b/third_party/fdlibm/BUILD.gn
+@@ -0,0 +1,12 @@
++# Copyright 2020 The Chromium Authors
++# Use of this source code is governed by a BSD-style license that can be
++# found in the LICENSE file.
++
++source_set("fdlibm") {
++  sources = [
++    "ieee754.cc",
++    "ieee754.h",
++    "overflowing-math.h",
++  ]
++  deps = [ "//base" ]
++}
+diff --git a/third_party/fdlibm/DEPS b/third_party/fdlibm/DEPS
+new file mode 100644
+index 0000000000000..0605625fa73a4
+--- /dev/null
++++ b/third_party/fdlibm/DEPS
+@@ -0,0 +1,5 @@
++include_rules = [
++    "+base/bit_cast.h",
++    "+base/compiler_specific.h",
++    "+build/build_config.h",
++]
+diff --git a/third_party/fdlibm/README.chromium b/third_party/fdlibm/README.chromium
+index eb45e2ab94382..362d3acb6169e 100644
+--- a/third_party/fdlibm/README.chromium
++++ b/third_party/fdlibm/README.chromium
+@@ -13,3 +13,15 @@ This library is a copy of that V8 library intended for use in Chromium.
+ 
+ This library may be useful when mathematical consistency across OS platforms is
+ desired.
++
++The initial commit is not a pristine import -- the patch in the chromium/
++subdirectory documents the changes made to the original sources. This patch was
++produced via `git diff` and can be applied using `git apply`.
++
++Changes from V8 upstream:
++- Changed namespace to fdlibm.
++- Alter //v8/src/base usage to use Chromium //base equivalents.
++- Implement 32-bit float functions (sinf(), etc.) by calling the 64-bit
++  versions.
++- Format the code.
++- Remove MSVC code, which is not supported by Chromium anymore.
+diff --git a/third_party/fdlibm/ieee754.cc b/third_party/fdlibm/ieee754.cc
+index 1706b56dfd900..3b2e00474902f 100644
+--- a/third_party/fdlibm/ieee754.cc
++++ b/third_party/fdlibm/ieee754.cc
+@@ -1,3 +1,4 @@
++
+ // The following is adapted from fdlibm (http://www.netlib.org/fdlibm).
+ //
+ // ====================================================
+@@ -12,30 +13,21 @@
+ // The original source code covered by the above license above has been
+ // modified significantly by Google Inc.
+ // Copyright 2016 the V8 project authors. All rights reserved.
++// Copyright 2020 The Chromium Authors
+ 
+-#include "src/base/ieee754.h"
++#include "third_party/fdlibm/ieee754.h"
+ 
+ #include <cmath>
+ #include <limits>
+ 
+-#include "src/base/build_config.h"
+-#include "src/base/macros.h"
+-#include "src/base/overflowing-math.h"
++#include "base/bit_cast.h"
++#include "build/build_config.h"
++#include "third_party/fdlibm/overflowing-math.h"
+ 
+-namespace v8 {
+-namespace base {
+-namespace ieee754 {
++namespace fdlibm {
+ 
+ namespace {
+ 
+-/* Disable "potential divide by 0" warning in Visual Studio compiler. */
+-
+-#if V8_CC_MSVC
+-
+-#pragma warning(disable : 4723)
+-
+-#endif
+-
+ /*
+  * The original fdlibm code used statements like:
+  *  n0 = ((*(int*)&one)>>29)^1;   * index of high word *
+@@ -51,27 +43,27 @@ namespace {
+ 
+ /* Get two 32 bit ints from a double.  */
+ 
+-#define EXTRACT_WORDS(ix0, ix1, d)         \
+-  do {                                     \
+-    uint64_t bits = bit_cast<uint64_t>(d); \
+-    (ix0) = bits >> 32;                    \
+-    (ix1) = bits & 0xFFFFFFFFu;            \
++#define EXTRACT_WORDS(ix0, ix1, d)               \
++  do {                                           \
++    uint64_t bits = base::bit_cast<uint64_t>(d); \
++    (ix0) = bits >> 32;                          \
++    (ix1) = bits & 0xFFFFFFFFu;                  \
+   } while (false)
+ 
+ /* Get the more significant 32 bit int from a double.  */
+ 
+-#define GET_HIGH_WORD(i, d)                \
+-  do {                                     \
+-    uint64_t bits = bit_cast<uint64_t>(d); \
+-    (i) = bits >> 32;                      \
++#define GET_HIGH_WORD(i, d)                      \
++  do {                                           \
++    uint64_t bits = base::bit_cast<uint64_t>(d); \
++    (i) = bits >> 32;                            \
+   } while (false)
+ 
+ /* Get the less significant 32 bit int from a double.  */
+ 
+-#define GET_LOW_WORD(i, d)                 \
+-  do {                                     \
+-    uint64_t bits = bit_cast<uint64_t>(d); \
+-    (i) = bits & 0xFFFFFFFFu;              \
++#define GET_LOW_WORD(i, d)                       \
++  do {                                           \
++    uint64_t bits = base::bit_cast<uint64_t>(d); \
++    (i) = bits & 0xFFFFFFFFu;                    \
+   } while (false)
+ 
+ /* Set a double from two 32 bit ints.  */
+@@ -81,34 +73,38 @@ namespace {
+     uint64_t bits = 0;                        \
+     bits |= static_cast<uint64_t>(ix0) << 32; \
+     bits |= static_cast<uint32_t>(ix1);       \
+-    (d) = bit_cast<double>(bits);             \
++    (d) = base::bit_cast<double>(bits);       \
+   } while (false)
+ 
+ /* Set the more significant 32 bits of a double from an int.  */
+ 
+-#define SET_HIGH_WORD(d, v)                 \
+-  do {                                      \
+-    uint64_t bits = bit_cast<uint64_t>(d);  \
+-    bits &= 0x0000'0000'FFFF'FFFF;          \
+-    bits |= static_cast<uint64_t>(v) << 32; \
+-    (d) = bit_cast<double>(bits);           \
++#define SET_HIGH_WORD(d, v)                      \
++  do {                                           \
++    uint64_t bits = base::bit_cast<uint64_t>(d); \
++    bits &= 0x0000'0000'FFFF'FFFF;               \
++    bits |= static_cast<uint64_t>(v) << 32;      \
++    (d) = base::bit_cast<double>(bits);          \
+   } while (false)
+ 
+ /* Set the less significant 32 bits of a double from an int.  */
+ 
+-#define SET_LOW_WORD(d, v)                 \
+-  do {                                     \
+-    uint64_t bits = bit_cast<uint64_t>(d); \
+-    bits &= 0xFFFF'FFFF'0000'0000;         \
+-    bits |= static_cast<uint32_t>(v);      \
+-    (d) = bit_cast<double>(bits);          \
++#define SET_LOW_WORD(d, v)                       \
++  do {                                           \
++    uint64_t bits = base::bit_cast<uint64_t>(d); \
++    bits &= 0xFFFF'FFFF'0000'0000;               \
++    bits |= static_cast<uint32_t>(v);            \
++    (d) = base::bit_cast<double>(bits);          \
+   } while (false)
+ 
+-int32_t __ieee754_rem_pio2(double x, double* y) V8_WARN_UNUSED_RESULT;
+-double __kernel_cos(double x, double y) V8_WARN_UNUSED_RESULT;
+-int __kernel_rem_pio2(double* x, double* y, int e0, int nx, int prec,
+-                      const int32_t* ipio2) V8_WARN_UNUSED_RESULT;
+-double __kernel_sin(double x, double y, int iy) V8_WARN_UNUSED_RESULT;
++[[nodiscard]] int32_t __ieee754_rem_pio2(double x, double* y);
++[[nodiscard]] double __kernel_cos(double x, double y);
++[[nodiscard]] int __kernel_rem_pio2(double* x,
++                                    double* y,
++                                    int e0,
++                                    int nx,
++                                    int prec,
++                                    const int32_t* ipio2);
++[[nodiscard]] double __kernel_sin(double x, double y, int iy);
+ 
+ /* __ieee754_rem_pio2(x,y)
+  *
+@@ -302,7 +298,7 @@ int32_t __ieee754_rem_pio2(double x, double *y) {
+  *         magnitude of the latter is at least a quarter of x*x/2,
+  *         thus, reducing the rounding error in the subtraction.
+  */
+-V8_INLINE double __kernel_cos(double x, double y) {
++ALWAYS_INLINE double __kernel_cos(double x, double y) {
+   static const double
+       one = 1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+       C1 = 4.16666666666666019037e-02,  /* 0x3FA55555, 0x5555554C */
+@@ -670,7 +666,7 @@ recompute:
+  *         then                   3    2
+  *              sin(x) = x + (S1*x + (x *(r-y/2)+y))
+  */
+-V8_INLINE double __kernel_sin(double x, double y, int iy) {
++ALWAYS_INLINE double __kernel_sin(double x, double y, int iy) {
+   static const double
+       half = 5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
+       S1 = -1.66666666666666324348e-01,  /* 0xBFC55555, 0x55555549 */
+@@ -2396,9 +2392,9 @@ double cbrt(double x) {
+    * 0.667; the error in the rounded t can be up to about 3 23-bit ulps
+    * before the final error is larger than 0.667 ulps.
+    */
+-  uint64_t bits = bit_cast<uint64_t>(t);
++  uint64_t bits = base::bit_cast<uint64_t>(t);
+   bits = (bits + 0x80000000) & 0xFFFFFFFFC0000000ULL;
+-  t = bit_cast<double>(bits);
++  t = base::bit_cast<double>(bits);
+ 
+   /* one step Newton iteration to 53 bits with error < 0.667 ulps */
+   s = t * t;             /* t*t is exact */
+@@ -2721,7 +2717,7 @@ double pow(double x, double y) {
+     }
+     if (iy == 0x3ff00000) { /* y is  +-1 */
+       if (hy < 0) {
+-        return base::Divide(one, x);
++        return Divide(one, x);
+       } else {
+         return x;
+       }
+@@ -2739,7 +2735,7 @@ double pow(double x, double y) {
+   if (lx == 0) {
+     if (ix == 0x7ff00000 || ix == 0 || ix == 0x3ff00000) {
+       z = ax;                         /*x is +-0,+-inf,+-1*/
+-      if (hy < 0) z = base::Divide(one, z); /* z = (1/|x|) */
++      if (hy < 0) z = Divide(one, z); /* z = (1/|x|) */
+       if (hx < 0) {
+         if (((ix - 0x3ff00000) | yisint) == 0) {
+           /* (-1)**non-int is NaN */
+@@ -2806,7 +2802,7 @@ double pow(double x, double y) {
+ 
+     /* compute ss = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
+     u = ax - bp[k]; /* bp[0]=1.0, bp[1]=1.5 */
+-    v = base::Divide(one, ax + bp[k]);
++    v = Divide(one, ax + bp[k]);
+     ss = u * v;
+     s_h = ss;
+     SET_LOW_WORD(s_h, 0);
+@@ -2883,7 +2879,7 @@ double pow(double x, double y) {
+   w = v - (z - u);
+   t = z * z;
+   t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
+-  r = base::Divide(z * t1, (t1 - two) - (w + z * w));
++  r = Divide(z * t1, (t1 - two) - (w + z * w));
+   z = one - (r - z);
+   GET_HIGH_WORD(j, z);
+   j += static_cast<int>(static_cast<uint32_t>(n) << 20);
+@@ -3008,6 +3004,26 @@ double tanh(double x) {
+   return (jx >= 0) ? z : -z;
+ }
+ 
++float powf(float x, float y) {
++  return pow(x, y);
++}
++
++float expf(float x) {
++  return exp(x);
++}
++
++float log10f(float x) {
++  return log10(x);
++}
++
++float sinf(double x) {
++  return sin(x);
++}
++
++float asinf(double x) {
++  return asin(x);
++}
++
+ #undef EXTRACT_WORDS
+ #undef GET_HIGH_WORD
+ #undef GET_LOW_WORD
+@@ -3015,6 +3031,4 @@ double tanh(double x) {
+ #undef SET_HIGH_WORD
+ #undef SET_LOW_WORD
+ 
+-}  // namespace ieee754
+-}  // namespace base
+-}  // namespace v8
++}  // namespace fdlibm
+diff --git a/third_party/fdlibm/ieee754.h b/third_party/fdlibm/ieee754.h
+index f2b3a3eb5808c..27b5013818a2c 100644
+--- a/third_party/fdlibm/ieee754.h
++++ b/third_party/fdlibm/ieee754.h
+@@ -1,64 +1,61 @@
+ // Copyright 2016 the V8 project authors. All rights reserved.
++// Copyright 2020 The Chromium Authors
+ // Use of this source code is governed by a BSD-style license that can be
+ // found in the LICENSE file.
+ 
+-#ifndef V8_BASE_IEEE754_H_
+-#define V8_BASE_IEEE754_H_
++#ifndef THIRD_PARTY_FDLIBM_IEEE754_H_
++#define THIRD_PARTY_FDLIBM_IEEE754_H_
+ 
+-#include "src/base/base-export.h"
+-
+-namespace v8 {
+-namespace base {
+-namespace ieee754 {
++namespace fdlibm {
+ 
+ // Returns the arc cosine of |x|; that is the value whose cosine is |x|.
+-V8_BASE_EXPORT double acos(double x);
++double acos(double x);
+ 
+ // Returns the inverse hyperbolic cosine of |x|; that is the value whose
+ // hyperbolic cosine is |x|.
+-V8_BASE_EXPORT double acosh(double x);
++double acosh(double x);
+ 
+ // Returns the arc sine of |x|; that is the value whose sine is |x|.
+-V8_BASE_EXPORT double asin(double x);
++double asin(double x);
+ 
+ // Returns the inverse hyperbolic sine of |x|; that is the value whose
+ // hyperbolic sine is |x|.
+-V8_BASE_EXPORT double asinh(double x);
++double asinh(double x);
+ 
+ // Returns the principal value of the arc tangent of |x|; that is the value
+ // whose tangent is |x|.
+-V8_BASE_EXPORT double atan(double x);
++double atan(double x);
+ 
+ // Returns the principal value of the arc tangent of |y/x|, using the signs of
+ // the two arguments to determine the quadrant of the result.
+-V8_BASE_EXPORT double atan2(double y, double x);
++double atan2(double y, double x);
+ 
+ // Returns the cosine of |x|, where |x| is given in radians.
+-V8_BASE_EXPORT double cos(double x);
++double cos(double x);
+ 
+ // Returns the base-e exponential of |x|.
+-V8_BASE_EXPORT double exp(double x);
++double exp(double x);
+ 
+-V8_BASE_EXPORT double atanh(double x);
++double atanh(double x);
+ 
+ // Returns the natural logarithm of |x|.
+-V8_BASE_EXPORT double log(double x);
++double log(double x);
+ 
+ // Returns a value equivalent to |log(1+x)|, but computed in a way that is
+ // accurate even if the value of |x| is near zero.
+-V8_BASE_EXPORT double log1p(double x);
++double log1p(double x);
+ 
+ // Returns the base 2 logarithm of |x|.
+-V8_BASE_EXPORT double log2(double x);
++double log2(double x);
+ 
+ // Returns the base 10 logarithm of |x|.
+-V8_BASE_EXPORT double log10(double x);
++double log10(double x);
+ 
+ // Returns the cube root of |x|.
+-V8_BASE_EXPORT double cbrt(double x);
++double cbrt(double x);
+ 
+ // Returns exp(x)-1, the exponential of |x| minus 1.
+-V8_BASE_EXPORT double expm1(double x);
++double expm1(double x);
+ 
+ // Returns |x| to the power of |y|.
+ // The result of base ** exponent when base is 1 or -1 and exponent is
+@@ -66,25 +63,37 @@ V8_BASE_EXPORT double expm1(double x);
+ // of ECMAScript specified a result of NaN for this operation, whereas
+ // later versions of IEEE 754-2008 specified 1. The historical ECMAScript
+ // behaviour is preserved for compatibility reasons.
+-V8_BASE_EXPORT double pow(double x, double y);
++double pow(double x, double y);
+ 
+ // Returns the sine of |x|, where |x| is given in radians.
+-V8_BASE_EXPORT double sin(double x);
++double sin(double x);
+ 
+ // Returns the tangent of |x|, where |x| is given in radians.
+-V8_BASE_EXPORT double tan(double x);
++double tan(double x);
+ 
+ // Returns the hyperbolic cosine of |x|, where |x| is given radians.
+-V8_BASE_EXPORT double cosh(double x);
++double cosh(double x);
+ 
+ // Returns the hyperbolic sine of |x|, where |x| is given radians.
+-V8_BASE_EXPORT double sinh(double x);
++double sinh(double x);
+ 
+ // Returns the hyperbolic tangent of |x|, where |x| is given radians.
+-V8_BASE_EXPORT double tanh(double x);
++double tanh(double x);
++
++// NOTE(caraitto): These functions are not present in the V8 math library --
++// they are defined in terms of other functions.
++
++float powf(float x, float y);
++
++float expf(float x);
++
++float log10f(float x);
++
++float sinf(double x);
++
++float asinf(double x);
++
++}  // namespace fdlibm
+ 
+-}  // namespace ieee754
+-}  // namespace base
+-}  // namespace v8
++#endif  // THIRD_PARTY_FDLIBM_IEEE754_H_
+ 
+-#endif  // V8_BASE_IEEE754_H_
+diff --git a/third_party/fdlibm/overflowing-math.h b/third_party/fdlibm/overflowing-math.h
+index 14dcfb10de1a6..4bd41cc3a6930 100644
+--- a/third_party/fdlibm/overflowing-math.h
++++ b/third_party/fdlibm/overflowing-math.h
+@@ -1,19 +1,17 @@
+ // Copyright 2019 the V8 project authors. All rights reserved.
++// Copyright 2020 The Chromium Authors
+ // Use of this source code is governed by a BSD-style license that can be
+ // found in the LICENSE file.
+ 
+-#ifndef V8_BASE_OVERFLOWING_MATH_H_
+-#define V8_BASE_OVERFLOWING_MATH_H_
++#ifndef THIRD_PARTY_FDLIBM_OVERFLOWING_MATH_H_
++#define THIRD_PARTY_FDLIBM_OVERFLOWING_MATH_H_
+ 
+ #include <stdint.h>
+ 
+ #include <cmath>
+ #include <type_traits>
+ 
+-#include "src/base/macros.h"
+-
+-namespace v8 {
+-namespace base {
++namespace fdlibm {
+ 
+ // Helpers for performing overflowing arithmetic operations without relying
+ // on C++ undefined behavior.
+@@ -90,7 +88,7 @@ inline T RoundingAverageUnsigned(T a, T b) {
+   return (static_cast<uint64_t>(a) + static_cast<uint64_t>(b) + 1) >> 1;
+ }
+ 
+-}  // namespace base
+-}  // namespace v8
++}  // namespace fdlibm
++
++#endif  // THIRD_PARTY_FDLIBM_OVERFLOWING_MATH_H_
+ 
+-#endif  // V8_BASE_OVERFLOWING_MATH_H_
diff --git a/third_party/grpc/patches/0001-Remove-absl-Flag.patch b/third_party/grpc/patches/0001-Remove-absl-Flag.patch
new file mode 100644
index 0000000000000..46c99333ee51d
--- /dev/null
+++ b/third_party/grpc/patches/0001-Remove-absl-Flag.patch
@@ -0,0 +1,217 @@
+From 042ae2dd3af073a26bbca88e747a741a4d160bc3 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Mon, 17 Feb 2025 13:40:47 +0000
+Subject: [PATCH] Replace absl::Flag with default flag value
+
+Chromium cannot use absl::Flag as it has impact on binary size.
+Wherever it is used, replace with the default flag value.
+
+---
+ .../source/src/core/config/config_vars.cc     | 72 ++++---------------
+ .../source/src/core/config/load_config.cc     | 15 +---
+ .../grpc/source/src/core/config/load_config.h | 10 ++-
+ 3 files changed, 21 insertions(+), 76 deletions(-)
+
+diff --git a/third_party/grpc/source/src/core/config/config_vars.cc b/third_party/grpc/source/src/core/config/config_vars.cc
+index a163b919859f7..963b4030df4d2 100644
+--- a/third_party/grpc/source/src/core/config/config_vars.cc
++++ b/third_party/grpc/source/src/core/config/config_vars.cc
+@@ -20,9 +20,9 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/flags/flag.h"
++#include <optional>
++
+ #include "absl/strings/escaping.h"
+-#include "absl/types/optional.h"
+ #include "src/core/config/load_config.h"
+
+ #ifndef GPR_DEFAULT_LOG_VERBOSITY_STRING
+@@ -35,96 +35,54 @@
+ #define GRPC_ENABLE_FORK_SUPPORT_DEFAULT false
+ #endif  // GRPC_ENABLE_FORK_SUPPORT
+
+-ABSL_FLAG(std::vector<std::string>, grpc_experiments, {},
+-          "A comma separated list of currently active experiments. Experiments "
+-          "may be prefixed with a '-' to disable them.");
+-ABSL_FLAG(absl::optional<int32_t>, grpc_client_channel_backup_poll_interval_ms,
+-          {},
+-          "Declares the interval in ms between two backup polls on client "
+-          "channels. These polls are run in the timer thread so that gRPC can "
+-          "process connection failures while there is no active polling "
+-          "thread. They help reconnect disconnected client channels (mostly "
+-          "due to idleness), so that the next RPC on this channel won't fail. "
+-          "Set to 0 to turn off the backup polls.");
+-ABSL_FLAG(absl::optional<std::string>, grpc_dns_resolver, {},
+-          "Declares which DNS resolver to use. The default is ares if gRPC is "
+-          "built with c-ares support. Otherwise, the value of this environment "
+-          "variable is ignored.");
+-ABSL_FLAG(std::vector<std::string>, grpc_trace, {},
+-          "A comma separated list of tracers that provide additional insight "
+-          "into how gRPC C core is processing requests via debug logs.");
+-ABSL_FLAG(absl::optional<std::string>, grpc_verbosity, {},
+-          "Logging verbosity.");
+-ABSL_FLAG(absl::optional<bool>, grpc_enable_fork_support, {},
+-          "Enable fork support");
+-ABSL_FLAG(absl::optional<std::string>, grpc_poll_strategy, {},
+-          "Declares which polling engines to try when starting gRPC. This is a "
+-          "comma-separated list of engines, which are tried in priority order "
+-          "first -> last.");
+-ABSL_FLAG(absl::optional<bool>, grpc_abort_on_leaks, {},
+-          "A debugging aid to cause a call to abort() when gRPC objects are "
+-          "leaked past grpc_shutdown()");
+-ABSL_FLAG(absl::optional<std::string>, grpc_system_ssl_roots_dir, {},
+-          "Custom directory to SSL Roots");
+-ABSL_FLAG(absl::optional<std::string>, grpc_default_ssl_roots_file_path, {},
+-          "Path to the default SSL roots file.");
+-ABSL_FLAG(absl::optional<bool>, grpc_not_use_system_ssl_roots, {},
+-          "Disable loading system root certificates.");
+-ABSL_FLAG(absl::optional<std::string>, grpc_ssl_cipher_suites, {},
+-          "A colon separated list of cipher suites to use with OpenSSL");
+-ABSL_FLAG(absl::optional<bool>, grpc_cpp_experimental_disable_reflection, {},
+-          "EXPERIMENTAL. Only respected when there is a dependency on "
+-          ":grpc++_reflection. If true, no reflection server will be "
+-          "automatically added.");
+-
+ namespace grpc_core {
+
+ ConfigVars::ConfigVars(const Overrides& overrides)
+     : client_channel_backup_poll_interval_ms_(
+-          LoadConfig(FLAGS_grpc_client_channel_backup_poll_interval_ms,
++          LoadConfig(std::optional<int32_t>{},
+                      "GRPC_CLIENT_CHANNEL_BACKUP_POLL_INTERVAL_MS",
+                      overrides.client_channel_backup_poll_interval_ms, 5000)),
+       enable_fork_support_(LoadConfig(
+-          FLAGS_grpc_enable_fork_support, "GRPC_ENABLE_FORK_SUPPORT",
++          std::optional<bool>{}, "GRPC_ENABLE_FORK_SUPPORT",
+           overrides.enable_fork_support, GRPC_ENABLE_FORK_SUPPORT_DEFAULT)),
+-      abort_on_leaks_(LoadConfig(FLAGS_grpc_abort_on_leaks,
++      abort_on_leaks_(LoadConfig(std::optional<bool>{},
+                                  "GRPC_ABORT_ON_LEAKS",
+                                  overrides.abort_on_leaks, false)),
+       not_use_system_ssl_roots_(LoadConfig(
+-          FLAGS_grpc_not_use_system_ssl_roots, "GRPC_NOT_USE_SYSTEM_SSL_ROOTS",
++          std::optional<bool>{}, "GRPC_NOT_USE_SYSTEM_SSL_ROOTS",
+           overrides.not_use_system_ssl_roots, false)),
+       cpp_experimental_disable_reflection_(
+-          LoadConfig(FLAGS_grpc_cpp_experimental_disable_reflection,
++          LoadConfig(std::optional<bool>{},
+                      "GRPC_CPP_EXPERIMENTAL_DISABLE_REFLECTION",
+                      overrides.cpp_experimental_disable_reflection, false)),
+-      dns_resolver_(LoadConfig(FLAGS_grpc_dns_resolver, "GRPC_DNS_RESOLVER",
++      dns_resolver_(LoadConfig(std::optional<std::string>{}, "GRPC_DNS_RESOLVER",
+                                overrides.dns_resolver, "")),
+-      verbosity_(LoadConfig(FLAGS_grpc_verbosity, "GRPC_VERBOSITY",
++      verbosity_(LoadConfig(std::optional<std::string>{}, "GRPC_VERBOSITY",
+                             overrides.verbosity,
+                             GPR_DEFAULT_LOG_VERBOSITY_STRING)),
+-      poll_strategy_(LoadConfig(FLAGS_grpc_poll_strategy, "GRPC_POLL_STRATEGY",
++      poll_strategy_(LoadConfig(std::optional<std::string>{}, "GRPC_POLL_STRATEGY",
+                                 overrides.poll_strategy, "all")),
+       ssl_cipher_suites_(LoadConfig(
+-          FLAGS_grpc_ssl_cipher_suites, "GRPC_SSL_CIPHER_SUITES",
++          std::optional<std::string>{}, "GRPC_SSL_CIPHER_SUITES",
+           overrides.ssl_cipher_suites,
+           "TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_"
+           "SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:"
+           "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384")),
+-      experiments_(LoadConfig(FLAGS_grpc_experiments, "GRPC_EXPERIMENTS",
++      experiments_(LoadConfig(std::vector<std::string>{}, "GRPC_EXPERIMENTS",
+                               overrides.experiments, "")),
+-      trace_(LoadConfig(FLAGS_grpc_trace, "GRPC_TRACE", overrides.trace, "")),
++      trace_(LoadConfig(std::vector<std::string>{}, "GRPC_TRACE", overrides.trace, "")),
+       override_system_ssl_roots_dir_(overrides.system_ssl_roots_dir),
+       override_default_ssl_roots_file_path_(
+           overrides.default_ssl_roots_file_path) {}
+
+ std::string ConfigVars::SystemSslRootsDir() const {
+-  return LoadConfig(FLAGS_grpc_system_ssl_roots_dir,
++  return LoadConfig(std::optional<std::string>{},
+                     "GRPC_SYSTEM_SSL_ROOTS_DIR", override_system_ssl_roots_dir_,
+                     "");
+ }
+
+ std::string ConfigVars::DefaultSslRootsFilePath() const {
+-  return LoadConfig(FLAGS_grpc_default_ssl_roots_file_path,
++  return LoadConfig(std::optional<std::string>{},
+                     "GRPC_DEFAULT_SSL_ROOTS_FILE_PATH",
+                     override_default_ssl_roots_file_path_, "");
+ }
+diff --git a/third_party/grpc/source/src/core/config/load_config.cc b/third_party/grpc/source/src/core/config/load_config.cc
+index f78c0ccdc212b..e1ddf301d8f76 100644
+--- a/third_party/grpc/source/src/core/config/load_config.cc
++++ b/third_party/grpc/source/src/core/config/load_config.cc
+@@ -19,7 +19,6 @@
+
+ #include <optional>
+
+-#include "absl/flags/marshalling.h"
+ #include "absl/log/check.h"
+ #include "absl/strings/numbers.h"
+ #include "absl/strings/str_join.h"
+@@ -53,24 +52,14 @@ int32_t LoadConfigFromEnv(absl::string_view environment_variable,
+
+ bool LoadConfigFromEnv(absl::string_view environment_variable,
+                        bool default_value) {
+-  auto env = LoadEnv(environment_variable);
+-  if (env.has_value()) {
+-    bool out;
+-    std::string error;
+-    if (absl::ParseFlag(env->c_str(), &out, &error)) return out;
+-    fprintf(stderr, "Error reading bool from %s: '%s' is not a bool: %s",
+-            std::string(environment_variable).c_str(), env->c_str(),
+-            error.c_str());
+-  }
+   return default_value;
+ }
+
+-std::string LoadConfig(const absl::Flag<std::vector<std::string>>& flag,
++std::string LoadConfig(const std::vector<std::string>& from_flag,
+                        absl::string_view environment_variable,
+-                       const absl::optional<std::string>& override,
++                       const std::optional<std::string>& override,
+                        const char* default_value) {
+   if (override.has_value()) return *override;
+-  auto from_flag = absl::GetFlag(flag);
+   if (!from_flag.empty()) return absl::StrJoin(from_flag, ",");
+   return LoadConfigFromEnv(environment_variable, default_value);
+ }
+diff --git a/third_party/grpc/source/src/core/config/load_config.h b/third_party/grpc/source/src/core/config/load_config.h
+index 03a9e4bc283e4..e0ee9dd154909 100644
+--- a/third_party/grpc/source/src/core/config/load_config.h
++++ b/third_party/grpc/source/src/core/config/load_config.h
+@@ -22,7 +22,6 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/flags/flag.h"
+ #include "absl/strings/string_view.h"
+
+ namespace grpc_core {
+@@ -35,18 +34,17 @@ bool LoadConfigFromEnv(absl::string_view environment_variable,
+                        bool default_value);
+
+ template <typename T, typename D>
+-T LoadConfig(const absl::Flag<absl::optional<T>>& flag,
++T LoadConfig(const std::optional<T>& from_flag,
+              absl::string_view environment_variable,
+-             const absl::optional<T>& override, D default_value) {
++             const std::optional<T>& override, D default_value) {
+   if (override.has_value()) return *override;
+-  auto from_flag = absl::GetFlag(flag);
+   if (from_flag.has_value()) return std::move(*from_flag);
+   return LoadConfigFromEnv(environment_variable, default_value);
+ }
+
+-std::string LoadConfig(const absl::Flag<std::vector<std::string>>& flag,
++std::string LoadConfig(const std::vector<std::string>& from_flag,
+                        absl::string_view environment_variable,
+-                       const absl::optional<std::string>& override,
++                       const std::optional<std::string>& override,
+                        const char* default_value);
+
+ }  // namespace grpc_core
+--
+2.48.1.601.g30ceb7b040-goog
+
diff --git a/third_party/grpc/patches/0002-Replace-LOG-CHECK.patch b/third_party/grpc/patches/0002-Replace-LOG-CHECK.patch
new file mode 100644
index 0000000000000..3a3e1df64fda9
--- /dev/null
+++ b/third_party/grpc/patches/0002-Replace-LOG-CHECK.patch
@@ -0,0 +1,28838 @@
+From aef5e9d494520e87816e9945ebc0cd3d068f40c5 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Mon, 17 Feb 2025 13:47:05 +0000
+Subject: [PATCH] Replace LOG/CHECK with ABSL_* counterparts
+
+Chromium cannot use absl's LOG()/CHECK() as they conflict with the
+macros in //base. This was generated with the following script.
+
+find third_party/grpc/source -type f | while read file; do
+  sed -Ei '
+  s/absl\/log\/check.h/absl\/log\/absl_check.h/g;
+  s/ CHECK\(/ ABSL_CHECK\(/g;
+  s/ QCHECK\(/ ABSL_QCHECK\(/g;
+  s/ PCHECK\(/ ABSL_PCHECK\(/g;
+  s/ DCHECK\(/ ABSL_DCHECK\(/g;
+  s/ CHECK_EQ\(/ ABSL_CHECK_EQ\(/g;
+  s/ CHECK_NE\(/ ABSL_CHECK_NE\(/g;
+  s/ CHECK_LE\(/ ABSL_CHECK_LE\(/g;
+  s/ CHECK_LT\(/ ABSL_CHECK_LT\(/g;
+  s/ CHECK_GE\(/ ABSL_CHECK_GE\(/g;
+  s/ CHECK_GT\(/ ABSL_CHECK_GT\(/g;
+  s/ QCHECK_EQ\(/ ABSL_QCHECK_EQ\(/g;
+  s/ QCHECK_NE\(/ ABSL_QCHECK_NE\(/g;
+  s/ QCHECK_LE\(/ ABSL_QCHECK_LE\(/g;
+  s/ QCHECK_LT\(/ ABSL_QCHECK_LT\(/g;
+  s/ QCHECK_GE\(/ ABSL_QCHECK_GE\(/g;
+  s/ QCHECK_GT\(/ ABSL_QCHECK_GT\(/g;
+  s/ DCHECK_EQ\(/ ABSL_DCHECK_EQ\(/g;
+  s/ DCHECK_NE\(/ ABSL_DCHECK_NE\(/g;
+  s/ DCHECK_LE\(/ ABSL_DCHECK_LE\(/g;
+  s/ DCHECK_LT\(/ ABSL_DCHECK_LT\(/g;
+  s/ DCHECK_GE\(/ ABSL_DCHECK_GE\(/g;
+  s/ DCHECK_GT\(/ ABSL_DCHECK_GT\(/g;
+  s/ CHECK_OK\(/ ABSL_CHECK_OK\(/g;
+  s/ QCHECK_OK\(/ ABSL_QCHECK_OK\(/g;
+  s/ DCHECK_OK\(/ ABSL_DCHECK_OK\(/g;
+  s/ CHECK_STREQ\(/ ABSL_CHECK_STREQ\(/g;
+  s/ CHECK_STRNE\(/ ABSL_CHECK_STRNE\(/g;
+  s/ CHECK_STRCASEEQ\(/ ABSL_CHECK_STRCASEEQ\(/g;
+  s/ CHECK_STRCASENE\(/ ABSL_CHECK_STRCASENE\(/g;
+  s/ QCHECK_STREQ\(/ ABSL_QCHECK_STREQ\(/g;
+  s/ QCHECK_STRNE\(/ ABSL_QCHECK_STRNE\(/g;
+  s/ QCHECK_STRCASEEQ\(/ ABSL_QCHECK_STRCASEEQ\(/g;
+  s/ QCHECK_STRCASENE\(/ ABSL_QCHECK_STRCASENE\(/g;
+  s/ DCHECK_STREQ\(/ ABSL_DCHECK_STREQ\(/g;
+  s/ DCHECK_STRNE\(/ ABSL_DCHECK_STRNE\(/g;
+  s/ DCHECK_STRCASEEQ\(/ ABSL_DCHECK_STRCASEEQ\(/g;
+  s/ DCHECK_STRCASENE\(/ ABSL_DCHECK_STRCASENE\(/g;
+  s/absl\/log\/log.h/absl\/log\/absl_log.h/g;
+  s/ LOG\(/ ABSL_LOG\(/g;
+  s/ PLOG\(/ ABSL_PLOG\(/g;
+  s/ DLOG\(/ ABSL_DLOG\(/g;
+  s/ VLOG\(/ ABSL_VLOG\(/g;
+  s/ DVLOG\(/ ABSL_DVLOG\(/g;
+  s/ LOG_IF\(/ ABSL_LOG_IF\(/g;
+  s/ PLOG_IF\(/ ABSL_PLOG_IF\(/g;
+  s/ DLOG_IF\(/ ABSL_DLOG_IF\(/g;
+  s/ LOG_EVERY_N\(/ ABSL_LOG_EVERY_N\(/g;
+  s/ LOG_FIRST_N\(/ ABSL_LOG_FIRST_N\(/g;
+  s/ LOG_EVERY_POW_2\(/ ABSL_LOG_EVERY_POW_2\(/g;
+  s/ LOG_EVERY_N_SEC\(/ ABSL_LOG_EVERY_N_SEC\(/g;
+  s/ PLOG_EVERY_N\(/ ABSL_PLOG_EVERY_N\(/g;
+  s/ PLOG_FIRST_N\(/ ABSL_PLOG_FIRST_N\(/g;
+  s/ PLOG_EVERY_POW_2\(/ ABSL_PLOG_EVERY_POW_2\(/g;
+  s/ PLOG_EVERY_N_SEC\(/ ABSL_PLOG_EVERY_N_SEC\(/g;
+  s/ DLOG_EVERY_N\(/ ABSL_DLOG_EVERY_N\(/g;
+  s/ DLOG_FIRST_N\(/ ABSL_DLOG_FIRST_N\(/g;
+  s/ DLOG_EVERY_POW_2\(/ ABSL_DLOG_EVERY_POW_2\(/g;
+  s/ DLOG_EVERY_N_SEC\(/ ABSL_DLOG_EVERY_N_SEC\(/g;
+  s/ VLOG_EVERY_N\(/ ABSL_VLOG_EVERY_N\(/g;
+  s/ VLOG_FIRST_N\(/ ABSL_VLOG_FIRST_N\(/g;
+  s/ VLOG_EVERY_POW_2\(/ ABSL_VLOG_EVERY_POW_2\(/g;
+  s/ VLOG_EVERY_N_SEC\(/ ABSL_VLOG_EVERY_N_SEC\(/g;
+  s/ LOG_IF_EVERY_N\(/ ABSL_LOG_IF_EVERY_N\(/g;
+  s/ LOG_IF_FIRST_N\(/ ABSL_LOG_IF_FIRST_N\(/g;
+  s/ LOG_IF_EVERY_POW_2\(/ ABSL_LOG_IF_EVERY_POW_2\(/g;
+  s/ LOG_IF_EVERY_N_SEC\(/ ABSL_LOG_IF_EVERY_N_SEC\(/g;
+  s/ PLOG_IF_EVERY_N\(/ ABSL_PLOG_IF_EVERY_N\(/g;
+  s/ PLOG_IF_FIRST_N\(/ ABSL_PLOG_IF_FIRST_N\(/g;
+  s/ PLOG_IF_EVERY_POW_2\(/ ABSL_PLOG_IF_EVERY_POW_2\(/g;
+  s/ PLOG_IF_EVERY_N_SEC\(/ ABSL_PLOG_IF_EVERY_N_SEC\(/g;
+  s/ DLOG_IF_EVERY_N\(/ ABSL_DLOG_IF_EVERY_N\(/g;
+  s/ DLOG_IF_FIRST_N\(/ ABSL_DLOG_IF_FIRST_N\(/g;
+  s/ DLOG_IF_EVERY_POW_2\(/ ABSL_DLOG_IF_EVERY_POW_2\(/g;
+  s/ DLOG_IF_EVERY_N_SEC\(/ ABSL_DLOG_IF_EVERY_N_SEC\(/g;' $file
+done
+
+---
+ .../source/src/core/call/request_buffer.cc    |  10 +-
+ .../grpc/source/src/core/channelz/channelz.cc |   6 +-
+ .../src/core/channelz/channelz_registry.cc    |  10 +-
+ .../src/core/client_channel/backup_poller.cc  |   4 +-
+ .../src/core/client_channel/client_channel.cc |  26 +--
+ .../client_channel/client_channel_filter.cc   |  74 ++++----
+ .../client_channel/client_channel_internal.h  |   4 +-
+ .../src/core/client_channel/config_selector.h |   6 +-
+ .../core/client_channel/dynamic_filters.cc    |  10 +-
+ .../src/core/client_channel/lb_metadata.cc    |   4 +-
+ .../load_balanced_call_destination.cc         |  10 +-
+ .../client_channel/local_subchannel_pool.cc   |   8 +-
+ .../src/core/client_channel/retry_filter.h    |   6 +-
+ .../retry_filter_legacy_call_data.cc          |  16 +-
+ .../core/client_channel/retry_interceptor.cc  |   2 +-
+ .../core/client_channel/retry_interceptor.h   |   2 +-
+ .../client_channel/retry_service_config.cc    |   4 +-
+ .../src/core/client_channel/subchannel.cc     |  24 +--
+ .../subchannel_stream_client.cc               |  34 ++--
+ .../src/core/config/core_configuration.cc     |   6 +-
+ .../src/core/config/core_configuration.h      |   6 +-
+ .../source/src/core/config/load_config.cc     |   4 +-
+ .../backend_metrics/backend_metric_filter.cc  |   2 +-
+ .../fault_injection/fault_injection_filter.cc |   2 +-
+ .../gcp_authentication_filter.cc              |   2 +-
+ .../message_compress/compression_filter.cc    |  12 +-
+ .../filters/http/server/http_server_filter.cc |   2 +-
+ .../server_load_reporting_filter.cc           |   8 +-
+ .../ext/filters/logging/logging_filter.cc     |   6 +-
+ .../message_size/message_size_filter.cc       |   2 +-
+ .../stateful_session_filter.cc                |  14 +-
+ .../chaotic_good/chaotic_good_transport.h     |   2 +-
+ .../client/chaotic_good_connector.cc          |   8 +-
+ .../chaotic_good/client_transport.cc          |  10 +-
+ .../core/ext/transport/chaotic_good/config.h  |   2 +-
+ .../chaotic_good/control_endpoint.cc          |   2 +-
+ .../transport/chaotic_good/data_endpoints.cc  |  10 +-
+ .../core/ext/transport/chaotic_good/frame.cc  |  20 +--
+ .../core/ext/transport/chaotic_good/frame.h   |   8 +-
+ .../chaotic_good/message_reassembly.h         |   6 +-
+ .../server/chaotic_good_server.cc             |  40 ++---
+ .../chaotic_good/server/chaotic_good_server.h |   2 +-
+ .../chaotic_good/server_transport.cc          |  12 +-
+ .../core/ext/transport/chttp2/alpn/alpn.cc    |   4 +-
+ .../chttp2/client/chttp2_connector.cc         |  20 +--
+ .../transport/chttp2/server/chttp2_server.cc  |  36 ++--
+ .../transport/chttp2/transport/bin_decoder.cc |  28 +--
+ .../transport/chttp2/transport/bin_encoder.cc |  12 +-
+ .../chttp2/transport/chttp2_transport.cc      | 122 ++++++-------
+ .../chttp2/transport/flow_control.cc          |   8 +-
+ .../transport/chttp2/transport/flow_control.h |   6 +-
+ .../ext/transport/chttp2/transport/frame.cc   |   6 +-
+ .../transport/chttp2/transport/frame_data.cc  |   4 +-
+ .../chttp2/transport/frame_goaway.cc          |   8 +-
+ .../transport/chttp2/transport/frame_ping.cc  |   8 +-
+ .../chttp2/transport/frame_rst_stream.cc      |   6 +-
+ .../chttp2/transport/frame_settings.cc        |   4 +-
+ .../chttp2/transport/frame_window_update.cc   |   6 +-
+ .../chttp2/transport/hpack_encoder.cc         |  10 +-
+ .../chttp2/transport/hpack_encoder.h          |   4 +-
+ .../chttp2/transport/hpack_encoder_table.cc   |  16 +-
+ .../chttp2/transport/hpack_parse_result.cc    |   4 +-
+ .../chttp2/transport/hpack_parse_result.h     |   4 +-
+ .../chttp2/transport/hpack_parser.cc          |  50 +++---
+ .../chttp2/transport/hpack_parser_table.cc    |  10 +-
+ .../ext/transport/chttp2/transport/internal.h |   2 +-
+ .../ext/transport/chttp2/transport/parsing.cc |  32 ++--
+ .../chttp2/transport/ping_callbacks.cc        |   4 +-
+ .../chttp2/transport/stream_lists.cc          |  18 +-
+ .../ext/transport/chttp2/transport/varint.h   |   4 +-
+ .../chttp2/transport/write_size_policy.cc     |   4 +-
+ .../ext/transport/chttp2/transport/writing.cc |  18 +-
+ .../client/secure/cronet_channel_create.cc    |   4 +-
+ .../cronet/transport/cronet_api_phony.cc      |  20 +--
+ .../cronet/transport/cronet_transport.cc      |  22 +--
+ .../ext/transport/inproc/inproc_transport.cc  |   6 +-
+ .../inproc/legacy_inproc_transport.cc         |  14 +-
+ .../source/src/core/handshaker/handshaker.cc  |   8 +-
+ .../http_connect/http_connect_handshaker.cc   |   8 +-
+ .../http_connect/http_proxy_mapper.cc         |  30 ++--
+ .../http_connect/xds_http_proxy_mapper.cc     |   6 +-
+ .../handshaker/security/secure_endpoint.cc    |  18 +-
+ .../security/security_handshaker.cc           |   6 +-
+ .../tcp_connect/tcp_connect_handshaker.cc     |   6 +-
+ .../core/lib/address_utils/parse_address.cc   |  46 ++---
+ .../core/lib/address_utils/sockaddr_utils.cc  |  30 ++--
+ .../src/core/lib/channel/channel_args.cc      |  26 +--
+ .../src/core/lib/channel/channel_stack.cc     |  14 +-
+ .../src/core/lib/channel/connected_channel.cc |   4 +-
+ .../core/lib/channel/promise_based_filter.cc  | 114 ++++++------
+ .../core/lib/channel/promise_based_filter.h   |  64 +++----
+ .../lib/compression/compression_internal.cc   |   4 +-
+ .../core/lib/compression/message_compress.cc  |  26 +--
+ .../grpc/source/src/core/lib/debug/trace.cc   |  10 +-
+ .../source/src/core/lib/debug/trace_impl.h    |   8 +-
+ .../core/lib/event_engine/ares_resolver.cc    |  36 ++--
+ .../lib/event_engine/cf_engine/cf_engine.cc   |   8 +-
+ .../cf_engine/dns_service_resolver.cc         |   4 +-
+ .../cf_engine/dns_service_resolver.h          |   4 +-
+ .../src/core/lib/event_engine/forkable.cc     |  10 +-
+ .../posix_engine/ev_epoll1_linux.cc           |  26 +--
+ .../posix_engine/ev_poll_posix.cc             |  20 +--
+ .../posix_engine/internal_errqueue.cc         |   6 +-
+ .../posix_engine/lockfree_event.cc            |   4 +-
+ .../posix_engine/posix_endpoint.cc            |  66 +++----
+ .../posix_engine/posix_endpoint.h             |  26 +--
+ .../event_engine/posix_engine/posix_engine.cc |  24 +--
+ .../posix_engine/posix_engine_listener.cc     |  18 +-
+ .../posix_engine_listener_utils.cc            |  28 +--
+ .../posix_engine/tcp_socket_utils.cc          |  14 +-
+ .../posix_engine/tcp_socket_utils.h           |   4 +-
+ .../posix_engine/timer_manager.cc             |  10 +-
+ .../posix_engine/traced_buffer_list.cc        |   4 +-
+ .../core/lib/event_engine/resolved_address.cc |   6 +-
+ .../source/src/core/lib/event_engine/slice.cc |   4 +-
+ .../core/lib/event_engine/tcp_socket_utils.cc |  30 ++--
+ .../event_engine/thread_pool/thread_count.cc  |   2 +-
+ .../thread_pool/work_stealing_thread_pool.cc  |  22 +--
+ .../windows/grpc_polled_fd_windows.cc         |  58 +++----
+ .../src/core/lib/event_engine/windows/iocp.cc |  16 +-
+ .../lib/event_engine/windows/win_socket.cc    |  14 +-
+ .../event_engine/windows/windows_endpoint.cc  |  24 +--
+ .../event_engine/windows/windows_engine.cc    |  22 +--
+ .../event_engine/windows/windows_listener.cc  |  24 +--
+ .../source/src/core/lib/experiments/config.cc |  16 +-
+ .../source/src/core/lib/iomgr/buffer_list.cc  |   6 +-
+ .../src/core/lib/iomgr/call_combiner.cc       |   8 +-
+ .../source/src/core/lib/iomgr/call_combiner.h |   2 +-
+ .../src/core/lib/iomgr/cfstream_handle.cc     |   6 +-
+ .../grpc/source/src/core/lib/iomgr/closure.h  |   6 +-
+ .../source/src/core/lib/iomgr/combiner.cc     |  12 +-
+ .../src/core/lib/iomgr/endpoint_cfstream.cc   |  26 +--
+ .../src/core/lib/iomgr/endpoint_pair_posix.cc |  10 +-
+ .../core/lib/iomgr/endpoint_pair_windows.cc   |  22 +--
+ .../grpc/source/src/core/lib/iomgr/error.cc   |   8 +-
+ .../grpc/source/src/core/lib/iomgr/error.h    |   4 +-
+ .../src/core/lib/iomgr/ev_epoll1_linux.cc     |  42 ++---
+ .../src/core/lib/iomgr/ev_poll_posix.cc       |  22 +--
+ .../source/src/core/lib/iomgr/ev_posix.cc     |   2 +-
+ .../lib/iomgr/event_engine_shims/closure.cc   |   2 +-
+ .../lib/iomgr/event_engine_shims/endpoint.cc  |  14 +-
+ .../source/src/core/lib/iomgr/exec_ctx.cc     |  10 +-
+ .../grpc/source/src/core/lib/iomgr/exec_ctx.h |   6 +-
+ .../source/src/core/lib/iomgr/executor.cc     |  12 +-
+ .../source/src/core/lib/iomgr/fork_posix.cc   |   8 +-
+ .../source/src/core/lib/iomgr/fork_windows.cc |   4 +-
+ .../src/core/lib/iomgr/internal_errqueue.cc   |   6 +-
+ .../source/src/core/lib/iomgr/iocp_windows.cc |  20 +--
+ .../grpc/source/src/core/lib/iomgr/iomgr.cc   |  10 +-
+ .../src/core/lib/iomgr/iomgr_windows.cc       |   6 +-
+ .../src/core/lib/iomgr/lockfree_event.cc      |   6 +-
+ .../src/core/lib/iomgr/polling_entity.cc      |   8 +-
+ .../core/lib/iomgr/sockaddr_utils_posix.cc    |   4 +-
+ .../lib/iomgr/socket_utils_common_posix.cc    |  12 +-
+ .../src/core/lib/iomgr/socket_windows.cc      |  16 +-
+ .../src/core/lib/iomgr/tcp_client_cfstream.cc |   2 +-
+ .../src/core/lib/iomgr/tcp_client_posix.cc    |  14 +-
+ .../src/core/lib/iomgr/tcp_client_windows.cc  |   8 +-
+ .../source/src/core/lib/iomgr/tcp_posix.cc    | 106 ++++++------
+ .../src/core/lib/iomgr/tcp_server_posix.cc    |  58 +++----
+ .../iomgr/tcp_server_utils_posix_common.cc    |  16 +-
+ .../iomgr/tcp_server_utils_posix_ifaddrs.cc   |  12 +-
+ .../src/core/lib/iomgr/tcp_server_windows.cc  |  42 ++---
+ .../source/src/core/lib/iomgr/tcp_windows.cc  |  24 +--
+ .../src/core/lib/iomgr/timer_generic.cc       |  12 +-
+ .../src/core/lib/iomgr/timer_manager.cc       |  10 +-
+ .../src/core/lib/iomgr/unix_sockets_posix.cc  |   4 +-
+ .../core/lib/iomgr/unix_sockets_posix_noop.cc |   4 +-
+ .../src/core/lib/iomgr/wakeup_fd_pipe.cc      |   4 +-
+ .../source/src/core/lib/promise/activity.cc   |   4 +-
+ .../source/src/core/lib/promise/activity.h    |  12 +-
+ .../source/src/core/lib/promise/context.h     |   4 +-
+ .../src/core/lib/promise/detail/join_state.h  |  36 ++--
+ .../src/core/lib/promise/detail/seq_state.h   |  52 +++---
+ .../src/core/lib/promise/detail/status.h      |   4 +-
+ .../promise/event_engine_wakeup_scheduler.h   |   4 +-
+ .../source/src/core/lib/promise/for_each.h    |  12 +-
+ .../core/lib/promise/inter_activity_latch.h   |   2 +-
+ .../src/core/lib/promise/interceptor_list.h   |   6 +-
+ .../grpc/source/src/core/lib/promise/latch.h  |  16 +-
+ .../source/src/core/lib/promise/map_pipe.h    |   2 +-
+ .../grpc/source/src/core/lib/promise/mpsc.h   |   8 +-
+ .../source/src/core/lib/promise/observable.h  |   8 +-
+ .../grpc/source/src/core/lib/promise/party.cc |  36 ++--
+ .../grpc/source/src/core/lib/promise/party.h  |  18 +-
+ .../grpc/source/src/core/lib/promise/pipe.h   |  28 +--
+ .../grpc/source/src/core/lib/promise/poll.h   |   8 +-
+ .../src/core/lib/promise/promise_mutex.h      |  12 +-
+ .../source/src/core/lib/promise/status_flag.h |  14 +-
+ .../source/src/core/lib/promise/try_join.h    |   4 +-
+ .../source/src/core/lib/promise/try_seq.h     |   4 +-
+ .../src/core/lib/resource_quota/arena.cc      |   4 +-
+ .../src/core/lib/resource_quota/arena.h       |   2 +-
+ .../lib/resource_quota/connection_quota.cc    |   8 +-
+ .../core/lib/resource_quota/memory_quota.cc   |  22 +--
+ .../core/lib/resource_quota/memory_quota.h    |   8 +-
+ .../core/lib/resource_quota/thread_quota.cc   |   4 +-
+ .../security/authorization/audit_logging.cc   |  10 +-
+ .../authorization/cel_authorization_engine.cc |   8 +-
+ .../security/authorization/evaluate_args.cc   |  10 +-
+ .../grpc_authorization_engine.cc              |   4 +-
+ .../grpc_authorization_policy_provider.cc     |  16 +-
+ .../authorization/grpc_server_authz_filter.cc |   2 +-
+ .../lib/security/authorization/matchers.cc    |   4 +-
+ .../security/authorization/rbac_translator.cc |   6 +-
+ .../security/authorization/stdout_logger.cc   |   6 +-
+ .../certificate_provider_registry.cc          |   8 +-
+ .../lib/security/context/security_context.cc  |  12 +-
+ .../credentials/alts/check_gcp_environment.cc |   4 +-
+ .../alts/check_gcp_environment_no_op.cc       |   4 +-
+ .../grpc_alts_credentials_client_options.cc   |   4 +-
+ .../alts/grpc_alts_credentials_options.cc     |   4 +-
+ .../security/credentials/call_creds_util.cc   |  10 +-
+ .../composite/composite_credentials.cc        |  14 +-
+ .../lib/security/credentials/credentials.cc   |  10 +-
+ .../lib/security/credentials/credentials.h    |   6 +-
+ .../aws_external_account_credentials.cc       |   6 +-
+ .../external/external_account_credentials.cc  |  10 +-
+ .../url_external_account_credentials.cc       |   2 +-
+ ...cp_service_account_identity_credentials.cc |   2 +-
+ .../google_default/credentials_generic.cc     |   4 +-
+ .../google_default_credentials.cc             |  14 +-
+ .../credentials/iam/iam_credentials.cc        |   8 +-
+ .../security/credentials/jwt/json_token.cc    |  30 ++--
+ .../credentials/jwt/jwt_credentials.cc        |  12 +-
+ .../security/credentials/jwt/jwt_verifier.cc  | 102 +++++------
+ .../credentials/oauth2/oauth2_credentials.cc  |  42 ++---
+ .../credentials/plugin/plugin_credentials.cc  |   8 +-
+ .../credentials/ssl/ssl_credentials.cc        |  46 ++---
+ .../credentials/ssl/ssl_credentials.h         |   4 +-
+ .../tls/grpc_tls_certificate_distributor.cc   |  48 +++---
+ .../tls/grpc_tls_certificate_provider.cc      |  30 ++--
+ .../tls/grpc_tls_certificate_provider.h       |   4 +-
+ .../tls/grpc_tls_certificate_verifier.cc      |   4 +-
+ .../tls/grpc_tls_certificate_verifier.h       |   4 +-
+ .../tls/grpc_tls_credentials_options.cc       |  40 ++---
+ .../credentials/tls/grpc_tls_crl_provider.cc  |   4 +-
+ .../credentials/tls/tls_credentials.cc        |  18 +-
+ .../lib/security/credentials/tls/tls_utils.cc |   8 +-
+ .../credentials/xds/xds_credentials.cc        |  10 +-
+ .../alts/alts_security_connector.cc           |  30 ++--
+ .../fake/fake_security_connector.cc           |  14 +-
+ .../insecure/insecure_security_connector.cc   |   6 +-
+ .../load_system_roots_supported.cc            |   8 +-
+ .../local/local_security_connector.cc         |  24 +--
+ .../security_connector/security_connector.cc  |  14 +-
+ .../ssl/ssl_security_connector.cc             |  26 +--
+ .../security/security_connector/ssl_utils.cc  |  30 ++--
+ .../tls/tls_security_connector.cc             |  54 +++---
+ .../security/transport/server_auth_filter.cc  |   8 +-
+ .../src/core/lib/slice/percent_encoding.cc    |   4 +-
+ .../grpc/source/src/core/lib/slice/slice.cc   |  18 +-
+ .../grpc/source/src/core/lib/slice/slice.h    |   6 +-
+ .../source/src/core/lib/slice/slice_buffer.cc |  26 +--
+ .../src/core/lib/slice/slice_internal.h       |   4 +-
+ .../core/lib/surface/byte_buffer_reader.cc    |   4 +-
+ .../grpc/source/src/core/lib/surface/call.cc  |  22 +--
+ .../grpc/source/src/core/lib/surface/call.h   |   2 +-
+ .../src/core/lib/surface/call_log_batch.cc    |   2 +-
+ .../source/src/core/lib/surface/call_utils.cc |   8 +-
+ .../source/src/core/lib/surface/call_utils.h  |   4 +-
+ .../source/src/core/lib/surface/channel.cc    |   8 +-
+ .../src/core/lib/surface/channel_create.cc    |   4 +-
+ .../src/core/lib/surface/channel_init.cc      |  30 ++--
+ .../src/core/lib/surface/channel_init.h       |  14 +-
+ .../src/core/lib/surface/client_call.cc       |   8 +-
+ .../src/core/lib/surface/completion_queue.cc  |  60 +++----
+ .../lib/surface/completion_queue_factory.cc   |  12 +-
+ .../src/core/lib/surface/filter_stack_call.cc |  24 +--
+ .../src/core/lib/surface/filter_stack_call.h  |   6 +-
+ .../grpc/source/src/core/lib/surface/init.cc  |  14 +-
+ .../src/core/lib/surface/legacy_channel.cc    |  20 +--
+ .../src/core/lib/surface/server_call.cc       |   8 +-
+ .../source/src/core/lib/surface/server_call.h |   2 +-
+ .../src/core/lib/surface/validate_metadata.h  |   4 +-
+ .../src/core/lib/transport/bdp_estimator.cc   |   6 +-
+ .../src/core/lib/transport/bdp_estimator.h    |   8 +-
+ .../src/core/lib/transport/call_destination.h |   2 +-
+ .../src/core/lib/transport/call_filters.cc    |  10 +-
+ .../src/core/lib/transport/call_filters.h     |  66 +++----
+ .../src/core/lib/transport/call_spine.cc      |   4 +-
+ .../src/core/lib/transport/call_spine.h       |  10 +-
+ .../src/core/lib/transport/call_state.h       |  70 ++++----
+ .../core/lib/transport/connectivity_state.cc  |   2 +-
+ .../core/lib/transport/interception_chain.h   |   2 +-
+ .../src/core/lib/transport/metadata_batch.h   |   6 +-
+ .../core/lib/transport/promise_endpoint.cc    |   6 +-
+ .../src/core/lib/transport/promise_endpoint.h |  20 +--
+ .../core/lib/transport/timeout_encoding.cc    |   8 +-
+ .../source/src/core/lib/transport/transport.h |   4 +-
+ .../load_balancing/child_policy_handler.cc    |  28 +--
+ .../src/core/load_balancing/endpoint_list.cc  |   8 +-
+ .../src/core/load_balancing/grpclb/grpclb.cc  |  78 ++++-----
+ .../grpclb/load_balancer_api.cc               |   4 +-
+ .../load_balancing/health_check_client.cc     |   8 +-
+ .../core/load_balancing/lb_policy_registry.cc |   8 +-
+ .../core/load_balancing/oob_backend_metric.cc |   8 +-
+ .../outlier_detection/outlier_detection.cc    |  14 +-
+ .../load_balancing/pick_first/pick_first.cc   |  64 +++----
+ .../core/load_balancing/priority/priority.cc  |  10 +-
+ .../load_balancing/ring_hash/ring_hash.cc     |  14 +-
+ .../source/src/core/load_balancing/rls/rls.cc |  32 ++--
+ .../load_balancing/round_robin/round_robin.cc |  26 +--
+ .../static_stride_scheduler.cc                |   6 +-
+ .../weighted_round_robin.cc                   |  26 +--
+ .../weighted_target/weighted_target.cc        |  14 +-
+ .../source/src/core/load_balancing/xds/cds.cc |  14 +-
+ .../load_balancing/xds/xds_cluster_impl.cc    |  14 +-
+ .../load_balancing/xds/xds_cluster_manager.cc |   2 +-
+ .../load_balancing/xds/xds_override_host.cc   |  12 +-
+ .../load_balancing/xds/xds_wrr_locality.cc    |   6 +-
+ .../resolver/dns/c_ares/dns_resolver_ares.cc  |   4 +-
+ .../dns/c_ares/grpc_ares_ev_driver_posix.cc   |   4 +-
+ .../dns/c_ares/grpc_ares_ev_driver_windows.cc |  62 +++----
+ .../resolver/dns/c_ares/grpc_ares_wrapper.cc  |  34 ++--
+ .../resolver/dns/c_ares/grpc_ares_wrapper.h   |   2 +-
+ .../core/resolver/dns/dns_resolver_plugin.cc  |  10 +-
+ .../event_engine_client_channel_resolver.cc   |   8 +-
+ .../core/resolver/dns/native/dns_resolver.cc  |   6 +-
+ .../src/core/resolver/endpoint_addresses.cc   |   6 +-
+ .../src/core/resolver/fake/fake_resolver.cc   |   4 +-
+ .../google_c2p/google_c2p_resolver.cc         |  12 +-
+ .../src/core/resolver/polling_resolver.cc     |  32 ++--
+ .../src/core/resolver/resolver_registry.cc    |  14 +-
+ .../resolver/sockaddr/sockaddr_resolver.cc    |   4 +-
+ .../resolver/xds/xds_dependency_manager.cc    |   6 +-
+ .../src/core/resolver/xds/xds_resolver.cc     |  22 +--
+ .../grpc/source/src/core/server/server.cc     |  74 ++++----
+ .../server/server_config_selector_filter.cc   |   4 +-
+ .../core/server/xds_server_config_fetcher.cc  |  34 ++--
+ .../service_config_channel_arg_filter.cc      |   4 +-
+ .../core/service_config/service_config_impl.h |   4 +-
+ .../service_config/service_config_parser.cc   |   4 +-
+ .../source/src/core/telemetry/call_tracer.cc  |   8 +-
+ .../grpc/source/src/core/telemetry/metrics.cc |   4 +-
+ .../frame_protector/alts_frame_protector.cc   |  24 +--
+ .../tsi/alts/frame_protector/frame_handler.cc |   8 +-
+ .../alts/handshaker/alts_handshaker_client.cc | 122 ++++++-------
+ .../alts/handshaker/alts_shared_resource.cc   |   6 +-
+ .../alts/handshaker/alts_tsi_handshaker.cc    | 104 +++++------
+ .../tsi/alts/handshaker/alts_tsi_utils.cc     |  10 +-
+ .../transport_security_common_api.cc          |  18 +-
+ ...lts_grpc_integrity_only_record_protocol.cc |  22 +--
+ ..._grpc_privacy_integrity_record_protocol.cc |  14 +-
+ .../alts_grpc_record_protocol_common.cc       |  20 +--
+ .../alts_zero_copy_grpc_protector.cc          |  18 +-
+ .../src/core/tsi/fake_transport_security.cc   |  20 +--
+ .../src/core/tsi/local_transport_security.cc  |  10 +-
+ .../tsi/ssl/key_logging/ssl_key_logging.cc    |  14 +-
+ .../ssl/session_cache/ssl_session_cache.cc    |  24 +--
+ .../ssl/session_cache/ssl_session_openssl.cc  |   6 +-
+ .../src/core/tsi/ssl_transport_security.cc    | 162 +++++++++---------
+ .../core/tsi/ssl_transport_security_utils.cc  |  46 ++---
+ .../grpc/source/src/core/util/alloc.cc        |   4 +-
+ .../source/src/core/util/chunked_vector.h     |   8 +-
+ .../grpc/source/src/core/util/crash.cc        |   4 +-
+ .../grpc/source/src/core/util/down_cast.h     |   4 +-
+ .../source/src/core/util/dual_ref_counted.h   |  40 ++---
+ .../grpc/source/src/core/util/dump_args.cc    |   4 +-
+ .../grpc/source/src/core/util/dump_args.h     |   2 +-
+ .../grpc/source/src/core/util/event_log.cc    |   4 +-
+ .../src/core/util/gcp_metadata_query.cc       |   6 +-
+ .../grpc/source/src/core/util/gpr_time.cc     |  18 +-
+ .../core/util/grpc_if_nametoindex_posix.cc    |   4 +-
+ .../util/grpc_if_nametoindex_unsupported.cc   |   4 +-
+ .../grpc/source/src/core/util/host_port.cc    |  10 +-
+ .../src/core/util/http_client/httpcli.cc      |   6 +-
+ .../http_client/httpcli_security_connector.cc |  10 +-
+ .../src/core/util/http_client/parser.cc       |  10 +-
+ .../source/src/core/util/json/json_reader.cc  |   6 +-
+ .../grpc/source/src/core/util/latent_see.cc   |   2 +-
+ .../grpc/source/src/core/util/latent_see.h    |   8 +-
+ .../grpc/source/src/core/util/linux/cpu.cc    |  10 +-
+ third_party/grpc/source/src/core/util/log.cc  |  34 ++--
+ .../grpc/source/src/core/util/lru_cache.h     |   8 +-
+ third_party/grpc/source/src/core/util/mpscq.h |   6 +-
+ .../grpc/source/src/core/util/posix/cpu.cc    |   4 +-
+ .../grpc/source/src/core/util/posix/stat.cc   |  10 +-
+ .../grpc/source/src/core/util/posix/sync.cc   |  48 +++---
+ .../grpc/source/src/core/util/posix/thd.cc    |  24 +--
+ .../grpc/source/src/core/util/posix/time.cc   |  14 +-
+ .../source/src/core/util/posix/tmpfile.cc     |  10 +-
+ .../grpc/source/src/core/util/ref_counted.h   |  24 +--
+ .../source/src/core/util/single_set_ptr.h     |   4 +-
+ .../source/src/core/util/status_helper.cc     |   4 +-
+ .../source/src/core/util/subprocess_posix.cc  |  18 +-
+ .../src/core/util/subprocess_windows.cc       |   4 +-
+ third_party/grpc/source/src/core/util/sync.cc |   8 +-
+ third_party/grpc/source/src/core/util/sync.h  |   8 +-
+ .../grpc/source/src/core/util/tdigest.cc      |  28 +--
+ third_party/grpc/source/src/core/util/thd.h   |  12 +-
+ third_party/grpc/source/src/core/util/time.cc |  14 +-
+ third_party/grpc/source/src/core/util/time.h  |   2 +-
+ .../grpc/source/src/core/util/time_precise.cc |   6 +-
+ .../grpc/source/src/core/util/time_util.cc    |   6 +-
+ .../src/core/util/unique_ptr_with_bitset.h    |  10 +-
+ third_party/grpc/source/src/core/util/uri.cc  |   4 +-
+ .../grpc/source/src/core/util/useful.h        |   2 +-
+ .../source/src/core/util/validation_errors.cc |   4 +-
+ .../src/core/util/wait_for_single_owner.h     |   4 +-
+ .../grpc/source/src/core/util/windows/stat.cc |  10 +-
+ .../grpc/source/src/core/util/windows/sync.cc |   4 +-
+ .../grpc/source/src/core/util/windows/thd.cc  |  12 +-
+ .../grpc/source/src/core/util/windows/time.cc |   6 +-
+ .../source/src/core/util/work_serializer.cc   |   6 +-
+ .../xds/grpc/certificate_provider_store.cc    |   4 +-
+ ...le_watcher_certificate_provider_factory.cc |   4 +-
+ .../core/xds/grpc/xds_certificate_provider.cc |   6 +-
+ .../src/core/xds/grpc/xds_client_grpc.cc      |   2 +-
+ .../src/core/xds/grpc/xds_cluster_parser.cc   |  12 +-
+ .../xds/grpc/xds_cluster_specifier_plugin.cc  |   4 +-
+ .../src/core/xds/grpc/xds_endpoint_parser.cc  |  12 +-
+ .../core/xds/grpc/xds_http_filter_registry.cc |   6 +-
+ .../src/core/xds/grpc/xds_listener_parser.cc  |  14 +-
+ .../source/src/core/xds/grpc/xds_metadata.cc  |   6 +-
+ .../src/core/xds/grpc/xds_metadata_parser.cc  |   4 +-
+ .../core/xds/grpc/xds_route_config_parser.cc  |  26 +--
+ .../source/src/core/xds/grpc/xds_routing.cc   |   6 +-
+ .../src/core/xds/grpc/xds_transport_grpc.cc   |  20 +--
+ .../src/core/xds/xds_client/lrs_client.cc     |  26 +--
+ .../src/core/xds/xds_client/xds_client.cc     |  30 ++--
+ .../source/src/cpp/client/call_credentials.cc |   4 +-
+ .../grpc/source/src/cpp/client/channel_cc.cc  |   4 +-
+ .../source/src/cpp/client/client_context.cc   |  12 +-
+ .../src/cpp/client/global_callback_hook.cc    |   6 +-
+ .../src/cpp/client/secure_credentials.cc      |  10 +-
+ .../source/src/cpp/client/xds_credentials.cc  |   6 +-
+ .../grpc/source/src/cpp/common/alarm.cc       |  12 +-
+ .../grpc/source/src/cpp/common/alts_util.cc   |  10 +-
+ .../src/cpp/common/channel_arguments.cc       |  10 +-
+ .../src/cpp/common/completion_queue_cc.cc     |  12 +-
+ .../cpp/common/tls_certificate_provider.cc    |   8 +-
+ .../cpp/common/tls_certificate_verifier.cc    |  14 +-
+ .../src/cpp/common/tls_credentials_options.cc |  14 +-
+ .../src/cpp/ext/csm/csm_observability.cc      |   4 +-
+ .../src/cpp/ext/csm/metadata_exchange.cc      |   4 +-
+ .../cpp/ext/filters/census/client_filter.cc   |   6 +-
+ .../src/cpp/ext/gcp/environment_autodetect.cc |  14 +-
+ .../cpp/ext/gcp/observability_logging_sink.cc |  10 +-
+ .../src/cpp/ext/otel/key_value_iterable.h     |   4 +-
+ .../cpp/ext/otel/otel_client_call_tracer.cc   |   4 +-
+ .../source/src/cpp/ext/otel/otel_plugin.cc    |  82 ++++-----
+ .../src/cpp/server/backend_metric_recorder.cc |   4 +-
+ .../external_connection_acceptor_impl.cc      |  16 +-
+ .../health/default_health_check_service.cc    |  22 +--
+ .../get_cpu_stats_unsupported.cc              |   4 +-
+ .../server/load_reporter/load_data_store.cc   |  48 +++---
+ .../cpp/server/load_reporter/load_reporter.cc |  42 ++---
+ .../load_reporter_async_service_impl.cc       |  38 ++--
+ .../load_reporter_async_service_impl.h        |   6 +-
+ .../src/cpp/server/load_reporter/util.cc      |   4 +-
+ .../src/cpp/server/orca/orca_service.cc       |  10 +-
+ .../source/src/cpp/server/server_builder.cc   |  24 +--
+ .../grpc/source/src/cpp/server/server_cc.cc   |  44 ++---
+ .../source/src/cpp/server/server_context.cc   |  16 +-
+ .../src/cpp/server/xds_server_credentials.cc  |   6 +-
+ .../src/cpp/thread_manager/thread_manager.cc  |  10 +-
+ .../grpc_observability/observability_util.cc  |   2 +-
+ 458 files changed, 3471 insertions(+), 3471 deletions(-)
+
+diff --git a/third_party/grpc/source/src/core/call/request_buffer.cc b/third_party/grpc/source/src/core/call/request_buffer.cc
+index c53972d558fcc..37bbc3b30de7f 100644
+--- a/third_party/grpc/source/src/core/call/request_buffer.cc
++++ b/third_party/grpc/source/src/core/call/request_buffer.cc
+@@ -31,7 +31,7 @@ ValueOrFailure<size_t> RequestBuffer::PushClientInitialMetadata(
+   MutexLock lock(&mu_);
+   if (std::get_if<Cancelled>(&state_)) return Failure{};
+   auto& buffering = std::get<Buffering>(state_);
+-  CHECK_EQ(buffering.initial_metadata.get(), nullptr);
++  ABSL_CHECK_EQ(buffering.initial_metadata.get(), nullptr);
+   buffering.initial_metadata = std::move(md);
+   buffering.buffered += buffering.initial_metadata->TransportSize();
+   WakeupAsyncAllPullers();
+@@ -50,7 +50,7 @@ Poll<ValueOrFailure<size_t>> RequestBuffer::PollPushMessage(
+     buffering->messages.push_back(std::move(message));
+   } else {
+     auto& streaming = std::get<Streaming>(state_);
+-    CHECK_EQ(streaming.end_of_stream, false);
++    ABSL_CHECK_EQ(streaming.end_of_stream, false);
+     if (streaming.message != nullptr) {
+       return PendingPush();
+     }
+@@ -69,7 +69,7 @@ StatusFlag RequestBuffer::FinishSends() {
+     state_.emplace<Buffered>(std::move(buffered));
+   } else {
+     auto& streaming = std::get<Streaming>(state_);
+-    CHECK_EQ(streaming.end_of_stream, false);
++    ABSL_CHECK_EQ(streaming.end_of_stream, false);
+     streaming.end_of_stream = true;
+   }
+   WakeupAsyncAllPullers();
+@@ -85,7 +85,7 @@ void RequestBuffer::Cancel(absl::Status error) {
+
+ void RequestBuffer::Commit(Reader* winner) {
+   MutexLock lock(&mu_);
+-  CHECK_EQ(winner_, nullptr);
++  ABSL_CHECK_EQ(winner_, nullptr);
+   winner_ = winner;
+   if (auto* buffering = std::get_if<Buffering>(&state_)) {
+     if (buffering->initial_metadata != nullptr &&
+@@ -94,7 +94,7 @@ void RequestBuffer::Commit(Reader* winner) {
+       state_.emplace<Streaming>();
+     }
+   } else if (auto* buffered = std::get_if<Buffered>(&state_)) {
+-    CHECK_NE(buffered->initial_metadata.get(), nullptr);
++    ABSL_CHECK_NE(buffered->initial_metadata.get(), nullptr);
+     if (winner->message_index_ == buffered->messages.size()) {
+       state_.emplace<Streaming>().end_of_stream = true;
+     }
+diff --git a/third_party/grpc/source/src/core/channelz/channelz.cc b/third_party/grpc/source/src/core/channelz/channelz.cc
+index 1a8aa222a7292..1b5ddb619a1b4 100644
+--- a/third_party/grpc/source/src/core/channelz/channelz.cc
++++ b/third_party/grpc/source/src/core/channelz/channelz.cc
+@@ -26,7 +26,7 @@
+ #include <atomic>
+ #include <cstdint>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/escaping.h"
+ #include "absl/strings/str_cat.h"
+@@ -354,8 +354,8 @@ void ServerNode::RemoveChildListenSocket(intptr_t child_uuid) {
+
+ std::string ServerNode::RenderServerSockets(intptr_t start_socket_id,
+                                             intptr_t max_results) {
+-  CHECK_GE(start_socket_id, 0);
+-  CHECK_GE(max_results, 0);
++  ABSL_CHECK_GE(start_socket_id, 0);
++  ABSL_CHECK_GE(max_results, 0);
+   // If user does not set max_results, we choose 500.
+   size_t pagination_limit = max_results == 0 ? 500 : max_results;
+   Json::Object object;
+diff --git a/third_party/grpc/source/src/core/channelz/channelz_registry.cc b/third_party/grpc/source/src/core/channelz/channelz_registry.cc
+index 6db28fa7514c6..339d16f0bda2c 100644
+--- a/third_party/grpc/source/src/core/channelz/channelz_registry.cc
++++ b/third_party/grpc/source/src/core/channelz/channelz_registry.cc
+@@ -29,8 +29,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/channelz/channelz.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/util/json/json.h"
+@@ -57,9 +57,9 @@ void ChannelzRegistry::InternalRegister(BaseNode* node) {
+ }
+
+ void ChannelzRegistry::InternalUnregister(intptr_t uuid) {
+-  CHECK_GE(uuid, 1);
++  ABSL_CHECK_GE(uuid, 1);
+   MutexLock lock(&mu_);
+-  CHECK(uuid <= uuid_generator_);
++  ABSL_CHECK(uuid <= uuid_generator_);
+   node_map_.erase(uuid);
+ }
+
+@@ -170,7 +170,7 @@ void ChannelzRegistry::InternalLogAllEntities() {
+   }
+   for (size_t i = 0; i < nodes.size(); ++i) {
+     std::string json = nodes[i]->RenderJsonString();
+-    LOG(INFO) << json;
++    ABSL_LOG(INFO) << json;
+   }
+ }
+
+diff --git a/third_party/grpc/source/src/core/client_channel/backup_poller.cc b/third_party/grpc/source/src/core/client_channel/backup_poller.cc
+index ef13d2285e30c..5e85fa72ae7d2 100644
+--- a/third_party/grpc/source/src/core/client_channel/backup_poller.cc
++++ b/third_party/grpc/source/src/core/client_channel/backup_poller.cc
+@@ -23,7 +23,7 @@
+ #include <grpc/support/sync.h>
+ #include <inttypes.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/config/config_vars.h"
+ #include "src/core/lib/iomgr/closure.h"
+@@ -74,7 +74,7 @@ void grpc_client_channel_global_init_backup_polling() {
+   int32_t poll_interval_ms =
+       grpc_core::ConfigVars::Get().ClientChannelBackupPollIntervalMs();
+   if (poll_interval_ms < 0) {
+-    LOG(ERROR) << "Invalid GRPC_CLIENT_CHANNEL_BACKUP_POLL_INTERVAL_MS: "
++    ABSL_LOG(ERROR) << "Invalid GRPC_CLIENT_CHANNEL_BACKUP_POLL_INTERVAL_MS: "
+                << poll_interval_ms << ", default value "
+                << g_poll_interval.millis() << " will be used.";
+   } else {
+diff --git a/third_party/grpc/source/src/core/client_channel/client_channel.cc b/third_party/grpc/source/src/core/client_channel/client_channel.cc
+index fad45a360849a..a7d729d9a4c58 100644
+--- a/third_party/grpc/source/src/core/client_channel/client_channel.cc
++++ b/third_party/grpc/source/src/core/client_channel/client_channel.cc
+@@ -37,7 +37,7 @@
+ #include <vector>
+
+ #include "absl/cleanup/cleanup.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/cord.h"
+@@ -283,7 +283,7 @@ class ClientChannel::SubchannelWrapper::WatcherWrapper
+           }
+         }
+       } else {
+-        LOG(ERROR) << "client_channel="
++        ABSL_LOG(ERROR) << "client_channel="
+                    << subchannel_wrapper_->client_channel_.get()
+                    << ": Illegal keepalive throttling value "
+                    << std::string(keepalive_throttling.value());
+@@ -316,7 +316,7 @@ ClientChannel::SubchannelWrapper::SubchannelWrapper(
+       << ": creating subchannel wrapper " << this << " for subchannel "
+       << subchannel_.get();
+ #ifndef NDEBUG
+-  DCHECK(client_channel_->work_serializer_->RunningInWorkSerializer());
++  ABSL_DCHECK(client_channel_->work_serializer_->RunningInWorkSerializer());
+ #endif
+   if (client_channel_->channelz_node_ != nullptr) {
+     auto* subchannel_node = subchannel_->channelz_node();
+@@ -357,7 +357,7 @@ void ClientChannel::SubchannelWrapper::Orphaned() {
+           if (subchannel_node != nullptr) {
+             auto it = self->client_channel_->subchannel_refcount_map_.find(
+                 self->subchannel_.get());
+-            CHECK(it != self->client_channel_->subchannel_refcount_map_.end());
++            ABSL_CHECK(it != self->client_channel_->subchannel_refcount_map_.end());
+             --it->second;
+             if (it->second == 0) {
+               self->client_channel_->channelz_node_->RemoveChildSubchannel(
+@@ -372,7 +372,7 @@ void ClientChannel::SubchannelWrapper::Orphaned() {
+ void ClientChannel::SubchannelWrapper::WatchConnectivityState(
+     std::unique_ptr<ConnectivityStateWatcherInterface> watcher) {
+   auto& watcher_wrapper = watcher_map_[watcher.get()];
+-  CHECK(watcher_wrapper == nullptr);
++  ABSL_CHECK(watcher_wrapper == nullptr);
+   watcher_wrapper = new WatcherWrapper(
+       std::move(watcher),
+       RefAsSubclass<SubchannelWrapper>(DEBUG_LOCATION, "WatcherWrapper"));
+@@ -384,7 +384,7 @@ void ClientChannel::SubchannelWrapper::WatchConnectivityState(
+ void ClientChannel::SubchannelWrapper::CancelConnectivityStateWatch(
+     ConnectivityStateWatcherInterface* watcher) {
+   auto it = watcher_map_.find(watcher);
+-  CHECK(it != watcher_map_.end());
++  ABSL_CHECK(it != watcher_map_.end());
+   subchannel_->CancelConnectivityStateWatch(it->second);
+   watcher_map_.erase(it);
+ }
+@@ -393,7 +393,7 @@ void ClientChannel::SubchannelWrapper::AddDataWatcher(
+     std::unique_ptr<DataWatcherInterface> watcher) {
+   static_cast<InternalSubchannelDataWatcherInterface*>(watcher.get())
+       ->SetSubchannel(subchannel_.get());
+-  CHECK(data_watchers_.insert(std::move(watcher)).second);
++  ABSL_CHECK(data_watchers_.insert(std::move(watcher)).second);
+ }
+
+ void ClientChannel::SubchannelWrapper::CancelDataWatcher(
+@@ -452,7 +452,7 @@ class ClientChannel::ClientChannelControlHelper
+       const char* extra = client_channel_->disconnect_error_.ok()
+                               ? ""
+                               : " (ignoring -- channel shutting down)";
+-      LOG(INFO) << "client_channel=" << client_channel_.get()
++      ABSL_LOG(INFO) << "client_channel=" << client_channel_.get()
+                 << ": update: state=" << ConnectivityStateName(state)
+                 << " status=(" << status << ") picker=" << picker.get()
+                 << extra;
+@@ -624,7 +624,7 @@ ClientChannel::ClientChannel(
+       work_serializer_(std::make_shared<WorkSerializer>(event_engine_)),
+       state_tracker_("client_channel", GRPC_CHANNEL_IDLE),
+       subchannel_pool_(GetSubchannelPool(channel_args_)) {
+-  CHECK(event_engine_.get() != nullptr);
++  ABSL_CHECK(event_engine_.get() != nullptr);
+   GRPC_TRACE_LOG(client_channel, INFO)
+       << "client_channel=" << this << ": creating client_channel";
+   // Set initial keepalive time.
+@@ -927,7 +927,7 @@ void ClientChannel::CreateResolverLocked() {
+           WeakRefAsSubclass<ClientChannel>()));
+   // Since the validity of the args was checked when the channel was created,
+   // CreateResolver() must return a non-null result.
+-  CHECK(resolver_ != nullptr);
++  ABSL_CHECK(resolver_ != nullptr);
+   UpdateStateLocked(GRPC_CHANNEL_CONNECTING, absl::Status(),
+                     "started resolving");
+   resolver_->StartLocked();
+@@ -989,11 +989,11 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
+               .LoadBalancingPolicyExists(*policy_name, &requires_config) ||
+          requires_config)) {
+       if (requires_config) {
+-        LOG(ERROR) << "LB policy: " << *policy_name
++        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
+                    << " passed through channel_args must not "
+                       "require a config. Using pick_first instead.";
+       } else {
+-        LOG(ERROR) << "LB policy: " << *policy_name
++        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
+                    << " passed through channel_args does not exist. "
+                       "Using pick_first instead.";
+       }
+@@ -1019,7 +1019,7 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
+   // - A channel arg, in which case we check that the specified policy exists
+   //   and accepts an empty config. If not, we revert to using pick_first
+   //   lb_policy
+-  CHECK_OK(lb_policy_config);
++  ABSL_CHECK_OK(lb_policy_config);
+   return std::move(*lb_policy_config);
+ }
+
+diff --git a/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc b/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc
+index 3182f1dcfdb88..567e3d6c8bec1 100644
+--- a/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc
++++ b/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc
+@@ -38,8 +38,8 @@
+ #include <vector>
+
+ #include "absl/cleanup/cleanup.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/cord.h"
+@@ -337,8 +337,8 @@ class DynamicTerminationFilter final {
+
+   static grpc_error_handle Init(grpc_channel_element* elem,
+                                 grpc_channel_element_args* args) {
+-    CHECK(args->is_last);
+-    CHECK(elem->filter == &kFilterVtable);
++    ABSL_CHECK(args->is_last);
++    ABSL_CHECK(elem->filter == &kFilterVtable);
+     new (elem->channel_data) DynamicTerminationFilter(args->channel_args);
+     return absl::OkStatus();
+   }
+@@ -500,7 +500,7 @@ class ClientChannelFilter::SubchannelWrapper final
+         << " for subchannel " << subchannel_.get();
+     GRPC_CHANNEL_STACK_REF(chand_->owning_stack_, "SubchannelWrapper");
+ #ifndef NDEBUG
+-    DCHECK(chand_->work_serializer_->RunningInWorkSerializer());
++    ABSL_DCHECK(chand_->work_serializer_->RunningInWorkSerializer());
+ #endif
+     if (chand_->channelz_node_ != nullptr) {
+       auto* subchannel_node = subchannel_->channelz_node();
+@@ -536,7 +536,7 @@ class ClientChannelFilter::SubchannelWrapper final
+         auto* subchannel_node = subchannel_->channelz_node();
+         if (subchannel_node != nullptr) {
+           auto it = chand_->subchannel_refcount_map_.find(subchannel_.get());
+-          CHECK(it != chand_->subchannel_refcount_map_.end());
++          ABSL_CHECK(it != chand_->subchannel_refcount_map_.end());
+           --it->second;
+           if (it->second == 0) {
+             chand_->channelz_node_->RemoveChildSubchannel(
+@@ -553,7 +553,7 @@ class ClientChannelFilter::SubchannelWrapper final
+       std::unique_ptr<ConnectivityStateWatcherInterface> watcher) override
+       ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {
+     auto& watcher_wrapper = watcher_map_[watcher.get()];
+-    CHECK_EQ(watcher_wrapper, nullptr);
++    ABSL_CHECK_EQ(watcher_wrapper, nullptr);
+     watcher_wrapper = new WatcherWrapper(
+         std::move(watcher),
+         RefAsSubclass<SubchannelWrapper>(DEBUG_LOCATION, "WatcherWrapper"));
+@@ -565,7 +565,7 @@ class ClientChannelFilter::SubchannelWrapper final
+   void CancelConnectivityStateWatch(ConnectivityStateWatcherInterface* watcher)
+       override ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {
+     auto it = watcher_map_.find(watcher);
+-    CHECK(it != watcher_map_.end());
++    ABSL_CHECK(it != watcher_map_.end());
+     subchannel_->CancelConnectivityStateWatch(it->second);
+     watcher_map_.erase(it);
+   }
+@@ -582,7 +582,7 @@ class ClientChannelFilter::SubchannelWrapper final
+       ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {
+     static_cast<InternalSubchannelDataWatcherInterface*>(watcher.get())
+         ->SetSubchannel(subchannel_.get());
+-    CHECK(data_watchers_.insert(std::move(watcher)).second);
++    ABSL_CHECK(data_watchers_.insert(std::move(watcher)).second);
+   }
+
+   void CancelDataWatcher(DataWatcherInterface* watcher) override
+@@ -675,7 +675,7 @@ class ClientChannelFilter::SubchannelWrapper final
+             }
+           }
+         } else {
+-          LOG(ERROR) << "chand=" << parent_->chand_
++          ABSL_LOG(ERROR) << "chand=" << parent_->chand_
+                      << ": Illegal keepalive throttling value "
+                      << std::string(keepalive_throttling.value());
+         }
+@@ -745,7 +745,7 @@ ClientChannelFilter::ExternalConnectivityWatcher::ExternalConnectivityWatcher(
+   {
+     MutexLock lock(&chand_->external_watchers_mu_);
+     // Will be deleted when the watch is complete.
+-    CHECK(chand->external_watchers_[on_complete] == nullptr);
++    ABSL_CHECK(chand->external_watchers_[on_complete] == nullptr);
+     // Store a ref to the watcher in the external_watchers_ map.
+     chand->external_watchers_[on_complete] =
+         RefAsSubclass<ExternalConnectivityWatcher>(
+@@ -1016,8 +1016,8 @@ class ClientChannelFilter::ClientChannelControlHelper final
+
+ grpc_error_handle ClientChannelFilter::Init(grpc_channel_element* elem,
+                                             grpc_channel_element_args* args) {
+-  CHECK(args->is_last);
+-  CHECK(elem->filter == &kFilter);
++  ABSL_CHECK(args->is_last);
++  ABSL_CHECK(elem->filter == &kFilter);
+   grpc_error_handle error;
+   new (elem->channel_data) ClientChannelFilter(args, &error);
+   return error;
+@@ -1175,11 +1175,11 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
+               .LoadBalancingPolicyExists(*policy_name, &requires_config) ||
+          requires_config)) {
+       if (requires_config) {
+-        LOG(ERROR) << "LB policy: " << *policy_name
++        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
+                    << " passed through channel_args must not "
+                       "require a config. Using pick_first instead.";
+       } else {
+-        LOG(ERROR) << "LB policy: " << *policy_name
++        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
+                    << " passed through channel_args does not exist. "
+                       "Using pick_first instead.";
+       }
+@@ -1205,7 +1205,7 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
+   // - A channel arg, in which case we check that the specified policy exists
+   //   and accepts an empty config. If not, we revert to using pick_first
+   //   lb_policy
+-  CHECK(lb_policy_config.ok());
++  ABSL_CHECK(lb_policy_config.ok());
+   return std::move(*lb_policy_config);
+ }
+
+@@ -1475,7 +1475,7 @@ void ClientChannelFilter::UpdateServiceConfigInDataPlaneLocked(
+   auto new_blackboard = MakeRefCounted<Blackboard>();
+   RefCountedPtr<DynamicFilters> dynamic_filters = DynamicFilters::Create(
+       new_args, std::move(filters), blackboard_.get(), new_blackboard.get());
+-  CHECK(dynamic_filters != nullptr);
++  ABSL_CHECK(dynamic_filters != nullptr);
+   blackboard_ = std::move(new_blackboard);
+   // Grab data plane lock to update service config.
+   //
+@@ -1506,7 +1506,7 @@ void ClientChannelFilter::CreateResolverLocked() {
+       std::make_unique<ResolverResultHandler>(this));
+   // Since the validity of the args was checked when the channel was created,
+   // CreateResolver() must return a non-null result.
+-  CHECK(resolver_ != nullptr);
++  ABSL_CHECK(resolver_ != nullptr);
+   UpdateStateLocked(GRPC_CHANNEL_CONNECTING, absl::Status(),
+                     "started resolving");
+   resolver_->StartLocked();
+@@ -1611,7 +1611,7 @@ T HandlePickResult(
+   }
+   auto* drop_pick =
+       std::get_if<LoadBalancingPolicy::PickResult::Drop>(&result->result);
+-  CHECK_NE(drop_pick, nullptr);
++  ABSL_CHECK_NE(drop_pick, nullptr);
+   return drop_func(drop_pick);
+ }
+
+@@ -1704,7 +1704,7 @@ void ClientChannelFilter::StartTransportOpLocked(grpc_transport_op* op) {
+       }
+     } else {
+       // Disconnect.
+-      CHECK(disconnect_error_.ok());
++      ABSL_CHECK(disconnect_error_.ok());
+       disconnect_error_ = op->disconnect_with_error;
+       UpdateStateAndPickerLocked(
+           GRPC_CHANNEL_SHUTDOWN, absl::Status(), "shutdown from API",
+@@ -1722,7 +1722,7 @@ void ClientChannelFilter::StartTransportOpLocked(grpc_transport_op* op) {
+ void ClientChannelFilter::StartTransportOp(grpc_channel_element* elem,
+                                            grpc_transport_op* op) {
+   auto* chand = static_cast<ClientChannelFilter*>(elem->channel_data);
+-  CHECK(op->set_accept_stream == false);
++  ABSL_CHECK(op->set_accept_stream == false);
+   // Handle bind_pollset.
+   if (op->bind_pollset != nullptr) {
+     grpc_pollset_set_add_pollset(chand->interested_parties_, op->bind_pollset);
+@@ -1943,7 +1943,7 @@ ClientChannelFilter::FilterBasedCallData::~FilterBasedCallData() {
+   CSliceUnref(path_);
+   // Make sure there are no remaining pending batches.
+   for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+-    CHECK_EQ(pending_batches_[i], nullptr);
++    ABSL_CHECK_EQ(pending_batches_[i], nullptr);
+   }
+ }
+
+@@ -1974,7 +1974,7 @@ void ClientChannelFilter::FilterBasedCallData::StartTransportStreamOpBatch(
+   auto* chand = static_cast<ClientChannelFilter*>(elem->channel_data);
+   if (GRPC_TRACE_FLAG_ENABLED(client_channel_call) &&
+       !GRPC_TRACE_FLAG_ENABLED(channel)) {
+-    LOG(INFO) << "chand=" << chand << " calld=" << calld
++    ABSL_LOG(INFO) << "chand=" << chand << " calld=" << calld
+               << ": batch started from above: "
+               << grpc_transport_stream_op_batch_string(batch, false);
+   }
+@@ -2091,7 +2091,7 @@ void ClientChannelFilter::FilterBasedCallData::PendingBatchesAdd(
+       << "chand=" << chand() << " calld=" << this
+       << ": adding pending batch at index " << idx;
+   grpc_transport_stream_op_batch*& pending = pending_batches_[idx];
+-  CHECK_EQ(pending, nullptr);
++  ABSL_CHECK_EQ(pending, nullptr);
+   pending = batch;
+ }
+
+@@ -2111,13 +2111,13 @@ void ClientChannelFilter::FilterBasedCallData::FailPendingBatchInCallCombiner(
+ void ClientChannelFilter::FilterBasedCallData::PendingBatchesFail(
+     grpc_error_handle error,
+     YieldCallCombinerPredicate yield_call_combiner_predicate) {
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   if (GRPC_TRACE_FLAG_ENABLED(client_channel_call)) {
+     size_t num_batches = 0;
+     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+       if (pending_batches_[i] != nullptr) ++num_batches;
+     }
+-    LOG(INFO) << "chand=" << chand() << " calld=" << this << ": failing "
++    ABSL_LOG(INFO) << "chand=" << chand() << " calld=" << this << ": failing "
+               << num_batches << " pending batches: " << StatusToString(error);
+   }
+   CallCombinerClosureList closures;
+@@ -2159,7 +2159,7 @@ void ClientChannelFilter::FilterBasedCallData::PendingBatchesResume() {
+     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+       if (pending_batches_[i] != nullptr) ++num_batches;
+     }
+-    LOG(INFO) << "chand=" << chand() << " calld=" << this << ": starting "
++    ABSL_LOG(INFO) << "chand=" << chand() << " calld=" << this << ": starting "
+               << num_batches
+               << " pending batches on dynamic_call=" << dynamic_call_.get();
+   }
+@@ -2530,11 +2530,11 @@ ClientChannelFilter::LoadBalancedCall::PickSubchannel(bool was_queued) {
+
+ bool ClientChannelFilter::LoadBalancedCall::PickSubchannelImpl(
+     LoadBalancingPolicy::SubchannelPicker* picker, grpc_error_handle* error) {
+-  CHECK(connected_subchannel_ == nullptr);
++  ABSL_CHECK(connected_subchannel_ == nullptr);
+   // Perform LB pick.
+   LoadBalancingPolicy::PickArgs pick_args;
+   Slice* path = send_initial_metadata()->get_pointer(HttpPathMetadata());
+-  CHECK_NE(path, nullptr);
++  ABSL_CHECK_NE(path, nullptr);
+   pick_args.path = path->as_string_view();
+   LbCallState lb_call_state(this);
+   pick_args.call_state = &lb_call_state;
+@@ -2549,7 +2549,7 @@ bool ClientChannelFilter::LoadBalancedCall::PickSubchannelImpl(
+             << "chand=" << chand_ << " lb_call=" << this
+             << ": LB pick succeeded: subchannel="
+             << complete_pick->subchannel.get();
+-        CHECK(complete_pick->subchannel != nullptr);
++        ABSL_CHECK(complete_pick->subchannel != nullptr);
+         // Grab a ref to the connected subchannel while we're still
+         // holding the data plane mutex.
+         SubchannelWrapper* subchannel =
+@@ -2634,7 +2634,7 @@ ClientChannelFilter::FilterBasedLoadBalancedCall::
+     ~FilterBasedLoadBalancedCall() {
+   // Make sure there are no remaining pending batches.
+   for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+-    CHECK_EQ(pending_batches_[i], nullptr);
++    ABSL_CHECK_EQ(pending_batches_[i], nullptr);
+   }
+   if (on_call_destruction_complete_ != nullptr) {
+     ExecCtx::Run(DEBUG_LOCATION, on_call_destruction_complete_,
+@@ -2675,7 +2675,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::PendingBatchesAdd(
+   GRPC_TRACE_LOG(client_channel_lb_call, INFO)
+       << "chand=" << chand() << " lb_call=" << this
+       << ": adding pending batch at index " << idx;
+-  CHECK_EQ(pending_batches_[idx], nullptr);
++  ABSL_CHECK_EQ(pending_batches_[idx], nullptr);
+   pending_batches_[idx] = batch;
+ }
+
+@@ -2695,14 +2695,14 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::
+ void ClientChannelFilter::FilterBasedLoadBalancedCall::PendingBatchesFail(
+     grpc_error_handle error,
+     YieldCallCombinerPredicate yield_call_combiner_predicate) {
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   failure_error_ = error;
+   if (GRPC_TRACE_FLAG_ENABLED(client_channel_lb_call)) {
+     size_t num_batches = 0;
+     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+       if (pending_batches_[i] != nullptr) ++num_batches;
+     }
+-    LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": failing "
++    ABSL_LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": failing "
+               << num_batches << " pending batches: " << StatusToString(error);
+   }
+   CallCombinerClosureList closures;
+@@ -2743,7 +2743,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::PendingBatchesResume() {
+     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+       if (pending_batches_[i] != nullptr) ++num_batches;
+     }
+-    LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": starting "
++    ABSL_LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": starting "
+               << num_batches << " pending batches on subchannel_call="
+               << subchannel_call_.get();
+   }
+@@ -2768,7 +2768,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::
+     StartTransportStreamOpBatch(grpc_transport_stream_op_batch* batch) {
+   if (GRPC_TRACE_FLAG_ENABLED(client_channel_lb_call) ||
+       GRPC_TRACE_FLAG_ENABLED(channel)) {
+-    LOG(INFO) << "chand=" << chand() << " lb_call=" << this
++    ABSL_LOG(INFO) << "chand=" << chand() << " lb_call=" << this
+               << ": batch started from above: "
+               << grpc_transport_stream_op_batch_string(batch, false)
+               << ", call_attempt_tracer()=" << call_attempt_tracer();
+@@ -3041,7 +3041,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::RetryPickLocked() {
+
+ void ClientChannelFilter::FilterBasedLoadBalancedCall::CreateSubchannelCall() {
+   Slice* path = send_initial_metadata()->get_pointer(HttpPathMetadata());
+-  CHECK_NE(path, nullptr);
++  ABSL_CHECK_NE(path, nullptr);
+   SubchannelCall::Args call_args = {
+       connected_subchannel()->Ref(), pollent_, path->Ref(), /*start_time=*/0,
+       arena()->GetContext<Call>()->deadline(),
+diff --git a/third_party/grpc/source/src/core/client_channel/client_channel_internal.h b/third_party/grpc/source/src/core/client_channel/client_channel_internal.h
+index 99e045c00476c..383f0456c4542 100644
+--- a/third_party/grpc/source/src/core/client_channel/client_channel_internal.h
++++ b/third_party/grpc/source/src/core/client_channel/client_channel_internal.h
+@@ -22,7 +22,7 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/resource_quota/arena.h"
+ #include "src/core/lib/transport/call_destination.h"
+ #include "src/core/load_balancing/lb_policy.h"
+@@ -64,7 +64,7 @@ class ClientChannelServiceConfigCallData final : public ServiceConfigCallData {
+       : ServiceConfigCallData(arena) {}
+
+   void SetOnCommit(absl::AnyInvocable<void()> on_commit) {
+-    CHECK(on_commit_ == nullptr);
++    ABSL_CHECK(on_commit_ == nullptr);
+     on_commit_ = std::move(on_commit);
+   }
+
+diff --git a/third_party/grpc/source/src/core/client_channel/config_selector.h b/third_party/grpc/source/src/core/client_channel/config_selector.h
+index 2901ee471bd98..1f9b59c4a30af 100644
+--- a/third_party/grpc/source/src/core/client_channel/config_selector.h
++++ b/third_party/grpc/source/src/core/client_channel/config_selector.h
+@@ -24,7 +24,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/client_channel/client_channel_internal.h"
+@@ -94,7 +94,7 @@ class DefaultConfigSelector final : public ConfigSelector {
+     // The client channel code ensures that this will never be null.
+     // If neither the resolver nor the client application provide a
+     // config, a default empty config will be used.
+-    DCHECK(service_config_ != nullptr);
++    ABSL_DCHECK(service_config_ != nullptr);
+   }
+
+   UniqueTypeName name() const override {
+@@ -104,7 +104,7 @@ class DefaultConfigSelector final : public ConfigSelector {
+
+   absl::Status GetCallConfig(GetCallConfigArgs args) override {
+     Slice* path = args.initial_metadata->get_pointer(HttpPathMetadata());
+-    CHECK_NE(path, nullptr);
++    ABSL_CHECK_NE(path, nullptr);
+     auto* parsed_method_configs =
+         service_config_->GetMethodParsedConfigVector(path->c_slice());
+     args.service_config_call_data->SetServiceConfig(service_config_,
+diff --git a/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc b/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc
+index 93a3c49d9572e..10535421d6a52 100644
+--- a/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc
++++ b/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc
+@@ -22,8 +22,8 @@
+ #include <new>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/channel/channel_stack.h"
+@@ -64,7 +64,7 @@ DynamicFilters::Call::Call(Args args, grpc_error_handle* error)
+   *error = grpc_call_stack_init(channel_stack_->channel_stack_.get(), 1,
+                                 Destroy, this, &call_args);
+   if (GPR_UNLIKELY(!error->ok())) {
+-    LOG(ERROR) << "error: " << StatusToString(*error);
++    ABSL_LOG(ERROR) << "error: " << StatusToString(*error);
+     return;
+   }
+   grpc_call_stack_set_pollset_or_pollset_set(call_stack, args.pollent);
+@@ -81,8 +81,8 @@ void DynamicFilters::Call::StartTransportStreamOpBatch(
+ }
+
+ void DynamicFilters::Call::SetAfterCallStackDestroy(grpc_closure* closure) {
+-  CHECK_EQ(after_call_stack_destroy_, nullptr);
+-  CHECK_NE(closure, nullptr);
++  ABSL_CHECK_EQ(after_call_stack_destroy_, nullptr);
++  ABSL_CHECK_NE(closure, nullptr);
+   after_call_stack_destroy_ = closure;
+ }
+
+diff --git a/third_party/grpc/source/src/core/client_channel/lb_metadata.cc b/third_party/grpc/source/src/core/client_channel/lb_metadata.cc
+index 59f19f5951731..ca59728985cb0 100644
+--- a/third_party/grpc/source/src/core/client_channel/lb_metadata.cc
++++ b/third_party/grpc/source/src/core/client_channel/lb_metadata.cc
+@@ -14,7 +14,7 @@
+
+ #include "src/core/client_channel/lb_metadata.h"
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+
+ namespace grpc_core {
+
+@@ -92,7 +92,7 @@ void MetadataMutationHandler::Apply(
+     }
+     metadata->Append(key, std::move(value),
+                      [key = key](absl::string_view error, const Slice& value) {
+-                       LOG(ERROR) << error << " key:" << key
++                       ABSL_LOG(ERROR) << error << " key:" << key
+                                   << " value:" << value.as_string_view();
+                      });
+   }
+diff --git a/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc b/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc
+index fd2d4ba010c0d..1d0929fef72cf 100644
+--- a/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc
++++ b/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc
+@@ -14,7 +14,7 @@
+
+ #include "src/core/client_channel/load_balanced_call_destination.h"
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/client_channel/client_channel.h"
+ #include "src/core/client_channel/client_channel_internal.h"
+ #include "src/core/client_channel/lb_metadata.h"
+@@ -78,7 +78,7 @@ T HandlePickResult(
+   }
+   auto* drop_pick =
+       std::get_if<LoadBalancingPolicy::PickResult::Drop>(&result->result);
+-  CHECK(drop_pick != nullptr);
++  ABSL_CHECK(drop_pick != nullptr);
+   return drop_func(drop_pick);
+ }
+
+@@ -97,7 +97,7 @@ LoopCtl<absl::StatusOr<RefCountedPtr<UnstartedCallDestination>>> PickSubchannel(
+       unstarted_handler.UnprocessedClientInitialMetadata();
+   LoadBalancingPolicy::PickArgs pick_args;
+   Slice* path = client_initial_metadata.get_pointer(HttpPathMetadata());
+-  CHECK(path != nullptr);
++  ABSL_CHECK(path != nullptr);
+   pick_args.path = path->as_string_view();
+   LbCallState lb_call_state;
+   pick_args.call_state = &lb_call_state;
+@@ -115,7 +115,7 @@ LoopCtl<absl::StatusOr<RefCountedPtr<UnstartedCallDestination>>> PickSubchannel(
+             << "client_channel: " << GetContext<Activity>()->DebugTag()
+             << " pick succeeded: subchannel="
+             << complete_pick->subchannel.get();
+-        CHECK(complete_pick->subchannel != nullptr);
++        ABSL_CHECK(complete_pick->subchannel != nullptr);
+         // Grab a ref to the call destination while we're still
+         // holding the data plane mutex.
+         auto call_destination =
+@@ -212,7 +212,7 @@ void LoadBalancedCallDestination::StartCall(
+                       [unstarted_handler, &last_picker](
+                           RefCountedPtr<LoadBalancingPolicy::SubchannelPicker>
+                               picker) mutable {
+-                        CHECK_NE(picker.get(), nullptr);
++                        ABSL_CHECK_NE(picker.get(), nullptr);
+                         last_picker = std::move(picker);
+                         // Returns 3 possible things:
+                         // - Continue to queue the pick
+diff --git a/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc b/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc
+index 428db14bdf9c4..6cb91b2dc7f5a 100644
+--- a/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc
++++ b/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc
+@@ -22,7 +22,7 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/client_channel/subchannel.h"
+
+ namespace grpc_core {
+@@ -33,7 +33,7 @@ RefCountedPtr<Subchannel> LocalSubchannelPool::RegisterSubchannel(
+   // Because this pool is only accessed under the client channel's work
+   // serializer, and because FindSubchannel is checked before invoking
+   // RegisterSubchannel, no such subchannel should exist in the map.
+-  CHECK(it == subchannel_map_.end());
++  ABSL_CHECK(it == subchannel_map_.end());
+   subchannel_map_[key] = constructed.get();
+   return constructed;
+ }
+@@ -44,8 +44,8 @@ void LocalSubchannelPool::UnregisterSubchannel(const SubchannelKey& key,
+   // Because this subchannel pool is accessed only under the client
+   // channel's work serializer, any subchannel created by RegisterSubchannel
+   // will be deleted from the map in UnregisterSubchannel.
+-  CHECK(it != subchannel_map_.end());
+-  CHECK(it->second == subchannel);
++  ABSL_CHECK(it != subchannel_map_.end());
++  ABSL_CHECK(it->second == subchannel);
+   subchannel_map_.erase(it);
+ }
+
+diff --git a/third_party/grpc/source/src/core/client_channel/retry_filter.h b/third_party/grpc/source/src/core/client_channel/retry_filter.h
+index f7bc5d33a9841..dfd8d195e1c04 100644
+--- a/third_party/grpc/source/src/core/client_channel/retry_filter.h
++++ b/third_party/grpc/source/src/core/client_channel/retry_filter.h
+@@ -27,7 +27,7 @@
+ #include <new>
+ #include <optional>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/client_channel/client_channel_filter.h"
+ #include "src/core/client_channel/retry_service_config.h"
+ #include "src/core/client_channel/retry_throttle.h"
+@@ -84,8 +84,8 @@ class RetryFilter final {
+
+   static grpc_error_handle Init(grpc_channel_element* elem,
+                                 grpc_channel_element_args* args) {
+-    CHECK(args->is_last);
+-    CHECK(elem->filter == &kVtable);
++    ABSL_CHECK(args->is_last);
++    ABSL_CHECK(elem->filter == &kVtable);
+     grpc_error_handle error;
+     new (elem->channel_data) RetryFilter(args->channel_args, &error);
+     return error;
+diff --git a/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc b/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc
+index f65de3b808da3..b604ba625187d 100644
+--- a/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc
++++ b/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc
+@@ -20,8 +20,8 @@
+ #include <memory>
+ #include <new>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/client_channel/client_channel_internal.h"
+@@ -1501,14 +1501,14 @@ RetryFilter::LegacyCallData::~LegacyCallData() {
+   CSliceUnref(path_);
+   // Make sure there are no remaining pending batches.
+   for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+-    CHECK_EQ(pending_batches_[i].batch, nullptr);
++    ABSL_CHECK_EQ(pending_batches_[i].batch, nullptr);
+   }
+ }
+
+ void RetryFilter::LegacyCallData::StartTransportStreamOpBatch(
+     grpc_transport_stream_op_batch* batch) {
+   if (GRPC_TRACE_FLAG_ENABLED(retry) && !GRPC_TRACE_FLAG_ENABLED(channel)) {
+-    LOG(INFO) << "chand=" << chand_ << " calld=" << this
++    ABSL_LOG(INFO) << "chand=" << chand_ << " calld=" << this
+               << ": batch started from surface: "
+               << grpc_transport_stream_op_batch_string(batch, false);
+   }
+@@ -1730,7 +1730,7 @@ RetryFilter::LegacyCallData::PendingBatchesAdd(
+   GRPC_TRACE_LOG(retry, INFO) << "chand=" << chand_ << " calld=" << this
+                               << ": adding pending batch at index " << idx;
+   PendingBatch* pending = &pending_batches_[idx];
+-  CHECK_EQ(pending->batch, nullptr);
++  ABSL_CHECK_EQ(pending->batch, nullptr);
+   pending->batch = batch;
+   pending->send_ops_cached = false;
+   // Update state in calld about pending batches.
+@@ -1809,13 +1809,13 @@ void RetryFilter::LegacyCallData::FailPendingBatchInCallCombiner(
+
+ // This is called via the call combiner, so access to calld is synchronized.
+ void RetryFilter::LegacyCallData::PendingBatchesFail(grpc_error_handle error) {
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   if (GRPC_TRACE_FLAG_ENABLED(retry)) {
+     size_t num_batches = 0;
+     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
+       if (pending_batches_[i].batch != nullptr) ++num_batches;
+     }
+-    LOG(INFO) << "chand=" << chand_ << " calld=" << this << ": failing "
++    ABSL_LOG(INFO) << "chand=" << chand_ << " calld=" << this << ": failing "
+               << num_batches << " pending batches: " << StatusToString(error);
+   }
+   CallCombinerClosureList closures;
+@@ -1886,7 +1886,7 @@ void RetryFilter::LegacyCallData::StartRetryTimer(
+   // Compute backoff delay.
+   Duration next_attempt_timeout;
+   if (server_pushback.has_value()) {
+-    CHECK(*server_pushback >= Duration::Zero());
++    ABSL_CHECK(*server_pushback >= Duration::Zero());
+     next_attempt_timeout = *server_pushback;
+     retry_backoff_.Reset();
+   } else {
+diff --git a/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc b/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc
+index 11f42b5de5c4c..a497d26e73087 100644
+--- a/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc
++++ b/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc
+@@ -119,7 +119,7 @@ std::optional<Duration> RetryState::ShouldRetry(
+   // We should retry.
+   Duration next_attempt_timeout;
+   if (server_pushback.has_value()) {
+-    CHECK_GE(*server_pushback, Duration::Zero());
++    ABSL_CHECK_GE(*server_pushback, Duration::Zero());
+     next_attempt_timeout = *server_pushback;
+     retry_backoff_.Reset();
+   } else {
+diff --git a/third_party/grpc/source/src/core/client_channel/retry_interceptor.h b/third_party/grpc/source/src/core/client_channel/retry_interceptor.h
+index 5c8c0bf75dbbb..09a6c7c4070f8 100644
+--- a/third_party/grpc/source/src/core/client_channel/retry_interceptor.h
++++ b/third_party/grpc/source/src/core/client_channel/retry_interceptor.h
+@@ -103,7 +103,7 @@ class RetryInterceptor : public Interceptor {
+       if (current_attempt_ == attempt) current_attempt_ = nullptr;
+     }
+     bool IsCurrentAttempt(Attempt* attempt) {
+-      CHECK(attempt != nullptr);
++      ABSL_CHECK(attempt != nullptr);
+       return current_attempt_ == attempt;
+     }
+
+diff --git a/third_party/grpc/source/src/core/client_channel/retry_service_config.cc b/third_party/grpc/source/src/core/client_channel/retry_service_config.cc
+index daa62363b349f..ce5d7fc542d51 100644
+--- a/third_party/grpc/source/src/core/client_channel/retry_service_config.cc
++++ b/third_party/grpc/source/src/core/client_channel/retry_service_config.cc
+@@ -27,7 +27,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/numbers.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/config/core_configuration.h"
+@@ -140,7 +140,7 @@ void RetryMethodConfig::JsonPostLoad(const Json& json, const JsonArgs& args,
+       if (max_attempts_ <= 1) {
+         errors->AddError("must be at least 2");
+       } else if (max_attempts_ > MAX_MAX_RETRY_ATTEMPTS) {
+-        LOG(ERROR) << "service config: clamped retryPolicy.maxAttempts at "
++        ABSL_LOG(ERROR) << "service config: clamped retryPolicy.maxAttempts at "
+                    << MAX_MAX_RETRY_ATTEMPTS;
+         max_attempts_ = MAX_MAX_RETRY_ATTEMPTS;
+       }
+diff --git a/third_party/grpc/source/src/core/client_channel/subchannel.cc b/third_party/grpc/source/src/core/client_channel/subchannel.cc
+index 9d07abf7b54ce..62025ab80a075 100644
+--- a/third_party/grpc/source/src/core/client_channel/subchannel.cc
++++ b/third_party/grpc/source/src/core/client_channel/subchannel.cc
+@@ -29,8 +29,8 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/cord.h"
+ #include "absl/strings/str_cat.h"
+@@ -255,7 +255,7 @@ SubchannelCall::SubchannelCall(Args args, grpc_error_handle* error)
+   *error = grpc_call_stack_init(connected_subchannel_->channel_stack(), 1,
+                                 SubchannelCall::Destroy, this, &call_args);
+   if (GPR_UNLIKELY(!error->ok())) {
+-    LOG(ERROR) << "error: " << StatusToString(*error);
++    ABSL_LOG(ERROR) << "error: " << StatusToString(*error);
+     return;
+   }
+   grpc_call_stack_set_pollset_or_pollset_set(callstk, args.pollent);
+@@ -281,8 +281,8 @@ grpc_call_stack* SubchannelCall::GetCallStack() {
+ }
+
+ void SubchannelCall::SetAfterCallStackDestroy(grpc_closure* closure) {
+-  CHECK_EQ(after_call_stack_destroy_, nullptr);
+-  CHECK_NE(closure, nullptr);
++  ABSL_CHECK_EQ(after_call_stack_destroy_, nullptr);
++  ABSL_CHECK_NE(closure, nullptr);
+   after_call_stack_destroy_ = closure;
+ }
+
+@@ -333,7 +333,7 @@ void SubchannelCall::MaybeInterceptRecvTrailingMetadata(
+   GRPC_CLOSURE_INIT(&recv_trailing_metadata_ready_, RecvTrailingMetadataReady,
+                     this, grpc_schedule_on_exec_ctx);
+   // save some state needed for the interception callback.
+-  CHECK_EQ(recv_trailing_metadata_, nullptr);
++  ABSL_CHECK_EQ(recv_trailing_metadata_, nullptr);
+   recv_trailing_metadata_ =
+       batch->payload->recv_trailing_metadata.recv_trailing_metadata;
+   original_recv_trailing_metadata_ =
+@@ -359,12 +359,12 @@ void GetCallStatus(grpc_status_code* status, Timestamp deadline,
+ void SubchannelCall::RecvTrailingMetadataReady(void* arg,
+                                                grpc_error_handle error) {
+   SubchannelCall* call = static_cast<SubchannelCall*>(arg);
+-  CHECK_NE(call->recv_trailing_metadata_, nullptr);
++  ABSL_CHECK_NE(call->recv_trailing_metadata_, nullptr);
+   grpc_status_code status = GRPC_STATUS_OK;
+   GetCallStatus(&status, call->deadline_, call->recv_trailing_metadata_, error);
+   channelz::SubchannelNode* channelz_node =
+       call->connected_subchannel_->channelz_node();
+-  CHECK_NE(channelz_node, nullptr);
++  ABSL_CHECK_NE(channelz_node, nullptr);
+   if (status == GRPC_STATUS_OK) {
+     channelz_node->RecordCallSucceeded();
+   } else {
+@@ -573,7 +573,7 @@ RefCountedPtr<Subchannel> Subchannel::Create(
+     const grpc_resolved_address& address, const ChannelArgs& args) {
+   SubchannelKey key(address, args);
+   auto* subchannel_pool = args.GetObject<SubchannelPoolInterface>();
+-  CHECK_NE(subchannel_pool, nullptr);
++  ABSL_CHECK_NE(subchannel_pool, nullptr);
+   RefCountedPtr<Subchannel> c = subchannel_pool->FindSubchannel(key);
+   if (c != nullptr) {
+     return c;
+@@ -662,7 +662,7 @@ void Subchannel::Orphaned() {
+     subchannel_pool_.reset();
+   }
+   MutexLock lock(&mu_);
+-  CHECK(!shutdown_);
++  ABSL_CHECK(!shutdown_);
+   shutdown_ = true;
+   connector_.reset();
+   connected_subchannel_.reset();
+@@ -808,7 +808,7 @@ bool Subchannel::PublishTransportLocked() {
+     absl::StatusOr<RefCountedPtr<grpc_channel_stack>> stack = builder.Build();
+     if (!stack.ok()) {
+       connecting_result_.Reset();
+-      LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
++      ABSL_LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
+                  << ": error initializing subchannel stack: " << stack.status();
+       return false;
+     }
+@@ -846,7 +846,7 @@ bool Subchannel::PublishTransportLocked() {
+     auto call_destination = builder.Build(transport_destination);
+     if (!call_destination.ok()) {
+       connecting_result_.Reset();
+-      LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
++      ABSL_LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
+                  << ": error initializing subchannel stack: "
+                  << call_destination.status();
+       return false;
+diff --git a/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc b/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc
+index 205daac3d96ad..0e8cfa3054c4f 100644
+--- a/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc
++++ b/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc
+@@ -23,8 +23,8 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/lib/resource_quota/resource_quota.h"
+@@ -74,21 +74,21 @@ SubchannelStreamClient::SubchannelStreamClient(
+                   SUBCHANNEL_STREAM_RECONNECT_MAX_BACKOFF_SECONDS))),
+       event_engine_(connected_subchannel_->args().GetObject<EventEngine>()) {
+   if (GPR_UNLIKELY(tracer_ != nullptr)) {
+-    LOG(INFO) << tracer_ << " " << this << ": created SubchannelStreamClient";
++    ABSL_LOG(INFO) << tracer_ << " " << this << ": created SubchannelStreamClient";
+   }
+   StartCall();
+ }
+
+ SubchannelStreamClient::~SubchannelStreamClient() {
+   if (GPR_UNLIKELY(tracer_ != nullptr)) {
+-    LOG(INFO) << tracer_ << " " << this
++    ABSL_LOG(INFO) << tracer_ << " " << this
+               << ": destroying SubchannelStreamClient";
+   }
+ }
+
+ void SubchannelStreamClient::Orphan() {
+   if (GPR_UNLIKELY(tracer_ != nullptr)) {
+-    LOG(INFO) << tracer_ << " " << this
++    ABSL_LOG(INFO) << tracer_ << " " << this
+               << ": SubchannelStreamClient shutting down";
+   }
+   {
+@@ -110,13 +110,13 @@ void SubchannelStreamClient::StartCall() {
+
+ void SubchannelStreamClient::StartCallLocked() {
+   if (event_handler_ == nullptr) return;
+-  CHECK(call_state_ == nullptr);
++  ABSL_CHECK(call_state_ == nullptr);
+   if (event_handler_ != nullptr) {
+     event_handler_->OnCallStartLocked(this);
+   }
+   call_state_ = MakeOrphanable<CallState>(Ref(), interested_parties_);
+   if (GPR_UNLIKELY(tracer_ != nullptr)) {
+-    LOG(INFO) << tracer_ << " " << this
++    ABSL_LOG(INFO) << tracer_ << " " << this
+               << ": SubchannelStreamClient created CallState "
+               << call_state_.get();
+   }
+@@ -129,13 +129,13 @@ void SubchannelStreamClient::StartRetryTimerLocked() {
+   }
+   const Duration timeout = retry_backoff_.NextAttemptDelay();
+   if (GPR_UNLIKELY(tracer_ != nullptr)) {
+-    LOG(INFO) << tracer_ << " " << this
++    ABSL_LOG(INFO) << tracer_ << " " << this
+               << ": SubchannelStreamClient health check call lost...";
+     if (timeout > Duration::Zero()) {
+-      LOG(INFO) << tracer_ << " " << this << ": ... will retry in "
++      ABSL_LOG(INFO) << tracer_ << " " << this << ": ... will retry in "
+                 << timeout.millis() << "ms.";
+     } else {
+-      LOG(INFO) << tracer_ << " " << this << ": ... retrying immediately.";
++      ABSL_LOG(INFO) << tracer_ << " " << this << ": ... retrying immediately.";
+     }
+   }
+   retry_timer_handle_ = event_engine_->RunAfter(
+@@ -152,7 +152,7 @@ void SubchannelStreamClient::OnRetryTimer() {
+   if (event_handler_ != nullptr && retry_timer_handle_.has_value() &&
+       call_state_ == nullptr) {
+     if (GPR_UNLIKELY(tracer_ != nullptr)) {
+-      LOG(INFO) << tracer_ << " " << this
++      ABSL_LOG(INFO) << tracer_ << " " << this
+                 << ": SubchannelStreamClient restarting health check call";
+     }
+     StartCallLocked();
+@@ -173,7 +173,7 @@ SubchannelStreamClient::CallState::CallState(
+
+ SubchannelStreamClient::CallState::~CallState() {
+   if (GPR_UNLIKELY(subchannel_stream_client_->tracer_ != nullptr)) {
+-    LOG(INFO) << subchannel_stream_client_->tracer_ << " "
++    ABSL_LOG(INFO) << subchannel_stream_client_->tracer_ << " "
+               << subchannel_stream_client_.get()
+               << ": SubchannelStreamClient destroying CallState " << this;
+   }
+@@ -207,7 +207,7 @@ void SubchannelStreamClient::CallState::StartCallLocked() {
+   call_->SetAfterCallStackDestroy(&after_call_stack_destruction_);
+   // Check if creation failed.
+   if (!error.ok() || subchannel_stream_client_->event_handler_ == nullptr) {
+-    LOG(ERROR) << "SubchannelStreamClient " << subchannel_stream_client_.get()
++    ABSL_LOG(ERROR) << "SubchannelStreamClient " << subchannel_stream_client_.get()
+                << " CallState " << this << ": error creating "
+                << "stream on subchannel (" << StatusToString(error)
+                << "); will retry";
+@@ -224,7 +224,7 @@ void SubchannelStreamClient::CallState::StartCallLocked() {
+   send_initial_metadata_.Set(
+       HttpPathMetadata(),
+       subchannel_stream_client_->event_handler_->GetPathLocked());
+-  CHECK(error.ok());
++  ABSL_CHECK(error.ok());
+   payload_.send_initial_metadata.send_initial_metadata =
+       &send_initial_metadata_;
+   batch_.send_initial_metadata = true;
+@@ -358,7 +358,7 @@ void SubchannelStreamClient::CallState::RecvMessageReady() {
+               subchannel_stream_client_.get(), recv_message_->JoinIntoString());
+       if (!status.ok()) {
+         if (GPR_UNLIKELY(subchannel_stream_client_->tracer_ != nullptr)) {
+-          LOG(INFO) << subchannel_stream_client_->tracer_ << " "
++          ABSL_LOG(INFO) << subchannel_stream_client_->tracer_ << " "
+                     << subchannel_stream_client_.get()
+                     << ": SubchannelStreamClient CallState " << this
+                     << ": failed to parse response message: " << status;
+@@ -404,7 +404,7 @@ void SubchannelStreamClient::CallState::RecvTrailingMetadataReady(
+                           nullptr /* error_string */);
+   }
+   if (GPR_UNLIKELY(self->subchannel_stream_client_->tracer_ != nullptr)) {
+-    LOG(INFO) << self->subchannel_stream_client_->tracer_ << " "
++    ABSL_LOG(INFO) << self->subchannel_stream_client_->tracer_ << " "
+               << self->subchannel_stream_client_.get()
+               << ": SubchannelStreamClient CallState " << self
+               << ": health watch failed with status " << status;
+@@ -430,7 +430,7 @@ void SubchannelStreamClient::CallState::CallEndedLocked(bool retry) {
+   if (this == subchannel_stream_client_->call_state_.get()) {
+     subchannel_stream_client_->call_state_.reset();
+     if (retry) {
+-      CHECK(subchannel_stream_client_->event_handler_ != nullptr);
++      ABSL_CHECK(subchannel_stream_client_->event_handler_ != nullptr);
+       if (seen_response_.load(std::memory_order_acquire)) {
+         // If the call fails after we've gotten a successful response, reset
+         // the backoff and restart the call immediately.
+diff --git a/third_party/grpc/source/src/core/config/core_configuration.cc b/third_party/grpc/source/src/core/config/core_configuration.cc
+index 5c5dc46944610..dd44573fbf337 100644
+--- a/third_party/grpc/source/src/core/config/core_configuration.cc
++++ b/third_party/grpc/source/src/core/config/core_configuration.cc
+@@ -20,7 +20,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -50,7 +50,7 @@ CoreConfiguration::CoreConfiguration(Builder* builder)
+
+ void CoreConfiguration::RegisterBuilder(
+     absl::AnyInvocable<void(Builder*)> builder) {
+-  CHECK(config_.load(std::memory_order_relaxed) == nullptr)
++  ABSL_CHECK(config_.load(std::memory_order_relaxed) == nullptr)
+       << "CoreConfiguration was already instantiated before builder "
+          "registration was completed";
+   RegisteredBuilder* n = new RegisteredBuilder();
+@@ -59,7 +59,7 @@ void CoreConfiguration::RegisterBuilder(
+   while (!builders_.compare_exchange_weak(n->next, n, std::memory_order_acq_rel,
+                                           std::memory_order_relaxed)) {
+   }
+-  CHECK(config_.load(std::memory_order_relaxed) == nullptr)
++  ABSL_CHECK(config_.load(std::memory_order_relaxed) == nullptr)
+       << "CoreConfiguration was already instantiated before builder "
+          "registration was completed";
+ }
+diff --git a/third_party/grpc/source/src/core/config/core_configuration.h b/third_party/grpc/source/src/core/config/core_configuration.h
+index 29bacf96d5dde..119aaf0461fee 100644
+--- a/third_party/grpc/source/src/core/config/core_configuration.h
++++ b/third_party/grpc/source/src/core/config/core_configuration.h
+@@ -20,7 +20,7 @@
+ #include <atomic>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/handshaker/handshaker_registry.h"
+ #include "src/core/handshaker/proxy_mapper_registry.h"
+ #include "src/core/lib/channel/channel_args_preconditioning.h"
+@@ -128,9 +128,9 @@ class GRPC_DLL CoreConfiguration {
+     ~WithSubstituteBuilder() {
+       // Reset and restore.
+       Reset();
+-      CHECK(CoreConfiguration::config_.exchange(
++      ABSL_CHECK(CoreConfiguration::config_.exchange(
+                 config_restore_, std::memory_order_acquire) == nullptr);
+-      CHECK(CoreConfiguration::builders_.exchange(
++      ABSL_CHECK(CoreConfiguration::builders_.exchange(
+                 builders_restore_, std::memory_order_acquire) == nullptr);
+     }
+
+diff --git a/third_party/grpc/source/src/core/config/load_config.cc b/third_party/grpc/source/src/core/config/load_config.cc
+index e1ddf301d8f76..e03c1ecf55860 100644
+--- a/third_party/grpc/source/src/core/config/load_config.cc
++++ b/third_party/grpc/source/src/core/config/load_config.cc
+@@ -19,7 +19,7 @@
+
+ #include <optional>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/numbers.h"
+ #include "absl/strings/str_join.h"
+ #include "src/core/util/env.h"
+@@ -34,7 +34,7 @@ std::optional<std::string> LoadEnv(absl::string_view environment_variable) {
+
+ std::string LoadConfigFromEnv(absl::string_view environment_variable,
+                               const char* default_value) {
+-  CHECK(!environment_variable.empty());
++  ABSL_CHECK(!environment_variable.empty());
+   return LoadEnv(environment_variable).value_or(default_value);
+ }
+
+diff --git a/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc b/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc
+index 5930beb4bf69e..f3b5d2b9e7145 100644
+--- a/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc
+@@ -24,7 +24,7 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/lib/channel/channel_stack.h"
+diff --git a/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc b/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc
+index 6c057937e39d4..186f491f49ef3 100644
+--- a/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc
+@@ -28,7 +28,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+diff --git a/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc b/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc
+index af17f3a025dd2..a09f8a0e24b04 100644
+--- a/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc
+@@ -20,7 +20,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/ext/filters/gcp_authentication/gcp_authentication_service_config_parser.h"
+diff --git a/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc b/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc
+index a752ea76b3fa4..5c8dd7e9cf084 100644
+--- a/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc
+@@ -26,7 +26,7 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -94,7 +94,7 @@ ChannelCompression::ChannelCompression(const ChannelArgs& args)
+                                          &name)) {
+       name = "<unknown>";
+     }
+-    LOG(ERROR) << "default compression algorithm " << name
++    ABSL_LOG(ERROR) << "default compression algorithm " << name
+                << " not enabled: switching to none";
+     default_compression_algorithm_ = GRPC_COMPRESS_NONE;
+   }
+@@ -131,8 +131,8 @@ MessageHandle ChannelCompression::CompressMessage(
+       const size_t after_size = tmp.Length();
+       const float savings_ratio = 1.0f - (static_cast<float>(after_size) /
+                                           static_cast<float>(before_size));
+-      CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
+-      LOG(INFO) << absl::StrFormat(
++      ABSL_CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
++      ABSL_LOG(INFO) << absl::StrFormat(
+           "Compressed[%s] %" PRIuPTR " bytes vs. %" PRIuPTR
+           " bytes (%.2f%% savings)",
+           algo_name, before_size, after_size, 100 * savings_ratio);
+@@ -145,8 +145,8 @@ MessageHandle ChannelCompression::CompressMessage(
+   } else {
+     if (GRPC_TRACE_FLAG_ENABLED(compression)) {
+       const char* algo_name;
+-      CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
+-      LOG(INFO) << "Algorithm '" << algo_name
++      ABSL_CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
++      ABSL_LOG(INFO) << "Algorithm '" << algo_name
+                 << "' enabled but decided not to compress. Input size: "
+                 << payload->Length();
+     }
+diff --git a/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc b/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc
+index fdaa56677637f..fa0a0ef9e0835 100644
+--- a/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc
+@@ -28,7 +28,7 @@
+ #include <utility>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/channel/channel_stack.h"
+diff --git a/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc b/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc
+index 1861f41512ee2..342044d041f43 100644
+--- a/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc
+@@ -33,7 +33,7 @@
+ #include <utility>
+
+ #include "absl/container/inlined_vector.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/ascii.h"
+ #include "absl/strings/str_cat.h"
+@@ -96,14 +96,14 @@ std::string GetCensusSafeClientIpString(
+   // Find the client URI string.
+   const Slice* client_uri_slice = initial_metadata.get_pointer(PeerString());
+   if (client_uri_slice == nullptr) {
+-    LOG(ERROR) << "Unable to extract client URI string (peer string) from gRPC "
++    ABSL_LOG(ERROR) << "Unable to extract client URI string (peer string) from gRPC "
+                   "metadata.";
+     return "";
+   }
+   absl::StatusOr<URI> client_uri =
+       URI::Parse(client_uri_slice->as_string_view());
+   if (!client_uri.ok()) {
+-    LOG(ERROR) << "Unable to parse the client URI string (peer string) to a "
++    ABSL_LOG(ERROR) << "Unable to parse the client URI string (peer string) to a "
+                   "client URI. Error: "
+                << client_uri.status();
+     return "";
+@@ -112,7 +112,7 @@ std::string GetCensusSafeClientIpString(
+   grpc_resolved_address resolved_address;
+   bool success = grpc_parse_uri(*client_uri, &resolved_address);
+   if (!success) {
+-    LOG(ERROR) << "Unable to parse client URI into a grpc_resolved_address.";
++    ABSL_LOG(ERROR) << "Unable to parse client URI into a grpc_resolved_address.";
+     return "";
+   }
+   // Convert the socket address in the grpc_resolved_address into a hex string
+diff --git a/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc b/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc
+index ad5e73c5225df..3f0c3de1376da 100644
+--- a/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc
+@@ -34,7 +34,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/numeric/int128.h"
+ #include "absl/random/random.h"
+ #include "absl/random/uniform_int_distribution.h"
+@@ -100,7 +100,7 @@ class MetadataEncoder {
+     }
+     uint64_t mdentry_len = key.length() + value.length();
+     if (mdentry_len > log_len_) {
+-      VLOG(2) << "Skipped metadata key because of max metadata logging bytes "
++      ABSL_VLOG(2) << "Skipped metadata key because of max metadata logging bytes "
+               << mdentry_len << " (current) vs " << log_len_
+               << " (max less already accounted metadata)";
+       truncated_ = true;
+@@ -152,7 +152,7 @@ LoggingSink::Entry::Address PeerStringToAddress(const Slice& peer_string) {
+   LoggingSink::Entry::Address address;
+   absl::StatusOr<URI> uri = URI::Parse(peer_string.as_string_view());
+   if (!uri.ok()) {
+-    VLOG(2) << "peer_string is in invalid format and cannot be logged";
++    ABSL_VLOG(2) << "peer_string is in invalid format and cannot be logged";
+     return address;
+   }
+
+diff --git a/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc b/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc
+index a487ec2246719..c91825827590f 100644
+--- a/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc
+@@ -24,7 +24,7 @@
+ #include <functional>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/lib/channel/channel_args.h"
+diff --git a/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc b/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc
+index 91ef18c2d5212..44e25703469a1 100644
+--- a/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc
++++ b/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc
+@@ -27,7 +27,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/escaping.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+@@ -134,7 +134,7 @@ absl::string_view GetClusterToUse(
+   // Get cluster assigned by the XdsConfigSelector.
+   auto cluster_attribute =
+       service_config_call_data->GetCallAttribute<XdsClusterAttribute>();
+-  CHECK_NE(cluster_attribute, nullptr);
++  ABSL_CHECK_NE(cluster_attribute, nullptr);
+   auto current_cluster = cluster_attribute->cluster();
+   static constexpr absl::string_view kClusterPrefix = "cluster:";
+   // If prefix is not "cluster:", then we can't use cluster override.
+@@ -148,7 +148,7 @@ absl::string_view GetClusterToUse(
+   // Use cluster from the cookie if it is configured for the route.
+   auto route_data =
+       service_config_call_data->GetCallAttribute<XdsRouteStateAttribute>();
+-  CHECK_NE(route_data, nullptr);
++  ABSL_CHECK_NE(route_data, nullptr);
+   // Cookie cluster was not configured for route - use the one from the
+   // attribute
+   if (!route_data->HasClusterForRoute(cluster_from_cookie)) {
+@@ -193,7 +193,7 @@ bool IsConfiguredPath(absl::string_view configured_path,
+   // Check to see if the configured path matches the request path.
+   const Slice* path_slice =
+       client_initial_metadata.get_pointer(HttpPathMetadata());
+-  CHECK_NE(path_slice, nullptr);
++  ABSL_CHECK_NE(path_slice, nullptr);
+   absl::string_view path = path_slice->as_string_view();
+   // Matching criteria from
+   // https://www.rfc-editor.org/rfc/rfc6265#section-5.1.4.
+@@ -217,13 +217,13 @@ void StatefulSessionFilter::Call::OnClientInitialMetadata(
+       "StatefulSessionFilter::Call::OnClientInitialMetadata");
+   // Get config.
+   auto* service_config_call_data = GetContext<ServiceConfigCallData>();
+-  CHECK_NE(service_config_call_data, nullptr);
++  ABSL_CHECK_NE(service_config_call_data, nullptr);
+   auto* method_params = static_cast<StatefulSessionMethodParsedConfig*>(
+       service_config_call_data->GetMethodParsedConfig(
+           filter->service_config_parser_index_));
+-  CHECK_NE(method_params, nullptr);
++  ABSL_CHECK_NE(method_params, nullptr);
+   cookie_config_ = method_params->GetConfig(filter->index_);
+-  CHECK_NE(cookie_config_, nullptr);
++  ABSL_CHECK_NE(cookie_config_, nullptr);
+   if (!cookie_config_->name.has_value() ||
+       !IsConfiguredPath(cookie_config_->path, md)) {
+     return;
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h
+index b7075b310d43b..bf9fe18df4bd5 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h
+@@ -230,7 +230,7 @@ class ChaoticGoodTransport : public RefCounted<ChaoticGoodTransport> {
+     GRPC_TRACE_LOG(chaotic_good, INFO)
+         << "CHAOTIC_GOOD: Deserialize " << header << " with payload "
+         << absl::CEscape(payload.JoinIntoString());
+-    CHECK_EQ(header.payload_length, payload.Length());
++    ABSL_CHECK_EQ(header.payload_length, payload.Length());
+     auto s = frame.Deserialize(header, std::move(payload));
+     GRPC_TRACE_LOG(chaotic_good, INFO)
+         << "CHAOTIC_GOOD: DeserializeFrame "
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc
+index cb3faaae28068..f0e54939349b7 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc
+@@ -21,8 +21,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/bit_gen_ref.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -221,7 +221,7 @@ void ChaoticGoodConnector::Connect(const Args& args, Result* result,
+   arena->SetContext(event_engine.get());
+   auto resolved_addr = EventEngine::ResolvedAddress(
+       reinterpret_cast<const sockaddr*>(args.address->addr), args.address->len);
+-  CHECK_NE(resolved_addr.address(), nullptr);
++  ABSL_CHECK_NE(resolved_addr.address(), nullptr);
+   auto* result_notifier_ptr = result_notifier.get();
+   auto activity = MakeActivity(
+       [result_notifier_ptr, resolved_addr]() mutable {
+@@ -318,7 +318,7 @@ grpc_channel* grpc_chaotic_good_channel_create(const char* target,
+   if (r.ok()) {
+     return r->release()->c_ptr();
+   }
+-  LOG(ERROR) << "Failed to create chaotic good client channel: " << r.status();
++  ABSL_LOG(ERROR) << "Failed to create chaotic good client channel: " << r.status();
+   error = absl_status_to_grpc_error(r.status());
+   intptr_t integer;
+   grpc_status_code status = GRPC_STATUS_INTERNAL;
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc
+index 9cefc35f4773b..58d368cd404a7 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc
+@@ -26,8 +26,8 @@
+ #include <tuple>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/bit_gen_ref.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -74,10 +74,10 @@ ChaoticGoodClientTransport::LookupStream(uint32_t stream_id) {
+
+ auto ChaoticGoodClientTransport::PushFrameIntoCall(
+     ServerInitialMetadataFrame frame, RefCountedPtr<Stream> stream) {
+-  DCHECK(stream->message_reassembly.in_message_boundary());
++  ABSL_DCHECK(stream->message_reassembly.in_message_boundary());
+   auto headers = ServerMetadataGrpcFromProto(frame.body);
+   if (!headers.ok()) {
+-    LOG_EVERY_N_SEC(INFO, 10) << "Encode headers failed: " << headers.status();
++    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "Encode headers failed: " << headers.status();
+     return Immediate(StatusFlag(Failure{}));
+   }
+   return Immediate(stream->call.PushServerInitialMetadata(std::move(*headers)));
+@@ -185,7 +185,7 @@ auto ChaoticGoodClientTransport::TransportReadLoop(
+                               std::move(transport), std::move(incoming_frame));
+                         }),
+                         Default([&]() {
+-                          LOG_EVERY_N_SEC(INFO, 10)
++                          ABSL_LOG_EVERY_N_SEC(INFO, 10)
+                               << "Bad frame type: "
+                               << incoming_frame.header().ToString();
+                           return absl::OkStatus();
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h
+index 497ea1a15b2d1..30f7cc1a5ac43 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h
+@@ -91,7 +91,7 @@ class Config {
+   }
+
+   void PrepareClientOutgoingSettings(chaotic_good_frame::Settings& settings) {
+-    CHECK_EQ(pending_data_endpoints_.size(), 0u);
++    ABSL_CHECK_EQ(pending_data_endpoints_.size(), 0u);
+     PrepareOutgoingSettings(settings);
+   }
+
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc
+index e2d4c1eecf422..117f64b300912 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc
+@@ -43,7 +43,7 @@ ControlEndpoint::ControlEndpoint(
+   auto arena = SimpleArenaAllocator(0)->MakeArena();
+   arena->SetContext(event_engine);
+   write_party_ = Party::Make(arena);
+-  CHECK(event_engine != nullptr);
++  ABSL_CHECK(event_engine != nullptr);
+   write_party_->arena()->SetContext(event_engine);
+   write_party_->Spawn(
+       "flush-control",
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc
+index e5bc1b5d484d8..9031307d9d1c3 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc
+@@ -75,7 +75,7 @@ Poll<SliceBuffer> OutputBuffers::PollNext(uint32_t connection_id) {
+   auto cleanup = absl::MakeCleanup([&waker]() { waker.Wakeup(); });
+   MutexLock lock(&mu_);
+   auto& buffer = buffers_[connection_id];
+-  CHECK(buffer.has_value());
++  ABSL_CHECK(buffer.has_value());
+   if (buffer->HavePending()) {
+     waker = std::move(write_waker_);
+     return buffer->TakePending();
+@@ -91,7 +91,7 @@ void OutputBuffers::AddEndpoint(uint32_t connection_id) {
+   if (buffers_.size() < connection_id + 1) {
+     buffers_.resize(connection_id + 1);
+   }
+-  CHECK(!buffers_[connection_id].has_value()) << GRPC_DUMP_ARGS(connection_id);
++  ABSL_CHECK(!buffers_[connection_id].has_value()) << GRPC_DUMP_ARGS(connection_id);
+   buffers_[connection_id].emplace();
+   waker = std::move(write_waker_);
+   ready_endpoints_.fetch_add(1, std::memory_order_relaxed);
+@@ -125,7 +125,7 @@ absl::StatusOr<uint64_t> InputQueues::CreateTicket(uint32_t connection_id,
+ Poll<absl::StatusOr<SliceBuffer>> InputQueues::PollRead(uint64_t ticket) {
+   MutexLock lock(&mu_);
+   auto it = outstanding_reads_.find(ticket);
+-  CHECK(it != outstanding_reads_.end()) << " ticket=" << ticket;
++  ABSL_CHECK(it != outstanding_reads_.end()) << " ticket=" << ticket;
+   if (auto* waker = std::get_if<Waker>(&it->second)) {
+     *waker = GetContext<Activity>()->MakeNonOwningWaker();
+     return Pending{};
+@@ -172,7 +172,7 @@ void InputQueues::CancelTicket(uint64_t ticket) {
+
+ void InputQueues::AddEndpoint(uint32_t connection_id) {
+   MutexLock lock(&mu_);
+-  CHECK_EQ(read_requests_.size(), read_request_waker_.size());
++  ABSL_CHECK_EQ(read_requests_.size(), read_request_waker_.size());
+   if (read_requests_.size() <= connection_id) {
+     read_requests_.resize(connection_id + 1);
+     read_request_waker_.resize(connection_id + 1);
+@@ -289,7 +289,7 @@ DataEndpoints::DataEndpoints(
+     bool enable_tracing)
+     : output_buffers_(MakeRefCounted<data_endpoints_detail::OutputBuffers>()),
+       input_queues_(MakeRefCounted<data_endpoints_detail::InputQueues>()) {
+-  CHECK(event_engine != nullptr);
++  ABSL_CHECK(event_engine != nullptr);
+   for (size_t i = 0; i < endpoints_vec.size(); ++i) {
+     endpoints_.emplace_back(i, output_buffers_, input_queues_,
+                             std::move(endpoints_vec[i]), enable_tracing,
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc
+index 72ca1322e4c8e..c16e846ccdb00 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc
+@@ -23,7 +23,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/ext/transport/chaotic_good/chaotic_good_frame.pb.h"
+@@ -50,13 +50,13 @@ absl::Status ReadProto(SliceBuffer payload,
+ void WriteProto(const google::protobuf::MessageLite& msg, SliceBuffer& output) {
+   auto length = msg.ByteSizeLong();
+   auto slice = MutableSlice::CreateUninitialized(length);
+-  CHECK(msg.SerializeToArray(slice.data(), length));
++  ABSL_CHECK(msg.SerializeToArray(slice.data(), length));
+   output.AppendIndexed(Slice(std::move(slice)));
+ }
+
+ uint32_t ProtoPayloadSize(const google::protobuf::MessageLite& msg) {
+   auto length = msg.ByteSizeLong();
+-  CHECK_LE(length, std::numeric_limits<uint32_t>::max());
++  ABSL_CHECK_LE(length, std::numeric_limits<uint32_t>::max());
+   return static_cast<uint32_t>(length);
+ }
+
+@@ -151,7 +151,7 @@ struct ServerMetadataEncoder {
+   }
+
+   void EncodeWithWarning(const Slice& key, const Slice& value) {
+-    LOG_EVERY_N_SEC(INFO, 10) << "encoding known key " << key.as_string_view()
++    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "encoding known key " << key.as_string_view()
+                               << " with unknown encoding";
+     Encode(key, value);
+   }
+@@ -229,7 +229,7 @@ absl::StatusOr<ServerMetadataHandle> ServerMetadataGrpcFromProto(
+
+ absl::Status MessageFrame::Deserialize(const FrameHeader& header,
+                                        SliceBuffer payload) {
+-  CHECK_EQ(header.type, FrameType::kMessage);
++  ABSL_CHECK_EQ(header.type, FrameType::kMessage);
+   if (header.stream_id == 0) {
+     return absl::InternalError("Expected non-zero stream id");
+   }
+@@ -240,13 +240,13 @@ absl::Status MessageFrame::Deserialize(const FrameHeader& header,
+
+ FrameHeader MessageFrame::MakeHeader() const {
+   auto length = message->payload()->Length();
+-  CHECK_LE(length, std::numeric_limits<uint32_t>::max());
++  ABSL_CHECK_LE(length, std::numeric_limits<uint32_t>::max());
+   return FrameHeader{FrameType::kMessage, 0, stream_id,
+                      static_cast<uint32_t>(length)};
+ }
+
+ void MessageFrame::SerializePayload(SliceBuffer& payload) const {
+-  CHECK_NE(stream_id, 0u);
++  ABSL_CHECK_NE(stream_id, 0u);
+   payload.Append(*message->payload());
+ }
+
+@@ -261,7 +261,7 @@ std::string MessageFrame::ToString() const {
+
+ absl::Status MessageChunkFrame::Deserialize(const FrameHeader& header,
+                                             SliceBuffer payload) {
+-  CHECK_EQ(header.type, FrameType::kMessageChunk);
++  ABSL_CHECK_EQ(header.type, FrameType::kMessageChunk);
+   if (header.stream_id == 0) {
+     return absl::InternalError("Expected non-zero stream id");
+   }
+@@ -272,13 +272,13 @@ absl::Status MessageChunkFrame::Deserialize(const FrameHeader& header,
+
+ FrameHeader MessageChunkFrame::MakeHeader() const {
+   auto length = payload.Length();
+-  CHECK_LE(length, std::numeric_limits<uint32_t>::max());
++  ABSL_CHECK_LE(length, std::numeric_limits<uint32_t>::max());
+   return FrameHeader{FrameType::kMessageChunk, 0, stream_id,
+                      static_cast<uint32_t>(length)};
+ }
+
+ void MessageChunkFrame::SerializePayload(SliceBuffer& payload) const {
+-  CHECK_NE(stream_id, 0u);
++  ABSL_CHECK_NE(stream_id, 0u);
+   payload.Append(this->payload);
+ }
+
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h
+index 011db54dd6afa..1289b4e0af58b 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h
+@@ -81,7 +81,7 @@ template <FrameType frame_type, typename Body>
+ struct ProtoTransportFrame final : public FrameInterface {
+   absl::Status Deserialize(const FrameHeader& header,
+                            SliceBuffer payload) override {
+-    DCHECK_EQ(header.type, frame_type);
++    ABSL_DCHECK_EQ(header.type, frame_type);
+     return ReadTransportProto(header, std::move(payload), body);
+   }
+   FrameHeader MakeHeader() const override {
+@@ -104,14 +104,14 @@ template <FrameType frame_type, typename Body>
+ struct ProtoStreamFrame final : public FrameInterface {
+   absl::Status Deserialize(const FrameHeader& header,
+                            SliceBuffer payload) override {
+-    DCHECK_EQ(header.type, frame_type);
++    ABSL_DCHECK_EQ(header.type, frame_type);
+     return ReadStreamProto(header, std::move(payload), body, stream_id);
+   }
+   FrameHeader MakeHeader() const override {
+     return FrameHeader{frame_type, 0, stream_id, ProtoPayloadSize(body)};
+   }
+   void SerializePayload(SliceBuffer& payload) const override {
+-    DCHECK_NE(stream_id, 0u);
++    ABSL_DCHECK_NE(stream_id, 0u);
+     WriteProto(body, payload);
+   }
+   std::string ToString() const override {
+@@ -129,7 +129,7 @@ struct EmptyStreamFrame final : public FrameInterface {
+   EmptyStreamFrame() = default;
+   explicit EmptyStreamFrame(uint32_t stream_id) : stream_id(stream_id) {}
+   absl::Status Deserialize(const FrameHeader& header, SliceBuffer) override {
+-    DCHECK_EQ(header.type, frame_type);
++    ABSL_DCHECK_EQ(header.type, frame_type);
+     return ReadEmptyFrame(header, stream_id);
+   }
+   FrameHeader MakeHeader() const override {
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h
+index 796c90ea116ee..1c6d4d1e7653b 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h
+@@ -15,7 +15,7 @@
+ #ifndef GRPC_SRC_CORE_EXT_TRANSPORT_CHAOTIC_GOOD_MESSAGE_REASSEMBLY_H
+ #define GRPC_SRC_CORE_EXT_TRANSPORT_CHAOTIC_GOOD_MESSAGE_REASSEMBLY_H
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/ext/transport/chaotic_good/frame.h"
+ #include "src/core/lib/transport/call_spine.h"
+
+@@ -27,11 +27,11 @@ namespace chaotic_good {
+ class MessageReassembly {
+  public:
+   void FailCall(CallInitiator& call, absl::string_view msg) {
+-    LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
++    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
+     call.Cancel();
+   }
+   void FailCall(CallHandler& call, absl::string_view msg) {
+-    LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
++    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
+     call.PushServerTrailingMetadata(
+         CancelledServerMetadataFromStatus(GRPC_STATUS_INTERNAL, msg));
+   }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc
+index 9653016ac6589..23674f749fb66 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc
+@@ -26,8 +26,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/bit_gen_ref.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -104,7 +104,7 @@ absl::StatusOr<int> ChaoticGoodServerListener::Bind(
+     grpc_event_engine::experimental::EventEngine::ResolvedAddress addr) {
+   if (GRPC_TRACE_FLAG_ENABLED(chaotic_good)) {
+     auto str = grpc_event_engine::experimental::ResolvedAddressToString(addr);
+-    LOG(INFO) << "CHAOTIC_GOOD: Listen on "
++    ABSL_LOG(INFO) << "CHAOTIC_GOOD: Listen on "
+               << (str.ok() ? str->c_str() : str.status().ToString());
+   }
+   EventEngine::Listener::AcceptCallback accept_cb =
+@@ -118,16 +118,16 @@ absl::StatusOr<int> ChaoticGoodServerListener::Bind(
+       };
+   auto shutdown_cb = [](absl::Status status) {
+     if (!status.ok()) {
+-      LOG(ERROR) << "Server accept connection failed: " << status;
++      ABSL_LOG(ERROR) << "Server accept connection failed: " << status;
+     }
+   };
+-  CHECK_NE(event_engine_, nullptr);
++  ABSL_CHECK_NE(event_engine_, nullptr);
+   auto ee_listener = event_engine_->CreateListener(
+       std::move(accept_cb), std::move(shutdown_cb),
+       grpc_event_engine::experimental::ChannelArgsEndpointConfig(args_),
+       std::make_unique<MemoryQuota>("chaotic_good_server_listener"));
+   if (!ee_listener.ok()) {
+-    LOG(ERROR) << "Bind failed: " << ee_listener.status().ToString();
++    ABSL_LOG(ERROR) << "Bind failed: " << ee_listener.status().ToString();
+     return ee_listener.status();
+   }
+   ee_listener_ = std::move(ee_listener.value());
+@@ -139,10 +139,10 @@ absl::StatusOr<int> ChaoticGoodServerListener::Bind(
+ }
+
+ absl::Status ChaoticGoodServerListener::StartListening() {
+-  CHECK(ee_listener_ != nullptr);
++  ABSL_CHECK(ee_listener_ != nullptr);
+   auto status = ee_listener_->Start();
+   if (!status.ok()) {
+-    LOG(ERROR) << "Start listening failed: " << status;
++    ABSL_LOG(ERROR) << "Start listening failed: " << status;
+   } else {
+     GRPC_TRACE_LOG(chaotic_good, INFO) << "CHAOTIC_GOOD: Started listening";
+   }
+@@ -244,7 +244,7 @@ void ChaoticGoodServerListener::DataConnectionListener::Orphaned() {
+   absl::flat_hash_map<std::string, PendingConnectionInfo> pending_connections;
+   {
+     MutexLock lock(&mu_);
+-    CHECK(!shutdown_);
++    ABSL_CHECK(!shutdown_);
+     pending_connections = std::move(pending_connections_);
+     pending_connections_.clear();
+     shutdown_ = true;
+@@ -406,18 +406,18 @@ auto ChaoticGoodServerListener::ActiveConnection::HandshakingState::
+ void ChaoticGoodServerListener::ActiveConnection::HandshakingState::
+     OnHandshakeDone(absl::StatusOr<HandshakerArgs*> result) {
+   if (!result.ok()) {
+-    LOG_EVERY_N_SEC(ERROR, 5) << "Handshake failed: ", result.status();
++    ABSL_LOG_EVERY_N_SEC(ERROR, 5) << "Handshake failed: ", result.status();
+     connection_->Done();
+     return;
+   }
+-  CHECK_NE(*result, nullptr);
++  ABSL_CHECK_NE(*result, nullptr);
+   if ((*result)->endpoint == nullptr) {
+-    LOG_EVERY_N_SEC(ERROR, 5)
++    ABSL_LOG_EVERY_N_SEC(ERROR, 5)
+         << "Server handshake done but has empty endpoint.";
+     connection_->Done();
+     return;
+   }
+-  CHECK(grpc_event_engine::experimental::grpc_is_event_engine_endpoint(
++  ABSL_CHECK(grpc_event_engine::experimental::grpc_is_event_engine_endpoint(
+       (*result)->endpoint.get()));
+   auto ee_endpoint =
+       grpc_event_engine::experimental::grpc_take_wrapped_event_engine_endpoint(
+@@ -489,14 +489,14 @@ int grpc_server_add_chaotic_good_port(grpc_server* server, const char* addr) {
+         core_server->channel_args().GetObjectRef<EventEngine>()->GetDNSResolver(
+             EventEngine::DNSResolver::ResolverOptions());
+     if (!ee_resolver.ok()) {
+-      LOG(ERROR) << "Failed to resolve " << addr << ": "
++      ABSL_LOG(ERROR) << "Failed to resolve " << addr << ": "
+                  << ee_resolver.status().ToString();
+       return 0;
+     }
+     results = grpc_event_engine::experimental::LookupHostnameBlocking(
+         ee_resolver->get(), parsed_addr, absl::StrCat(0xd20));
+     if (!results.ok()) {
+-      LOG(ERROR) << "Failed to resolve " << addr << ": "
++      ABSL_LOG(ERROR) << "Failed to resolve " << addr << ": "
+                  << results.status().ToString();
+       return 0;
+     }
+@@ -507,7 +507,7 @@ int grpc_server_add_chaotic_good_port(grpc_server* server, const char* addr) {
+         grpc_core::GetDNSResolver()->LookupHostnameBlocking(
+             parsed_addr, absl::StrCat(0xd20));
+     if (!resolved_or.ok()) {
+-      LOG(ERROR) << "Failed to resolve " << addr << ": "
++      ABSL_LOG(ERROR) << "Failed to resolve " << addr << ": "
+                  << resolved_or.status().ToString();
+       return 0;
+     }
+@@ -534,17 +534,17 @@ int grpc_server_add_chaotic_good_port(grpc_server* server, const char* addr) {
+     if (port_num == 0) {
+       port_num = bind_result.value();
+     } else {
+-      CHECK(port_num == bind_result.value());
++      ABSL_CHECK(port_num == bind_result.value());
+     }
+     core_server->AddListener(std::move(listener));
+   }
+   if (error_list.size() == results->size()) {
+-    LOG(ERROR) << "Failed to bind any address for " << addr;
++    ABSL_LOG(ERROR) << "Failed to bind any address for " << addr;
+     for (const auto& error : error_list) {
+-      LOG(ERROR) << "  " << error.first << ": " << error.second;
++      ABSL_LOG(ERROR) << "  " << error.first << ": " << error.second;
+     }
+   } else if (!error_list.empty()) {
+-    LOG(INFO) << "Failed to bind some addresses for " << addr;
++    ABSL_LOG(INFO) << "Failed to bind some addresses for " << addr;
+     for (const auto& error : error_list) {
+       GRPC_TRACE_LOG(chaotic_good, INFO)
+           << "Binding Failed: " << error.first << ": " << error.second;
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h
+index bcabd259cb9e8..81b2af5a472cf 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h
+@@ -141,7 +141,7 @@ class ChaoticGoodServerListener final : public Server::ListenerInterface {
+         Duration connect_timeout,
+         std::shared_ptr<grpc_event_engine::experimental::EventEngine>
+             event_engine);
+-    ~DataConnectionListener() override { CHECK(shutdown_); }
++    ~DataConnectionListener() override { ABSL_CHECK(shutdown_); }
+
+     void Orphaned() override;
+
+diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc
+index 039d531093b9d..77e74cbd22042 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc
+@@ -24,8 +24,8 @@
+ #include <tuple>
+
+ #include "absl/cleanup/cleanup.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/bit_gen_ref.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -216,7 +216,7 @@ auto ChaoticGoodServerTransport::CallOutboundLoop(
+ absl::Status ChaoticGoodServerTransport::NewStream(
+     ChaoticGoodTransport& transport, const FrameHeader& header,
+     SliceBuffer payload) {
+-  CHECK_EQ(header.payload_length, payload.Length());
++  ABSL_CHECK_EQ(header.payload_length, payload.Length());
+   auto client_initial_metadata_frame =
+       transport.DeserializeFrame<ClientInitialMetadataFrame>(
+           header, std::move(payload));
+@@ -300,7 +300,7 @@ auto ChaoticGoodServerTransport::ReadOneFrame(
+                       []() -> absl::Status { return absl::OkStatus(); });
+                 }),
+                 Default([&]() {
+-                  LOG_EVERY_N_SEC(INFO, 10)
++                  ABSL_LOG_EVERY_N_SEC(INFO, 10)
+                       << "Bad frame type: "
+                       << incoming_frame.header().ToString();
+                   return ImmediateOkStatus();
+@@ -360,8 +360,8 @@ ChaoticGoodServerTransport::ChaoticGoodServerTransport(
+
+ void ChaoticGoodServerTransport::SetCallDestination(
+     RefCountedPtr<UnstartedCallDestination> call_destination) {
+-  CHECK(call_destination_ == nullptr);
+-  CHECK(call_destination != nullptr);
++  ABSL_CHECK(call_destination_ == nullptr);
++  ABSL_CHECK(call_destination != nullptr);
+   call_destination_ = call_destination;
+   got_acceptor_.Set();
+ }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc
+index cd6119f4782a6..6bf0b208f05ed 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc
+@@ -20,7 +20,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/util/useful.h"
+
+ // in order of preference
+@@ -42,6 +42,6 @@ size_t grpc_chttp2_num_alpn_versions(void) {
+ }
+
+ const char* grpc_chttp2_get_alpn_version_index(size_t i) {
+-  CHECK_LT(i, GPR_ARRAY_SIZE(supported_versions));
++  ABSL_CHECK_LT(i, GPR_ARRAY_SIZE(supported_versions));
+   return supported_versions[i];
+ }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc
+index 985b0be82c148..34b09870bd2fb 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc
+@@ -32,8 +32,8 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+@@ -96,7 +96,7 @@ void Chttp2Connector::Connect(const Args& args, Result* result,
+                               grpc_closure* notify) {
+   {
+     MutexLock lock(&mu_);
+-    CHECK_EQ(notify_, nullptr);
++    ABSL_CHECK_EQ(notify_, nullptr);
+     args_ = args;
+     result_ = result;
+     notify_ = notify;
+@@ -144,7 +144,7 @@ void Chttp2Connector::OnHandshakeDone(absl::StatusOr<HandshakerArgs*> result) {
+   } else if ((*result)->endpoint != nullptr) {
+     result_->transport = grpc_create_chttp2_transport(
+         (*result)->args, std::move((*result)->endpoint), true);
+-    CHECK_NE(result_->transport, nullptr);
++    ABSL_CHECK_NE(result_->transport, nullptr);
+     result_->socket_node =
+         grpc_chttp2_transport_get_socket_node(result_->transport);
+     result_->channel_args = std::move((*result)->args);
+@@ -167,7 +167,7 @@ void Chttp2Connector::OnHandshakeDone(absl::StatusOr<HandshakerArgs*> result) {
+     // If the handshaking succeeded but there is no endpoint, then the
+     // handshaker may have handed off the connection to some external
+     // code. Just verify that exit_early flag is set.
+-    DCHECK((*result)->exit_early);
++    ABSL_DCHECK((*result)->exit_early);
+     NullThenSchedClosure(DEBUG_LOCATION, &notify_, result.status());
+   }
+   handshake_mgr_.reset();
+@@ -234,7 +234,7 @@ class Chttp2SecureClientChannelFactory : public ClientChannelFactory {
+       const grpc_resolved_address& address, const ChannelArgs& args) override {
+     absl::StatusOr<ChannelArgs> new_args = GetSecureNamingChannelArgs(args);
+     if (!new_args.ok()) {
+-      LOG(ERROR) << "Failed to create channel args during subchannel creation: "
++      ABSL_LOG(ERROR) << "Failed to create channel args during subchannel creation: "
+                  << new_args.status() << "; Got args: " << args.ToString();
+       return nullptr;
+     }
+@@ -277,7 +277,7 @@ class Chttp2SecureClientChannelFactory : public ClientChannelFactory {
+ absl::StatusOr<RefCountedPtr<Channel>> CreateChannel(const char* target,
+                                                      const ChannelArgs& args) {
+   if (target == nullptr) {
+-    LOG(ERROR) << "cannot create channel with NULL target name";
++    ABSL_LOG(ERROR) << "cannot create channel with NULL target name";
+     return absl::InvalidArgumentError("channel target is NULL");
+   }
+   return ChannelCreate(target, args, GRPC_CLIENT_CHANNEL, nullptr);
+@@ -364,14 +364,14 @@ grpc_channel* grpc_channel_create_from_fd(const char* target, int fd,
+           .SetObject(creds->Ref());
+
+   int flags = fcntl(fd, F_GETFL, 0);
+-  CHECK_EQ(fcntl(fd, F_SETFL, flags | O_NONBLOCK), 0);
++  ABSL_CHECK_EQ(fcntl(fd, F_SETFL, flags | O_NONBLOCK), 0);
+   grpc_core::OrphanablePtr<grpc_endpoint> client(grpc_tcp_create_from_fd(
+       grpc_fd_create(fd, "client", true),
+       grpc_event_engine::experimental::ChannelArgsEndpointConfig(final_args),
+       "fd-client"));
+   grpc_core::Transport* transport =
+       grpc_create_chttp2_transport(final_args, std::move(client), true);
+-  CHECK(transport);
++  ABSL_CHECK(transport);
+   auto channel = grpc_core::ChannelCreate(
+       target, final_args, GRPC_CLIENT_DIRECT_CHANNEL, transport);
+   if (channel.ok()) {
+@@ -393,7 +393,7 @@ grpc_channel* grpc_channel_create_from_fd(const char* /* target */,
+                                           int /* fd */,
+                                           grpc_channel_credentials* /* creds*/,
+                                           const grpc_channel_args* /* args */) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+   return nullptr;
+ }
+
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc
+index 66ee7105b444b..b5bb15ef65ebd 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc
+@@ -38,8 +38,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -323,7 +323,7 @@ void Chttp2ServerListener::ConfigFetcherWatcher::UpdateConnectionManager(
+     void set_connections(
+         std::map<ActiveConnection*, OrphanablePtr<ActiveConnection>>
+             connections) {
+-      CHECK(connections_.empty());
++      ABSL_CHECK(connections_.empty());
+       connections_ = std::move(connections);
+     }
+
+@@ -345,10 +345,10 @@ void Chttp2ServerListener::ConfigFetcherWatcher::UpdateConnectionManager(
+   grpc_error_handle error = grpc_tcp_server_add_port(
+       listener_->tcp_server_, &listener_->resolved_address_, &port_temp);
+   if (!error.ok()) {
+-    LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
++    ABSL_LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
+     // TODO(yashykt): We wouldn't need to assert here if we bound to the
+     // port earlier during AddPort.
+-    CHECK(0);
++    ABSL_CHECK(0);
+   }
+   listener_->StartListening();
+   {
+@@ -538,7 +538,7 @@ void Chttp2ServerListener::ActiveConnection::HandshakingState::OnHandshakeDone(
+               });
+         } else {
+           // Failed to create channel from transport. Clean up.
+-          LOG(ERROR) << "Failed to create channel: "
++          ABSL_LOG(ERROR) << "Failed to create channel: "
+                      << StatusToString(channel_init_err);
+           transport->Orphan();
+           cleanup_connection = true;
+@@ -937,7 +937,7 @@ void Chttp2ServerListener::Orphan() {
+   // Cancel the watch before shutting down so as to avoid holding a ref to the
+   // listener in the watcher.
+   if (config_fetcher_watcher_ != nullptr) {
+-    CHECK_NE(config_fetcher_, nullptr);
++    ABSL_CHECK_NE(config_fetcher_, nullptr);
+     config_fetcher_->CancelWatch(config_fetcher_watcher_);
+   }
+   std::map<ActiveConnection*, OrphanablePtr<ActiveConnection>> connections;
+@@ -1106,7 +1106,7 @@ void NewChttp2ServerListener::ActiveConnection::HandshakingState::
+           });
+     } else {
+       // Failed to create channel from transport. Clean up.
+-      LOG(ERROR) << "Failed to create channel: "
++      ABSL_LOG(ERROR) << "Failed to create channel: "
+                  << StatusToString(channel_init_err);
+       transport->Orphan();
+     }
+@@ -1363,10 +1363,10 @@ void NewChttp2ServerListener::Start() {
+     grpc_error_handle error =
+         grpc_tcp_server_add_port(tcp_server_, resolved_address(), &port_temp);
+     if (!error.ok()) {
+-      LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
++      ABSL_LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
+       // TODO(yashykt): We wouldn't need to assert here if we bound to the
+       // port earlier during AddPort.
+-      CHECK(0);
++      ABSL_CHECK(0);
+     }
+   }
+   if (tcp_server != nullptr) {
+@@ -1544,7 +1544,7 @@ grpc_error_handle Chttp2ServerAddPort(Server* server, const char* addr,
+         if (*port_num == -1) {
+           *port_num = port_temp;
+         } else {
+-          CHECK(*port_num == port_temp);
++          ABSL_CHECK(*port_num == port_temp);
+         }
+       }
+     }
+@@ -1561,7 +1561,7 @@ grpc_error_handle Chttp2ServerAddPort(Server* server, const char* addr,
+                           results->size() - error_list.size(), results->size());
+       error = GRPC_ERROR_CREATE_REFERENCING(msg.c_str(), error_list.data(),
+                                             error_list.size());
+-      LOG(INFO) << "WARNING: " << StatusToString(error);
++      ABSL_LOG(INFO) << "WARNING: " << StatusToString(error);
+       // we managed to bind some addresses: continue without error
+     }
+     return absl::OkStatus();
+@@ -1576,7 +1576,7 @@ namespace experimental {
+
+ absl::Status PassiveListenerImpl::AcceptConnectedEndpoint(
+     std::unique_ptr<EventEngine::Endpoint> endpoint) {
+-  CHECK_NE(server_.get(), nullptr);
++  ABSL_CHECK_NE(server_.get(), nullptr);
+   if (IsServerListenerEnabled()) {
+     RefCountedPtr<NewChttp2ServerListener> new_listener;
+     {
+@@ -1615,7 +1615,7 @@ absl::Status PassiveListenerImpl::AcceptConnectedEndpoint(
+ }
+
+ absl::Status PassiveListenerImpl::AcceptConnectedFd(int fd) {
+-  CHECK_NE(server_.get(), nullptr);
++  ABSL_CHECK_NE(server_.get(), nullptr);
+   ExecCtx exec_ctx;
+   auto& args = server_->channel_args();
+   auto* supports_fd = QueryExtension<EventEngineSupportsFdExtension>(
+@@ -1682,7 +1682,7 @@ int grpc_server_add_http2_port(grpc_server* server, const char* addr,
+ done:
+   sc.reset(DEBUG_LOCATION, "server");
+   if (!err.ok()) {
+-    LOG(ERROR) << grpc_core::StatusToString(err);
++    ABSL_LOG(ERROR) << grpc_core::StatusToString(err);
+   }
+   return port_num;
+ }
+@@ -1693,7 +1693,7 @@ void grpc_server_add_channel_from_fd(grpc_server* server, int fd,
+   // For now, we only support insecure server credentials
+   if (creds == nullptr ||
+       creds->type() != grpc_core::InsecureServerCredentials::Type()) {
+-    LOG(ERROR) << "Failed to create channel due to invalid creds";
++    ABSL_LOG(ERROR) << "Failed to create channel due to invalid creds";
+     return;
+   }
+   grpc_core::ExecCtx exec_ctx;
+@@ -1721,7 +1721,7 @@ void grpc_server_add_channel_from_fd(grpc_server* server, int fd,
+     grpc_chttp2_transport_start_reading(transport, nullptr, nullptr, nullptr,
+                                         nullptr);
+   } else {
+-    LOG(ERROR) << "Failed to create channel: "
++    ABSL_LOG(ERROR) << "Failed to create channel: "
+                << grpc_core::StatusToString(error);
+     transport->Orphan();
+   }
+@@ -1731,7 +1731,7 @@ void grpc_server_add_channel_from_fd(grpc_server* server, int fd,
+
+ void grpc_server_add_channel_from_fd(grpc_server* /* server */, int /* fd */,
+                                      grpc_server_credentials* /* creds */) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+ }
+
+ #endif  // GPR_SUPPORT_CHANNELS_FROM_FD
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc
+index 8ccfdc2f3cff8..50504bab974cc 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc
+@@ -22,8 +22,8 @@
+ #include <grpc/support/port_platform.h>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/slice/slice.h"
+
+ static uint8_t decode_table[] = {
+@@ -57,7 +57,7 @@ static bool input_is_valid(const uint8_t* input_ptr, size_t length) {
+
+   for (i = 0; i < length; ++i) {
+     if (GPR_UNLIKELY((decode_table[input_ptr[i]] & 0xC0) != 0)) {
+-      LOG(ERROR) << "Base64 decoding failed, invalid character '"
++      ABSL_LOG(ERROR) << "Base64 decoding failed, invalid character '"
+                  << static_cast<char>(*input_ptr) << "' in base64 input.\n";
+       return false;
+     }
+@@ -86,13 +86,13 @@ size_t grpc_chttp2_base64_infer_length_after_decode(const grpc_slice& slice) {
+     len--;
+   }
+   if (GPR_UNLIKELY(GRPC_SLICE_LENGTH(slice) - len > 2)) {
+-    LOG(ERROR) << "Base64 decoding failed. Input has more than 2 paddings.";
++    ABSL_LOG(ERROR) << "Base64 decoding failed. Input has more than 2 paddings.";
+     return 0;
+   }
+   size_t tuples = len / 4;
+   size_t tail_case = len % 4;
+   if (GPR_UNLIKELY(tail_case == 1)) {
+-    LOG(ERROR) << "Base64 decoding failed. Input has a length of " << len
++    ABSL_LOG(ERROR) << "Base64 decoding failed. Input has a length of " << len
+                << " (without padding), which is invalid.\n";
+     return 0;
+   }
+@@ -161,7 +161,7 @@ grpc_slice grpc_chttp2_base64_decode(const grpc_slice& input) {
+   grpc_slice output;
+
+   if (GPR_UNLIKELY(input_length % 4 != 0)) {
+-    LOG(ERROR) << "Base64 decoding failed, input of "
++    ABSL_LOG(ERROR) << "Base64 decoding failed, input of "
+                   "grpc_chttp2_base64_decode has a length of "
+                << input_length << ", which is not a multiple of 4.\n";
+     return grpc_empty_slice();
+@@ -186,13 +186,13 @@ grpc_slice grpc_chttp2_base64_decode(const grpc_slice& input) {
+
+   if (GPR_UNLIKELY(!grpc_base64_decode_partial(&ctx))) {
+     char* s = grpc_slice_to_c_string(input);
+-    LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
++    ABSL_LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
+     gpr_free(s);
+     grpc_core::CSliceUnref(output);
+     return grpc_empty_slice();
+   }
+-  CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
+-  CHECK(ctx.input_cur == GRPC_SLICE_END_PTR(input));
++  ABSL_CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
++  ABSL_CHECK(ctx.input_cur == GRPC_SLICE_END_PTR(input));
+   return output;
+ }
+
+@@ -204,7 +204,7 @@ grpc_slice grpc_chttp2_base64_decode_with_length(const grpc_slice& input,
+
+   // The length of a base64 string cannot be 4 * n + 1
+   if (GPR_UNLIKELY(input_length % 4 == 1)) {
+-    LOG(ERROR) << "Base64 decoding failed, input of "
++    ABSL_LOG(ERROR) << "Base64 decoding failed, input of "
+                   "grpc_chttp2_base64_decode_with_length has a length of "
+                << input_length << ", which has a tail of 1 byte.\n";
+     grpc_core::CSliceUnref(output);
+@@ -213,7 +213,7 @@ grpc_slice grpc_chttp2_base64_decode_with_length(const grpc_slice& input,
+
+   if (GPR_UNLIKELY(output_length >
+                    input_length / 4 * 3 + tail_xtra[input_length % 4])) {
+-    LOG(ERROR) << "Base64 decoding failed, output_length " << output_length
++    ABSL_LOG(ERROR) << "Base64 decoding failed, output_length " << output_length
+                << " is longer than the max possible output length "
+                << ((input_length / 4 * 3) + tail_xtra[input_length % 4])
+                << ".\n";
+@@ -229,12 +229,12 @@ grpc_slice grpc_chttp2_base64_decode_with_length(const grpc_slice& input,
+
+   if (GPR_UNLIKELY(!grpc_base64_decode_partial(&ctx))) {
+     char* s = grpc_slice_to_c_string(input);
+-    LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
++    ABSL_LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
+     gpr_free(s);
+     grpc_core::CSliceUnref(output);
+     return grpc_empty_slice();
+   }
+-  CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
+-  CHECK(ctx.input_cur <= GRPC_SLICE_END_PTR(input));
++  ABSL_CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
++  ABSL_CHECK(ctx.input_cur <= GRPC_SLICE_END_PTR(input));
+   return output;
+ }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc
+index c9727428ebca3..6ae90c7e6bb9e 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc
+@@ -22,7 +22,7 @@
+ #include <stdint.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/ext/transport/chttp2/transport/huffsyms.h"
+
+ static const char alphabet[] =
+@@ -86,8 +86,8 @@ grpc_slice grpc_chttp2_base64_encode(const grpc_slice& input) {
+       break;
+   }
+
+-  CHECK(out == (char*)GRPC_SLICE_END_PTR(output));
+-  CHECK(in == GRPC_SLICE_END_PTR(input));
++  ABSL_CHECK(out == (char*)GRPC_SLICE_END_PTR(output));
++  ABSL_CHECK(in == GRPC_SLICE_END_PTR(input));
+   return output;
+ }
+
+@@ -130,7 +130,7 @@ grpc_slice grpc_chttp2_huffman_compress(const grpc_slice& input) {
+                              static_cast<uint8_t>(0xffu >> temp_length));
+   }
+
+-  CHECK(out == GRPC_SLICE_END_PTR(output));
++  ABSL_CHECK(out == GRPC_SLICE_END_PTR(output));
+
+   return output;
+ }
+@@ -226,9 +226,9 @@ grpc_slice grpc_chttp2_base64_encode_and_huffman_compress(
+         static_cast<uint8_t>(0xffu >> out.temp_length));
+   }
+
+-  CHECK(out.out <= GRPC_SLICE_END_PTR(output));
++  ABSL_CHECK(out.out <= GRPC_SLICE_END_PTR(output));
+   GRPC_SLICE_SET_LENGTH(output, out.out - start_out);
+
+-  CHECK(in == GRPC_SLICE_END_PTR(input));
++  ABSL_CHECK(in == GRPC_SLICE_END_PTR(input));
+   return output;
+ }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc
+index e22db84bfb54f..d827f01bd1309 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc
+@@ -46,8 +46,8 @@
+ #include "absl/base/attributes.h"
+ #include "absl/container/flat_hash_map.h"
+ #include "absl/hash/hash.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -395,11 +395,11 @@ grpc_chttp2_transport::~grpc_chttp2_transport() {
+   grpc_chttp2_goaway_parser_destroy(&goaway_parser);
+
+   for (i = 0; i < STREAM_LIST_COUNT; i++) {
+-    CHECK_EQ(lists[i].head, nullptr);
+-    CHECK_EQ(lists[i].tail, nullptr);
++    ABSL_CHECK_EQ(lists[i].head, nullptr);
++    ABSL_CHECK_EQ(lists[i].tail, nullptr);
+   }
+
+-  CHECK(stream_map.empty());
++  ABSL_CHECK(stream_map.empty());
+   GRPC_COMBINER_UNREF(combiner, "chttp2_transport");
+
+   while (write_cb_pool) {
+@@ -421,7 +421,7 @@ static void read_channel_args(grpc_chttp2_transport* t,
+       channel_args.GetInt(GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER).value_or(-1);
+   if (initial_sequence_number > 0) {
+     if ((t->next_stream_id & 1) != (initial_sequence_number & 1)) {
+-      LOG(ERROR) << GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER
++      ABSL_LOG(ERROR) << GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER
+                  << ": low bit must be " << (t->next_stream_id & 1) << " on "
+                  << (is_client ? "client" : "server");
+     } else {
+@@ -524,7 +524,7 @@ static void read_channel_args(grpc_chttp2_transport* t,
+       t->settings.mutable_local().SetMaxConcurrentStreams(value);
+     }
+   } else if (channel_args.Contains(GRPC_ARG_MAX_CONCURRENT_STREAMS)) {
+-    VLOG(2) << GRPC_ARG_MAX_CONCURRENT_STREAMS
++    ABSL_VLOG(2) << GRPC_ARG_MAX_CONCURRENT_STREAMS
+             << " is not available on clients";
+   }
+   value =
+@@ -572,7 +572,7 @@ static void read_channel_args(grpc_chttp2_transport* t,
+ static void init_keepalive_pings_if_enabled_locked(
+     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
+     GRPC_UNUSED grpc_error_handle error) {
+-  DCHECK(error.ok());
++  ABSL_DCHECK(error.ok());
+   if (t->keepalive_time != grpc_core::Duration::Infinity()) {
+     t->keepalive_state = GRPC_CHTTP2_KEEPALIVE_STATE_WAITING;
+     t->keepalive_ping_timer_handle =
+@@ -671,7 +671,7 @@ grpc_chttp2_transport::grpc_chttp2_transport(
+     }
+   }
+
+-  CHECK(strlen(GRPC_CHTTP2_CLIENT_CONNECT_STRING) ==
++  ABSL_CHECK(strlen(GRPC_CHTTP2_CLIENT_CONNECT_STRING) ==
+         GRPC_CHTTP2_CLIENT_CONNECT_STRLEN);
+
+   grpc_slice_buffer_init(&read_buffer);
+@@ -763,7 +763,7 @@ static void close_transport_locked(grpc_chttp2_transport* t,
+           grpc_error_add_child(t->close_transport_on_writes_finished, error);
+       return;
+     }
+-    CHECK(!error.ok());
++    ABSL_CHECK(!error.ok());
+     t->closed_with_error = error;
+     connectivity_state_set(t, GRPC_CHANNEL_SHUTDOWN, absl::Status(),
+                            "close_transport");
+@@ -807,7 +807,7 @@ static void close_transport_locked(grpc_chttp2_transport* t,
+     while (grpc_chttp2_list_pop_writable_stream(t, &s)) {
+       GRPC_CHTTP2_STREAM_UNREF(s, "chttp2_writing:close");
+     }
+-    CHECK(t->write_state == GRPC_CHTTP2_WRITE_STATE_IDLE);
++    ABSL_CHECK(t->write_state == GRPC_CHTTP2_WRITE_STATE_IDLE);
+     if (t->interested_parties_until_recv_settings != nullptr) {
+       grpc_endpoint_delete_from_pollset_set(
+           t->ep.get(), t->interested_parties_until_recv_settings);
+@@ -896,9 +896,9 @@ grpc_chttp2_stream::~grpc_chttp2_stream() {
+     }
+   }
+
+-  CHECK((write_closed && read_closed) || id == 0);
++  ABSL_CHECK((write_closed && read_closed) || id == 0);
+   if (id != 0) {
+-    CHECK_EQ(t->stream_map.count(id), 0u);
++    ABSL_CHECK_EQ(t->stream_map.count(id), 0u);
+   }
+
+   grpc_slice_buffer_destroy(&frame_storage);
+@@ -911,11 +911,11 @@ grpc_chttp2_stream::~grpc_chttp2_stream() {
+     }
+   }
+
+-  CHECK_EQ(send_initial_metadata_finished, nullptr);
+-  CHECK_EQ(send_trailing_metadata_finished, nullptr);
+-  CHECK_EQ(recv_initial_metadata_ready, nullptr);
+-  CHECK_EQ(recv_message_ready, nullptr);
+-  CHECK_EQ(recv_trailing_metadata_finished, nullptr);
++  ABSL_CHECK_EQ(send_initial_metadata_finished, nullptr);
++  ABSL_CHECK_EQ(send_trailing_metadata_finished, nullptr);
++  ABSL_CHECK_EQ(recv_initial_metadata_ready, nullptr);
++  ABSL_CHECK_EQ(recv_message_ready, nullptr);
++  ABSL_CHECK_EQ(recv_trailing_metadata_finished, nullptr);
+   grpc_slice_buffer_destroy(&flow_controlled_buffer);
+   grpc_core::ExecCtx::Run(DEBUG_LOCATION, destroy_stream_arg, absl::OkStatus());
+ }
+@@ -948,7 +948,7 @@ grpc_chttp2_stream* grpc_chttp2_parsing_accept_stream(grpc_chttp2_transport* t,
+     return nullptr;
+   }
+   grpc_chttp2_stream* accepting = nullptr;
+-  CHECK_EQ(t->accepting_stream, nullptr);
++  ABSL_CHECK_EQ(t->accepting_stream, nullptr);
+   t->accepting_stream = &accepting;
+   t->accept_stream_cb(t->accept_stream_cb_user_data, t,
+                       reinterpret_cast<void*>(id));
+@@ -1051,7 +1051,7 @@ static void write_action_begin_locked(
+     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
+     grpc_error_handle /*error_ignored*/) {
+   GRPC_LATENT_SEE_INNER_SCOPE("write_action_begin_locked");
+-  CHECK(t->write_state != GRPC_CHTTP2_WRITE_STATE_IDLE);
++  ABSL_CHECK(t->write_state != GRPC_CHTTP2_WRITE_STATE_IDLE);
+   grpc_chttp2_begin_write_result r;
+   if (!t->closed_with_error.ok()) {
+     r.writing = false;
+@@ -1065,7 +1065,7 @@ static void write_action_begin_locked(
+                     begin_writing_desc(r.partial));
+     write_action(t.get());
+     if (t->reading_paused_on_pending_induced_frames) {
+-      CHECK_EQ(t->num_pending_induced_frames, 0u);
++      ABSL_CHECK_EQ(t->num_pending_induced_frames, 0u);
+       // We had paused reading, because we had many induced frames (SETTINGS
+       // ACK, PINGS ACK and RST_STREAMS) pending in t->qbuf. Now that we have
+       // been able to flush qbuf, we can resume reading.
+@@ -1205,7 +1205,7 @@ void grpc_chttp2_add_incoming_goaway(grpc_chttp2_transport* t,
+   // We want to log this irrespective of whether http tracing is enabled if we
+   // received a GOAWAY with a non NO_ERROR code.
+   if (goaway_error != GRPC_HTTP2_NO_ERROR) {
+-    LOG(INFO) << t->peer_string.as_string_view() << ": Got goaway ["
++    ABSL_LOG(INFO) << t->peer_string.as_string_view() << ": Got goaway ["
+               << goaway_error
+               << "] err=" << grpc_core::StatusToString(t->goaway_error);
+   }
+@@ -1233,7 +1233,7 @@ void grpc_chttp2_add_incoming_goaway(grpc_chttp2_transport* t,
+   if (GPR_UNLIKELY(t->is_client &&
+                    goaway_error == GRPC_HTTP2_ENHANCE_YOUR_CALM &&
+                    goaway_text == "too_many_pings")) {
+-    LOG(ERROR) << t->peer_string.as_string_view()
++    ABSL_LOG(ERROR) << t->peer_string.as_string_view()
+                << ": Received a GOAWAY with error code ENHANCE_YOUR_CALM and "
+                   "debug data equal to \"too_many_pings\". Current keepalive "
+                   "time (before throttling): "
+@@ -1274,7 +1274,7 @@ static void maybe_start_some_streams(grpc_chttp2_transport* t) {
+         << " allocating new grpc_chttp2_stream " << s << " to id "
+         << t->next_stream_id;
+
+-    CHECK_EQ(s->id, 0u);
++    ABSL_CHECK_EQ(s->id, 0u);
+     s->id = t->next_stream_id;
+     t->next_stream_id += 2;
+
+@@ -1379,11 +1379,11 @@ static bool contains_non_ok_status(grpc_metadata_batch* batch) {
+
+ static void log_metadata(const grpc_metadata_batch* md_batch, uint32_t id,
+                          const bool is_client, const bool is_initial) {
+-  VLOG(2) << "--metadata--";
++  ABSL_VLOG(2) << "--metadata--";
+   const std::string prefix = absl::StrCat(
+       "HTTP:", id, is_initial ? ":HDR" : ":TRL", is_client ? ":CLI:" : ":SVR:");
+   md_batch->Log([&prefix](absl::string_view key, absl::string_view value) {
+-    VLOG(2) << prefix << key << ": " << value;
++    ABSL_VLOG(2) << prefix << key << ": " << value;
+   });
+ }
+
+@@ -1416,7 +1416,7 @@ static void send_initial_metadata_locked(
+   if (t->is_client && t->channelz_socket != nullptr) {
+     t->channelz_socket->RecordStreamStartedFromLocal();
+   }
+-  CHECK_EQ(s->send_initial_metadata_finished, nullptr);
++  ABSL_CHECK_EQ(s->send_initial_metadata_finished, nullptr);
+   on_complete->next_data.scratch |= t->closure_barrier_may_cover_write;
+
+   s->send_initial_metadata_finished = add_closure_barrier(on_complete);
+@@ -1434,7 +1434,7 @@ static void send_initial_metadata_locked(
+   if (!s->write_closed) {
+     if (t->is_client) {
+       if (t->closed_with_error.ok()) {
+-        CHECK_EQ(s->id, 0u);
++        ABSL_CHECK_EQ(s->id, 0u);
+         if (t->max_concurrent_streams_reject_on_client &&
+             t->stream_map.size() >=
+                 t->settings.peer().max_concurrent_streams()) {
+@@ -1467,7 +1467,7 @@ static void send_initial_metadata_locked(
+             false);
+       }
+     } else {
+-      CHECK_NE(s->id, 0u);
++      ABSL_CHECK_NE(s->id, 0u);
+       grpc_chttp2_mark_stream_writable(t, s);
+       if (!(op->send_message &&
+             (op->payload->send_message.flags & GRPC_WRITE_BUFFER_HINT))) {
+@@ -1583,7 +1583,7 @@ static void send_trailing_metadata_locked(
+     grpc_transport_stream_op_batch* op, grpc_chttp2_stream* s,
+     grpc_transport_stream_op_batch_payload* op_payload,
+     grpc_chttp2_transport* t, grpc_closure* on_complete) {
+-  CHECK_EQ(s->send_trailing_metadata_finished, nullptr);
++  ABSL_CHECK_EQ(s->send_trailing_metadata_finished, nullptr);
+   on_complete->next_data.scratch |= t->closure_barrier_may_cover_write;
+   s->send_trailing_metadata_finished = add_closure_barrier(on_complete);
+   s->send_trailing_metadata =
+@@ -1615,7 +1615,7 @@ static void send_trailing_metadata_locked(
+ static void recv_initial_metadata_locked(
+     grpc_chttp2_stream* s, grpc_transport_stream_op_batch_payload* op_payload,
+     grpc_chttp2_transport* t) {
+-  CHECK_EQ(s->recv_initial_metadata_ready, nullptr);
++  ABSL_CHECK_EQ(s->recv_initial_metadata_ready, nullptr);
+   s->recv_initial_metadata_ready =
+       op_payload->recv_initial_metadata.recv_initial_metadata_ready;
+   s->recv_initial_metadata =
+@@ -1631,7 +1631,7 @@ static void recv_initial_metadata_locked(
+ static void recv_message_locked(
+     grpc_chttp2_stream* s, grpc_transport_stream_op_batch_payload* op_payload,
+     grpc_chttp2_transport* t) {
+-  CHECK_EQ(s->recv_message_ready, nullptr);
++  ABSL_CHECK_EQ(s->recv_message_ready, nullptr);
+   s->recv_message_ready = op_payload->recv_message.recv_message_ready;
+   s->recv_message = op_payload->recv_message.recv_message;
+   s->recv_message->emplace();
+@@ -1644,9 +1644,9 @@ static void recv_message_locked(
+ static void recv_trailing_metadata_locked(
+     grpc_chttp2_stream* s, grpc_transport_stream_op_batch_payload* op_payload,
+     grpc_chttp2_transport* t) {
+-  CHECK_EQ(s->collecting_stats, nullptr);
++  ABSL_CHECK_EQ(s->collecting_stats, nullptr);
+   s->collecting_stats = op_payload->recv_trailing_metadata.collect_stats;
+-  CHECK_EQ(s->recv_trailing_metadata_finished, nullptr);
++  ABSL_CHECK_EQ(s->recv_trailing_metadata_finished, nullptr);
+   s->recv_trailing_metadata_finished =
+       op_payload->recv_trailing_metadata.recv_trailing_metadata_ready;
+   s->recv_trailing_metadata =
+@@ -1670,7 +1670,7 @@ static void perform_stream_op_locked(void* stream_op,
+   }
+   s->tcp_tracer = TcpTracerIfSampled(s);
+   if (GRPC_TRACE_FLAG_ENABLED(http)) {
+-    LOG(INFO) << "perform_stream_op_locked[s=" << s << "; op=" << op
++    ABSL_LOG(INFO) << "perform_stream_op_locked[s=" << s << "; op=" << op
+               << "]: " << grpc_transport_stream_op_batch_string(op, false)
+               << "; on_complete = " << op->on_complete;
+     if (op->send_initial_metadata) {
+@@ -1735,12 +1735,12 @@ void grpc_chttp2_transport::PerformStreamOp(
+
+   if (!is_client) {
+     if (op->send_initial_metadata) {
+-      CHECK(!op->payload->send_initial_metadata.send_initial_metadata
++      ABSL_CHECK(!op->payload->send_initial_metadata.send_initial_metadata
+                  ->get(grpc_core::GrpcTimeoutMetadata())
+                  .has_value());
+     }
+     if (op->send_trailing_metadata) {
+-      CHECK(!op->payload->send_trailing_metadata.send_trailing_metadata
++      ABSL_CHECK(!op->payload->send_trailing_metadata.send_trailing_metadata
+                  ->get(grpc_core::GrpcTimeoutMetadata())
+                  .has_value());
+     }
+@@ -1833,8 +1833,8 @@ void grpc_chttp2_retry_initiate_ping(
+ static void retry_initiate_ping_locked(
+     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
+     GRPC_UNUSED grpc_error_handle error) {
+-  DCHECK(error.ok());
+-  CHECK(t->delayed_ping_timer_handle != TaskHandle::kInvalid);
++  ABSL_DCHECK(error.ok());
++  ABSL_CHECK(t->delayed_ping_timer_handle != TaskHandle::kInvalid);
+   t->delayed_ping_timer_handle = TaskHandle::kInvalid;
+   grpc_chttp2_initiate_write(t.get(),
+                              GRPC_CHTTP2_INITIATE_WRITE_RETRY_SEND_PING);
+@@ -1842,7 +1842,7 @@ static void retry_initiate_ping_locked(
+
+ void grpc_chttp2_ack_ping(grpc_chttp2_transport* t, uint64_t id) {
+   if (!t->ping_callbacks.AckPing(id, t->event_engine.get())) {
+-    VLOG(2) << "Unknown ping response from " << t->peer_string.as_string_view()
++    ABSL_VLOG(2) << "Unknown ping response from " << t->peer_string.as_string_view()
+             << ": " << id;
+     return;
+   }
+@@ -2017,7 +2017,7 @@ static void send_goaway(grpc_chttp2_transport* t, grpc_error_handle error,
+   } else if (t->sent_goaway_state == GRPC_CHTTP2_NO_GOAWAY_SEND ||
+              t->sent_goaway_state == GRPC_CHTTP2_GRACEFUL_GOAWAY) {
+     // We want to log this irrespective of whether http tracing is enabled
+-    VLOG(2) << t->peer_string.as_string_view() << " "
++    ABSL_VLOG(2) << t->peer_string.as_string_view() << " "
+             << (t->is_client ? "CLIENT" : "SERVER")
+             << ": Sending goaway last_new_stream_id=" << t->last_new_stream_id
+             << " err=" << grpc_core::StatusToString(error);
+@@ -2164,7 +2164,7 @@ void grpc_chttp2_maybe_complete_recv_message(grpc_chttp2_transport* t,
+     } else {
+       if (s->frame_storage.length != 0) {
+         while (true) {
+-          CHECK_GT(s->frame_storage.length, 0u);
++          ABSL_CHECK_GT(s->frame_storage.length, 0u);
+           int64_t min_progress_size;
+           auto r = grpc_deframe_unprocessed_incoming_frames(
+               s, &min_progress_size, &**s->recv_message, s->recv_message_flags);
+@@ -2246,7 +2246,7 @@ void grpc_chttp2_maybe_complete_recv_trailing_metadata(grpc_chttp2_transport* t,
+ static grpc_chttp2_transport::RemovedStreamHandle remove_stream(
+     grpc_chttp2_transport* t, uint32_t id, grpc_error_handle error) {
+   grpc_chttp2_stream* s = t->stream_map.extract(id).mapped();
+-  DCHECK(s);
++  ABSL_DCHECK(s);
+   if (t->incoming_stream == s) {
+     t->incoming_stream = nullptr;
+     grpc_chttp2_parsing_become_skip_parser(t);
+@@ -2496,8 +2496,8 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+   grpc_error_get_status(error, s->deadline, &grpc_status, &message, nullptr,
+                         nullptr);
+
+-  CHECK_GE(grpc_status, 0);
+-  CHECK_LT((int)grpc_status, 100);
++  ABSL_CHECK_GE(grpc_status, 0);
++  ABSL_CHECK_LT((int)grpc_status, 100);
+
+   auto remove_stream_handle = grpc_chttp2_mark_stream_closed(t, s, 1, 1, error);
+   grpc_core::MaybeTarpit(
+@@ -2538,7 +2538,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+           *p++ = '2';
+           *p++ = '0';
+           *p++ = '0';
+-          CHECK(p == GRPC_SLICE_END_PTR(http_status_hdr));
++          ABSL_CHECK(p == GRPC_SLICE_END_PTR(http_status_hdr));
+           len += static_cast<uint32_t> GRPC_SLICE_LENGTH(http_status_hdr);
+
+           content_type_hdr = GRPC_SLICE_MALLOC(31);
+@@ -2574,7 +2574,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+           *p++ = 'r';
+           *p++ = 'p';
+           *p++ = 'c';
+-          CHECK(p == GRPC_SLICE_END_PTR(content_type_hdr));
++          ABSL_CHECK(p == GRPC_SLICE_END_PTR(content_type_hdr));
+           len += static_cast<uint32_t> GRPC_SLICE_LENGTH(content_type_hdr);
+         }
+
+@@ -2601,11 +2601,11 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+           *p++ = static_cast<uint8_t>('0' + (grpc_status / 10));
+           *p++ = static_cast<uint8_t>('0' + (grpc_status % 10));
+         }
+-        CHECK(p == GRPC_SLICE_END_PTR(status_hdr));
++        ABSL_CHECK(p == GRPC_SLICE_END_PTR(status_hdr));
+         len += static_cast<uint32_t> GRPC_SLICE_LENGTH(status_hdr);
+
+         size_t msg_len = message.length();
+-        CHECK(msg_len <= UINT32_MAX);
++        ABSL_CHECK(msg_len <= UINT32_MAX);
+         grpc_core::VarintWriter<1> msg_len_writer(
+             static_cast<uint32_t>(msg_len));
+         message_pfx = GRPC_SLICE_MALLOC(14 + msg_len_writer.length());
+@@ -2626,7 +2626,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+         *p++ = 'e';
+         msg_len_writer.Write(0, p);
+         p += msg_len_writer.length();
+-        CHECK(p == GRPC_SLICE_END_PTR(message_pfx));
++        ABSL_CHECK(p == GRPC_SLICE_END_PTR(message_pfx));
+         len += static_cast<uint32_t> GRPC_SLICE_LENGTH(message_pfx);
+         len += static_cast<uint32_t>(msg_len);
+
+@@ -2642,7 +2642,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+         *p++ = static_cast<uint8_t>(id >> 16);
+         *p++ = static_cast<uint8_t>(id >> 8);
+         *p++ = static_cast<uint8_t>(id);
+-        CHECK(p == GRPC_SLICE_END_PTR(hdr));
++        ABSL_CHECK(p == GRPC_SLICE_END_PTR(hdr));
+
+         grpc_slice_buffer_add(&t->qbuf, hdr);
+         if (!sent_initial_metadata) {
+@@ -2862,7 +2862,7 @@ static void read_action_locked(
+   if (t->keepalive_ping_timeout_handle != TaskHandle::kInvalid) {
+     if (GRPC_TRACE_FLAG_ENABLED(http2_ping) ||
+         GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
+-      LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t.get()
++      ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t.get()
+                 << "]: Clear keepalive timer because data was received";
+     }
+     t->event_engine->Cancel(
+@@ -2955,7 +2955,7 @@ static void finish_bdp_ping_locked(
+       t->flow_control.bdp_estimator()->CompletePing();
+   grpc_chttp2_act_on_flowctl_action(t->flow_control.PeriodicUpdate(), t.get(),
+                                     nullptr);
+-  CHECK(t->next_bdp_ping_timer_handle == TaskHandle::kInvalid);
++  ABSL_CHECK(t->next_bdp_ping_timer_handle == TaskHandle::kInvalid);
+   t->next_bdp_ping_timer_handle =
+       t->event_engine->RunAfter(next_ping - grpc_core::Timestamp::Now(), [t] {
+         grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
+@@ -2974,7 +2974,7 @@ static void next_bdp_ping_timer_expired(grpc_chttp2_transport* t) {
+ static void next_bdp_ping_timer_expired_locked(
+     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
+     GRPC_UNUSED grpc_error_handle error) {
+-  DCHECK(error.ok());
++  ABSL_DCHECK(error.ok());
+   t->next_bdp_ping_timer_handle = TaskHandle::kInvalid;
+   if (t->flow_control.bdp_estimator()->accumulator() == 0) {
+     // Block the bdp ping till we receive more data.
+@@ -3042,9 +3042,9 @@ static void init_keepalive_ping(
+ static void init_keepalive_ping_locked(
+     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
+     GRPC_UNUSED grpc_error_handle error) {
+-  DCHECK(error.ok());
+-  CHECK(t->keepalive_state == GRPC_CHTTP2_KEEPALIVE_STATE_WAITING);
+-  CHECK(t->keepalive_ping_timer_handle != TaskHandle::kInvalid);
++  ABSL_DCHECK(error.ok());
++  ABSL_CHECK(t->keepalive_state == GRPC_CHTTP2_KEEPALIVE_STATE_WAITING);
++  ABSL_CHECK(t->keepalive_ping_timer_handle != TaskHandle::kInvalid);
+   t->keepalive_ping_timer_handle = TaskHandle::kInvalid;
+   grpc_core::Timestamp now = grpc_core::Timestamp::Now();
+   grpc_core::Timestamp adjusted_keepalive_timestamp = std::exchange(
+@@ -3092,11 +3092,11 @@ static void finish_keepalive_ping_locked(
+     if (error.ok()) {
+       if (GRPC_TRACE_FLAG_ENABLED(http) ||
+           GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
+-        LOG(INFO) << t->peer_string.as_string_view()
++        ABSL_LOG(INFO) << t->peer_string.as_string_view()
+                   << ": Finish keepalive ping";
+       }
+       t->keepalive_state = GRPC_CHTTP2_KEEPALIVE_STATE_WAITING;
+-      CHECK(t->keepalive_ping_timer_handle == TaskHandle::kInvalid);
++      ABSL_CHECK(t->keepalive_ping_timer_handle == TaskHandle::kInvalid);
+       t->keepalive_ping_timer_handle =
+           t->event_engine->RunAfter(t->keepalive_time, [t] {
+             grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
+@@ -3139,7 +3139,7 @@ static void maybe_reset_keepalive_ping_timer_locked(grpc_chttp2_transport* t) {
+     // need to Ref or Unref here since we still hold the Ref.
+     if (GRPC_TRACE_FLAG_ENABLED(http) ||
+         GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
+-      LOG(INFO) << t->peer_string.as_string_view()
++      ABSL_LOG(INFO) << t->peer_string.as_string_view()
+                 << ": Keepalive ping cancelled. Resetting timer.";
+     }
+   }
+@@ -3241,7 +3241,7 @@ static void benign_reclaimer_locked(
+                                    GRPC_HTTP2_ENHANCE_YOUR_CALM),
+                 /*immediate_disconnect_hint=*/true);
+   } else if (error.ok() && GRPC_TRACE_FLAG_ENABLED(resource_quota)) {
+-    LOG(INFO) << "HTTP2: " << t->peer_string.as_string_view()
++    ABSL_LOG(INFO) << "HTTP2: " << t->peer_string.as_string_view()
+               << " - skip benign reclamation, there are still "
+               << t->stream_map.size() << " streams";
+   }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc
+index 91f611959d0af..478fefaed5e8b 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc
+@@ -28,8 +28,8 @@
+ #include <tuple>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/str_join.h"
+@@ -332,7 +332,7 @@ void StreamFlowControl::SentUpdate(uint32_t announce) {
+   TransportFlowControl::IncomingUpdateContext tfc_upd(tfc_);
+   pending_size_ = std::nullopt;
+   tfc_upd.UpdateAnnouncedWindowDelta(&announced_window_delta_, announce);
+-  CHECK_EQ(DesiredAnnounceSize(), 0u);
++  ABSL_CHECK_EQ(DesiredAnnounceSize(), 0u);
+   std::ignore = tfc_upd.MakeAction();
+ }
+
+@@ -382,7 +382,7 @@ FlowControlAction StreamFlowControl::UpdateAction(FlowControlAction action) {
+
+ void StreamFlowControl::IncomingUpdateContext::SetPendingSize(
+     int64_t pending_size) {
+-  CHECK_GE(pending_size, 0);
++  ABSL_CHECK_GE(pending_size, 0);
+   sfc_->pending_size_ = pending_size;
+ }
+
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h
+index 769fce6ec5e42..382c9f45c06f3 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h
+@@ -29,7 +29,7 @@
+ #include <utility>
+
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/ext/transport/chttp2/transport/http2_settings.h"
+@@ -128,7 +128,7 @@ class GRPC_MUST_USE_RESULT FlowControlAction {
+   static const char* UrgencyString(Urgency u);
+   std::string DebugString() const;
+
+-  void AssertEmpty() { CHECK(*this == FlowControlAction()); }
++  void AssertEmpty() { ABSL_CHECK(*this == FlowControlAction()); }
+
+   bool operator==(const FlowControlAction& other) const {
+     return send_stream_update_ == other.send_stream_update_ &&
+@@ -191,7 +191,7 @@ class TransportFlowControl final {
+   class IncomingUpdateContext {
+    public:
+     explicit IncomingUpdateContext(TransportFlowControl* tfc) : tfc_(tfc) {}
+-    ~IncomingUpdateContext() { CHECK_EQ(tfc_, nullptr); }
++    ~IncomingUpdateContext() { ABSL_CHECK_EQ(tfc_, nullptr); }
+
+     IncomingUpdateContext(const IncomingUpdateContext&) = delete;
+     IncomingUpdateContext& operator=(const IncomingUpdateContext&) = delete;
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc
+index e12cc5afba84e..a4338068a13a7 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc
+@@ -20,7 +20,7 @@
+ #include <cstdint>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/util/crash.h"
+@@ -58,7 +58,7 @@ uint16_t Read2b(const uint8_t* input) {
+ }
+
+ void Write3b(uint32_t x, uint8_t* output) {
+-  CHECK_LT(x, 16777216u);
++  ABSL_CHECK_LT(x, 16777216u);
+   output[0] = static_cast<uint8_t>(x >> 16);
+   output[1] = static_cast<uint8_t>(x >> 8);
+   output[2] = static_cast<uint8_t>(x);
+@@ -491,7 +491,7 @@ void Serialize(absl::Span<Http2Frame> frames, SliceBuffer& out) {
+
+ absl::StatusOr<Http2Frame> ParseFramePayload(const Http2FrameHeader& hdr,
+                                              SliceBuffer payload) {
+-  CHECK(payload.Length() == hdr.length);
++  ABSL_CHECK(payload.Length() == hdr.length);
+   switch (hdr.type) {
+     case kFrameTypeData:
+       return ParseDataFrame(hdr, payload);
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc
+index 1ec015abecaa0..cc2f0c4b8a1f8 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc
+@@ -22,7 +22,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <stdlib.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/ext/transport/chttp2/transport/call_tracer_wrapper.h"
+@@ -61,7 +61,7 @@ void grpc_chttp2_encode_data(uint32_t id, grpc_slice_buffer* inbuf,
+
+   hdr = GRPC_SLICE_MALLOC(header_size);
+   p = GRPC_SLICE_START_PTR(hdr);
+-  CHECK(write_bytes < (1 << 24));
++  ABSL_CHECK(write_bytes < (1 << 24));
+   *p++ = static_cast<uint8_t>(write_bytes >> 16);
+   *p++ = static_cast<uint8_t>(write_bytes >> 8);
+   *p++ = static_cast<uint8_t>(write_bytes);
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc
+index a108986a24d33..3d9e2ef2a8b94 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc
+@@ -24,7 +24,7 @@
+ #include <string.h>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+@@ -134,7 +134,7 @@ grpc_error_handle grpc_chttp2_goaway_parser_parse(void* parser,
+         memcpy(p->debug_data + p->debug_pos, cur,
+                static_cast<size_t>(end - cur));
+       }
+-      CHECK((size_t)(end - cur) < UINT32_MAX - p->debug_pos);
++      ABSL_CHECK((size_t)(end - cur) < UINT32_MAX - p->debug_pos);
+       p->debug_pos += static_cast<uint32_t>(end - cur);
+       p->state = GRPC_CHTTP2_GOAWAY_DEBUG;
+       if (is_last) {
+@@ -155,7 +155,7 @@ void grpc_chttp2_goaway_append(uint32_t last_stream_id, uint32_t error_code,
+   grpc_slice header = GRPC_SLICE_MALLOC(9 + 4 + 4);
+   uint8_t* p = GRPC_SLICE_START_PTR(header);
+   uint32_t frame_length;
+-  CHECK(GRPC_SLICE_LENGTH(debug_data) < UINT32_MAX - 4 - 4);
++  ABSL_CHECK(GRPC_SLICE_LENGTH(debug_data) < UINT32_MAX - 4 - 4);
+   frame_length = 4 + 4 + static_cast<uint32_t> GRPC_SLICE_LENGTH(debug_data);
+
+   // frame header: length
+@@ -181,7 +181,7 @@ void grpc_chttp2_goaway_append(uint32_t last_stream_id, uint32_t error_code,
+   *p++ = static_cast<uint8_t>(error_code >> 16);
+   *p++ = static_cast<uint8_t>(error_code >> 8);
+   *p++ = static_cast<uint8_t>(error_code);
+-  CHECK(p == GRPC_SLICE_END_PTR(header));
++  ABSL_CHECK(p == GRPC_SLICE_END_PTR(header));
+   grpc_slice_buffer_add(slice_buffer, header);
+   grpc_slice_buffer_add(slice_buffer, debug_data);
+ }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc
+index 2db29ee7ef617..9f0514502f79d 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc
+@@ -26,8 +26,8 @@
+ #include <algorithm>
+
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/ext/transport/chttp2/transport/internal.h"
+@@ -89,7 +89,7 @@ grpc_error_handle grpc_chttp2_ping_parser_parse(void* parser,
+   }
+
+   if (p->byte == 8) {
+-    CHECK(is_last);
++    ABSL_CHECK(is_last);
+     if (p->is_ack) {
+       GRPC_TRACE_LOG(http2_ping, INFO)
+           << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+@@ -101,7 +101,7 @@ grpc_error_handle grpc_chttp2_ping_parser_parse(void* parser,
+             t->keepalive_permit_without_calls == 0 && t->stream_map.empty();
+         if (GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
+             GRPC_TRACE_FLAG_ENABLED(http)) {
+-          LOG(INFO) << "SERVER[" << t << "]: received ping " << p->opaque_8bytes
++          ABSL_LOG(INFO) << "SERVER[" << t << "]: received ping " << p->opaque_8bytes
+                     << ": "
+                     << t->ping_abuse_policy.GetDebugString(transport_idle);
+         }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc
+index 0378d6773c083..f5328b2d172c2 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc
+@@ -22,8 +22,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <stddef.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/distributions.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+@@ -107,7 +107,7 @@ grpc_error_handle grpc_chttp2_rst_stream_parser_parse(void* parser,
+   s->call_tracer_wrapper.RecordIncomingBytes({framing_bytes, 0, 0});
+
+   if (p->byte == 4) {
+-    CHECK(is_last);
++    ABSL_CHECK(is_last);
+     uint32_t reason = ((static_cast<uint32_t>(p->reason_bytes[0])) << 24) |
+                       ((static_cast<uint32_t>(p->reason_bytes[1])) << 16) |
+                       ((static_cast<uint32_t>(p->reason_bytes[2])) << 8) |
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc
+index c8a7df69549f5..41888a7b66613 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc
+@@ -25,7 +25,7 @@
+ #include <string>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/ext/transport/chttp2/transport/flow_control.h"
+@@ -186,7 +186,7 @@ grpc_error_handle grpc_chttp2_settings_parser_parse(void* p,
+               parser->incoming_settings->initial_window_size();
+           if (GRPC_TRACE_FLAG_ENABLED(http) ||
+               GRPC_TRACE_FLAG_ENABLED(flowctl)) {
+-            LOG(INFO) << t << "[" << (t->is_client ? "cli" : "svr")
++            ABSL_LOG(INFO) << t << "[" << (t->is_client ? "cli" : "svr")
+                       << "] adding " << t->initial_window_update
+                       << " for initial_window change";
+           }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc
+index 92ad73d90126c..d073d6a7ce09d 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <stddef.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -42,7 +42,7 @@ grpc_slice grpc_chttp2_window_update_create(
+   }
+   uint8_t* p = GRPC_SLICE_START_PTR(slice);
+
+-  CHECK(window_delta);
++  ABSL_CHECK(window_delta);
+
+   *p++ = 0;
+   *p++ = 0;
+@@ -99,7 +99,7 @@ grpc_error_handle grpc_chttp2_window_update_parser_parse(
+       return GRPC_ERROR_CREATE(
+           absl::StrCat("invalid window update bytes: ", p->amount));
+     }
+-    CHECK(is_last);
++    ABSL_CHECK(is_last);
+
+     if (t->incoming_stream_id != 0) {
+       if (s != nullptr) {
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc
+index cc17bba7597d9..0f086e78c8230 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc
+@@ -25,8 +25,8 @@
+ #include <algorithm>
+ #include <cstdint>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/ext/transport/chttp2/transport/bin_encoder.h"
+ #include "src/core/ext/transport/chttp2/transport/hpack_constants.h"
+ #include "src/core/ext/transport/chttp2/transport/hpack_encoder_table.h"
+@@ -61,7 +61,7 @@ static void FillHeader(uint8_t* p, uint8_t type, uint32_t id, size_t len,
+   // max_frame_size is derived from GRPC_CHTTP2_SETTINGS_MAX_FRAME_SIZE,
+   // which has a max allowable value of 16777215 (see chttp_transport.cc).
+   // Thus, the following assert can be a debug assert.
+-  DCHECK_LE(len, 16777216u);
++  ABSL_DCHECK_LE(len, 16777216u);
+   *p++ = static_cast<uint8_t>(len >> 16);
+   *p++ = static_cast<uint8_t>(len >> 8);
+   *p++ = static_cast<uint8_t>(len);
+@@ -374,7 +374,7 @@ void Compressor<HttpSchemeMetadata, HttpSchemeCompressor>::EncodeWith(
+       encoder->EmitIndexed(7);  // :scheme: https
+       break;
+     case HttpSchemeMetadata::ValueType::kInvalid:
+-      LOG(ERROR) << "Not encoding bad http scheme";
++      ABSL_LOG(ERROR) << "Not encoding bad http scheme";
+       encoder->NoteEncodingError();
+       break;
+   }
+@@ -432,7 +432,7 @@ void Compressor<HttpMethodMetadata, HttpMethodCompressor>::EncodeWith(
+           Slice::FromStaticString(":method"), Slice::FromStaticString("PUT"));
+       break;
+     case HttpMethodMetadata::ValueType::kInvalid:
+-      LOG(ERROR) << "Not encoding bad http method";
++      ABSL_LOG(ERROR) << "Not encoding bad http method";
+       encoder->NoteEncodingError();
+       break;
+   }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h
+index 4fd5b1c08f409..133c4527624b0 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h
+@@ -27,7 +27,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -207,7 +207,7 @@ class Compressor<
+   void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,
+                   Encoder* encoder) {
+     if (value != known_value) {
+-      LOG(ERROR) << "Not encoding bad " << MetadataTrait::key() << " header";
++      ABSL_LOG(ERROR) << "Not encoding bad " << MetadataTrait::key() << " header";
+       encoder->NoteEncodingError();
+       return;
+     }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc
+index 2947587c7a641..98e44b1c2169c 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc
+@@ -18,15 +18,15 @@
+
+ #include <algorithm>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+ uint32_t HPackEncoderTable::AllocateIndex(size_t element_size) {
+-  DCHECK_GE(element_size, 32u);
++  ABSL_DCHECK_GE(element_size, 32u);
+
+   uint32_t new_index = tail_remote_index_ + table_elems_ + 1;
+-  DCHECK(element_size <= MaxEntrySize());
++  ABSL_DCHECK(element_size <= MaxEntrySize());
+
+   if (element_size > max_table_size_) {
+     while (table_size_ > 0) {
+@@ -41,7 +41,7 @@ uint32_t HPackEncoderTable::AllocateIndex(size_t element_size) {
+   while (table_size_ + element_size > max_table_size_) {
+     EvictOne();
+   }
+-  CHECK(table_elems_ < elem_size_.size());
++  ABSL_CHECK(table_elems_ < elem_size_.size());
+   elem_size_[new_index % elem_size_.size()] =
+       static_cast<uint16_t>(element_size);
+   table_size_ += element_size;
+@@ -70,17 +70,17 @@ bool HPackEncoderTable::SetMaxSize(uint32_t max_table_size) {
+
+ void HPackEncoderTable::EvictOne() {
+   tail_remote_index_++;
+-  CHECK_GT(tail_remote_index_, 0u);
+-  CHECK_GT(table_elems_, 0u);
++  ABSL_CHECK_GT(tail_remote_index_, 0u);
++  ABSL_CHECK_GT(table_elems_, 0u);
+   auto removing_size = elem_size_[tail_remote_index_ % elem_size_.size()];
+-  CHECK(table_size_ >= removing_size);
++  ABSL_CHECK(table_size_ >= removing_size);
+   table_size_ -= removing_size;
+   table_elems_--;
+ }
+
+ void HPackEncoderTable::Rebuild(uint32_t capacity) {
+   decltype(elem_size_) new_elem_size(capacity);
+-  CHECK_LE(table_elems_, capacity);
++  ABSL_CHECK_LE(table_elems_, capacity);
+   for (uint32_t i = 0; i < table_elems_; i++) {
+     uint32_t ofs = tail_remote_index_ + i + 1;
+     new_elem_size[ofs % capacity] = elem_size_[ofs % elem_size_.size()];
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc
+index ffead9117a94f..4ad438a7da65e 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc
+@@ -17,7 +17,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <stddef.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/ext/transport/chttp2/transport/hpack_constants.h"
+ #include "src/core/lib/iomgr/error.h"
+@@ -52,7 +52,7 @@ class MetadataSizeLimitExceededEncoder {
+ };
+
+ absl::Status MakeStreamError(absl::Status error) {
+-  DCHECK(!error.ok());
++  ABSL_DCHECK(!error.ok());
+   return grpc_error_set_int(std::move(error), StatusIntProperty::kStreamId, 0);
+ }
+ }  // namespace
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h
+index 583edbd85ce12..2c9bbf0e2b306 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h
+@@ -23,7 +23,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -191,7 +191,7 @@ class HpackParseResult {
+
+   static HpackParseResult InvalidMetadataError(ValidateMetadataResult result,
+                                                absl::string_view key) {
+-    DCHECK(result != ValidateMetadataResult::kOk);
++    ABSL_DCHECK(result != ValidateMetadataResult::kOk);
+     HpackParseResult p{HpackParseStatus::kInvalidMetadata};
+     p.state_->key = std::string(key);
+     p.state_->validate_metadata_result = result;
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc
+index c6ae51074f6c8..f793e2119debf 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc
+@@ -31,8 +31,8 @@
+ #include <variant>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+@@ -193,7 +193,7 @@ class HPackParser::Input {
+   std::optional<StringPrefix> ParseStringPrefix() {
+     auto cur = Next();
+     if (!cur.has_value()) {
+-      DCHECK(eof_error());
++      ABSL_DCHECK(eof_error());
+       return {};
+     }
+     // Huffman if the top bit is 1
+@@ -204,7 +204,7 @@ class HPackParser::Input {
+       // all ones ==> varint string length
+       auto v = ParseVarint(0x7f);
+       if (!v.has_value()) {
+-        DCHECK(eof_error());
++        ABSL_DCHECK(eof_error());
+         return {};
+       }
+       strlen = *v;
+@@ -231,7 +231,7 @@ class HPackParser::Input {
+   // Intended for errors that are specific to a stream and recoverable.
+   // Callers should ensure that any hpack table updates happen.
+   void SetErrorAndContinueParsing(HpackParseResult error) {
+-    DCHECK(error.stream_error());
++    ABSL_DCHECK(error.stream_error());
+     SetError(std::move(error));
+   }
+
+@@ -239,7 +239,7 @@ class HPackParser::Input {
+   // Intended for unrecoverable errors, with the expectation that they will
+   // close the connection on return to chttp2.
+   void SetErrorAndStopParsing(HpackParseResult error) {
+-    DCHECK(error.connection_error());
++    ABSL_DCHECK(error.connection_error());
+     SetError(std::move(error));
+     begin_ = end_;
+   }
+@@ -248,17 +248,17 @@ class HPackParser::Input {
+   // min_progress_size: how many bytes beyond the current frontier do we need to
+   // read prior to being able to get further in this parse.
+   void UnexpectedEOF(size_t min_progress_size) {
+-    CHECK_GT(min_progress_size, 0u);
++    ABSL_CHECK_GT(min_progress_size, 0u);
+     if (eof_error()) return;
+     // Set min progress size, taking into account bytes parsed already but not
+     // consumed.
+     min_progress_size_ = min_progress_size + (begin_ - frontier_);
+-    DCHECK(eof_error());
++    ABSL_DCHECK(eof_error());
+   }
+
+   // Update the frontier - signifies we've successfully parsed another element
+   void UpdateFrontier() {
+-    DCHECK_EQ(skip_bytes_, 0u);
++    ABSL_DCHECK_EQ(skip_bytes_, 0u);
+     frontier_ = begin_;
+   }
+
+@@ -381,7 +381,7 @@ HPackParser::String::StringResult HPackParser::String::ParseUncompressed(
+   // Check there's enough bytes
+   if (input->remaining() < length) {
+     input->UnexpectedEOF(/*min_progress_size=*/length);
+-    DCHECK(input->eof_error());
++    ABSL_DCHECK(input->eof_error());
+     return StringResult{HpackParseStatus::kEof, wire_size, String{}};
+   }
+   auto* refcount = input->slice_refcount();
+@@ -601,7 +601,7 @@ class HPackParser::Parser {
+
+  private:
+   bool ParseTop() {
+-    DCHECK(state_.parse_state == ParseState::kTop);
++    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
+     auto cur = *input_->Next();
+     input_->ClearFieldError();
+     switch (cur >> 4) {
+@@ -708,7 +708,7 @@ class HPackParser::Parser {
+         type = "???";
+         break;
+     }
+-    LOG(INFO) << "HTTP:" << log_info_.stream_id << ":" << type << ":"
++    ABSL_LOG(INFO) << "HTTP:" << log_info_.stream_id << ":" << type << ":"
+               << (log_info_.is_client ? "CLI" : "SVR") << ": "
+               << memento.md.DebugString()
+               << (memento.parse_status.get() == nullptr
+@@ -773,7 +773,7 @@ class HPackParser::Parser {
+
+   // Parse an index encoded key and a string encoded value
+   bool StartIdxKey(uint32_t index, bool add_to_table) {
+-    DCHECK(state_.parse_state == ParseState::kTop);
++    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
+     input_->UpdateFrontier();
+     const auto* elem = state_.hpack_table.Lookup(index);
+     if (GPR_UNLIKELY(elem == nullptr)) {
+@@ -789,14 +789,14 @@ class HPackParser::Parser {
+
+   // Parse a varint index encoded key and a string encoded value
+   bool StartVarIdxKey(uint32_t offset, bool add_to_table) {
+-    DCHECK(state_.parse_state == ParseState::kTop);
++    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
+     auto index = input_->ParseVarint(offset);
+     if (GPR_UNLIKELY(!index.has_value())) return false;
+     return StartIdxKey(*index, add_to_table);
+   }
+
+   bool StartParseLiteralKey(bool add_to_table) {
+-    DCHECK(state_.parse_state == ParseState::kTop);
++    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
+     state_.add_to_table = add_to_table;
+     state_.parse_state = ParseState::kParsingKeyLength;
+     input_->UpdateFrontier();
+@@ -831,7 +831,7 @@ class HPackParser::Parser {
+   }
+
+   bool ParseKeyLength() {
+-    DCHECK(state_.parse_state == ParseState::kParsingKeyLength);
++    ABSL_DCHECK(state_.parse_state == ParseState::kParsingKeyLength);
+     auto pfx = input_->ParseStringPrefix();
+     if (!pfx.has_value()) return false;
+     state_.is_string_huff_compressed = pfx->huff;
+@@ -852,14 +852,14 @@ class HPackParser::Parser {
+   }
+
+   bool ParseKeyBody() {
+-    DCHECK(state_.parse_state == ParseState::kParsingKeyBody);
++    ABSL_DCHECK(state_.parse_state == ParseState::kParsingKeyBody);
+     auto key = String::Parse(input_, state_.is_string_huff_compressed,
+                              state_.string_length);
+     switch (key.status) {
+       case HpackParseStatus::kOk:
+         break;
+       case HpackParseStatus::kEof:
+-        DCHECK(input_->eof_error());
++        ABSL_DCHECK(input_->eof_error());
+         return false;
+       default:
+         input_->SetErrorAndStopParsing(
+@@ -899,7 +899,7 @@ class HPackParser::Parser {
+   }
+
+   bool SkipKeyBody() {
+-    DCHECK(state_.parse_state == ParseState::kSkippingKeyBody);
++    ABSL_DCHECK(state_.parse_state == ParseState::kSkippingKeyBody);
+     if (!SkipStringBody()) return false;
+     input_->UpdateFrontier();
+     state_.parse_state = ParseState::kSkippingValueLength;
+@@ -907,7 +907,7 @@ class HPackParser::Parser {
+   }
+
+   bool SkipValueLength() {
+-    DCHECK(state_.parse_state == ParseState::kSkippingValueLength);
++    ABSL_DCHECK(state_.parse_state == ParseState::kSkippingValueLength);
+     auto pfx = input_->ParseStringPrefix();
+     if (!pfx.has_value()) return false;
+     state_.string_length = pfx->length;
+@@ -917,7 +917,7 @@ class HPackParser::Parser {
+   }
+
+   bool SkipValueBody() {
+-    DCHECK(state_.parse_state == ParseState::kSkippingValueBody);
++    ABSL_DCHECK(state_.parse_state == ParseState::kSkippingValueBody);
+     if (!SkipStringBody()) return false;
+     input_->UpdateFrontier();
+     state_.parse_state = ParseState::kTop;
+@@ -928,7 +928,7 @@ class HPackParser::Parser {
+   }
+
+   bool ParseValueLength() {
+-    DCHECK(state_.parse_state == ParseState::kParsingValueLength);
++    ABSL_DCHECK(state_.parse_state == ParseState::kParsingValueLength);
+     auto pfx = input_->ParseStringPrefix();
+     if (!pfx.has_value()) return false;
+     state_.is_string_huff_compressed = pfx->huff;
+@@ -952,7 +952,7 @@ class HPackParser::Parser {
+   }
+
+   bool ParseValueBody() {
+-    DCHECK(state_.parse_state == ParseState::kParsingValueBody);
++    ABSL_DCHECK(state_.parse_state == ParseState::kParsingValueBody);
+     auto value =
+         state_.is_binary_header
+             ? String::ParseBinary(input_, state_.is_string_huff_compressed,
+@@ -980,7 +980,7 @@ class HPackParser::Parser {
+       case HpackParseStatus::kOk:
+         break;
+       case HpackParseStatus::kEof:
+-        DCHECK(input_->eof_error());
++        ABSL_DCHECK(input_->eof_error());
+         return false;
+       default: {
+         auto result =
+@@ -1003,7 +1003,7 @@ class HPackParser::Parser {
+           if (!state_.field_error.ok()) return;
+           input_->SetErrorAndContinueParsing(
+               HpackParseResult::MetadataParseError(key_string));
+-          LOG(ERROR) << "Error parsing '" << key_string
++          ABSL_LOG(ERROR) << "Error parsing '" << key_string
+                      << "' metadata: " << message;
+         });
+     HPackTable::Memento memento{
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc
+index b258e6ead0975..a61ad9d03b071 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc
+@@ -26,8 +26,8 @@
+ #include <cstring>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -40,7 +40,7 @@
+ namespace grpc_core {
+
+ void HPackTable::MementoRingBuffer::Put(Memento m) {
+-  CHECK_LT(num_entries_, max_entries_);
++  ABSL_CHECK_LT(num_entries_, max_entries_);
+   if (entries_.size() < max_entries_) {
+     ++num_entries_;
+     return entries_.push_back(std::move(m));
+@@ -55,7 +55,7 @@ void HPackTable::MementoRingBuffer::Put(Memento m) {
+ }
+
+ auto HPackTable::MementoRingBuffer::PopOne() -> Memento {
+-  CHECK_GT(num_entries_, 0u);
++  ABSL_CHECK_GT(num_entries_, 0u);
+   size_t index = first_entry_ % max_entries_;
+   if (index == timestamp_index_) {
+     global_stats().IncrementHttp2HpackEntryLifetime(
+@@ -120,7 +120,7 @@ HPackTable::MementoRingBuffer::~MementoRingBuffer() {
+ // Evict one element from the table
+ void HPackTable::EvictOne() {
+   auto first_entry = entries_.PopOne();
+-  CHECK(first_entry.md.transport_size() <= mem_used_);
++  ABSL_CHECK(first_entry.md.transport_size() <= mem_used_);
+   mem_used_ -= first_entry.md.transport_size();
+ }
+
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h
+index fd1cf9ca1cd04..cdb7dd7082519 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h
+@@ -798,7 +798,7 @@ void grpc_chttp2_settings_timeout(
+   (sizeof(GRPC_CHTTP2_CLIENT_CONNECT_STRING) - 1)
+
+ #define GRPC_CHTTP2_IF_TRACING(severity) \
+-  LOG_IF(severity, GRPC_TRACE_FLAG_ENABLED(http))
++  ABSL_LOG_IF(severity, GRPC_TRACE_FLAG_ENABLED(http))
+
+ void grpc_chttp2_fake_status(grpc_chttp2_transport* t,
+                              grpc_chttp2_stream* stream,
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc
+index ccb9642e111d9..36295dd1bd3a4 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc
+@@ -33,8 +33,8 @@
+
+ #include "absl/base/attributes.h"
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/bit_gen_ref.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+@@ -270,7 +270,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_0:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_frame_size = (static_cast<uint32_t>(*cur)) << 16;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_1;
+@@ -278,7 +278,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_1:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_frame_size |= (static_cast<uint32_t>(*cur)) << 8;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_2;
+@@ -286,7 +286,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_2:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_frame_size |= *cur;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_3;
+@@ -294,7 +294,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_3:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_frame_type = *cur;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_4;
+@@ -302,7 +302,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_4:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_frame_flags = *cur;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_5;
+@@ -310,7 +310,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_5:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_stream_id = ((static_cast<uint32_t>(*cur)) & 0x7f) << 24;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_6;
+@@ -318,7 +318,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_6:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_stream_id |= (static_cast<uint32_t>(*cur)) << 16;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_7;
+@@ -326,7 +326,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_7:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_stream_id |= (static_cast<uint32_t>(*cur)) << 8;
+       if (++cur == end) {
+         t->deframe_state = GRPC_DTS_FH_8;
+@@ -334,7 +334,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FH_8:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       t->incoming_stream_id |= (static_cast<uint32_t>(*cur));
+       GRPC_TRACE_LOG(http, INFO)
+           << "INCOMING[" << t << "]: "
+@@ -368,7 +368,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
+       }
+       [[fallthrough]];
+     case GRPC_DTS_FRAME:
+-      DCHECK_LT(cur, end);
++      ABSL_DCHECK_LT(cur, end);
+       if (static_cast<uint32_t>(end - cur) == t->incoming_frame_size) {
+         err = parse_frame_slice(
+             t,
+@@ -458,7 +458,7 @@ static grpc_error_handle init_frame_parser(grpc_chttp2_transport* t,
+     case GRPC_CHTTP2_FRAME_SECURITY:
+       if (!t->settings.peer().allow_security_frame()) {
+         if (GRPC_TRACE_FLAG_ENABLED(http)) {
+-          LOG(ERROR) << "Security frame received but not allowed, ignoring";
++          ABSL_LOG(ERROR) << "Security frame received but not allowed, ignoring";
+         }
+         return init_non_header_skip_frame_parser(t);
+       }
+@@ -734,7 +734,7 @@ static grpc_error_handle init_header_frame_parser(grpc_chttp2_transport* t,
+     }
+     if (GRPC_TRACE_FLAG_ENABLED(http) ||
+         GRPC_TRACE_FLAG_ENABLED(chttp2_new_stream)) {
+-      LOG(INFO) << "[t:" << t << " fd:" << grpc_endpoint_get_fd(t->ep.get())
++      ABSL_LOG(INFO) << "[t:" << t << " fd:" << grpc_endpoint_get_fd(t->ep.get())
+                 << " peer:" << t->peer_string.as_string_view()
+                 << "] Accepting new stream; "
+                    "num_incoming_streams_before_settings_ack="
+@@ -746,7 +746,7 @@ static grpc_error_handle init_header_frame_parser(grpc_chttp2_transport* t,
+   } else {
+     t->incoming_stream = s;
+   }
+-  DCHECK_NE(s, nullptr);
++  ABSL_DCHECK_NE(s, nullptr);
+   s->call_tracer_wrapper.RecordIncomingBytes({9, 0, 0});
+   if (GPR_UNLIKELY(s->read_closed)) {
+     GRPC_CHTTP2_IF_TRACING(ERROR)
+@@ -785,7 +785,7 @@ static grpc_error_handle init_header_frame_parser(grpc_chttp2_transport* t,
+       frame_type = HPackParser::LogInfo::kTrailers;
+       break;
+     case 2:
+-      LOG(ERROR) << "too many header frames received";
++      ABSL_LOG(ERROR) << "too many header frames received";
+       return init_header_skip_frame_parser(t, priority_type, is_eoh);
+   }
+   if (frame_type == HPackParser::LogInfo::kTrailers && !t->header_eof) {
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc
+index 90d78a11e4a4f..b2f3e7027c2c8 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc
+@@ -18,7 +18,7 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/random/distributions.h"
+
+@@ -93,7 +93,7 @@ std::optional<uint64_t> Chttp2PingCallbacks::OnPingTimeout(
+     Duration ping_timeout,
+     grpc_event_engine::experimental::EventEngine* event_engine,
+     Callback callback) {
+-  CHECK(started_new_ping_without_setting_timeout_);
++  ABSL_CHECK(started_new_ping_without_setting_timeout_);
+   started_new_ping_without_setting_timeout_ = false;
+   auto it = inflight_.find(most_recent_inflight_);
+   if (it == inflight_.end()) return std::nullopt;
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc
+index 4ff249fa870bf..72c13d476208c 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc
+@@ -20,8 +20,8 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/ext/transport/chttp2/transport/internal.h"
+ #include "src/core/ext/transport/chttp2/transport/legacy_frame.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -59,7 +59,7 @@ static bool stream_list_pop(grpc_chttp2_transport* t,
+   grpc_chttp2_stream* s = t->lists[id].head;
+   if (s) {
+     grpc_chttp2_stream* new_head = s->links[id].next;
+-    CHECK(s->included.is_set(id));
++    ABSL_CHECK(s->included.is_set(id));
+     if (new_head) {
+       t->lists[id].head = new_head;
+       new_head->links[id].prev = nullptr;
+@@ -71,7 +71,7 @@ static bool stream_list_pop(grpc_chttp2_transport* t,
+   }
+   *stream = s;
+   if (s && GRPC_TRACE_FLAG_ENABLED(http2_stream_state)) {
+-    LOG(INFO) << t << "[" << s->id << "][" << (t->is_client ? "cli" : "svr")
++    ABSL_LOG(INFO) << t << "[" << s->id << "][" << (t->is_client ? "cli" : "svr")
+               << "]: pop from " << stream_list_id_string(id);
+   }
+   return s != nullptr;
+@@ -79,12 +79,12 @@ static bool stream_list_pop(grpc_chttp2_transport* t,
+
+ static void stream_list_remove(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+                                grpc_chttp2_stream_list_id id) {
+-  CHECK(s->included.is_set(id));
++  ABSL_CHECK(s->included.is_set(id));
+   s->included.clear(id);
+   if (s->links[id].prev) {
+     s->links[id].prev->links[id].next = s->links[id].next;
+   } else {
+-    CHECK(t->lists[id].head == s);
++    ABSL_CHECK(t->lists[id].head == s);
+     t->lists[id].head = s->links[id].next;
+   }
+   if (s->links[id].next) {
+@@ -112,7 +112,7 @@ static void stream_list_add_tail(grpc_chttp2_transport* t,
+                                  grpc_chttp2_stream* s,
+                                  grpc_chttp2_stream_list_id id) {
+   grpc_chttp2_stream* old_tail;
+-  CHECK(!s->included.is_set(id));
++  ABSL_CHECK(!s->included.is_set(id));
+   old_tail = t->lists[id].tail;
+   s->links[id].next = nullptr;
+   s->links[id].prev = old_tail;
+@@ -132,7 +132,7 @@ static void stream_list_add_head(grpc_chttp2_transport* t,
+                                  grpc_chttp2_stream* s,
+                                  grpc_chttp2_stream_list_id id) {
+   grpc_chttp2_stream* old_head;
+-  CHECK(!s->included.is_set(id));
++  ABSL_CHECK(!s->included.is_set(id));
+   old_head = t->lists[id].head;
+   s->links[id].next = old_head;
+   s->links[id].prev = nullptr;
+@@ -170,7 +170,7 @@ static bool stream_list_prepend(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
+
+ bool grpc_chttp2_list_add_writable_stream(grpc_chttp2_transport* t,
+                                           grpc_chttp2_stream* s) {
+-  CHECK_NE(s->id, 0u);
++  ABSL_CHECK_NE(s->id, 0u);
+   if (grpc_core::IsPrioritizeFinishedRequestsEnabled() &&
+       s->send_trailing_metadata != nullptr) {
+     return stream_list_prepend(t, s, GRPC_CHTTP2_LIST_WRITABLE);
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h
+index e84f1b6ee2105..02c8a85d14ea8 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h
+@@ -23,7 +23,7 @@
+ #include <stdint.h>
+ #include <stdlib.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ // Helpers for hpack varint encoding
+
+@@ -49,7 +49,7 @@ class VarintWriter {
+   explicit VarintWriter(size_t value)
+       : value_(value),
+         length_(value < kMaxInPrefix ? 1 : VarintLength(value - kMaxInPrefix)) {
+-    CHECK(value <= UINT32_MAX);
++    ABSL_CHECK(value <= UINT32_MAX);
+   }
+
+   size_t value() const { return value_; }
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc
+index b843205de7017..85049a0385a6a 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc
+@@ -18,14 +18,14 @@
+
+ #include <algorithm>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+ size_t Chttp2WriteSizePolicy::WriteTargetSize() { return current_target_; }
+
+ void Chttp2WriteSizePolicy::BeginWrite(size_t size) {
+-  CHECK(experiment_start_time_ == Timestamp::InfFuture());
++  ABSL_CHECK(experiment_start_time_ == Timestamp::InfFuture());
+   if (size < current_target_ * 7 / 10) {
+     // If we were trending fast but stopped getting enough data to verify, then
+     // reset back to the default state.
+diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc
+index f4b551d7b00fb..a7cf58f9c3d44 100644
+--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc
++++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc
+@@ -31,8 +31,8 @@
+ #include <utility>
+
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/channelz/channelz.h"
+ #include "src/core/ext/transport/chttp2/transport/call_tracer_wrapper.h"
+@@ -135,7 +135,7 @@ static void maybe_initiate_ping(grpc_chttp2_transport* t) {
+             GRPC_TRACE_FLAG_ENABLED(bdp_estimator) ||
+             GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
+             GRPC_TRACE_FLAG_ENABLED(http2_ping)) {
+-          LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
++          ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+                     << "]: Ping " << id << " sent ["
+                     << std::string(t->peer_string.as_string_view())
+                     << "]: " << t->ping_rate_policy.GetDebugString();
+@@ -147,7 +147,7 @@ static void maybe_initiate_ping(grpc_chttp2_transport* t) {
+             GRPC_TRACE_FLAG_ENABLED(bdp_estimator) ||
+             GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
+             GRPC_TRACE_FLAG_ENABLED(http2_ping)) {
+-          LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
++          ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+                     << "]: Ping delayed ["
+                     << std::string(t->peer_string.as_string_view())
+                     << "]: too many recent pings: "
+@@ -160,7 +160,7 @@ static void maybe_initiate_ping(grpc_chttp2_transport* t) {
+             GRPC_TRACE_FLAG_ENABLED(bdp_estimator) ||
+             GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
+             GRPC_TRACE_FLAG_ENABLED(http2_ping)) {
+-          LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
++          ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+                     << "]: Ping delayed ["
+                     << std::string(t->peer_string.as_string_view())
+                     << "]: not enough time elapsed since last "
+@@ -261,7 +261,7 @@ class WriteContext {
+       grpc_core::Http2Frame frame(std::move(*update));
+       Serialize(absl::Span<grpc_core::Http2Frame>(&frame, 1), t_->outbuf);
+       if (t_->keepalive_timeout != grpc_core::Duration::Infinity()) {
+-        CHECK(
++        ABSL_CHECK(
+             t_->settings_ack_watchdog ==
+             grpc_event_engine::experimental::EventEngine::TaskHandle::kInvalid);
+         // We base settings timeout on keepalive timeout, but double it to allow
+@@ -282,7 +282,7 @@ class WriteContext {
+     // simple writes are queued to qbuf, and flushed here
+     grpc_slice_buffer_move_into(&t_->qbuf, t_->outbuf.c_slice_buffer());
+     t_->num_pending_induced_frames = 0;
+-    CHECK_EQ(t_->qbuf.count, 0u);
++    ABSL_CHECK_EQ(t_->qbuf.count, 0u);
+   }
+
+   void FlushWindowUpdates() {
+@@ -755,7 +755,7 @@ void grpc_chttp2_end_write(grpc_chttp2_transport* t, grpc_error_handle error) {
+           grpc_chttp2_ping_timeout(t);
+         });
+     if (GRPC_TRACE_FLAG_ENABLED(http2_ping) && id.has_value()) {
+-      LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
++      ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+                 << "]: Set ping timeout timer of " << timeout.ToString()
+                 << " for ping id " << id.value();
+     }
+@@ -767,7 +767,7 @@ void grpc_chttp2_end_write(grpc_chttp2_transport* t, grpc_error_handle error) {
+                 kInvalid) {
+       if (GRPC_TRACE_FLAG_ENABLED(http2_ping) ||
+           GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
+-        LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
++        ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+                   << "]: Set keepalive ping timeout timer of "
+                   << t->keepalive_timeout.ToString();
+       }
+diff --git a/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc b/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc
+index ff036c2795527..9ec3d7be5c411 100644
+--- a/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc
++++ b/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/impl/channel_arg_names.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/ext/transport/cronet/transport/cronet_transport.h"
+@@ -37,7 +37,7 @@
+ GRPCAPI grpc_channel* grpc_cronet_secure_channel_create(
+     void* engine, const char* target, const grpc_channel_args* args,
+     void* reserved) {
+-  VLOG(2) << "grpc_create_cronet_transport: stream_engine = " << engine
++  ABSL_VLOG(2) << "grpc_create_cronet_transport: stream_engine = " << engine
+           << ", target=" << target;
+
+   // Disable client authority filter when using Cronet
+diff --git a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc
+index 25b80945e5b17..d921f92d504d8 100644
+--- a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc
++++ b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc
+@@ -21,7 +21,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "third_party/objective_c/Cronet/bidirectional_stream_c.h"
+
+ #ifdef GRPC_COMPILE_WITH_CRONET
+@@ -31,12 +31,12 @@
+ bidirectional_stream* bidirectional_stream_create(
+     stream_engine* /*engine*/, void* /*annotation*/,
+     bidirectional_stream_callback* /*callback*/) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+   return nullptr;
+ }
+
+ int bidirectional_stream_destroy(bidirectional_stream* /*stream*/) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+   return 0;
+ }
+
+@@ -45,35 +45,35 @@ int bidirectional_stream_start(
+     const char* /*method*/,
+     const bidirectional_stream_header_array* /*headers*/,
+     bool /*end_of_stream*/) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+   return 0;
+ }
+
+ int bidirectional_stream_read(bidirectional_stream* /*stream*/,
+                               char* /*buffer*/, int /*capacity*/) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+   return 0;
+ }
+
+ int bidirectional_stream_write(bidirectional_stream* /*stream*/,
+                                const char* /*buffer*/, int /*count*/,
+                                bool /*end_of_stream*/) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+   return 0;
+ }
+
+-void bidirectional_stream_cancel(bidirectional_stream* /*stream*/) { CHECK(0); }
++void bidirectional_stream_cancel(bidirectional_stream* /*stream*/) { ABSL_CHECK(0); }
+
+ void bidirectional_stream_disable_auto_flush(bidirectional_stream* /*stream*/,
+                                              bool /*disable_auto_flush*/) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+ }
+
+ void bidirectional_stream_delay_request_headers_until_flush(
+     bidirectional_stream* /*stream*/, bool /*delay_headers_until_flush*/) {
+-  CHECK(0);
++  ABSL_CHECK(0);
+ }
+
+-void bidirectional_stream_flush(bidirectional_stream* /*stream*/) { CHECK(0); }
++void bidirectional_stream_flush(bidirectional_stream* /*stream*/) { ABSL_CHECK(0); }
+
+ #endif  // GRPC_COMPILE_WITH_CRONET
+diff --git a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc
+index cf4d67e3cea14..12cc5fd05f9e1 100644
+--- a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc
++++ b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc
+@@ -33,8 +33,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+@@ -407,7 +407,7 @@ static void execute_from_storage(stream_obj* s) {
+   for (struct op_and_state* curr = s->storage.head; curr != nullptr;) {
+     GRPC_TRACE_VLOG(cronet, 2)
+         << "calling op at " << curr << ". done = " << curr->done;
+-    CHECK(!curr->done);
++    ABSL_CHECK(!curr->done);
+     enum e_op_result result = execute_stream_op(curr);
+     GRPC_TRACE_VLOG(cronet, 2) << "execute_stream_op[" << curr << "] returns "
+                                << op_result_string(result);
+@@ -442,7 +442,7 @@ static void convert_cronet_array_to_metadata(
+     }
+     mds->Append(header_array->headers[i].key, grpc_core::Slice(value),
+                 [&](absl::string_view error, const grpc_core::Slice& value) {
+-                  VLOG(2) << "Failed to parse metadata: key="
++                  ABSL_VLOG(2) << "Failed to parse metadata: key="
+                           << header_array->headers[i].key << " error=" << error
+                           << " value=" << value.as_string_view();
+                 });
+@@ -453,7 +453,7 @@ static void convert_cronet_array_to_metadata(
+ // Cronet callback
+ //
+ static void on_failed(bidirectional_stream* stream, int net_error) {
+-  LOG(ERROR) << "on_failed(" << stream << ", " << net_error << ")";
++  ABSL_LOG(ERROR) << "on_failed(" << stream << ", " << net_error << ")";
+   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
+   grpc_core::ExecCtx exec_ctx;
+
+@@ -587,7 +587,7 @@ static void on_response_headers_received(
+         s->state.state_callback_received[OP_FAILED])) {
+     // Do an extra read to trigger on_succeeded() callback in case connection
+     // is closed
+-    CHECK(s->state.rs.length_field_received == false);
++    ABSL_CHECK(s->state.rs.length_field_received == false);
+     read_grpc_header(s);
+   }
+   gpr_mu_unlock(&s->mu);
+@@ -793,7 +793,7 @@ class CronetMetadataEncoder {
+       value = grpc_slice_to_c_string(value_slice.c_slice());
+     }
+     GRPC_TRACE_VLOG(cronet, 2) << "header " << key << " = " << value;
+-    CHECK_LT(count_, capacity_);
++    ABSL_CHECK_LT(count_, capacity_);
+     headers_[count_].key = key;
+     headers_[count_].value = value;
+     ++count_;
+@@ -1052,8 +1052,8 @@ static enum e_op_result execute_stream_op_send_initial_metadata(
+       << "running: " << oas << " OP_SEND_INITIAL_METADATA";
+   // Start new cronet stream. It is destroyed in on_succeeded, on_canceled,
+   // on_failed
+-  CHECK_EQ(s->cbs, nullptr);
+-  CHECK(!stream_state->state_op_done[OP_SEND_INITIAL_METADATA]);
++  ABSL_CHECK_EQ(s->cbs, nullptr);
++  ABSL_CHECK(!stream_state->state_op_done[OP_SEND_INITIAL_METADATA]);
+   s->cbs =
+       bidirectional_stream_create(t->engine, s->curr_gs, &cronet_callbacks);
+   GRPC_TRACE_VLOG(cronet, 2) << s->cbs << " = bidirectional_stream_create()";
+@@ -1257,7 +1257,7 @@ static enum e_op_result execute_stream_op_recv_message(
+       if (stream_state->rs.length_field > 0) {
+         stream_state->rs.read_buffer = static_cast<char*>(
+             gpr_malloc(static_cast<size_t>(stream_state->rs.length_field)));
+-        CHECK(stream_state->rs.read_buffer);
++        ABSL_CHECK(stream_state->rs.read_buffer);
+         stream_state->rs.remaining_bytes = stream_state->rs.length_field;
+         stream_state->rs.received_bytes = 0;
+         GRPC_TRACE_VLOG(cronet, 2)
+@@ -1574,7 +1574,7 @@ grpc_core::Transport* grpc_create_cronet_transport(
+       if (0 ==
+           strcmp(args->args[i].key, GRPC_ARG_USE_CRONET_PACKET_COALESCING)) {
+         if (GPR_UNLIKELY(args->args[i].type != GRPC_ARG_INTEGER)) {
+-          LOG(ERROR) << GRPC_ARG_USE_CRONET_PACKET_COALESCING
++          ABSL_LOG(ERROR) << GRPC_ARG_USE_CRONET_PACKET_COALESCING
+                      << " ignored: it must be an integer";
+         } else {
+           ct->use_packet_coalescing = (args->args[i].value.integer != 0);
+diff --git a/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc b/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc
+index ef0cd9bc1a8eb..9d5494d8f905e 100644
+--- a/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc
++++ b/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc
+@@ -20,8 +20,8 @@
+ #include <atomic>
+ #include <memory>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/ext/transport/inproc/legacy_inproc_transport.h"
+@@ -239,7 +239,7 @@ InprocServerTransport::MakeClientTransport() {
+
+ RefCountedPtr<Channel> MakeLameChannel(absl::string_view why,
+                                        absl::Status error) {
+-  LOG(ERROR) << why << ": " << error.message();
++  ABSL_LOG(ERROR) << why << ": " << error.message();
+   intptr_t integer;
+   grpc_status_code status = GRPC_STATUS_INTERNAL;
+   if (grpc_error_get_int(error, StatusIntProperty::kRpcStatus, &integer)) {
+diff --git a/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc b/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc
+index 9abf6b75a082d..7ede595c46304 100644
+--- a/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc
++++ b/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc
+@@ -35,8 +35,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -314,7 +314,7 @@ void log_metadata(const grpc_metadata_batch* md_batch, bool is_client,
+   std::string prefix = absl::StrCat(
+       "INPROC:", is_initial ? "HDR:" : "TRL:", is_client ? "CLI:" : "SVR:");
+   md_batch->Log([&prefix](absl::string_view key, absl::string_view value) {
+-    LOG(INFO) << absl::StrCat(prefix, key, ": ", value);
++    ABSL_LOG(INFO) << absl::StrCat(prefix, key, ": ", value);
+   });
+ }
+
+@@ -1271,8 +1271,8 @@ grpc_channel* grpc_legacy_inproc_channel_create(grpc_server* server,
+     auto new_channel = grpc_core::ChannelCreate(
+         "inproc", client_args, GRPC_CLIENT_DIRECT_CHANNEL, client_transport);
+     if (!new_channel.ok()) {
+-      CHECK(!channel);
+-      LOG(ERROR) << "Failed to create client channel: "
++      ABSL_CHECK(!channel);
++      ABSL_LOG(ERROR) << "Failed to create client channel: "
+                  << grpc_core::StatusToString(error);
+       intptr_t integer;
+       grpc_status_code status = GRPC_STATUS_INTERNAL;
+@@ -1289,8 +1289,8 @@ grpc_channel* grpc_legacy_inproc_channel_create(grpc_server* server,
+       channel = new_channel->release()->c_ptr();
+     }
+   } else {
+-    CHECK(!channel);
+-    LOG(ERROR) << "Failed to create server channel: "
++    ABSL_CHECK(!channel);
++    ABSL_LOG(ERROR) << "Failed to create server channel: "
+                << grpc_core::StatusToString(error);
+     intptr_t integer;
+     grpc_status_code status = GRPC_STATUS_INTERNAL;
+diff --git a/third_party/grpc/source/src/core/handshaker/handshaker.cc b/third_party/grpc/source/src/core/handshaker/handshaker.cc
+index 241d656da802e..6cc90d1dc1e33 100644
+--- a/third_party/grpc/source/src/core/handshaker/handshaker.cc
++++ b/third_party/grpc/source/src/core/handshaker/handshaker.cc
+@@ -29,8 +29,8 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+@@ -96,7 +96,7 @@ void HandshakeManager::DoHandshake(
+   // last ref to this object.
+   auto self = Ref();
+   MutexLock lock(&mu_);
+-  CHECK_EQ(index_, 0u);
++  ABSL_CHECK_EQ(index_, 0u);
+   on_handshake_done_ = std::move(on_handshake_done);
+   // Construct handshaker args.  These will be passed through all
+   // handshakers and eventually be freed by the on_handshake_done callback.
+@@ -153,7 +153,7 @@ void HandshakeManager::CallNextHandshakerLocked(absl::Status error) {
+       << "handshake_manager " << this << ": error=" << error
+       << " shutdown=" << is_shutdown_ << " index=" << index_
+       << ", args=" << HandshakerArgsString(&args_);
+-  CHECK(index_ <= handshakers_.size());
++  ABSL_CHECK(index_ <= handshakers_.size());
+   // If we got an error or we've been shut down or we're exiting early or
+   // we've finished the last handshaker, invoke the on_handshake_done
+   // callback.
+diff --git a/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc b/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc
+index 1490215b79fd4..b8b419a0d3719 100644
+--- a/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc
++++ b/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc
+@@ -31,7 +31,7 @@
+ #include <utility>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -111,7 +111,7 @@ void HttpConnectHandshaker::HandshakeFailedLocked(absl::Status error) {
+   if (args_ != nullptr && args_->endpoint != nullptr) {
+     peer_string = grpc_endpoint_get_peer(args_->endpoint.get());
+   }
+-  LOG_EVERY_N_SEC(ERROR, 60)
++  ABSL_LOG_EVERY_N_SEC(ERROR, 60)
+       << "HTTP proxy handshake with " << peer_string << " failed: " << error;
+   // Invoke callback.
+   FinishLocked(std::move(error));
+@@ -282,7 +282,7 @@ void HttpConnectHandshaker::DoHandshake(
+     for (size_t i = 0; i < num_header_strings; ++i) {
+       char* sep = strchr(header_strings[i], ':');
+       if (sep == nullptr) {
+-        LOG(ERROR) << "skipping unparsable HTTP CONNECT header: "
++        ABSL_LOG(ERROR) << "skipping unparsable HTTP CONNECT header: "
+                    << header_strings[i];
+         continue;
+       }
+@@ -299,7 +299,7 @@ void HttpConnectHandshaker::DoHandshake(
+   // Log connection via proxy.
+   std::string proxy_name(grpc_endpoint_get_peer(args->endpoint.get()));
+   std::string server_name_string(*server_name);
+-  VLOG(2) << "Connecting to server " << server_name_string << " via HTTP proxy "
++  ABSL_VLOG(2) << "Connecting to server " << server_name_string << " via HTTP proxy "
+           << proxy_name;
+   // Construct HTTP CONNECT request.
+   grpc_http_request request;
+diff --git a/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc b/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc
+index 52d9445513a39..d9160976062c5 100644
+--- a/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc
++++ b/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc
+@@ -29,8 +29,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/ascii.h"
+@@ -105,7 +105,7 @@ bool AddressIncluded(const std::optional<grpc_resolved_address>& target_address,
+ ///
+ std::optional<std::string> GetHttpProxyServer(
+     const ChannelArgs& args, std::optional<std::string>* user_cred) {
+-  CHECK_NE(user_cred, nullptr);
++  ABSL_CHECK_NE(user_cred, nullptr);
+   absl::StatusOr<URI> uri;
+   // We check the following places to determine the HTTP proxy to use, stopping
+   // at the first one that is set:
+@@ -124,12 +124,12 @@ std::optional<std::string> GetHttpProxyServer(
+   if (uri_str->empty()) return std::nullopt;
+   uri = URI::Parse(*uri_str);
+   if (!uri.ok() || uri->authority().empty()) {
+-    LOG(ERROR) << "cannot parse value of 'http_proxy' env var. Error: "
++    ABSL_LOG(ERROR) << "cannot parse value of 'http_proxy' env var. Error: "
+                << uri.status();
+     return std::nullopt;
+   }
+   if (uri->scheme() != "http") {
+-    LOG(ERROR) << "'" << uri->scheme() << "' scheme not supported in proxy URI";
++    ABSL_LOG(ERROR) << "'" << uri->scheme() << "' scheme not supported in proxy URI";
+     return std::nullopt;
+   }
+   // Split on '@' to separate user credentials from host
+@@ -137,7 +137,7 @@ std::optional<std::string> GetHttpProxyServer(
+   size_t authority_nstrs;
+   gpr_string_split(uri->authority().c_str(), "@", &authority_strs,
+                    &authority_nstrs);
+-  CHECK_NE(authority_nstrs, 0u);  // should have at least 1 string
++  ABSL_CHECK_NE(authority_nstrs, 0u);  // should have at least 1 string
+   std::optional<std::string> proxy_name;
+   if (authority_nstrs == 1) {
+     // User cred not present in authority
+@@ -146,7 +146,7 @@ std::optional<std::string> GetHttpProxyServer(
+     // User cred found
+     *user_cred = authority_strs[0];
+     proxy_name = authority_strs[1];
+-    VLOG(2) << "userinfo found in proxy URI";
++    ABSL_VLOG(2) << "userinfo found in proxy URI";
+   } else {
+     // Bad authority
+     proxy_name = std::nullopt;
+@@ -188,7 +188,7 @@ std::optional<grpc_resolved_address> GetAddressProxyServer(
+   }
+   auto address = StringToSockaddr(*address_value);
+   if (!address.ok()) {
+-    LOG(ERROR) << "cannot parse value of '"
++    ABSL_LOG(ERROR) << "cannot parse value of '"
+                << std::string(HttpProxyMapper::kAddressProxyEnvVar)
+                << "' env var. Error: " << address.status().ToString();
+     return std::nullopt;
+@@ -208,17 +208,17 @@ std::optional<std::string> HttpProxyMapper::MapName(
+   if (!name_to_resolve.has_value()) return name_to_resolve;
+   absl::StatusOr<URI> uri = URI::Parse(server_uri);
+   if (!uri.ok() || uri->path().empty()) {
+-    LOG(ERROR) << "'http_proxy' environment variable set, but cannot "
++    ABSL_LOG(ERROR) << "'http_proxy' environment variable set, but cannot "
+                   "parse server URI '"
+                << server_uri << "' -- not using proxy. Error: " << uri.status();
+     return std::nullopt;
+   }
+   if (uri->scheme() == "unix") {
+-    VLOG(2) << "not using proxy for Unix domain socket '" << server_uri << "'";
++    ABSL_VLOG(2) << "not using proxy for Unix domain socket '" << server_uri << "'";
+     return std::nullopt;
+   }
+   if (uri->scheme() == "vsock") {
+-    VLOG(2) << "not using proxy for VSock '" << server_uri << "'";
++    ABSL_VLOG(2) << "not using proxy for VSock '" << server_uri << "'";
+     return std::nullopt;
+   }
+   // Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set.
+@@ -231,7 +231,7 @@ std::optional<std::string> HttpProxyMapper::MapName(
+     std::string server_port;
+     if (!SplitHostPort(absl::StripPrefix(uri->path(), "/"), &server_host,
+                        &server_port)) {
+-      VLOG(2) << "unable to split host and port, not checking no_proxy list "
++      ABSL_VLOG(2) << "unable to split host and port, not checking no_proxy list "
+                  "for host '"
+               << server_uri << "'";
+     } else {
+@@ -240,7 +240,7 @@ std::optional<std::string> HttpProxyMapper::MapName(
+                               ? std::optional<grpc_resolved_address>(*address)
+                               : std::nullopt,
+                           server_host, *no_proxy_str)) {
+-        VLOG(2) << "not using proxy for host in no_proxy list '" << server_uri
++        ABSL_VLOG(2) << "not using proxy for host in no_proxy list '" << server_uri
+                 << "'";
+         return std::nullopt;
+       }
+@@ -266,13 +266,13 @@ std::optional<grpc_resolved_address> HttpProxyMapper::MapAddress(
+   }
+   auto address_string = grpc_sockaddr_to_string(&address, true);
+   if (!address_string.ok()) {
+-    LOG(ERROR) << "Unable to convert address to string: "
++    ABSL_LOG(ERROR) << "Unable to convert address to string: "
+                << address_string.status();
+     return std::nullopt;
+   }
+   std::string host_name, port;
+   if (!SplitHostPort(*address_string, &host_name, &port)) {
+-    LOG(ERROR) << "Address " << *address_string
++    ABSL_LOG(ERROR) << "Address " << *address_string
+                << " cannot be split in host and port";
+     return std::nullopt;
+   }
+diff --git a/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc b/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc
+index 4e5287e58943f..4b874f584d29d 100644
+--- a/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc
++++ b/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc
+@@ -20,7 +20,7 @@
+ #include <optional>
+ #include <string>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/handshaker/http_connect/http_connect_handshaker.h"
+ #include "src/core/lib/address_utils/parse_address.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+@@ -35,13 +35,13 @@ std::optional<grpc_resolved_address> XdsHttpProxyMapper::MapAddress(
+   if (!proxy_address_str.has_value()) return std::nullopt;
+   auto proxy_address = StringToSockaddr(*proxy_address_str);
+   if (!proxy_address.ok()) {
+-    LOG(ERROR) << "error parsing address \"" << *proxy_address_str
++    ABSL_LOG(ERROR) << "error parsing address \"" << *proxy_address_str
+                << "\": " << proxy_address.status();
+     return std::nullopt;
+   }
+   auto endpoint_address_str = grpc_sockaddr_to_string(&endpoint_address, true);
+   if (!endpoint_address_str.ok()) {
+-    LOG(ERROR) << "error converting address to string: "
++    ABSL_LOG(ERROR) << "error converting address to string: "
+                << endpoint_address_str.status();
+     return std::nullopt;
+   }
+diff --git a/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc b/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc
+index caeb48f58f212..99820e7c52246 100644
+--- a/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc
++++ b/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc
+@@ -35,8 +35,8 @@
+ #include <utility>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -156,7 +156,7 @@ static void secure_endpoint_unref(secure_endpoint* ep, const char* reason,
+                                   const char* file, int line) {
+   if (GRPC_TRACE_FLAG_ENABLED(secure_endpoint)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&ep->ref.count);
+-    VLOG(2).AtLocation(file, line) << "SECENDP unref " << ep << " : " << reason
++    ABSL_VLOG(2).AtLocation(file, line) << "SECENDP unref " << ep << " : " << reason
+                                    << " " << val << " -> " << val - 1;
+   }
+   if (gpr_unref(&ep->ref)) {
+@@ -168,7 +168,7 @@ static void secure_endpoint_ref(secure_endpoint* ep, const char* reason,
+                                 const char* file, int line) {
+   if (GRPC_TRACE_FLAG_ENABLED(secure_endpoint)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&ep->ref.count);
+-    VLOG(2).AtLocation(file, line) << "SECENDP   ref " << ep << " : " << reason
++    ABSL_VLOG(2).AtLocation(file, line) << "SECENDP   ref " << ep << " : " << reason
+                                    << " " << val << " -> " << val + 1;
+   }
+   gpr_ref(&ep->ref);
+@@ -233,7 +233,7 @@ static void call_read_cb(secure_endpoint* ep, grpc_error_handle error) {
+     for (i = 0; i < ep->read_buffer->count; i++) {
+       char* data = grpc_dump_slice(ep->read_buffer->slices[i],
+                                    GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-      VLOG(2) << "READ " << ep << ": " << data;
++      ABSL_VLOG(2) << "READ " << ep << ": " << data;
+       gpr_free(data);
+     }
+   }
+@@ -295,7 +295,7 @@ static void on_read(void* user_data, grpc_error_handle error) {
+               &unprotected_buffer_size_written);
+           gpr_mu_unlock(&ep->protector_mu);
+           if (result != TSI_OK) {
+-            LOG(ERROR) << "Decryption error: " << tsi_result_to_string(result);
++            ABSL_LOG(ERROR) << "Decryption error: " << tsi_result_to_string(result);
+             break;
+           }
+           message_bytes += processed_message_size;
+@@ -361,7 +361,7 @@ static void endpoint_read(grpc_endpoint* secure_ep, grpc_slice_buffer* slices,
+   SECURE_ENDPOINT_REF(ep, "read");
+   if (ep->leftover_bytes.count) {
+     grpc_slice_buffer_swap(&ep->leftover_bytes, &ep->source_buffer);
+-    CHECK_EQ(ep->leftover_bytes.count, 0u);
++    ABSL_CHECK_EQ(ep->leftover_bytes.count, 0u);
+     on_read(ep, absl::OkStatus());
+     return;
+   }
+@@ -409,7 +409,7 @@ static void endpoint_write(grpc_endpoint* secure_ep, grpc_slice_buffer* slices,
+       for (i = 0; i < slices->count; i++) {
+         char* data =
+             grpc_dump_slice(slices->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-        VLOG(2) << "WRITE " << ep << ": " << data;
++        ABSL_VLOG(2) << "WRITE " << ep << ": " << data;
+         gpr_free(data);
+       }
+     }
+@@ -450,7 +450,7 @@ static void endpoint_write(grpc_endpoint* secure_ep, grpc_slice_buffer* slices,
+                                                &protected_buffer_size_to_send);
+           gpr_mu_unlock(&ep->protector_mu);
+           if (result != TSI_OK) {
+-            LOG(ERROR) << "Encryption error: " << tsi_result_to_string(result);
++            ABSL_LOG(ERROR) << "Encryption error: " << tsi_result_to_string(result);
+             break;
+           }
+           message_bytes += processed_message_size;
+diff --git a/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc b/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc
+index dc4ff5f4c6793..afd4763d6982b 100644
+--- a/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc
++++ b/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc
+@@ -37,7 +37,7 @@
+
+ #include "absl/base/attributes.h"
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -345,7 +345,7 @@ grpc_error_handle SecurityHandshaker::OnHandshakeNextDoneLocked(
+   }
+   // Read more if we need to.
+   if (result == TSI_INCOMPLETE_DATA) {
+-    CHECK_EQ(bytes_to_send_size, 0u);
++    ABSL_CHECK_EQ(bytes_to_send_size, 0u);
+     grpc_endpoint_read(
+         args_->endpoint.get(), args_->read_buffer.c_slice_buffer(),
+         NewClosure([self = RefAsSubclass<SecurityHandshaker>()](
+@@ -365,7 +365,7 @@ grpc_error_handle SecurityHandshaker::OnHandshakeNextDoneLocked(
+   }
+   // Update handshaker result.
+   if (handshaker_result != nullptr) {
+-    CHECK_EQ(handshaker_result_, nullptr);
++    ABSL_CHECK_EQ(handshaker_result_, nullptr);
+     handshaker_result_ = handshaker_result;
+   }
+   if (bytes_to_send_size > 0) {
+diff --git a/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc b/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc
+index 433ed2b061f89..8f4cccec1b00c 100644
+--- a/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc
++++ b/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc
+@@ -29,7 +29,7 @@
+
+ #include "absl/base/thread_annotations.h"
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/config/core_configuration.h"
+@@ -123,7 +123,7 @@ void TCPConnectHandshaker::DoHandshake(
+     MutexLock lock(&mu_);
+     on_handshake_done_ = std::move(on_handshake_done);
+   }
+-  CHECK_EQ(args->endpoint.get(), nullptr);
++  ABSL_CHECK_EQ(args->endpoint.get(), nullptr);
+   args_ = args;
+   absl::string_view resolved_address_text =
+       args->args.GetString(GRPC_ARG_TCP_HANDSHAKER_RESOLVED_ADDRESS).value();
+@@ -179,7 +179,7 @@ void TCPConnectHandshaker::Connected(void* arg, grpc_error_handle error) {
+       }
+       return;
+     }
+-    CHECK_NE(self->endpoint_to_destroy_, nullptr);
++    ABSL_CHECK_NE(self->endpoint_to_destroy_, nullptr);
+     self->args_->endpoint.reset(self->endpoint_to_destroy_);
+     self->endpoint_to_destroy_ = nullptr;
+     if (self->bind_endpoint_to_pollset_) {
+diff --git a/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc b/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc
+index 8a3c270a3d103..70999637fa376 100644
+--- a/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc
++++ b/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc
+@@ -41,8 +41,8 @@
+ #endif  // GRPC_HAVE_UNIX_SOCKET
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/strip.h"
+@@ -60,13 +60,13 @@
+ bool grpc_parse_unix(const grpc_core::URI& uri,
+                      grpc_resolved_address* resolved_addr) {
+   if (uri.scheme() != "unix") {
+-    LOG(ERROR) << "Expected 'unix' scheme, got '" << uri.scheme() << "'";
++    ABSL_LOG(ERROR) << "Expected 'unix' scheme, got '" << uri.scheme() << "'";
+     return false;
+   }
+   grpc_error_handle error =
+       grpc_core::UnixSockaddrPopulate(uri.path(), resolved_addr);
+   if (!error.ok()) {
+-    LOG(ERROR) << "" << grpc_core::StatusToString(error);
++    ABSL_LOG(ERROR) << "" << grpc_core::StatusToString(error);
+     return false;
+   }
+   return true;
+@@ -75,14 +75,14 @@ bool grpc_parse_unix(const grpc_core::URI& uri,
+ bool grpc_parse_unix_abstract(const grpc_core::URI& uri,
+                               grpc_resolved_address* resolved_addr) {
+   if (uri.scheme() != "unix-abstract") {
+-    LOG(ERROR) << "Expected 'unix-abstract' scheme, got '" << uri.scheme()
++    ABSL_LOG(ERROR) << "Expected 'unix-abstract' scheme, got '" << uri.scheme()
+                << "'";
+     return false;
+   }
+   grpc_error_handle error =
+       grpc_core::UnixAbstractSockaddrPopulate(uri.path(), resolved_addr);
+   if (!error.ok()) {
+-    LOG(ERROR) << "" << grpc_core::StatusToString(error);
++    ABSL_LOG(ERROR) << "" << grpc_core::StatusToString(error);
+     return false;
+   }
+   return true;
+@@ -159,13 +159,13 @@ grpc_error_handle UnixAbstractSockaddrPopulate(
+ bool grpc_parse_vsock(const grpc_core::URI& uri,
+                       grpc_resolved_address* resolved_addr) {
+   if (uri.scheme() != "vsock") {
+-    LOG(ERROR) << "Expected 'vsock' scheme, got '" << uri.scheme() << "'";
++    ABSL_LOG(ERROR) << "Expected 'vsock' scheme, got '" << uri.scheme() << "'";
+     return false;
+   }
+   grpc_error_handle error =
+       grpc_core::VSockaddrPopulate(uri.path(), resolved_addr);
+   if (!error.ok()) {
+-    LOG(ERROR) << "" << grpc_core::StatusToString(error);
++    ABSL_LOG(ERROR) << "" << grpc_core::StatusToString(error);
+     return false;
+   }
+   return true;
+@@ -215,7 +215,7 @@ bool grpc_parse_ipv4_hostport(absl::string_view hostport,
+   std::string port;
+   if (!grpc_core::SplitHostPort(hostport, &host, &port)) {
+     if (log_errors) {
+-      LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
++      ABSL_LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
+     }
+     return false;
+   }
+@@ -226,19 +226,19 @@ bool grpc_parse_ipv4_hostport(absl::string_view hostport,
+   in->sin_family = GRPC_AF_INET;
+   if (grpc_inet_pton(GRPC_AF_INET, host.c_str(), &in->sin_addr) == 0) {
+     if (log_errors) {
+-      LOG(ERROR) << "invalid ipv4 address: '" << host << "'";
++      ABSL_LOG(ERROR) << "invalid ipv4 address: '" << host << "'";
+     }
+     goto done;
+   }
+   // Parse port.
+   if (port.empty()) {
+-    if (log_errors) LOG(ERROR) << "no port given for ipv4 scheme";
++    if (log_errors) ABSL_LOG(ERROR) << "no port given for ipv4 scheme";
+     goto done;
+   }
+   int port_num;
+   if (sscanf(port.c_str(), "%d", &port_num) != 1 || port_num < 0 ||
+       port_num > 65535) {
+-    if (log_errors) LOG(ERROR) << "invalid ipv4 port: '" << port << "'";
++    if (log_errors) ABSL_LOG(ERROR) << "invalid ipv4 port: '" << port << "'";
+     goto done;
+   }
+   in->sin_port = grpc_htons(static_cast<uint16_t>(port_num));
+@@ -250,7 +250,7 @@ done:
+ bool grpc_parse_ipv4(const grpc_core::URI& uri,
+                      grpc_resolved_address* resolved_addr) {
+   if (uri.scheme() != "ipv4") {
+-    LOG(ERROR) << "Expected 'ipv4' scheme, got '" << uri.scheme() << "'";
++    ABSL_LOG(ERROR) << "Expected 'ipv4' scheme, got '" << uri.scheme() << "'";
+     return false;
+   }
+   return grpc_parse_ipv4_hostport(absl::StripPrefix(uri.path(), "/"),
+@@ -265,7 +265,7 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
+   std::string port;
+   if (!grpc_core::SplitHostPort(hostport, &host, &port)) {
+     if (log_errors) {
+-      LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
++      ABSL_LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
+     }
+     return false;
+   }
+@@ -278,14 +278,14 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
+   char* host_end =
+       static_cast<char*>(gpr_memrchr(host.c_str(), '%', host.size()));
+   if (host_end != nullptr) {
+-    CHECK(host_end >= host.c_str());
++    ABSL_CHECK(host_end >= host.c_str());
+     char host_without_scope[GRPC_INET6_ADDRSTRLEN + 1];
+     size_t host_without_scope_len =
+         static_cast<size_t>(host_end - host.c_str());
+     uint32_t sin6_scope_id = 0;
+     if (host_without_scope_len > GRPC_INET6_ADDRSTRLEN) {
+       if (log_errors) {
+-        LOG(ERROR) << "invalid ipv6 address length " << host_without_scope_len
++        ABSL_LOG(ERROR) << "invalid ipv6 address length " << host_without_scope_len
+                    << ". Length cannot be greater than "
+                    << "GRPC_INET6_ADDRSTRLEN i.e " << GRPC_INET6_ADDRSTRLEN;
+       }
+@@ -296,7 +296,7 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
+     if (grpc_inet_pton(GRPC_AF_INET6, host_without_scope, &in6->sin6_addr) ==
+         0) {
+       if (log_errors) {
+-        LOG(ERROR) << "invalid ipv6 address: '" << host_without_scope << "'";
++        ABSL_LOG(ERROR) << "invalid ipv6 address: '" << host_without_scope << "'";
+       }
+       goto done;
+     }
+@@ -304,7 +304,7 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
+                                   host.size() - host_without_scope_len - 1,
+                                   &sin6_scope_id) == 0) {
+       if ((sin6_scope_id = grpc_if_nametoindex(host_end + 1)) == 0) {
+-        LOG(ERROR) << "Invalid interface name: '" << host_end + 1
++        ABSL_LOG(ERROR) << "Invalid interface name: '" << host_end + 1
+                    << "'. Non-numeric and failed if_nametoindex.";
+         goto done;
+       }
+@@ -314,20 +314,20 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
+   } else {
+     if (grpc_inet_pton(GRPC_AF_INET6, host.c_str(), &in6->sin6_addr) == 0) {
+       if (log_errors) {
+-        LOG(ERROR) << "invalid ipv6 address: '" << host << "'";
++        ABSL_LOG(ERROR) << "invalid ipv6 address: '" << host << "'";
+       }
+       goto done;
+     }
+   }
+   // Parse port.
+   if (port.empty()) {
+-    if (log_errors) LOG(ERROR) << "no port given for ipv6 scheme";
++    if (log_errors) ABSL_LOG(ERROR) << "no port given for ipv6 scheme";
+     goto done;
+   }
+   int port_num;
+   if (sscanf(port.c_str(), "%d", &port_num) != 1 || port_num < 0 ||
+       port_num > 65535) {
+-    if (log_errors) LOG(ERROR) << "invalid ipv6 port: '" << port << "'";
++    if (log_errors) ABSL_LOG(ERROR) << "invalid ipv6 port: '" << port << "'";
+     goto done;
+   }
+   in6->sin6_port = grpc_htons(static_cast<uint16_t>(port_num));
+@@ -339,7 +339,7 @@ done:
+ bool grpc_parse_ipv6(const grpc_core::URI& uri,
+                      grpc_resolved_address* resolved_addr) {
+   if (uri.scheme() != "ipv6") {
+-    LOG(ERROR) << "Expected 'ipv6' scheme, got '" << uri.scheme() << "'";
++    ABSL_LOG(ERROR) << "Expected 'ipv6' scheme, got '" << uri.scheme() << "'";
+     return false;
+   }
+   return grpc_parse_ipv6_hostport(absl::StripPrefix(uri.path(), "/"),
+@@ -363,7 +363,7 @@ bool grpc_parse_uri(const grpc_core::URI& uri,
+   if (uri.scheme() == "ipv6") {
+     return grpc_parse_ipv6(uri, resolved_addr);
+   }
+-  LOG(ERROR) << "Can't parse scheme '" << uri.scheme() << "'";
++  ABSL_LOG(ERROR) << "Can't parse scheme '" << uri.scheme() << "'";
+   return false;
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc b/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc
+index b52491637c04d..083471e0259be 100644
+--- a/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc
++++ b/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc
+@@ -22,7 +22,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <inttypes.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #ifdef GRPC_HAVE_VSOCK
+ #include <linux/vm_sockets.h>
+ #endif
+@@ -31,7 +31,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -109,7 +109,7 @@ static const uint8_t kV4MappedPrefix[] = {0, 0, 0, 0, 0,    0,
+
+ int grpc_sockaddr_is_v4mapped(const grpc_resolved_address* resolved_addr,
+                               grpc_resolved_address* resolved_addr4_out) {
+-  CHECK(resolved_addr != resolved_addr4_out);
++  ABSL_CHECK(resolved_addr != resolved_addr4_out);
+   const grpc_sockaddr* addr =
+       reinterpret_cast<const grpc_sockaddr*>(resolved_addr->addr);
+   grpc_sockaddr_in* addr4_out =
+@@ -139,7 +139,7 @@ int grpc_sockaddr_is_v4mapped(const grpc_resolved_address* resolved_addr,
+
+ int grpc_sockaddr_to_v4mapped(const grpc_resolved_address* resolved_addr,
+                               grpc_resolved_address* resolved_addr6_out) {
+-  CHECK(resolved_addr != resolved_addr6_out);
++  ABSL_CHECK(resolved_addr != resolved_addr6_out);
+   const grpc_sockaddr* addr =
+       reinterpret_cast<const grpc_sockaddr*>(resolved_addr->addr);
+   grpc_sockaddr_in6* addr6_out =
+@@ -202,8 +202,8 @@ void grpc_sockaddr_make_wildcard4(int port,
+                                   grpc_resolved_address* resolved_wild_out) {
+   grpc_sockaddr_in* wild_out =
+       reinterpret_cast<grpc_sockaddr_in*>(resolved_wild_out->addr);
+-  CHECK(port >= 0);
+-  CHECK(port < 65536);
++  ABSL_CHECK(port >= 0);
++  ABSL_CHECK(port < 65536);
+   memset(resolved_wild_out, 0, sizeof(*resolved_wild_out));
+   wild_out->sin_family = GRPC_AF_INET;
+   wild_out->sin_port = grpc_htons(static_cast<uint16_t>(port));
+@@ -214,8 +214,8 @@ void grpc_sockaddr_make_wildcard6(int port,
+                                   grpc_resolved_address* resolved_wild_out) {
+   grpc_sockaddr_in6* wild_out =
+       reinterpret_cast<grpc_sockaddr_in6*>(resolved_wild_out->addr);
+-  CHECK(port >= 0);
+-  CHECK(port < 65536);
++  ABSL_CHECK(port >= 0);
++  ABSL_CHECK(port < 65536);
+   memset(resolved_wild_out, 0, sizeof(*resolved_wild_out));
+   wild_out->sin6_family = GRPC_AF_INET6;
+   wild_out->sin6_port = grpc_htons(static_cast<uint16_t>(port));
+@@ -369,7 +369,7 @@ int grpc_sockaddr_get_port(const grpc_resolved_address* resolved_addr) {
+       return 1;
+ #endif
+     default:
+-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
++      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
+                  << " in grpc_sockaddr_get_port";
+       return 0;
+   }
+@@ -379,19 +379,19 @@ int grpc_sockaddr_set_port(grpc_resolved_address* resolved_addr, int port) {
+   grpc_sockaddr* addr = reinterpret_cast<grpc_sockaddr*>(resolved_addr->addr);
+   switch (addr->sa_family) {
+     case GRPC_AF_INET:
+-      CHECK(port >= 0);
+-      CHECK(port < 65536);
++      ABSL_CHECK(port >= 0);
++      ABSL_CHECK(port < 65536);
+       (reinterpret_cast<grpc_sockaddr_in*>(addr))->sin_port =
+           grpc_htons(static_cast<uint16_t>(port));
+       return 1;
+     case GRPC_AF_INET6:
+-      CHECK(port >= 0);
+-      CHECK(port < 65536);
++      ABSL_CHECK(port >= 0);
++      ABSL_CHECK(port < 65536);
+       (reinterpret_cast<grpc_sockaddr_in6*>(addr))->sin6_port =
+           grpc_htons(static_cast<uint16_t>(port));
+       return 1;
+     default:
+-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
++      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
+                  << " in grpc_sockaddr_set_port";
+       return 0;
+   }
+@@ -440,7 +440,7 @@ void grpc_sockaddr_mask_bits(grpc_resolved_address* address,
+     // We cannot use s6_addr32 since it is not defined on all platforms that we
+     // need it on.
+     uint32_t address_parts[4];
+-    CHECK(sizeof(addr6->sin6_addr) == sizeof(address_parts));
++    ABSL_CHECK(sizeof(addr6->sin6_addr) == sizeof(address_parts));
+     memcpy(address_parts, &addr6->sin6_addr, sizeof(grpc_in6_addr));
+     if (mask_bits <= 32) {
+       uint32_t mask_ip_addr = (~(uint32_t{0})) << (32 - mask_bits);
+diff --git a/third_party/grpc/source/src/core/lib/channel/channel_args.cc b/third_party/grpc/source/src/core/lib/channel/channel_args.cc
+index a2c6ba422618f..7093802cb9ced 100644
+--- a/third_party/grpc/source/src/core/lib/channel/channel_args.cc
++++ b/third_party/grpc/source/src/core/lib/channel/channel_args.cc
+@@ -32,8 +32,8 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -262,7 +262,7 @@ std::optional<bool> ChannelArgs::GetBool(absl::string_view name) const {
+   if (v == nullptr) return std::nullopt;
+   auto i = v->GetIfInt();
+   if (!i.has_value()) {
+-    LOG(ERROR) << name << " ignored: it must be an integer";
++    ABSL_LOG(ERROR) << name << " ignored: it must be an integer";
+     return std::nullopt;
+   }
+   switch (*i) {
+@@ -271,7 +271,7 @@ std::optional<bool> ChannelArgs::GetBool(absl::string_view name) const {
+     case 1:
+       return true;
+     default:
+-      LOG(ERROR) << name << " treated as bool but set to " << *i
++      ABSL_LOG(ERROR) << name << " treated as bool but set to " << *i
+                  << " (assuming true)";
+       return true;
+   }
+@@ -425,7 +425,7 @@ grpc_channel_args* grpc_channel_args_copy_and_add_and_remove(
+   for (size_t i = 0; i < num_to_add; ++i) {
+     dst->args[dst_idx++] = copy_arg(&to_add[i]);
+   }
+-  CHECK(dst_idx == dst->num_args);
++  ABSL_CHECK(dst_idx == dst->num_args);
+   return dst;
+ }
+
+@@ -554,15 +554,15 @@ int grpc_channel_arg_get_integer(const grpc_arg* arg,
+                                  const grpc_integer_options options) {
+   if (arg == nullptr) return options.default_value;
+   if (arg->type != GRPC_ARG_INTEGER) {
+-    LOG(ERROR) << arg->key << " ignored: it must be an integer";
++    ABSL_LOG(ERROR) << arg->key << " ignored: it must be an integer";
+     return options.default_value;
+   }
+   if (arg->value.integer < options.min_value) {
+-    LOG(ERROR) << arg->key << " ignored: it must be >= " << options.min_value;
++    ABSL_LOG(ERROR) << arg->key << " ignored: it must be >= " << options.min_value;
+     return options.default_value;
+   }
+   if (arg->value.integer > options.max_value) {
+-    LOG(ERROR) << arg->key << " ignored: it must be <= " << options.max_value;
++    ABSL_LOG(ERROR) << arg->key << " ignored: it must be <= " << options.max_value;
+     return options.default_value;
+   }
+   return arg->value.integer;
+@@ -578,7 +578,7 @@ int grpc_channel_args_find_integer(const grpc_channel_args* args,
+ char* grpc_channel_arg_get_string(const grpc_arg* arg) {
+   if (arg == nullptr) return nullptr;
+   if (arg->type != GRPC_ARG_STRING) {
+-    LOG(ERROR) << arg->key << " ignored: it must be an string";
++    ABSL_LOG(ERROR) << arg->key << " ignored: it must be an string";
+     return nullptr;
+   }
+   return arg->value.string;
+@@ -593,7 +593,7 @@ char* grpc_channel_args_find_string(const grpc_channel_args* args,
+ bool grpc_channel_arg_get_bool(const grpc_arg* arg, bool default_value) {
+   if (arg == nullptr) return default_value;
+   if (arg->type != GRPC_ARG_INTEGER) {
+-    LOG(ERROR) << arg->key << " ignored: it must be an integer";
++    ABSL_LOG(ERROR) << arg->key << " ignored: it must be an integer";
+     return default_value;
+   }
+   switch (arg->value.integer) {
+@@ -602,7 +602,7 @@ bool grpc_channel_arg_get_bool(const grpc_arg* arg, bool default_value) {
+     case 1:
+       return true;
+     default:
+-      LOG(ERROR) << arg->key << " treated as bool but set to "
++      ABSL_LOG(ERROR) << arg->key << " treated as bool but set to "
+                  << arg->value.integer << " (assuming true)";
+       return true;
+   }
+@@ -662,7 +662,7 @@ ChannelArgs ChannelArgsBuiltinPrecondition(const grpc_channel_args* src) {
+     if (key == GRPC_ARG_PRIMARY_USER_AGENT_STRING ||
+         key == GRPC_ARG_SECONDARY_USER_AGENT_STRING) {
+       if (src->args[i].type != GRPC_ARG_STRING) {
+-        LOG(ERROR) << "Channel argument '" << key << "' should be a string";
++        ABSL_LOG(ERROR) << "Channel argument '" << key << "' should be a string";
+       } else {
+         concatenated_values[key].push_back(src->args[i].value.string);
+       }
+@@ -694,7 +694,7 @@ grpc_channel_args_client_channel_creation_mutator g_mutator = nullptr;
+
+ void grpc_channel_args_set_client_channel_creation_mutator(
+     grpc_channel_args_client_channel_creation_mutator cb) {
+-  DCHECK_EQ(g_mutator, nullptr);
++  ABSL_DCHECK_EQ(g_mutator, nullptr);
+   g_mutator = cb;
+ }
+ grpc_channel_args_client_channel_creation_mutator
+diff --git a/third_party/grpc/source/src/core/lib/channel/channel_stack.cc b/third_party/grpc/source/src/core/lib/channel/channel_stack.cc
+index 0b0b0345538d3..32a754047aa15 100644
+--- a/third_party/grpc/source/src/core/lib/channel/channel_stack.cc
++++ b/third_party/grpc/source/src/core/lib/channel/channel_stack.cc
+@@ -24,8 +24,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/channel/channel_fwd.h"
+ #include "src/core/lib/surface/channel_init.h"
+@@ -64,7 +64,7 @@ size_t grpc_channel_stack_size(const grpc_channel_filter** filters,
+                                                sizeof(grpc_channel_element));
+   size_t i;
+
+-  CHECK((GPR_MAX_ALIGNMENT & (GPR_MAX_ALIGNMENT - 1)) == 0)
++  ABSL_CHECK((GPR_MAX_ALIGNMENT & (GPR_MAX_ALIGNMENT - 1)) == 0)
+       << "GPR_MAX_ALIGNMENT must be a power of two";
+
+   // add the size for each filter
+@@ -117,9 +117,9 @@ grpc_error_handle grpc_channel_stack_init(
+     grpc_channel_stack* stack, const grpc_core::Blackboard* old_blackboard,
+     grpc_core::Blackboard* new_blackboard) {
+   if (GRPC_TRACE_FLAG_ENABLED(channel_stack)) {
+-    LOG(INFO) << "CHANNEL_STACK: init " << name;
++    ABSL_LOG(INFO) << "CHANNEL_STACK: init " << name;
+     for (size_t i = 0; i < filter_count; i++) {
+-      LOG(INFO) << "CHANNEL_STACK:   filter " << filters[i]->name;
++      ABSL_LOG(INFO) << "CHANNEL_STACK:   filter " << filters[i]->name;
+     }
+   }
+
+@@ -166,8 +166,8 @@ grpc_error_handle grpc_channel_stack_init(
+     call_size += GPR_ROUND_UP_TO_ALIGNMENT_SIZE(filters[i]->sizeof_call_data);
+   }
+
+-  CHECK(user_data > (char*)stack);
+-  CHECK((uintptr_t)(user_data - (char*)stack) ==
++  ABSL_CHECK(user_data > (char*)stack);
++  ABSL_CHECK((uintptr_t)(user_data - (char*)stack) ==
+         grpc_channel_stack_size(filters, filter_count));
+
+   stack->call_stack_size = call_size;
+diff --git a/third_party/grpc/source/src/core/lib/channel/connected_channel.cc b/third_party/grpc/source/src/core/lib/channel/connected_channel.cc
+index c4b3b41d30ef5..640e0141c11c9 100644
+--- a/third_party/grpc/source/src/core/lib/channel/connected_channel.cc
++++ b/third_party/grpc/source/src/core/lib/channel/connected_channel.cc
+@@ -31,7 +31,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/config/core_configuration.h"
+@@ -220,7 +220,7 @@ static void connected_channel_destroy_call_elem(
+ static grpc_error_handle connected_channel_init_channel_elem(
+     grpc_channel_element* elem, grpc_channel_element_args* args) {
+   channel_data* cd = static_cast<channel_data*>(elem->channel_data);
+-  CHECK(args->is_last);
++  ABSL_CHECK(args->is_last);
+   cd->transport = args->channel_args.GetObject<grpc_core::Transport>();
+   return absl::OkStatus();
+ }
+diff --git a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc
+index d13e13bb19ae1..bcf3ab0787ae3 100644
+--- a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc
++++ b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc
+@@ -25,8 +25,8 @@
+
+ #include "absl/base/attributes.h"
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -172,7 +172,7 @@ BaseCallData::CapturedBatch::~CapturedBatch() {
+   uintptr_t& refcnt = *RefCountField(batch_);
+   if (refcnt == 0) return;  // refcnt==0 ==> cancelled
+   --refcnt;
+-  CHECK_NE(refcnt, 0u);
++  ABSL_CHECK_NE(refcnt, 0u);
+ }
+
+ BaseCallData::CapturedBatch::CapturedBatch(const CapturedBatch& rhs)
+@@ -203,7 +203,7 @@ BaseCallData::CapturedBatch& BaseCallData::CapturedBatch::operator=(
+
+ void BaseCallData::CapturedBatch::ResumeWith(Flusher* releaser) {
+   auto* batch = std::exchange(batch_, nullptr);
+-  CHECK_NE(batch, nullptr);
++  ABSL_CHECK_NE(batch, nullptr);
+   uintptr_t& refcnt = *RefCountField(batch);
+   if (refcnt == 0) {
+     // refcnt==0 ==> cancelled
+@@ -218,7 +218,7 @@ void BaseCallData::CapturedBatch::ResumeWith(Flusher* releaser) {
+
+ void BaseCallData::CapturedBatch::CompleteWith(Flusher* releaser) {
+   auto* batch = std::exchange(batch_, nullptr);
+-  CHECK_NE(batch, nullptr);
++  ABSL_CHECK_NE(batch, nullptr);
+   uintptr_t& refcnt = *RefCountField(batch);
+   if (refcnt == 0) return;  // refcnt==0 ==> cancelled
+   if (--refcnt == 0) {
+@@ -229,7 +229,7 @@ void BaseCallData::CapturedBatch::CompleteWith(Flusher* releaser) {
+ void BaseCallData::CapturedBatch::CancelWith(grpc_error_handle error,
+                                              Flusher* releaser) {
+   auto* batch = std::exchange(batch_, nullptr);
+-  CHECK_NE(batch, nullptr);
++  ABSL_CHECK_NE(batch, nullptr);
+   uintptr_t& refcnt = *RefCountField(batch);
+   if (refcnt == 0) {
+     // refcnt==0 ==> cancelled
+@@ -352,7 +352,7 @@ template <typename T>
+ void BaseCallData::SendMessage::GotPipe(T* pipe_end) {
+   GRPC_TRACE_LOG(channel, INFO)
+       << base_->LogTag() << " SendMessage.GotPipe st=" << StateString(state_);
+-  CHECK_NE(pipe_end, nullptr);
++  ABSL_CHECK_NE(pipe_end, nullptr);
+   switch (state_) {
+     case State::kInitial:
+       state_ = State::kIdle;
+@@ -496,7 +496,7 @@ void BaseCallData::SendMessage::WakeInsideCombiner(Flusher* flusher,
+       }
+       [[fallthrough]];
+     case State::kPushedToPipe: {
+-      CHECK(push_.has_value());
++      ABSL_CHECK(push_.has_value());
+       auto r_push = (*push_)();
+       if (auto* p = r_push.value_if_ready()) {
+         GRPC_TRACE_LOG(channel, INFO)
+@@ -505,12 +505,12 @@ void BaseCallData::SendMessage::WakeInsideCombiner(Flusher* flusher,
+                "result="
+             << (*p ? "true" : "false");
+         // We haven't pulled through yet, so this certainly shouldn't succeed.
+-        CHECK(!*p);
++        ABSL_CHECK(!*p);
+         state_ = State::kCancelled;
+         batch_.CancelWith(absl::CancelledError(), flusher);
+         break;
+       }
+-      CHECK(next_.has_value());
++      ABSL_CHECK(next_.has_value());
+       auto r_next = (*next_)();
+       if (auto* p = r_next.value_if_ready()) {
+         GRPC_TRACE_LOG(channel, INFO)
+@@ -822,12 +822,12 @@ void BaseCallData::ReceiveMessage::WakeInsideCombiner(Flusher* flusher,
+                             completed_status_, "recv_message");
+         break;
+       }
+-      CHECK(state_ == State::kPushedToPipe ||
++      ABSL_CHECK(state_ == State::kPushedToPipe ||
+             state_ == State::kCompletedWhilePushedToPipe);
+       [[fallthrough]];
+     case State::kCompletedWhilePushedToPipe:
+     case State::kPushedToPipe: {
+-      CHECK(push_.has_value());
++      ABSL_CHECK(push_.has_value());
+       auto r_push = (*push_)();
+       if (auto* p = r_push.value_if_ready()) {
+         GRPC_TRACE_LOG(channel, INFO)
+@@ -835,11 +835,11 @@ void BaseCallData::ReceiveMessage::WakeInsideCombiner(Flusher* flusher,
+             << " ReceiveMessage.WakeInsideCombiner push complete: "
+             << (*p ? "true" : "false");
+         // We haven't pulled through yet, so this certainly shouldn't succeed.
+-        CHECK(!*p);
++        ABSL_CHECK(!*p);
+         state_ = State::kCancelled;
+         break;
+       }
+-      CHECK(next_.has_value());
++      ABSL_CHECK(next_.has_value());
+       auto r_next = (*next_)();
+       if (auto* p = r_next.value_if_ready()) {
+         next_.reset();
+@@ -874,7 +874,7 @@ void BaseCallData::ReceiveMessage::WakeInsideCombiner(Flusher* flusher,
+       [[fallthrough]];
+     case State::kCompletedWhilePulledFromPipe:
+     case State::kPulledFromPipe: {
+-      CHECK(push_.has_value());
++      ABSL_CHECK(push_.has_value());
+       if ((*push_)().ready()) {
+         GRPC_TRACE_LOG(channel, INFO)
+             << base_->LogTag()
+@@ -978,7 +978,7 @@ class ClientCallData::PollContext {
+  public:
+   explicit PollContext(ClientCallData* self, Flusher* flusher)
+       : self_(self), flusher_(flusher) {
+-    CHECK_EQ(self_->poll_ctx_, nullptr);
++    ABSL_CHECK_EQ(self_->poll_ctx_, nullptr);
+
+     self_->poll_ctx_ = this;
+     scoped_activity_.Init(self_);
+@@ -989,11 +989,11 @@ class ClientCallData::PollContext {
+   PollContext& operator=(const PollContext&) = delete;
+
+   void Run() {
+-    DCHECK(HasContext<Arena>());
++    ABSL_DCHECK(HasContext<Arena>());
+     GRPC_TRACE_LOG(channel, INFO)
+         << self_->LogTag() << " ClientCallData.PollContext.Run "
+         << self_->DebugString();
+-    CHECK(have_scoped_activity_);
++    ABSL_CHECK(have_scoped_activity_);
+     repoll_ = false;
+     if (self_->send_message() != nullptr) {
+       self_->send_message()->WakeInsideCombiner(flusher_, true);
+@@ -1028,8 +1028,8 @@ class ClientCallData::PollContext {
+         case RecvInitialMetadata::kCompleteAndGotPipe:
+           self_->recv_initial_metadata_->state =
+               RecvInitialMetadata::kCompleteAndPushedToPipe;
+-          CHECK(!self_->recv_initial_metadata_->metadata_push_.has_value());
+-          CHECK(!self_->recv_initial_metadata_->metadata_next_.has_value());
++          ABSL_CHECK(!self_->recv_initial_metadata_->metadata_push_.has_value());
++          ABSL_CHECK(!self_->recv_initial_metadata_->metadata_next_.has_value());
+           self_->recv_initial_metadata_->metadata_push_.emplace(
+               self_->recv_initial_metadata_->server_initial_metadata_publisher
+                   ->Push(ServerMetadataHandle(
+@@ -1040,7 +1040,7 @@ class ClientCallData::PollContext {
+               self_->server_initial_metadata_pipe()->receiver.Next());
+           [[fallthrough]];
+         case RecvInitialMetadata::kCompleteAndPushedToPipe: {
+-          CHECK(self_->recv_initial_metadata_->metadata_next_.has_value());
++          ABSL_CHECK(self_->recv_initial_metadata_->metadata_next_.has_value());
+           Poll<NextResult<ServerMetadataHandle>> p =
+               (*self_->recv_initial_metadata_->metadata_next_)();
+           if (NextResult<ServerMetadataHandle>* nr = p.value_if_ready()) {
+@@ -1132,7 +1132,7 @@ class ClientCallData::PollContext {
+             }
+           } else {
+             self_->cancelled_error_ = StatusFromMetadata(*md);
+-            CHECK(!self_->cancelled_error_.ok());
++            ABSL_CHECK(!self_->cancelled_error_.ok());
+             if (self_->recv_initial_metadata_ != nullptr) {
+               switch (self_->recv_initial_metadata_->state) {
+                 case RecvInitialMetadata::kInitial:
+@@ -1170,7 +1170,7 @@ class ClientCallData::PollContext {
+               self_->send_initial_metadata_batch_.CancelWith(
+                   self_->cancelled_error_, flusher_);
+             } else {
+-              CHECK(
++              ABSL_CHECK(
+                   self_->recv_trailing_state_ == RecvTrailingState::kInitial ||
+                   self_->recv_trailing_state_ == RecvTrailingState::kForwarded);
+               self_->call_combiner()->Cancel(self_->cancelled_error_);
+@@ -1276,7 +1276,7 @@ ClientCallData::ClientCallData(grpc_call_element* elem,
+
+ ClientCallData::~ClientCallData() {
+   ScopedActivity scoped_activity(this);
+-  CHECK_EQ(poll_ctx_, nullptr);
++  ABSL_CHECK_EQ(poll_ctx_, nullptr);
+   if (recv_initial_metadata_ != nullptr) {
+     recv_initial_metadata_->~RecvInitialMetadata();
+   }
+@@ -1290,7 +1290,7 @@ std::string ClientCallData::DebugTag() const {
+
+ // Activity implementation.
+ void ClientCallData::ForceImmediateRepoll(WakeupMask) {
+-  CHECK_NE(poll_ctx_, nullptr);
++  ABSL_CHECK_NE(poll_ctx_, nullptr);
+   poll_ctx_->Repoll();
+ }
+
+@@ -1358,7 +1358,7 @@ void ClientCallData::StartBatch(grpc_transport_stream_op_batch* b) {
+   // If this is a cancel stream, cancel anything we have pending and propagate
+   // the cancellation.
+   if (batch->cancel_stream) {
+-    CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
++    ABSL_CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
+           !batch->send_message && !batch->recv_initial_metadata &&
+           !batch->recv_message && !batch->recv_trailing_metadata);
+     PollContext poll_ctx(this, &flusher);
+@@ -1431,12 +1431,12 @@ void ClientCallData::StartBatch(grpc_transport_stream_op_batch* b) {
+       batch.CancelWith(cancelled_error_, &flusher);
+     } else {
+       // Otherwise, we should not have seen a send_initial_metadata op yet.
+-      CHECK(send_initial_state_ == SendInitialState::kInitial);
++      ABSL_CHECK(send_initial_state_ == SendInitialState::kInitial);
+       // Mark ourselves as queued.
+       send_initial_state_ = SendInitialState::kQueued;
+       if (batch->recv_trailing_metadata) {
+         // If there's a recv_trailing_metadata op, we queue that too.
+-        CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
++        ABSL_CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
+         recv_trailing_state_ = RecvTrailingState::kQueued;
+       }
+       // This is the queuing!
+@@ -1451,7 +1451,7 @@ void ClientCallData::StartBatch(grpc_transport_stream_op_batch* b) {
+     if (recv_trailing_state_ == RecvTrailingState::kCancelled) {
+       batch.CancelWith(cancelled_error_, &flusher);
+     } else {
+-      CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
++      ABSL_CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
+       recv_trailing_state_ = RecvTrailingState::kForwarded;
+       HookRecvTrailingMetadata(batch);
+     }
+@@ -1527,7 +1527,7 @@ void ClientCallData::Cancel(grpc_error_handle error, Flusher* flusher) {
+ // Begin running the promise - which will ultimately take some initial
+ // metadata and return some trailing metadata.
+ void ClientCallData::StartPromise(Flusher* flusher) {
+-  CHECK(send_initial_state_ == SendInitialState::kQueued);
++  ABSL_CHECK(send_initial_state_ == SendInitialState::kQueued);
+   ChannelFilter* filter = promise_filter_detail::ChannelFilterFromElem(elem());
+
+   // Construct the promise.
+@@ -1637,8 +1637,8 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
+     CallArgs call_args) {
+   GRPC_TRACE_LOG(channel, INFO)
+       << LogTag() << " ClientCallData.MakeNextPromise " << DebugString();
+-  CHECK_NE(poll_ctx_, nullptr);
+-  CHECK(send_initial_state_ == SendInitialState::kQueued);
++  ABSL_CHECK_NE(poll_ctx_, nullptr);
++  ABSL_CHECK(send_initial_state_ == SendInitialState::kQueued);
+   send_initial_metadata_batch_->payload->send_initial_metadata
+       .send_initial_metadata = call_args.client_initial_metadata.get();
+   if (recv_initial_metadata_ != nullptr) {
+@@ -1646,7 +1646,7 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
+     // It might be the one we passed in - in which case we know this filter
+     // only wants to examine the metadata, or it might be a new instance, in
+     // which case we know the filter wants to mutate.
+-    CHECK_NE(call_args.server_initial_metadata, nullptr);
++    ABSL_CHECK_NE(call_args.server_initial_metadata, nullptr);
+     recv_initial_metadata_->server_initial_metadata_publisher =
+         call_args.server_initial_metadata;
+     switch (recv_initial_metadata_->state) {
+@@ -1675,17 +1675,17 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
+                 recv_initial_metadata_->state)));  // unreachable
+     }
+   } else {
+-    CHECK_EQ(call_args.server_initial_metadata, nullptr);
++    ABSL_CHECK_EQ(call_args.server_initial_metadata, nullptr);
+   }
+   if (send_message() != nullptr) {
+     send_message()->GotPipe(call_args.client_to_server_messages);
+   } else {
+-    CHECK_EQ(call_args.client_to_server_messages, nullptr);
++    ABSL_CHECK_EQ(call_args.client_to_server_messages, nullptr);
+   }
+   if (receive_message() != nullptr) {
+     receive_message()->GotPipe(call_args.server_to_client_messages);
+   } else {
+-    CHECK_EQ(call_args.server_to_client_messages, nullptr);
++    ABSL_CHECK_EQ(call_args.server_to_client_messages, nullptr);
+   }
+   return ArenaPromise<ServerMetadataHandle>(
+       [this]() { return PollTrailingMetadata(); });
+@@ -1698,10 +1698,10 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
+ Poll<ServerMetadataHandle> ClientCallData::PollTrailingMetadata() {
+   GRPC_TRACE_LOG(channel, INFO)
+       << LogTag() << " ClientCallData.PollTrailingMetadata " << DebugString();
+-  CHECK_NE(poll_ctx_, nullptr);
++  ABSL_CHECK_NE(poll_ctx_, nullptr);
+   if (send_initial_state_ == SendInitialState::kQueued) {
+     // First poll: pass the send_initial_metadata op down the stack.
+-    CHECK(send_initial_metadata_batch_.is_captured());
++    ABSL_CHECK(send_initial_metadata_batch_.is_captured());
+     send_initial_state_ = SendInitialState::kForwarded;
+     if (recv_trailing_state_ == RecvTrailingState::kQueued) {
+       // (and the recv_trailing_metadata op if it's part of the queuing)
+@@ -1768,7 +1768,7 @@ void ClientCallData::RecvTrailingMetadataReady(grpc_error_handle error) {
+     SetStatusFromError(recv_trailing_metadata_, error);
+   }
+   // Record that we've got the callback.
+-  CHECK(recv_trailing_state_ == RecvTrailingState::kForwarded);
++  ABSL_CHECK(recv_trailing_state_ == RecvTrailingState::kForwarded);
+   recv_trailing_state_ = RecvTrailingState::kComplete;
+   if (receive_message() != nullptr) {
+     receive_message()->Done(*recv_trailing_metadata_, &flusher);
+@@ -1857,7 +1857,7 @@ class ServerCallData::PollContext {
+           created_.line(), "; Old: ", self_->poll_ctx_->created_.file(), ":",
+           self_->poll_ctx_->created_.line()));
+     }
+-    CHECK_EQ(self_->poll_ctx_, nullptr);
++    ABSL_CHECK_EQ(self_->poll_ctx_, nullptr);
+     self_->poll_ctx_ = this;
+     scoped_activity_.Init(self_);
+     have_scoped_activity_ = true;
+@@ -1965,7 +1965,7 @@ ServerCallData::~ServerCallData() {
+   if (send_initial_metadata_ != nullptr) {
+     send_initial_metadata_->~SendInitialMetadata();
+   }
+-  CHECK_EQ(poll_ctx_, nullptr);
++  ABSL_CHECK_EQ(poll_ctx_, nullptr);
+ }
+
+ std::string ServerCallData::DebugTag() const {
+@@ -1974,7 +1974,7 @@ std::string ServerCallData::DebugTag() const {
+
+ // Activity implementation.
+ void ServerCallData::ForceImmediateRepoll(WakeupMask) {
+-  CHECK_NE(poll_ctx_, nullptr);
++  ABSL_CHECK_NE(poll_ctx_, nullptr);
+   poll_ctx_->Repoll();
+ }
+
+@@ -1991,7 +1991,7 @@ void ServerCallData::StartBatch(grpc_transport_stream_op_batch* b) {
+   // If this is a cancel stream, cancel anything we have pending and
+   // propagate the cancellation.
+   if (batch->cancel_stream) {
+-    CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
++    ABSL_CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
+           !batch->send_message && !batch->recv_initial_metadata &&
+           !batch->recv_message && !batch->recv_trailing_metadata);
+     PollContext poll_ctx(this, &flusher);
+@@ -2008,11 +2008,11 @@ void ServerCallData::StartBatch(grpc_transport_stream_op_batch* b) {
+   // recv_initial_metadata: we hook the response of this so we can start the
+   // promise at an appropriate time.
+   if (batch->recv_initial_metadata) {
+-    CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
++    ABSL_CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
+           !batch->send_message && !batch->recv_message &&
+           !batch->recv_trailing_metadata);
+     // Otherwise, we should not have seen a send_initial_metadata op yet.
+-    CHECK(recv_initial_state_ == RecvInitialState::kInitial);
++    ABSL_CHECK(recv_initial_state_ == RecvInitialState::kInitial);
+     // Hook the callback so we know when to start the promise.
+     recv_initial_metadata_ =
+         batch->payload->recv_initial_metadata.recv_initial_metadata;
+@@ -2190,13 +2190,13 @@ void ServerCallData::Completed(grpc_error_handle error,
+ //   - return a wrapper around PollTrailingMetadata as the promise.
+ ArenaPromise<ServerMetadataHandle> ServerCallData::MakeNextPromise(
+     CallArgs call_args) {
+-  CHECK(recv_initial_state_ == RecvInitialState::kComplete);
+-  CHECK(std::move(call_args.client_initial_metadata).get() ==
++  ABSL_CHECK(recv_initial_state_ == RecvInitialState::kComplete);
++  ABSL_CHECK(std::move(call_args.client_initial_metadata).get() ==
+         recv_initial_metadata_);
+   forward_recv_initial_metadata_callback_ = true;
+   if (send_initial_metadata_ != nullptr) {
+-    CHECK(send_initial_metadata_->server_initial_metadata_publisher == nullptr);
+-    CHECK_NE(call_args.server_initial_metadata, nullptr);
++    ABSL_CHECK(send_initial_metadata_->server_initial_metadata_publisher == nullptr);
++    ABSL_CHECK_NE(call_args.server_initial_metadata, nullptr);
+     send_initial_metadata_->server_initial_metadata_publisher =
+         call_args.server_initial_metadata;
+     switch (send_initial_metadata_->state) {
+@@ -2219,17 +2219,17 @@ ArenaPromise<ServerMetadataHandle> ServerCallData::MakeNextPromise(
+         break;
+     }
+   } else {
+-    CHECK_EQ(call_args.server_initial_metadata, nullptr);
++    ABSL_CHECK_EQ(call_args.server_initial_metadata, nullptr);
+   }
+   if (send_message() != nullptr) {
+     send_message()->GotPipe(call_args.server_to_client_messages);
+   } else {
+-    CHECK_EQ(call_args.server_to_client_messages, nullptr);
++    ABSL_CHECK_EQ(call_args.server_to_client_messages, nullptr);
+   }
+   if (receive_message() != nullptr) {
+     receive_message()->GotPipe(call_args.client_to_server_messages);
+   } else {
+-    CHECK_EQ(call_args.client_to_server_messages, nullptr);
++    ABSL_CHECK_EQ(call_args.client_to_server_messages, nullptr);
+   }
+   return ArenaPromise<ServerMetadataHandle>(
+       [this]() { return PollTrailingMetadata(); });
+@@ -2291,7 +2291,7 @@ void ServerCallData::RecvInitialMetadataReady(grpc_error_handle error) {
+                             "ServerCallData::RecvInitialMetadataReady"));
+   GRPC_TRACE_LOG(channel, INFO)
+       << LogTag() << ": RecvInitialMetadataReady " << error;
+-  CHECK(recv_initial_state_ == RecvInitialState::kForwarded);
++  ABSL_CHECK(recv_initial_state_ == RecvInitialState::kForwarded);
+   // If there was an error we just propagate that through
+   if (!error.ok()) {
+     recv_initial_state_ = RecvInitialState::kResponded;
+@@ -2361,8 +2361,8 @@ void ServerCallData::WakeInsideCombiner(Flusher* flusher) {
+         SendInitialMetadata::kQueuedAndGotPipe) {
+       send_initial_metadata_->state =
+           SendInitialMetadata::kQueuedAndPushedToPipe;
+-      CHECK(!send_initial_metadata_->metadata_push_.has_value());
+-      CHECK(!send_initial_metadata_->metadata_next_.has_value());
++      ABSL_CHECK(!send_initial_metadata_->metadata_push_.has_value());
++      ABSL_CHECK(!send_initial_metadata_->metadata_next_.has_value());
+       send_initial_metadata_->metadata_push_.emplace(
+           send_initial_metadata_->server_initial_metadata_publisher->Push(
+               ServerMetadataHandle(
+@@ -2436,7 +2436,7 @@ void ServerCallData::WakeInsideCombiner(Flusher* flusher) {
+     if (send_initial_metadata_ != nullptr &&
+         send_initial_metadata_->state ==
+             SendInitialMetadata::kQueuedAndPushedToPipe) {
+-      CHECK(send_initial_metadata_->metadata_next_.has_value());
++      ABSL_CHECK(send_initial_metadata_->metadata_next_.has_value());
+       auto p = (*send_initial_metadata_->metadata_next_)();
+       GRPC_TRACE_LOG(channel, INFO)
+           << LogTag() << ": WakeInsideCombiner send_initial_metadata poll="
+@@ -2483,7 +2483,7 @@ void ServerCallData::WakeInsideCombiner(Flusher* flusher) {
+               StateString(send_trailing_state_)));  // unreachable
+           break;
+         case SendTrailingState::kInitial: {
+-          CHECK(*md->get_pointer(GrpcStatusMetadata()) != GRPC_STATUS_OK);
++          ABSL_CHECK(*md->get_pointer(GrpcStatusMetadata()) != GRPC_STATUS_OK);
+           Completed(StatusFromMetadata(*md), md->get(GrpcTarPit()).has_value(),
+                     flusher);
+         } break;
+diff --git a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h
+index 4622e02f2aa94..f21d06144ca0e 100644
+--- a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h
++++ b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h
+@@ -35,8 +35,8 @@
+
+ #include "absl/container/inlined_vector.h"
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+@@ -287,7 +287,7 @@ auto MapResult(const NoInterceptor*, Promise x, void*) {
+ template <typename Promise, typename Derived>
+ auto MapResult(absl::Status (Derived::Call::*fn)(ServerMetadata&), Promise x,
+                FilterCallData<Derived>* call_data) {
+-  DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
+   return OnCancel(Map(std::move(x),
+                       [call_data](ServerMetadataHandle md) {
+                         auto status =
+@@ -308,7 +308,7 @@ auto MapResult(absl::Status (Derived::Call::*fn)(ServerMetadata&), Promise x,
+ template <typename Promise, typename Derived>
+ auto MapResult(void (Derived::Call::*fn)(ServerMetadata&), Promise x,
+                FilterCallData<Derived>* call_data) {
+-  DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
+   return OnCancel(Map(std::move(x),
+                       [call_data](ServerMetadataHandle md) {
+                         call_data->call.OnServerTrailingMetadata(*md);
+@@ -325,7 +325,7 @@ auto MapResult(void (Derived::Call::*fn)(ServerMetadata&), Promise x,
+ template <typename Promise, typename Derived>
+ auto MapResult(void (Derived::Call::*fn)(ServerMetadata&, Derived*), Promise x,
+                FilterCallData<Derived>* call_data) {
+-  DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
+   return OnCancel(
+       Map(std::move(x),
+           [call_data](ServerMetadataHandle md) {
+@@ -466,7 +466,7 @@ template <typename Interceptor, typename Derived>
+ auto RunCall(Interceptor interceptor, CallArgs call_args,
+              NextPromiseFactory next_promise_factory,
+              FilterCallData<Derived>* call_data) {
+-  DCHECK(interceptor == &Derived::Call::OnClientInitialMetadata);
++  ABSL_DCHECK(interceptor == &Derived::Call::OnClientInitialMetadata);
+   return RunCallImpl<Interceptor, Derived>::Run(
+       std::move(call_args), std::move(next_promise_factory), call_data);
+ }
+@@ -475,7 +475,7 @@ template <typename Derived>
+ inline auto InterceptClientToServerMessageHandler(
+     void (Derived::Call::*fn)(const Message&),
+     FilterCallData<Derived>* call_data, const CallArgs&) {
+-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+     call_data->call.OnClientToServerMessage(*msg);
+     return std::move(msg);
+@@ -486,7 +486,7 @@ template <typename Derived>
+ inline auto InterceptClientToServerMessageHandler(
+     ServerMetadataHandle (Derived::Call::*fn)(const Message&),
+     FilterCallData<Derived>* call_data, const CallArgs&) {
+-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+     auto return_md = call_data->call.OnClientToServerMessage(*msg);
+     if (return_md == nullptr) return std::move(msg);
+@@ -500,7 +500,7 @@ template <typename Derived>
+ inline auto InterceptClientToServerMessageHandler(
+     ServerMetadataHandle (Derived::Call::*fn)(const Message&, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs&) {
+-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+     auto return_md =
+         call_data->call.OnClientToServerMessage(*msg, call_data->channel);
+@@ -515,7 +515,7 @@ template <typename Derived>
+ inline auto InterceptClientToServerMessageHandler(
+     void (Derived::Call::*fn)(const Message&, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs&) {
+-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+     call_data->call.OnClientToServerMessage(*msg, call_data->channel);
+     return std::move(msg);
+@@ -526,7 +526,7 @@ template <typename Derived>
+ inline auto InterceptClientToServerMessageHandler(
+     MessageHandle (Derived::Call::*fn)(MessageHandle, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs&) {
+-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+     return call_data->call.OnClientToServerMessage(std::move(msg),
+                                                    call_data->channel);
+@@ -537,7 +537,7 @@ template <typename Derived>
+ inline auto InterceptClientToServerMessageHandler(
+     absl::StatusOr<MessageHandle> (Derived::Call::*fn)(MessageHandle, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs&) {
+-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+     auto r = call_data->call.OnClientToServerMessage(std::move(msg),
+                                                      call_data->channel);
+@@ -581,7 +581,7 @@ template <typename Derived>
+ inline void InterceptServerInitialMetadata(
+     void (Derived::Call::*fn)(ServerMetadata&),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+   call_args.server_initial_metadata->InterceptAndMap(
+       [call_data](ServerMetadataHandle md) {
+         call_data->call.OnServerInitialMetadata(*md);
+@@ -593,7 +593,7 @@ template <typename Derived>
+ inline void InterceptServerInitialMetadata(
+     absl::Status (Derived::Call::*fn)(ServerMetadata&),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+   call_args.server_initial_metadata->InterceptAndMap(
+       [call_data](
+           ServerMetadataHandle md) -> std::optional<ServerMetadataHandle> {
+@@ -610,7 +610,7 @@ template <typename Derived>
+ inline void InterceptServerInitialMetadata(
+     void (Derived::Call::*fn)(ServerMetadata&, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+   call_args.server_initial_metadata->InterceptAndMap(
+       [call_data](ServerMetadataHandle md) {
+         call_data->call.OnServerInitialMetadata(*md, call_data->channel);
+@@ -622,7 +622,7 @@ template <typename Derived>
+ inline void InterceptServerInitialMetadata(
+     absl::Status (Derived::Call::*fn)(ServerMetadata&, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+   call_args.server_initial_metadata->InterceptAndMap(
+       [call_data](
+           ServerMetadataHandle md) -> std::optional<ServerMetadataHandle> {
+@@ -643,7 +643,7 @@ template <typename Derived>
+ inline void InterceptServerToClientMessage(
+     void (Derived::Call::*fn)(const Message&),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+   call_args.server_to_client_messages->InterceptAndMap(
+       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+         call_data->call.OnServerToClientMessage(*msg);
+@@ -655,7 +655,7 @@ template <typename Derived>
+ inline void InterceptServerToClientMessage(
+     ServerMetadataHandle (Derived::Call::*fn)(const Message&),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+   call_args.server_to_client_messages->InterceptAndMap(
+       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+         auto return_md = call_data->call.OnServerToClientMessage(*msg);
+@@ -670,7 +670,7 @@ template <typename Derived>
+ inline void InterceptServerToClientMessage(
+     void (Derived::Call::*fn)(const Message&, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+   call_args.server_to_client_messages->InterceptAndMap(
+       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+         call_data->call.OnServerToClientMessage(*msg, call_data->channel);
+@@ -682,7 +682,7 @@ template <typename Derived>
+ inline void InterceptServerToClientMessage(
+     ServerMetadataHandle (Derived::Call::*fn)(const Message&, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+   call_args.server_to_client_messages->InterceptAndMap(
+       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+         auto return_md =
+@@ -698,7 +698,7 @@ template <typename Derived>
+ inline void InterceptServerToClientMessage(
+     MessageHandle (Derived::Call::*fn)(MessageHandle, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+   call_args.server_to_client_messages->InterceptAndMap(
+       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+         return call_data->call.OnServerToClientMessage(std::move(msg),
+@@ -710,7 +710,7 @@ template <typename Derived>
+ inline void InterceptServerToClientMessage(
+     absl::StatusOr<MessageHandle> (Derived::Call::*fn)(MessageHandle, Derived*),
+     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
+-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
++  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+   call_args.server_to_client_messages->InterceptAndMap(
+       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
+         auto r = call_data->call.OnServerToClientMessage(std::move(msg),
+@@ -727,7 +727,7 @@ inline void InterceptFinalize(const NoInterceptor*, void*, void*) {}
+ template <class Call>
+ inline void InterceptFinalize(void (Call::*fn)(const grpc_call_final_info*),
+                               void*, Call* call) {
+-  DCHECK(fn == &Call::OnFinalize);
++  ABSL_DCHECK(fn == &Call::OnFinalize);
+   GetContext<CallFinalization>()->Add(
+       [call](const grpc_call_final_info* final_info) {
+         call->OnFinalize(final_info);
+@@ -738,7 +738,7 @@ template <class Derived>
+ inline void InterceptFinalize(
+     void (Derived::Call::*fn)(const grpc_call_final_info*, Derived*),
+     Derived* channel, typename Derived::Call* call) {
+-  DCHECK(fn == &Derived::Call::OnFinalize);
++  ABSL_DCHECK(fn == &Derived::Call::OnFinalize);
+   GetContext<CallFinalization>()->Add(
+       [call, channel](const grpc_call_final_info* final_info) {
+         call->OnFinalize(final_info, channel);
+@@ -906,7 +906,7 @@ class BaseCallData : public Activity, private Wakeable {
+   ~BaseCallData() override;
+
+   void set_pollent(grpc_polling_entity* pollent) {
+-    CHECK(nullptr == pollent_.exchange(pollent, std::memory_order_release));
++    ABSL_CHECK(nullptr == pollent_.exchange(pollent, std::memory_order_release));
+   }
+
+   // Activity implementation (partial).
+@@ -949,7 +949,7 @@ class BaseCallData : public Activity, private Wakeable {
+     ~Flusher();
+
+     void Resume(grpc_transport_stream_op_batch* batch) {
+-      CHECK(!call_->is_last());
++      ABSL_CHECK(!call_->is_last());
+       if (batch->HasOp()) {
+         release_.push_back(batch);
+       } else if (batch->on_complete != nullptr) {
+@@ -1028,7 +1028,7 @@ class BaseCallData : public Activity, private Wakeable {
+     PipeSender<MessageHandle>* original_sender() override { abort(); }
+
+     void GotPipe(PipeReceiver<MessageHandle>* receiver) override {
+-      CHECK_EQ(receiver_, nullptr);
++      ABSL_CHECK_EQ(receiver_, nullptr);
+       receiver_ = receiver;
+     }
+
+@@ -1036,7 +1036,7 @@ class BaseCallData : public Activity, private Wakeable {
+
+     PipeSender<MessageHandle>* Push() override { return &pipe_.sender; }
+     PipeReceiver<MessageHandle>* Pull() override {
+-      CHECK_NE(receiver_, nullptr);
++      ABSL_CHECK_NE(receiver_, nullptr);
+       return receiver_;
+     }
+
+@@ -1057,12 +1057,12 @@ class BaseCallData : public Activity, private Wakeable {
+     void GotPipe(PipeReceiver<MessageHandle>*) override { abort(); }
+
+     void GotPipe(PipeSender<MessageHandle>* sender) override {
+-      CHECK_EQ(sender_, nullptr);
++      ABSL_CHECK_EQ(sender_, nullptr);
+       sender_ = sender;
+     }
+
+     PipeSender<MessageHandle>* Push() override {
+-      CHECK_NE(sender_, nullptr);
++      ABSL_CHECK_NE(sender_, nullptr);
+       return sender_;
+     }
+     PipeReceiver<MessageHandle>* Pull() override { return &pipe_.receiver; }
+@@ -1577,7 +1577,7 @@ struct CallDataFilterWithFlagsMethods {
+     if ((kFlags & kFilterIsLast) != 0) {
+       ExecCtx::Run(DEBUG_LOCATION, then_schedule_closure, absl::OkStatus());
+     } else {
+-      CHECK_EQ(then_schedule_closure, nullptr);
++      ABSL_CHECK_EQ(then_schedule_closure, nullptr);
+     }
+   }
+ };
+@@ -1614,7 +1614,7 @@ template <typename F, uint8_t kFlags>
+ struct ChannelFilterWithFlagsMethods {
+   static absl::Status InitChannelElem(grpc_channel_element* elem,
+                                       grpc_channel_element_args* args) {
+-    CHECK(args->is_last == ((kFlags & kFilterIsLast) != 0));
++    ABSL_CHECK(args->is_last == ((kFlags & kFilterIsLast) != 0));
+     auto status = F::Create(
+         args->channel_args,
+         ChannelFilter::Args(args->channel_stack, elem,
+diff --git a/third_party/grpc/source/src/core/lib/compression/compression_internal.cc b/third_party/grpc/source/src/core/lib/compression/compression_internal.cc
+index ae09cf3e7e3b1..472341aba79f8 100644
+--- a/third_party/grpc/source/src/core/lib/compression/compression_internal.cc
++++ b/third_party/grpc/source/src/core/lib/compression/compression_internal.cc
+@@ -25,7 +25,7 @@
+ #include <string>
+
+ #include "absl/container/inlined_vector.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/ascii.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/str_split.h"
+@@ -118,7 +118,7 @@ CompressionAlgorithmSet::CompressionAlgorithmForLevel(
+     return GRPC_COMPRESS_NONE;
+   }
+
+-  CHECK_GT(level, 0);
++  ABSL_CHECK_GT(level, 0);
+
+   // Establish a "ranking" or compression algorithms in increasing order of
+   // compression.
+diff --git a/third_party/grpc/source/src/core/lib/compression/message_compress.cc b/third_party/grpc/source/src/core/lib/compression/message_compress.cc
+index 7a731495e4a68..6f62c318eda24 100644
+--- a/third_party/grpc/source/src/core/lib/compression/message_compress.cc
++++ b/third_party/grpc/source/src/core/lib/compression/message_compress.cc
+@@ -25,8 +25,8 @@
+ #include <zconf.h>
+ #include <zlib.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/slice/slice.h"
+
+ #define OUTPUT_BLOCK_SIZE 1024
+@@ -40,40 +40,40 @@ static int zlib_body(z_stream* zs, grpc_slice_buffer* input,
+   grpc_slice outbuf = GRPC_SLICE_MALLOC(OUTPUT_BLOCK_SIZE);
+   const uInt uint_max = ~uInt{0};
+
+-  CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
++  ABSL_CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
+   zs->avail_out = static_cast<uInt> GRPC_SLICE_LENGTH(outbuf);
+   zs->next_out = GRPC_SLICE_START_PTR(outbuf);
+   flush = Z_NO_FLUSH;
+   for (i = 0; i < input->count; i++) {
+     if (i == input->count - 1) flush = Z_FINISH;
+-    CHECK(GRPC_SLICE_LENGTH(input->slices[i]) <= uint_max);
++    ABSL_CHECK(GRPC_SLICE_LENGTH(input->slices[i]) <= uint_max);
+     zs->avail_in = static_cast<uInt> GRPC_SLICE_LENGTH(input->slices[i]);
+     zs->next_in = GRPC_SLICE_START_PTR(input->slices[i]);
+     do {
+       if (zs->avail_out == 0) {
+         grpc_slice_buffer_add_indexed(output, outbuf);
+         outbuf = GRPC_SLICE_MALLOC(OUTPUT_BLOCK_SIZE);
+-        CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
++        ABSL_CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
+         zs->avail_out = static_cast<uInt> GRPC_SLICE_LENGTH(outbuf);
+         zs->next_out = GRPC_SLICE_START_PTR(outbuf);
+       }
+       r = flate(zs, flush);
+       if (r < 0 && r != Z_BUF_ERROR /* not fatal */) {
+-        VLOG(2) << "zlib error (" << r << ")";
++        ABSL_VLOG(2) << "zlib error (" << r << ")";
+         goto error;
+       }
+     } while (zs->avail_out == 0);
+     if (zs->avail_in) {
+-      VLOG(2) << "zlib: not all input consumed";
++      ABSL_VLOG(2) << "zlib: not all input consumed";
+       goto error;
+     }
+   }
+   if (r != Z_STREAM_END) {
+-    VLOG(2) << "zlib: Data error";
++    ABSL_VLOG(2) << "zlib: Data error";
+     goto error;
+   }
+
+-  CHECK(outbuf.refcount);
++  ABSL_CHECK(outbuf.refcount);
+   outbuf.data.refcounted.length -= zs->avail_out;
+   grpc_slice_buffer_add_indexed(output, outbuf);
+
+@@ -103,7 +103,7 @@ static int zlib_compress(grpc_slice_buffer* input, grpc_slice_buffer* output,
+   zs.zfree = zfree_gpr;
+   r = deflateInit2(&zs, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 15 | (gzip ? 16 : 0),
+                    8, Z_DEFAULT_STRATEGY);
+-  CHECK(r == Z_OK);
++  ABSL_CHECK(r == Z_OK);
+   r = zlib_body(&zs, input, output, deflate) && output->length < input->length;
+   if (!r) {
+     for (i = count_before; i < output->count; i++) {
+@@ -127,7 +127,7 @@ static int zlib_decompress(grpc_slice_buffer* input, grpc_slice_buffer* output,
+   zs.zalloc = zalloc_gpr;
+   zs.zfree = zfree_gpr;
+   r = inflateInit2(&zs, 15 | (gzip ? 16 : 0));
+-  CHECK(r == Z_OK);
++  ABSL_CHECK(r == Z_OK);
+   r = zlib_body(&zs, input, output, inflate);
+   if (!r) {
+     for (i = count_before; i < output->count; i++) {
+@@ -162,7 +162,7 @@ static int compress_inner(grpc_compression_algorithm algorithm,
+     case GRPC_COMPRESS_ALGORITHMS_COUNT:
+       break;
+   }
+-  LOG(ERROR) << "invalid compression algorithm " << algorithm;
++  ABSL_LOG(ERROR) << "invalid compression algorithm " << algorithm;
+   return 0;
+ }
+
+@@ -187,6 +187,6 @@ int grpc_msg_decompress(grpc_compression_algorithm algorithm,
+     case GRPC_COMPRESS_ALGORITHMS_COUNT:
+       break;
+   }
+-  LOG(ERROR) << "invalid compression algorithm " << algorithm;
++  ABSL_LOG(ERROR) << "invalid compression algorithm " << algorithm;
+   return 0;
+ }
+diff --git a/third_party/grpc/source/src/core/lib/debug/trace.cc b/third_party/grpc/source/src/core/lib/debug/trace.cc
+index bd4a81b8ffe39..a1f74e1a262f8 100644
+--- a/third_party/grpc/source/src/core/lib/debug/trace.cc
++++ b/third_party/grpc/source/src/core/lib/debug/trace.cc
+@@ -25,7 +25,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_split.h"
+@@ -39,9 +39,9 @@ int grpc_tracer_set_enabled(const char* name, int enabled);
+ namespace grpc_core {
+ namespace {
+ void LogAllTracers() {
+-  VLOG(2) << "available tracers:";
++  ABSL_VLOG(2) << "available tracers:";
+   for (const auto& name : GetAllTraceFlags()) {
+-    LOG(INFO) << "  " << name.first;
++    ABSL_LOG(INFO) << "  " << name.first;
+   }
+ }
+
+@@ -86,12 +86,12 @@ bool ParseTracers(absl::string_view tracers) {
+         some_trace_was_found = true;
+       }
+     }
+-    if (!found) LOG(ERROR) << "Unknown tracer: " << trace_glob;
++    if (!found) ABSL_LOG(ERROR) << "Unknown tracer: " << trace_glob;
+   }
+   if (!enabled_tracers.empty()) {
+     absl::string_view enabled_tracers_view(enabled_tracers);
+     absl::ConsumeSuffix(&enabled_tracers_view, ", ");
+-    LOG(INFO) << "gRPC Tracers: " << enabled_tracers_view;
++    ABSL_LOG(INFO) << "gRPC Tracers: " << enabled_tracers_view;
+   }
+   return some_trace_was_found;
+ }
+diff --git a/third_party/grpc/source/src/core/lib/debug/trace_impl.h b/third_party/grpc/source/src/core/lib/debug/trace_impl.h
+index 5d43e103433a8..15b996dcb32fd 100644
+--- a/third_party/grpc/source/src/core/lib/debug/trace_impl.h
++++ b/third_party/grpc/source/src/core/lib/debug/trace_impl.h
+@@ -22,7 +22,7 @@
+ #include <string>
+
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+
+ #ifdef _WIN32
+@@ -86,13 +86,13 @@ class TraceFlag {
+   GPR_UNLIKELY((grpc_core::tracer##_trace).enabled())
+
+ #define GRPC_TRACE_LOG(tracer, level) \
+-  LOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))
++  ABSL_LOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))
+
+ #define GRPC_TRACE_DLOG(tracer, level) \
+-  DLOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))
++  ABSL_DLOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))
+
+ #define GRPC_TRACE_VLOG(tracer, level) \
+-  if (GRPC_TRACE_FLAG_ENABLED(tracer)) VLOG(level)
++  if (GRPC_TRACE_FLAG_ENABLED(tracer)) ABSL_VLOG(level)
+
+ #ifndef NDEBUG
+ typedef TraceFlag DebugOnlyTraceFlag;
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc b/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc
+index b34b1448641a0..fee813a6020d2 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc
+@@ -54,8 +54,8 @@
+
+ #include "absl/functional/any_invocable.h"
+ #include "absl/hash/hash.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/numbers.h"
+ #include "absl/strings/str_cat.h"
+@@ -204,7 +204,7 @@ AresResolver::CreateAresResolver(
+   ares_channel channel;
+   int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);
+   if (status != ARES_SUCCESS) {
+-    LOG(ERROR) << "ares_init_options failed, status: " << status;
++    ABSL_LOG(ERROR) << "ares_init_options failed, status: " << status;
+     return AresStatusToAbslStatus(
+         status,
+         absl::StrCat("Failed to init c-ares channel: ", ares_strerror(status)));
+@@ -233,8 +233,8 @@ AresResolver::AresResolver(
+ }
+
+ AresResolver::~AresResolver() {
+-  CHECK(fd_node_list_.empty());
+-  CHECK(callback_map_.empty());
++  ABSL_CHECK(fd_node_list_.empty());
++  ABSL_CHECK(callback_map_.empty());
+   ares_destroy(channel_);
+ }
+
+@@ -251,7 +251,7 @@ void AresResolver::Orphan() {
+         GRPC_TRACE_LOG(cares_resolver, INFO)
+             << "(EventEngine c-ares resolver) resolver: " << this
+             << " shutdown fd: " << fd_node->polled_fd->GetName();
+-        CHECK(fd_node->polled_fd->ShutdownLocked(
++        ABSL_CHECK(fd_node->polled_fd->ShutdownLocked(
+             absl::CancelledError("AresResolver::Orphan")));
+         fd_node->already_shutdown = true;
+       }
+@@ -525,7 +525,7 @@ void AresResolver::MaybeStartTimerLocked() {
+
+ void AresResolver::OnReadable(FdNode* fd_node, absl::Status status) {
+   grpc_core::MutexLock lock(&mutex_);
+-  CHECK(fd_node->readable_registered);
++  ABSL_CHECK(fd_node->readable_registered);
+   fd_node->readable_registered = false;
+   GRPC_TRACE_LOG(cares_resolver, INFO)
+       << "(EventEngine c-ares resolver) OnReadable: fd: " << fd_node->as
+@@ -545,7 +545,7 @@ void AresResolver::OnReadable(FdNode* fd_node, absl::Status status) {
+
+ void AresResolver::OnWritable(FdNode* fd_node, absl::Status status) {
+   grpc_core::MutexLock lock(&mutex_);
+-  CHECK(fd_node->writable_registered);
++  ABSL_CHECK(fd_node->writable_registered);
+   fd_node->writable_registered = false;
+   GRPC_TRACE_LOG(cares_resolver, INFO)
+       << "(EventEngine c-ares resolver) OnWritable: fd: " << fd_node->as
+@@ -597,7 +597,7 @@ void AresResolver::OnHostbynameDoneLocked(void* arg, int status,
+                                           int /*timeouts*/,
+                                           struct hostent* hostent) {
+   auto* hostname_qa = static_cast<HostnameQueryArg*>(arg);
+-  CHECK_GT(hostname_qa->pending_requests--, 0);
++  ABSL_CHECK_GT(hostname_qa->pending_requests--, 0);
+   auto* ares_resolver = hostname_qa->ares_resolver;
+   if (status != ARES_SUCCESS) {
+     std::string error_msg =
+@@ -614,7 +614,7 @@ void AresResolver::OnHostbynameDoneLocked(void* arg, int status,
+         << " ARES_SUCCESS";
+     for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {
+       if (hostname_qa->result.size() == kMaxRecordSize) {
+-        LOG(ERROR) << "A/AAAA response exceeds maximum record size of 65536";
++        ABSL_LOG(ERROR) << "A/AAAA response exceeds maximum record size of 65536";
+         break;
+       }
+       switch (hostent->h_addrtype) {
+@@ -665,8 +665,8 @@ void AresResolver::OnHostbynameDoneLocked(void* arg, int status,
+   if (hostname_qa->pending_requests == 0) {
+     auto nh =
+         ares_resolver->callback_map_.extract(hostname_qa->callback_map_id);
+-    CHECK(!nh.empty());
+-    CHECK(std::holds_alternative<
++    ABSL_CHECK(!nh.empty());
++    ABSL_CHECK(std::holds_alternative<
+           EventEngine::DNSResolver::LookupHostnameCallback>(nh.mapped()));
+     auto callback = std::get<EventEngine::DNSResolver::LookupHostnameCallback>(
+         std::move(nh.mapped()));
+@@ -692,8 +692,8 @@ void AresResolver::OnSRVQueryDoneLocked(void* arg, int status, int /*timeouts*/,
+   std::unique_ptr<QueryArg> qa(static_cast<QueryArg*>(arg));
+   auto* ares_resolver = qa->ares_resolver;
+   auto nh = ares_resolver->callback_map_.extract(qa->callback_map_id);
+-  CHECK(!nh.empty());
+-  CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupSRVCallback>(
++  ABSL_CHECK(!nh.empty());
++  ABSL_CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupSRVCallback>(
+       nh.mapped()));
+   auto callback = std::get<EventEngine::DNSResolver::LookupSRVCallback>(
+       std::move(nh.mapped()));
+@@ -729,7 +729,7 @@ void AresResolver::OnSRVQueryDoneLocked(void* arg, int status, int /*timeouts*/,
+   for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;
+        srv_it = srv_it->next) {
+     if (result.size() == kMaxRecordSize) {
+-      LOG(ERROR) << "SRV response exceeds maximum record size of 65536";
++      ABSL_LOG(ERROR) << "SRV response exceeds maximum record size of 65536";
+       break;
+     }
+     EventEngine::DNSResolver::SRVRecord record;
+@@ -753,8 +753,8 @@ void AresResolver::OnTXTDoneLocked(void* arg, int status, int /*timeouts*/,
+   std::unique_ptr<QueryArg> qa(static_cast<QueryArg*>(arg));
+   auto* ares_resolver = qa->ares_resolver;
+   auto nh = ares_resolver->callback_map_.extract(qa->callback_map_id);
+-  CHECK(!nh.empty());
+-  CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupTXTCallback>(
++  ABSL_CHECK(!nh.empty());
++  ABSL_CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupTXTCallback>(
+       nh.mapped()));
+   auto callback = std::get<EventEngine::DNSResolver::LookupTXTCallback>(
+       std::move(nh.mapped()));
+@@ -798,7 +798,7 @@ void AresResolver::OnTXTDoneLocked(void* arg, int status, int /*timeouts*/,
+       << result.size() << " TXT records";
+   if (GRPC_TRACE_FLAG_ENABLED(cares_resolver)) {
+     for (const auto& record : result) {
+-      LOG(INFO) << record;
++      ABSL_LOG(INFO) << record;
+     }
+   }
+   // Clean up.
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc
+index 1ec17efdc39d6..e1c6ed0496d31 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc
+@@ -21,8 +21,8 @@
+ #include <CoreFoundation/CoreFoundation.h>
+ #include <grpc/support/cpu.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/event_engine/cf_engine/cf_engine.h"
+ #include "src/core/lib/event_engine/cf_engine/cfstream_endpoint.h"
+ #include "src/core/lib/event_engine/cf_engine/dns_service_resolver.h"
+@@ -62,12 +62,12 @@ CFEventEngine::~CFEventEngine() {
+     grpc_core::MutexLock lock(&task_mu_);
+     if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
+       for (auto handle : known_handles_) {
+-        LOG(ERROR) << "CFEventEngine:" << this
++        ABSL_LOG(ERROR) << "CFEventEngine:" << this
+                    << " uncleared TaskHandle at shutdown:"
+                    << HandleToString(handle);
+       }
+     }
+-    CHECK(GPR_LIKELY(known_handles_.empty()));
++    ABSL_CHECK(GPR_LIKELY(known_handles_.empty()));
+     timer_manager_.Shutdown();
+   }
+   thread_pool_->Quiesce();
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc
+index f60101ff08bee..b1ed86fec56bd 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc
+@@ -18,7 +18,7 @@
+ #include <AvailabilityMacros.h>
+ #ifdef AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/address_utils/parse_address.h"
+@@ -148,7 +148,7 @@ void DNSServiceResolverImpl::ResolveCallback(
+
+   grpc_core::ReleasableMutexLock lock(&that->request_mu_);
+   auto request_it = that->requests_.find(sdRef);
+-  CHECK(request_it != that->requests_.end());
++  ABSL_CHECK(request_it != that->requests_.end());
+
+   if (errorCode != kDNSServiceErr_NoError &&
+       errorCode != kDNSServiceErr_NoSuchRecord) {
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h
+index fdf4f799ab9dd..42e65e181e752 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h
++++ b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h
+@@ -24,7 +24,7 @@
+ #include <grpc/event_engine/event_engine.h>
+
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/event_engine/cf_engine/cf_engine.h"
+ #include "src/core/util/ref_counted.h"
+ #include "src/core/util/ref_counted_ptr.h"
+@@ -45,7 +45,7 @@ class DNSServiceResolverImpl
+   explicit DNSServiceResolverImpl(std::shared_ptr<CFEventEngine> engine)
+       : engine_(std::move((engine))) {}
+   ~DNSServiceResolverImpl() override {
+-    CHECK(requests_.empty());
++    ABSL_CHECK(requests_.empty());
+     dispatch_release(queue_);
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/forkable.cc b/third_party/grpc/source/src/core/lib/event_engine/forkable.cc
+index 012c2cce1ca67..56d144a88cf0f 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/forkable.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/forkable.cc
+@@ -16,7 +16,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ #ifdef GRPC_POSIX_FORK_ALLOW_PTHREAD_ATFORK
+ #include <pthread.h>
+@@ -42,7 +42,7 @@ void ObjectGroupForkHandler::RegisterForkable(
+     std::shared_ptr<Forkable> forkable, GRPC_UNUSED void (*prepare)(void),
+     GRPC_UNUSED void (*parent)(void), GRPC_UNUSED void (*child)(void)) {
+   if (IsForkEnabled()) {
+-    CHECK(!is_forking_);
++    ABSL_CHECK(!is_forking_);
+     forkables_.emplace_back(forkable);
+ #ifdef GRPC_POSIX_FORK_ALLOW_PTHREAD_ATFORK
+     if (!std::exchange(registered_, true)) {
+@@ -54,7 +54,7 @@ void ObjectGroupForkHandler::RegisterForkable(
+
+ void ObjectGroupForkHandler::Prefork() {
+   if (IsForkEnabled()) {
+-    CHECK(!std::exchange(is_forking_, true));
++    ABSL_CHECK(!std::exchange(is_forking_, true));
+     GRPC_TRACE_LOG(fork, INFO) << "PrepareFork";
+     for (auto it = forkables_.begin(); it != forkables_.end();) {
+       auto shared = it->lock();
+@@ -70,7 +70,7 @@ void ObjectGroupForkHandler::Prefork() {
+
+ void ObjectGroupForkHandler::PostforkParent() {
+   if (IsForkEnabled()) {
+-    CHECK(is_forking_);
++    ABSL_CHECK(is_forking_);
+     GRPC_TRACE_LOG(fork, INFO) << "PostforkParent";
+     for (auto it = forkables_.begin(); it != forkables_.end();) {
+       auto shared = it->lock();
+@@ -87,7 +87,7 @@ void ObjectGroupForkHandler::PostforkParent() {
+
+ void ObjectGroupForkHandler::PostforkChild() {
+   if (IsForkEnabled()) {
+-    CHECK(is_forking_);
++    ABSL_CHECK(is_forking_);
+     GRPC_TRACE_LOG(fork, INFO) << "PostforkChild";
+     for (auto it = forkables_.begin(); it != forkables_.end();) {
+       auto shared = it->lock();
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc
+index 3c5b8be63af11..0452991e0433f 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc
+@@ -22,8 +22,8 @@
+ #include <atomic>
+ #include <memory>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+@@ -161,14 +161,14 @@ int EpollCreateAndCloexec() {
+ #ifdef GRPC_LINUX_EPOLL_CREATE1
+   int fd = epoll_create1(EPOLL_CLOEXEC);
+   if (fd < 0) {
+-    LOG(ERROR) << "epoll_create1 unavailable";
++    ABSL_LOG(ERROR) << "epoll_create1 unavailable";
+   }
+ #else
+   int fd = epoll_create(MAX_EPOLL_EVENTS);
+   if (fd < 0) {
+-    LOG(ERROR) << "epoll_create unavailable";
++    ABSL_LOG(ERROR) << "epoll_create unavailable";
+   } else if (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {
+-    LOG(ERROR) << "fcntl following epoll_create failed";
++    ABSL_LOG(ERROR) << "fcntl following epoll_create failed";
+     return -1;
+   }
+ #endif
+@@ -254,7 +254,7 @@ void Epoll1EventHandle::OrphanHandle(PosixEngineClosure* on_done,
+       epoll_event phony_event;
+       if (epoll_ctl(poller_->g_epoll_set_.epfd, EPOLL_CTL_DEL, fd_,
+                     &phony_event) != 0) {
+-        LOG(ERROR) << "OrphanHandle: epoll_ctl failed: "
++        ABSL_LOG(ERROR) << "OrphanHandle: epoll_ctl failed: "
+                    << grpc_core::StrError(errno);
+       }
+     }
+@@ -297,7 +297,7 @@ void Epoll1EventHandle::HandleShutdownInternal(absl::Status why,
+       epoll_event phony_event;
+       if (epoll_ctl(poller_->g_epoll_set_.epfd, EPOLL_CTL_DEL, fd_,
+                     &phony_event) != 0) {
+-        LOG(ERROR) << "HandleShutdownInternal: epoll_ctl failed: "
++        ABSL_LOG(ERROR) << "HandleShutdownInternal: epoll_ctl failed: "
+                    << grpc_core::StrError(errno);
+       }
+     }
+@@ -310,14 +310,14 @@ Epoll1Poller::Epoll1Poller(Scheduler* scheduler)
+     : scheduler_(scheduler), was_kicked_(false), closed_(false) {
+   g_epoll_set_.epfd = EpollCreateAndCloexec();
+   wakeup_fd_ = *CreateWakeupFd();
+-  CHECK(wakeup_fd_ != nullptr);
+-  CHECK_GE(g_epoll_set_.epfd, 0);
++  ABSL_CHECK(wakeup_fd_ != nullptr);
++  ABSL_CHECK_GE(g_epoll_set_.epfd, 0);
+   GRPC_TRACE_LOG(event_engine_poller, INFO)
+       << "grpc epoll fd: " << g_epoll_set_.epfd;
+   struct epoll_event ev{};
+   ev.events = static_cast<uint32_t>(EPOLLIN | EPOLLET);
+   ev.data.ptr = wakeup_fd_.get();
+-  CHECK(epoll_ctl(g_epoll_set_.epfd, EPOLL_CTL_ADD, wakeup_fd_->ReadFd(),
++  ABSL_CHECK(epoll_ctl(g_epoll_set_.epfd, EPOLL_CTL_ADD, wakeup_fd_->ReadFd(),
+                   &ev) == 0);
+   g_epoll_set_.num_events = 0;
+   g_epoll_set_.cursor = 0;
+@@ -370,7 +370,7 @@ EventHandle* Epoll1Poller::CreateHandle(int fd, absl::string_view /*name*/,
+   ev.data.ptr = reinterpret_cast<void*>(reinterpret_cast<intptr_t>(new_handle) |
+                                         (track_err ? 1 : 0));
+   if (epoll_ctl(g_epoll_set_.epfd, EPOLL_CTL_ADD, fd, &ev) != 0) {
+-    LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
++    ABSL_LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
+   }
+
+   return new_handle;
+@@ -394,7 +394,7 @@ bool Epoll1Poller::ProcessEpollEvents(int max_epoll_events_to_handle,
+     struct epoll_event* ev = &g_epoll_set_.events[c];
+     void* data_ptr = ev->data.ptr;
+     if (data_ptr == wakeup_fd_.get()) {
+-      CHECK(wakeup_fd_->ConsumeWakeup().ok());
++      ABSL_CHECK(wakeup_fd_->ConsumeWakeup().ok());
+       was_kicked = true;
+     } else {
+       Epoll1EventHandle* handle = reinterpret_cast<Epoll1EventHandle*>(
+@@ -513,7 +513,7 @@ void Epoll1Poller::Kick() {
+     return;
+   }
+   was_kicked_ = true;
+-  CHECK(wakeup_fd_->Wakeup().ok());
++  ABSL_CHECK(wakeup_fd_->Wakeup().ok());
+ }
+
+ std::shared_ptr<Epoll1Poller> MakeEpoll1Poller(Scheduler* scheduler) {
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc
+index 6d7d54c62eecf..f2ea5804eedb4 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc
+@@ -28,7 +28,7 @@
+
+ #include "absl/container/inlined_vector.h"
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+@@ -294,7 +294,7 @@ EventHandle* PollPoller::CreateHandle(int fd, absl::string_view /*name*/,
+                                       bool track_err) {
+   // Avoid unused-parameter warning for debug-only parameter
+   (void)track_err;
+-  DCHECK(track_err == false);
++  ABSL_DCHECK(track_err == false);
+   PollEventHandle* handle = new PollEventHandle(fd, shared_from_this());
+   // We need to send a kick to the thread executing Work(..) so that it can
+   // add this new Fd into the list of Fds to poll.
+@@ -312,7 +312,7 @@ void PollEventHandle::OrphanHandle(PosixEngineClosure* on_done, int* release_fd,
+     if (release_fd != nullptr) {
+       *release_fd = fd_;
+     }
+-    CHECK(!is_orphaned_);
++    ABSL_CHECK(!is_orphaned_);
+     is_orphaned_ = true;
+     // Perform shutdown operations if not already done so.
+     if (!is_shutdown_) {
+@@ -526,7 +526,7 @@ void PollPoller::KickExternal(bool ext) {
+   }
+   was_kicked_ = true;
+   was_kicked_ext_ = ext;
+-  CHECK(wakeup_fd_->Wakeup().ok());
++  ABSL_CHECK(wakeup_fd_->Wakeup().ok());
+ }
+
+ void PollPoller::Kick() { KickExternal(true); }
+@@ -565,7 +565,7 @@ PollPoller::PollPoller(Scheduler* scheduler)
+       poll_handles_list_head_(nullptr),
+       closed_(false) {
+   wakeup_fd_ = *CreateWakeupFd();
+-  CHECK(wakeup_fd_ != nullptr);
++  ABSL_CHECK(wakeup_fd_ != nullptr);
+   ForkPollerListAddPoller(this);
+ }
+
+@@ -578,15 +578,15 @@ PollPoller::PollPoller(Scheduler* scheduler, bool use_phony_poll)
+       poll_handles_list_head_(nullptr),
+       closed_(false) {
+   wakeup_fd_ = *CreateWakeupFd();
+-  CHECK(wakeup_fd_ != nullptr);
++  ABSL_CHECK(wakeup_fd_ != nullptr);
+   ForkPollerListAddPoller(this);
+ }
+
+ PollPoller::~PollPoller() {
+   // Assert that no active handles are present at the time of destruction.
+   // They should have been orphaned before reaching this state.
+-  CHECK_EQ(num_poll_handles_, 0);
+-  CHECK_EQ(poll_handles_list_head_, nullptr);
++  ABSL_CHECK_EQ(num_poll_handles_, 0);
++  ABSL_CHECK_EQ(poll_handles_list_head_, nullptr);
+ }
+
+ Poller::WorkResult PollPoller::Work(
+@@ -638,7 +638,7 @@ Poller::WorkResult PollPoller::Work(
+         // There shouldn't be any orphaned fds at this point. This is because
+         // prior to marking a handle as orphaned it is first removed from
+         // poll handle list for the poller under the poller lock.
+-        CHECK(!head->IsOrphaned());
++        ABSL_CHECK(!head->IsOrphaned());
+         if (!head->IsPollhup()) {
+           pfds[pfd_count].fd = head->WrappedFd();
+           watchers[pfd_count] = head;
+@@ -714,7 +714,7 @@ Poller::WorkResult PollPoller::Work(
+       }
+     } else {
+       if (pfds[0].revents & kPollinCheck) {
+-        CHECK(wakeup_fd_->ConsumeWakeup().ok());
++        ABSL_CHECK(wakeup_fd_->ConsumeWakeup().ok());
+       }
+       for (i = 1; i < pfd_count; i++) {
+         PollEventHandle* head = watchers[i];
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc
+index c5fa3db25b9a8..f60f8655b38fd 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc
+@@ -16,7 +16,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/port.h"
+
+ #ifdef GRPC_POSIX_SOCKET_TCP
+@@ -48,7 +48,7 @@ bool KernelSupportsErrqueue() {
+     // least 4.0.0
+     struct utsname buffer;
+     if (uname(&buffer) != 0) {
+-      LOG(ERROR) << "uname: " << grpc_core::StrError(errno);
++      ABSL_LOG(ERROR) << "uname: " << grpc_core::StrError(errno);
+       return false;
+     }
+     char* release = buffer.release;
+@@ -59,7 +59,7 @@ bool KernelSupportsErrqueue() {
+     if (strtol(release, nullptr, 10) >= 4) {
+       return true;
+     } else {
+-      VLOG(2) << "ERRQUEUE support not enabled";
++      ABSL_VLOG(2) << "ERRQUEUE support not enabled";
+     }
+ #endif  // GRPC_LINUX_ERRQUEUE
+     return false;
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc
+index eda19bb2dc6ce..8ff625ed8ad0f 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc
+@@ -19,7 +19,7 @@
+ #include <atomic>
+ #include <cstdint>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "src/core/lib/event_engine/posix_engine/event_poller.h"
+ #include "src/core/lib/event_engine/posix_engine/posix_engine_closure.h"
+@@ -76,7 +76,7 @@ void LockfreeEvent::DestroyEvent() {
+     if (curr & kShutdownBit) {
+       grpc_core::internal::StatusFreeHeapPtr(curr & ~kShutdownBit);
+     } else {
+-      CHECK(curr == kClosureNotReady || curr == kClosureReady);
++      ABSL_CHECK(curr == kClosureNotReady || curr == kClosureReady);
+     }
+     // we CAS in a shutdown, no error value here. If this event is interacted
+     // with post-deletion (see the note in the constructor) we want the bit
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc
+index 75ab2799ee003..3a0a0a1c837dc 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc
+@@ -32,8 +32,8 @@
+ #include <type_traits>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -241,7 +241,7 @@ msg_iovlen_type TcpZerocopySendRecord::PopulateIovs(size_t* unwind_slice_idx,
+     ++(out_offset_.slice_idx);
+     out_offset_.byte_idx = 0;
+   }
+-  DCHECK_GT(iov_size, 0u);
++  ABSL_DCHECK_GT(iov_size, 0u);
+   return iov_size;
+ }
+
+@@ -307,8 +307,8 @@ bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {
+     iov[i].iov_len = slice.length();
+   }
+
+-  CHECK_NE(incoming_buffer_->Length(), 0u);
+-  DCHECK_GT(min_progress_size_, 0);
++  ABSL_CHECK_NE(incoming_buffer_->Length(), 0u);
++  ABSL_DCHECK_GT(min_progress_size_, 0);
+
+   do {
+     // Assume there is something on the queue. If we receive TCP_INQ from
+@@ -368,11 +368,11 @@ bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {
+
+     grpc_core::global_stats().IncrementTcpReadSize(read_bytes);
+     AddToEstimate(static_cast<size_t>(read_bytes));
+-    DCHECK((size_t)read_bytes <= incoming_buffer_->Length() - total_read_bytes);
++    ABSL_DCHECK((size_t)read_bytes <= incoming_buffer_->Length() - total_read_bytes);
+
+ #ifdef GRPC_HAVE_TCP_INQ
+     if (inq_capable_) {
+-      DCHECK(!(msg.msg_flags & MSG_CTRUNC));
++      ABSL_DCHECK(!(msg.msg_flags & MSG_CTRUNC));
+       struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
+       for (; cmsg != nullptr; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+         if (cmsg->cmsg_level == SOL_TCP && cmsg->cmsg_type == TCP_CM_INQ &&
+@@ -421,7 +421,7 @@ bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {
+     inq_ = 1;
+   }
+
+-  DCHECK_GT(total_read_bytes, 0u);
++  ABSL_DCHECK_GT(total_read_bytes, 0u);
+   status = absl::OkStatus();
+   if (grpc_core::IsTcpFrameSizeTuningEnabled()) {
+     // Update min progress size based on the total number of bytes read in
+@@ -514,7 +514,7 @@ void PosixEndpointImpl::UpdateRcvLowat() {
+   if (result.ok()) {
+     set_rcvlowat_ = *result;
+   } else {
+-    LOG(ERROR) << "ERROR in SO_RCVLOWAT: " << result.status().message();
++    ABSL_LOG(ERROR) << "ERROR in SO_RCVLOWAT: " << result.status().message();
+   }
+ }
+
+@@ -599,7 +599,7 @@ bool PosixEndpointImpl::Read(absl::AnyInvocable<void(absl::Status)> on_read,
+   grpc_core::ReleasableMutexLock lock(&read_mu_);
+   GRPC_TRACE_LOG(event_engine_endpoint, INFO)
+       << "Endpoint[" << this << "]: Read";
+-  CHECK(read_cb_ == nullptr);
++  ABSL_CHECK(read_cb_ == nullptr);
+   incoming_buffer_ = buffer;
+   incoming_buffer_->Clear();
+   incoming_buffer_->Swap(last_read_buffer_);
+@@ -673,8 +673,8 @@ TcpZerocopySendRecord* PosixEndpointImpl::TcpGetSendZerocopyRecord(
+     }
+     if (zerocopy_send_record != nullptr) {
+       zerocopy_send_record->PrepareForSends(buf);
+-      DCHECK_EQ(buf.Count(), 0u);
+-      DCHECK_EQ(buf.Length(), 0u);
++      ABSL_DCHECK_EQ(buf.Count(), 0u);
++      ABSL_DCHECK_EQ(buf.Length(), 0u);
+       outgoing_byte_idx_ = 0;
+       outgoing_buffer_ = nullptr;
+     }
+@@ -721,7 +721,7 @@ bool PosixEndpointImpl::ProcessErrors() {
+       return processed_err;
+     }
+     if (GPR_UNLIKELY((msg.msg_flags & MSG_CTRUNC) != 0)) {
+-      LOG(ERROR) << "Error message was truncated.";
++      ABSL_LOG(ERROR) << "Error message was truncated.";
+     }
+
+     if (msg.msg_controllen == 0) {
+@@ -761,10 +761,10 @@ void PosixEndpointImpl::ZerocopyDisableAndWaitForRemaining() {
+
+ // Reads \a cmsg to process zerocopy control messages.
+ void PosixEndpointImpl::ProcessZerocopy(struct cmsghdr* cmsg) {
+-  DCHECK(cmsg);
++  ABSL_DCHECK(cmsg);
+   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(cmsg));
+-  DCHECK_EQ(serr->ee_errno, 0u);
+-  DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
++  ABSL_DCHECK_EQ(serr->ee_errno, 0u);
++  ABSL_DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
+   const uint32_t lo = serr->ee_info;
+   const uint32_t hi = serr->ee_data;
+   for (uint32_t seq = lo; seq <= hi; ++seq) {
+@@ -774,7 +774,7 @@ void PosixEndpointImpl::ProcessZerocopy(struct cmsghdr* cmsg) {
+     // both; if so, batch the unref/put.
+     TcpZerocopySendRecord* record =
+         tcp_zerocopy_send_ctx_->ReleaseSendRecord(seq);
+-    DCHECK(record);
++    ABSL_DCHECK(record);
+     UnrefMaybePutZerocopySendRecord(record);
+   }
+   if (tcp_zerocopy_send_ctx_->UpdateZeroCopyOptMemStateAfterFree()) {
+@@ -816,7 +816,7 @@ struct cmsghdr* PosixEndpointImpl::ProcessTimestamp(msghdr* msg,
+   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(next_cmsg));
+   if (serr->ee_errno != ENOMSG ||
+       serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {
+-    LOG(ERROR) << "Unexpected control message";
++    ABSL_LOG(ERROR) << "Unexpected control message";
+     return cmsg;
+   }
+   traced_buffers_.ProcessTimestamp(serr, opt_stats, tss);
+@@ -987,7 +987,7 @@ bool PosixEndpointImpl::DoFlushZerocopy(TcpZerocopySendRecord* record,
+         handle_->SetWritable();
+       } else {
+ #ifdef GRPC_LINUX_ERRQUEUE
+-        LOG_EVERY_N_SEC(INFO, 1)
++        ABSL_LOG_EVERY_N_SEC(INFO, 1)
+             << "Tx0cp encountered an ENOBUFS error possibly because one or "
+                "both of RLIMIT_MEMLOCK or hard memlock ulimit values are too "
+                "small for the intended user. Current system value of "
+@@ -1063,7 +1063,7 @@ bool PosixEndpointImpl::TcpFlush(absl::Status& status) {
+       outgoing_slice_idx++;
+       outgoing_byte_idx_ = 0;
+     }
+-    CHECK_GT(iov_size, 0u);
++    ABSL_CHECK_GT(iov_size, 0u);
+
+     msg.msg_name = nullptr;
+     msg.msg_namelen = 0;
+@@ -1108,7 +1108,7 @@ bool PosixEndpointImpl::TcpFlush(absl::Status& status) {
+       }
+     }
+
+-    CHECK_EQ(outgoing_byte_idx_, 0u);
++    ABSL_CHECK_EQ(outgoing_byte_idx_, 0u);
+     bytes_counter_ += sent_length;
+     trailing = sending_length - static_cast<size_t>(sent_length);
+     while (trailing > 0) {
+@@ -1147,7 +1147,7 @@ void PosixEndpointImpl::HandleWrite(absl::Status status) {
+                           ? TcpFlushZerocopy(current_zerocopy_send_, status)
+                           : TcpFlush(status);
+   if (!flush_result) {
+-    DCHECK(status.ok());
++    ABSL_DCHECK(status.ok());
+     handle_->NotifyOnWrite(on_write_);
+   } else {
+     GRPC_TRACE_LOG(event_engine_endpoint, INFO)
+@@ -1166,9 +1166,9 @@ bool PosixEndpointImpl::Write(
+   absl::Status status = absl::OkStatus();
+   TcpZerocopySendRecord* zerocopy_send_record = nullptr;
+
+-  CHECK(write_cb_ == nullptr);
+-  DCHECK_EQ(current_zerocopy_send_, nullptr);
+-  DCHECK_NE(data, nullptr);
++  ABSL_CHECK(write_cb_ == nullptr);
++  ABSL_DCHECK_EQ(current_zerocopy_send_, nullptr);
++  ABSL_DCHECK_NE(data, nullptr);
+
+   GRPC_TRACE_LOG(event_engine_endpoint, INFO)
+       << "Endpoint[" << this << "]: Write " << data->Length() << " bytes";
+@@ -1200,7 +1200,7 @@ bool PosixEndpointImpl::Write(
+     outgoing_buffer_arg_ = args->google_specific;
+   }
+   if (outgoing_buffer_arg_) {
+-    CHECK(poller_->CanTrackErrors());
++    ABSL_CHECK(poller_->CanTrackErrors());
+   }
+
+   bool flush_result = zerocopy_send_record != nullptr
+@@ -1275,7 +1275,7 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
+       engine_(engine) {
+   PosixSocketWrapper sock(handle->WrappedFd());
+   fd_ = handle_->WrappedFd();
+-  CHECK(options.resource_quota != nullptr);
++  ABSL_CHECK(options.resource_quota != nullptr);
+   auto peer_addr_string = sock.PeerAddressString();
+   mem_quota_ = options.resource_quota->memory_quota();
+   memory_owner_ = mem_quota_->CreateMemoryOwner();
+@@ -1298,12 +1298,12 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
+   if (zerocopy_enabled) {
+     if (GetRLimitMemLockMax() == 0) {
+       zerocopy_enabled = false;
+-      LOG(ERROR) << "Tx zero-copy will not be used by gRPC since RLIMIT_MEMLOCK"
++      ABSL_LOG(ERROR) << "Tx zero-copy will not be used by gRPC since RLIMIT_MEMLOCK"
+                  << " value is not set. Consider raising its value with "
+                  << "setrlimit().";
+     } else if (GetUlimitHardMemLock() == 0) {
+       zerocopy_enabled = false;
+-      LOG(ERROR) << "Tx zero-copy will not be used by gRPC since hard memlock "
++      ABSL_LOG(ERROR) << "Tx zero-copy will not be used by gRPC since hard memlock "
+                  << "ulimit value is not set. Use ulimit -l <value> to set its "
+                  << "value.";
+     } else {
+@@ -1311,12 +1311,12 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
+       if (setsockopt(fd_, SOL_SOCKET, SO_ZEROCOPY, &enable, sizeof(enable)) !=
+           0) {
+         zerocopy_enabled = false;
+-        LOG(ERROR) << "Failed to set zerocopy options on the socket.";
++        ABSL_LOG(ERROR) << "Failed to set zerocopy options on the socket.";
+       }
+     }
+
+     if (zerocopy_enabled) {
+-      VLOG(2) << "Tx-zero copy enabled for gRPC sends. RLIMIT_MEMLOCK value "
++      ABSL_VLOG(2) << "Tx-zero copy enabled for gRPC sends. RLIMIT_MEMLOCK value "
+               << "=" << GetRLimitMemLockMax()
+               << ",ulimit hard memlock value = " << GetUlimitHardMemLock();
+     }
+@@ -1330,7 +1330,7 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
+   if (setsockopt(fd_, SOL_TCP, TCP_INQ, &one, sizeof(one)) == 0) {
+     inq_capable_ = true;
+   } else {
+-    VLOG(2) << "cannot set inq fd=" << fd_ << " errno=" << errno;
++    ABSL_VLOG(2) << "cannot set inq fd=" << fd_ << " errno=" << errno;
+     inq_capable_ = false;
+   }
+ #else
+@@ -1355,7 +1355,7 @@ std::unique_ptr<PosixEndpoint> CreatePosixEndpoint(
+     EventHandle* handle, PosixEngineClosure* on_shutdown,
+     std::shared_ptr<EventEngine> engine, MemoryAllocator&& allocator,
+     const PosixTcpOptions& options) {
+-  DCHECK_NE(handle, nullptr);
++  ABSL_DCHECK_NE(handle, nullptr);
+   return std::make_unique<PosixEndpoint>(handle, on_shutdown, std::move(engine),
+                                          std::move(allocator), options);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h
+index 3ddd318af7542..aea0b61e6adf0 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h
+@@ -34,8 +34,8 @@
+ #include "absl/container/flat_hash_map.h"
+ #include "absl/functional/any_invocable.h"
+ #include "absl/hash/hash.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/lib/event_engine/extensions/supports_fd.h"
+@@ -129,7 +129,7 @@ class TcpZerocopySendRecord {
+   //  sendmsg() failed or when tcp_write() is done.
+   bool Unref() {
+     const intptr_t prior = ref_.fetch_sub(1, std::memory_order_acq_rel);
+-    DCHECK_GT(prior, 0);
++    ABSL_DCHECK_GT(prior, 0);
+     if (prior == 1) {
+       AllSendsComplete();
+       return true;
+@@ -144,9 +144,9 @@ class TcpZerocopySendRecord {
+   };
+
+   void DebugAssertEmpty() {
+-    DCHECK_EQ(buf_.Count(), 0u);
+-    DCHECK_EQ(buf_.Length(), 0u);
+-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
++    ABSL_DCHECK_EQ(buf_.Count(), 0u);
++    ABSL_DCHECK_EQ(buf_.Length(), 0u);
++    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+   }
+
+   // When all sendmsg() calls associated with this tcp_write() have been
+@@ -154,7 +154,7 @@ class TcpZerocopySendRecord {
+   // for each sendmsg()) and all reference counts have been dropped, drop our
+   // reference to the underlying data since we no longer need it.
+   void AllSendsComplete() {
+-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
++    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+     buf_.Clear();
+   }
+
+@@ -181,7 +181,7 @@ class TcpZerocopySendCtx {
+     if (send_records_ == nullptr || free_send_records_ == nullptr) {
+       gpr_free(send_records_);
+       gpr_free(free_send_records_);
+-      VLOG(2) << "Disabling TCP TX zerocopy due to memory pressure.\n";
++      ABSL_VLOG(2) << "Disabling TCP TX zerocopy due to memory pressure.\n";
+       memory_limited_ = true;
+       enabled_ = false;
+     } else {
+@@ -235,7 +235,7 @@ class TcpZerocopySendCtx {
+     --last_send_;
+     if (ReleaseSendRecord(last_send_)->Unref()) {
+       // We should still be holding the ref taken by tcp_write().
+-      DCHECK(0);
++      ABSL_DCHECK(0);
+     }
+   }
+
+@@ -273,7 +273,7 @@ class TcpZerocopySendCtx {
+   // same time.
+   void PutSendRecord(TcpZerocopySendRecord* record) {
+     grpc_core::MutexLock lock(&mu_);
+-    DCHECK(record >= send_records_ && record < send_records_ + max_sends_);
++    ABSL_DCHECK(record >= send_records_ && record < send_records_ + max_sends_);
+     PutSendRecordLocked(record);
+   }
+
+@@ -330,7 +330,7 @@ class TcpZerocopySendCtx {
+       zcopy_enobuf_state_ = OptMemState::kCheck;
+       return false;
+     }
+-    DCHECK(zcopy_enobuf_state_ != OptMemState::kCheck);
++    ABSL_DCHECK(zcopy_enobuf_state_ != OptMemState::kCheck);
+     if (zcopy_enobuf_state_ == OptMemState::kFull) {
+       // A previous sendmsg attempt was blocked by ENOBUFS. Return true to
+       // mark the fd as writable so the next write attempt could be made.
+@@ -421,7 +421,7 @@ class TcpZerocopySendCtx {
+   TcpZerocopySendRecord* ReleaseSendRecordLocked(uint32_t seq)
+       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
+     auto iter = ctx_lookup_.find(seq);
+-    DCHECK(iter != ctx_lookup_.end());
++    ABSL_DCHECK(iter != ctx_lookup_.end());
+     TcpZerocopySendRecord* record = iter->second;
+     ctx_lookup_.erase(iter);
+     return record;
+@@ -441,7 +441,7 @@ class TcpZerocopySendCtx {
+
+   void PutSendRecordLocked(TcpZerocopySendRecord* record)
+       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
+-    DCHECK(free_send_records_size_ < max_sends_);
++    ABSL_DCHECK(free_send_records_size_ < max_sends_);
+     free_send_records_[free_send_records_size_] = record;
+     free_send_records_size_++;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc
+index 739f228e7d1d6..1d6339a9fa4f1 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc
+@@ -31,8 +31,8 @@
+
+ #include "absl/cleanup/cleanup.h"
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+@@ -131,7 +131,7 @@ void AsyncConnect::OnWritable(absl::Status status)
+   absl::StatusOr<std::unique_ptr<EventEngine::Endpoint>> ep;
+
+   mu_.Lock();
+-  CHECK_NE(fd_, nullptr);
++  ABSL_CHECK_NE(fd_, nullptr);
+   fd = std::exchange(fd_, nullptr);
+   bool connect_cancelled = connect_cancelled_;
+   if (fd->IsHandleShutdown() && status.ok()) {
+@@ -219,7 +219,7 @@ void AsyncConnect::OnWritable(absl::Status status)
+       // your program or another program on the same computer
+       // opened too many network connections.  The "easy" fix:
+       // don't do that!
+-      LOG(ERROR) << "kernel out of buffers";
++      ABSL_LOG(ERROR) << "kernel out of buffers";
+       mu_.Unlock();
+       fd->NotifyOnWrite(on_writable_);
+       // Don't run the cleanup function for this case.
+@@ -325,7 +325,7 @@ PosixEnginePollerManager::PosixEnginePollerManager(
+       poller_state_(PollerState::kExternal),
+       executor_(nullptr),
+       trigger_shutdown_called_(false) {
+-  DCHECK_NE(poller_, nullptr);
++  ABSL_DCHECK_NE(poller_, nullptr);
+ }
+
+ void PosixEnginePollerManager::Run(
+@@ -342,7 +342,7 @@ void PosixEnginePollerManager::Run(absl::AnyInvocable<void()> cb) {
+ }
+
+ void PosixEnginePollerManager::TriggerShutdown() {
+-  DCHECK(trigger_shutdown_called_ == false);
++  ABSL_DCHECK(trigger_shutdown_called_ == false);
+   trigger_shutdown_called_ = true;
+   // If the poller is external, dont try to shut it down. Otherwise
+   // set poller state to PollerState::kShuttingDown.
+@@ -455,12 +455,12 @@ PosixEventEngine::~PosixEventEngine() {
+     grpc_core::MutexLock lock(&mu_);
+     if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
+       for (auto handle : known_handles_) {
+-        LOG(ERROR) << "(event_engine) PosixEventEngine:" << this
++        ABSL_LOG(ERROR) << "(event_engine) PosixEventEngine:" << this
+                    << " uncleared TaskHandle at shutdown:"
+                    << HandleToString(handle);
+       }
+     }
+-    CHECK(GPR_LIKELY(known_handles_.empty()));
++    ABSL_CHECK(GPR_LIKELY(known_handles_.empty()));
+   }
+   timer_manager_->Shutdown();
+ #if GRPC_PLATFORM_SUPPORTS_POSIX_POLLING
+@@ -585,7 +585,7 @@ bool PosixEventEngine::CancelConnect(EventEngine::ConnectionHandle handle) {
+     auto it = shard->pending_connections.find(connection_handle);
+     if (it != shard->pending_connections.end()) {
+       ac = it->second;
+-      CHECK_NE(ac, nullptr);
++      ABSL_CHECK_NE(ac, nullptr);
+       // Trying to acquire ac->mu here would could cause a deadlock because
+       // the OnWritable method tries to acquire the two mutexes used
+       // here in the reverse order. But we dont need to acquire ac->mu before
+@@ -632,7 +632,7 @@ EventEngine::ConnectionHandle PosixEventEngine::Connect(
+     const EndpointConfig& args, MemoryAllocator memory_allocator,
+     Duration timeout) {
+ #if GRPC_PLATFORM_SUPPORTS_POSIX_POLLING
+-  CHECK_NE(poller_manager_, nullptr);
++  ABSL_CHECK_NE(poller_manager_, nullptr);
+   PosixTcpOptions options = TcpOptionsFromEndpointConfig(args);
+   absl::StatusOr<PosixSocketWrapper::PosixSocketCreateResult> socket =
+       PosixSocketWrapper::CreateAndPrepareTcpClientSocket(options, addr);
+@@ -669,9 +669,9 @@ PosixEventEngine::CreatePosixEndpointFromFd(int fd,
+                                             const EndpointConfig& config,
+                                             MemoryAllocator memory_allocator) {
+ #if GRPC_PLATFORM_SUPPORTS_POSIX_POLLING
+-  DCHECK_GT(fd, 0);
++  ABSL_DCHECK_GT(fd, 0);
+   PosixEventPoller* poller = poller_manager_->Poller();
+-  DCHECK_NE(poller, nullptr);
++  ABSL_DCHECK_NE(poller, nullptr);
+   EventHandle* handle =
+       poller->CreateHandle(fd, "tcp-client", poller->CanTrackErrors());
+   return CreatePosixEndpoint(handle, nullptr, shared_from_this(),
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+index 8906df34f0169..28fa27acebc91 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+@@ -34,8 +34,8 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -77,7 +77,7 @@ absl::StatusOr<int> PosixEngineListenerImpl::Bind(
+   EventEngine::ResolvedAddress res_addr = addr;
+   EventEngine::ResolvedAddress addr6_v4mapped;
+   int requested_port = ResolvedAddressGetPort(res_addr);
+-  CHECK(addr.size() <= EventEngine::ResolvedAddress::MAX_SIZE_BYTES);
++  ABSL_CHECK(addr.size() <= EventEngine::ResolvedAddress::MAX_SIZE_BYTES);
+   UnlinkIfUnixDomainSocket(addr);
+
+   /// Check if this is a wildcard port, and if so, try to keep the port the same
+@@ -152,7 +152,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
+           // nothing to accept. This is not a performant code path, but if an fd
+           // limit has been reached, the system is likely in an unhappy state
+           // regardless.
+-          LOG_EVERY_N_SEC(ERROR, 1)
++          ABSL_LOG_EVERY_N_SEC(ERROR, 1)
+               << "File descriptor limit reached. Retrying.";
+           handle_->NotifyOnRead(notify_on_accept_);
+           // Do not schedule another timer if one is already armed.
+@@ -174,7 +174,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
+           handle_->NotifyOnRead(notify_on_accept_);
+           return;
+         default:
+-          LOG(ERROR) << "Closing acceptor. Failed accept4: "
++          ABSL_LOG(ERROR) << "Closing acceptor. Failed accept4: "
+                      << grpc_core::StrError(errno);
+           // Shutting down the acceptor. Unref the ref grabbed in
+           // AsyncConnectionAcceptor::Start().
+@@ -189,7 +189,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
+       socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;
+       if (getpeername(fd, const_cast<sockaddr*>(addr.address()), &len) < 0) {
+         auto listener_addr_uri = ResolvedAddressToURI(socket_.addr);
+-        LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
++        ABSL_LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
+                    << ". Dropping the connection, and continuing "
+                       "to listen on "
+                    << (listener_addr_uri.ok() ? *listener_addr_uri
+@@ -207,7 +207,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
+     auto result = sock.ApplySocketMutatorInOptions(
+         GRPC_FD_SERVER_CONNECTION_USAGE, listener_->options_);
+     if (!result.ok()) {
+-      LOG(ERROR) << "Closing acceptor. Failed to apply socket mutator: "
++      ABSL_LOG(ERROR) << "Closing acceptor. Failed to apply socket mutator: "
+                  << result;
+       // Shutting down the acceptor. Unref the ref grabbed in
+       // AsyncConnectionAcceptor::Start().
+@@ -218,7 +218,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
+     // Create an Endpoint here.
+     auto peer_name = ResolvedAddressToURI(addr);
+     if (!peer_name.ok()) {
+-      LOG(ERROR) << "Invalid address: " << peer_name.status();
++      ABSL_LOG(ERROR) << "Invalid address: " << peer_name.status();
+       // Shutting down the acceptor. Unref the ref grabbed in
+       // AsyncConnectionAcceptor::Start().
+       Unref();
+@@ -299,7 +299,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::Shutdown() {
+ absl::Status PosixEngineListenerImpl::Start() {
+   grpc_core::MutexLock lock(&this->mu_);
+   // Start each asynchronous acceptor.
+-  CHECK(!this->started_);
++  ABSL_CHECK(!this->started_);
+   this->started_ = true;
+   for (auto it = acceptors_.begin(); it != acceptors_.end(); it++) {
+     (*it)->Start();
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc
+index 23ad660870f9d..20c7f8a4d3eb6 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc
+@@ -24,8 +24,8 @@
+ #include <string>
+
+ #include "absl/cleanup/cleanup.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_replace.h"
+@@ -117,7 +117,7 @@ int InitMaxAcceptQueueSize() {
+   max_accept_queue_size = n;
+
+   if (max_accept_queue_size < MIN_SAFE_ACCEPT_QUEUE_SIZE) {
+-    LOG(INFO) << "Suspiciously small accept queue (" << max_accept_queue_size
++    ABSL_LOG(INFO) << "Suspiciously small accept queue (" << max_accept_queue_size
+               << ") will probably lead to connection drops";
+   }
+   return max_accept_queue_size;
+@@ -133,7 +133,7 @@ absl::Status PrepareSocket(const PosixTcpOptions& options,
+                            ListenerSocket& socket) {
+   ResolvedAddress sockname_temp;
+   int fd = socket.sock.Fd();
+-  CHECK_GE(fd, 0);
++  ABSL_CHECK_GE(fd, 0);
+   bool close_fd = true;
+   socket.zero_copy_enabled = false;
+   socket.port = 0;
+@@ -151,7 +151,7 @@ absl::Status PrepareSocket(const PosixTcpOptions& options,
+ #ifdef GRPC_LINUX_ERRQUEUE
+   if (!socket.sock.SetSocketZeroCopy().ok()) {
+     // it's not fatal, so just log it.
+-    VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
++    ABSL_VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
+   } else {
+     socket.zero_copy_enabled = true;
+   }
+@@ -174,7 +174,7 @@ absl::Status PrepareSocket(const PosixTcpOptions& options,
+   if (bind(fd, socket.addr.address(), socket.addr.size()) < 0) {
+     auto sockaddr_str = ResolvedAddressToString(socket.addr);
+     if (!sockaddr_str.ok()) {
+-      LOG(ERROR) << "Could not convert sockaddr to string: "
++      ABSL_LOG(ERROR) << "Could not convert sockaddr to string: "
+                  << sockaddr_str.status();
+       sockaddr_str = "<unparsable>";
+     }
+@@ -222,7 +222,7 @@ absl::StatusOr<ListenerSocket> CreateAndPrepareListenerSocket(
+     socket.addr = addr;
+   }
+   GRPC_RETURN_IF_ERROR(PrepareSocket(options, socket));
+-  CHECK_GT(socket.port, 0);
++  ABSL_CHECK_GT(socket.port, 0);
+   return socket;
+ }
+
+@@ -239,7 +239,7 @@ absl::StatusOr<int> ListenerContainerAddAllLocalAddresses(
+     auto result = GetUnusedPort();
+     GRPC_RETURN_IF_ERROR(result.status());
+     requested_port = *result;
+-    VLOG(2) << "Picked unused port " << requested_port;
++    ABSL_VLOG(2) << "Picked unused port " << requested_port;
+   }
+   if (getifaddrs(&ifa) != 0 || ifa == nullptr) {
+     return absl::FailedPreconditionError(
+@@ -271,13 +271,13 @@ absl::StatusOr<int> ListenerContainerAddAllLocalAddresses(
+     addr = EventEngine::ResolvedAddress(ifa_it->ifa_addr, len);
+     ResolvedAddressSetPort(addr, requested_port);
+     std::string addr_str = *ResolvedAddressToString(addr);
+-    VLOG(2) << absl::StrFormat(
++    ABSL_VLOG(2) << absl::StrFormat(
+         "Adding local addr from interface %s flags 0x%x to server: %s",
+         ifa_name, ifa_it->ifa_flags, addr_str.c_str());
+     // We could have multiple interfaces with the same address (e.g.,
+     // bonding), so look for duplicates.
+     if (listener_sockets.Find(addr).ok()) {
+-      VLOG(2) << "Skipping duplicate addr " << addr_str << " on interface "
++      ABSL_VLOG(2) << "Skipping duplicate addr " << addr_str << " on interface "
+               << ifa_name;
+       continue;
+     }
+@@ -342,19 +342,19 @@ absl::StatusOr<int> ListenerContainerAddWildcardAddresses(
+   }
+   if (assigned_port > 0) {
+     if (!v6_sock.ok()) {
+-      VLOG(2) << "Failed to add :: listener, the environment may not support "
++      ABSL_VLOG(2) << "Failed to add :: listener, the environment may not support "
+                  "IPv6: "
+               << v6_sock.status();
+     }
+     if (!v4_sock.ok()) {
+-      VLOG(2) << "Failed to add 0.0.0.0 listener, "
++      ABSL_VLOG(2) << "Failed to add 0.0.0.0 listener, "
+                  "the environment may not support IPv4: "
+               << v4_sock.status();
+     }
+     return assigned_port;
+   } else {
+-    CHECK(!v6_sock.ok());
+-    CHECK(!v4_sock.ok());
++    ABSL_CHECK(!v6_sock.ok());
++    ABSL_CHECK(!v4_sock.ok());
+     return absl::FailedPreconditionError(absl::StrCat(
+         "Failed to add any wildcard listeners: ", v6_sock.status().message(),
+         v4_sock.status().message()));
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc
+index 7cce3548323a7..4add0063bc07c 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc
+@@ -47,8 +47,8 @@
+ #include <atomic>
+ #include <cstring>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/lib/event_engine/tcp_socket_utils.h"
+ #include "src/core/util/status_helper.h"
+@@ -103,7 +103,7 @@ int CreateSocket(std::function<int(int, int, int)> socket_factory, int family,
+                                       : socket(family, type, protocol);
+   if (res < 0 && errno == EMFILE) {
+     int saved_errno = errno;
+-    LOG_EVERY_N_SEC(ERROR, 10)
++    ABSL_LOG_EVERY_N_SEC(ERROR, 10)
+         << "socket(" << family << ", " << type << ", " << protocol
+         << ") returned " << res << " with error: |"
+         << grpc_core::StrError(errno)
+@@ -647,18 +647,18 @@ void PosixSocketWrapper::TrySetSocketTcpUserTimeout(
+     if (g_socket_supports_tcp_user_timeout.load() > 0) {
+       if (0 != setsockopt(fd_, IPPROTO_TCP, TCP_USER_TIMEOUT, &timeout,
+                           sizeof(timeout))) {
+-        LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
++        ABSL_LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
+                    << grpc_core::StrError(errno);
+         return;
+       }
+       if (0 != getsockopt(fd_, IPPROTO_TCP, TCP_USER_TIMEOUT, &newval, &len)) {
+-        LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
++        ABSL_LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
+                    << grpc_core::StrError(errno);
+         return;
+       }
+       if (newval != timeout) {
+         // Do not fail on failing to set TCP_USER_TIMEOUT
+-        LOG(ERROR) << "Failed to set TCP_USER_TIMEOUT";
++        ABSL_LOG(ERROR) << "Failed to set TCP_USER_TIMEOUT";
+         return;
+       }
+     }
+@@ -668,7 +668,7 @@ void PosixSocketWrapper::TrySetSocketTcpUserTimeout(
+ // Set a socket using a grpc_socket_mutator
+ absl::Status PosixSocketWrapper::SetSocketMutator(
+     grpc_fd_usage usage, grpc_socket_mutator* mutator) {
+-  CHECK(mutator);
++  ABSL_CHECK(mutator);
+   if (!grpc_socket_mutator_mutate_fd(mutator, fd_, usage)) {
+     return absl::Status(absl::StatusCode::kInternal,
+                         "grpc_socket_mutator failed.");
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h
+index 2b07e16f5e276..cf72c86f57cd1 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h
+@@ -25,7 +25,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/lib/iomgr/port.h"
+@@ -159,7 +159,7 @@ void UnlinkIfUnixDomainSocket(
+
+ class PosixSocketWrapper {
+  public:
+-  explicit PosixSocketWrapper(int fd) : fd_(fd) { CHECK_GT(fd_, 0); }
++  explicit PosixSocketWrapper(int fd) : fd_(fd) { ABSL_CHECK_GT(fd_, 0); }
+
+   PosixSocketWrapper() : fd_(-1) {};
+
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc
+index 2ce6087b74092..9fba763116729 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc
+@@ -25,8 +25,8 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/time/time.h"
+ #include "src/core/lib/debug/trace.h"
+
+@@ -65,7 +65,7 @@ void TimerManager::MainLoop() {
+   grpc_core::Timestamp next = grpc_core::Timestamp::InfFuture();
+   std::optional<std::vector<experimental::EventEngine::Closure*>> check_result =
+       timer_list_->TimerCheck(&next);
+-  CHECK(check_result.has_value())
++  ABSL_CHECK(check_result.has_value())
+       << "ERROR: More than one MainLoop is running.";
+   bool timers_found = !check_result->empty();
+   if (timers_found) {
+@@ -100,7 +100,7 @@ void TimerManager::TimerInit(Timer* timer, grpc_core::Timestamp deadline,
+   if (GRPC_TRACE_FLAG_ENABLED(timer)) {
+     grpc_core::MutexLock lock(&mu_);
+     if (shutdown_) {
+-      LOG(ERROR) << "WARNING: TimerManager::" << this
++      ABSL_LOG(ERROR) << "WARNING: TimerManager::" << this
+                  << ": scheduling Closure::" << closure
+                  << " after TimerManager has been shut down.";
+     }
+@@ -137,7 +137,7 @@ void TimerManager::Kick() {
+
+ void TimerManager::RestartPostFork() {
+   grpc_core::MutexLock lock(&mu_);
+-  CHECK(GPR_LIKELY(shutdown_));
++  ABSL_CHECK(GPR_LIKELY(shutdown_));
+   GRPC_TRACE_VLOG(timer, 2)
+       << "TimerManager::" << this << " restarting after shutdown";
+   shutdown_ = false;
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc
+index 6db28efd6faf6..1b688aa5fd512 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc
+@@ -24,7 +24,7 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/port.h"
+ #include "src/core/util/sync.h"
+
+@@ -45,7 +45,7 @@ void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {
+
+ void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,
+                                absl::Status /*shutdown_err*/) {
+-  VLOG(2) << "Timestamps callback has not been registered";
++  ABSL_VLOG(2) << "Timestamps callback has not been registered";
+ }
+
+ // The saved callback function that will be invoked when we get all the
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc b/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc
+index ac7ba92563096..416530eab0036 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc
+@@ -18,7 +18,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/event_engine/resolved_address_internal.h"
+
+ // IWYU pragma: no_include <sys/socket.h>
+@@ -28,8 +28,8 @@ namespace grpc_event_engine::experimental {
+ EventEngine::ResolvedAddress::ResolvedAddress(const sockaddr* address,
+                                               socklen_t size)
+     : size_(size) {
+-  DCHECK_GE(size, 0u);
+-  CHECK(static_cast<size_t>(size) <= sizeof(address_));
++  ABSL_DCHECK_GE(size, 0u);
++  ABSL_CHECK(static_cast<size_t>(size) <= sizeof(address_));
+   memcpy(&address_, address, size);
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/slice.cc b/third_party/grpc/source/src/core/lib/event_engine/slice.cc
+index 851d3f7de4900..4ba072263d482 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/slice.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/slice.cc
+@@ -22,7 +22,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/lib/slice/slice_refcount.h"
+
+@@ -46,7 +46,7 @@ Slice CopyConstructors<Slice>::FromCopiedString(std::string s) {
+
+ MutableSlice::MutableSlice(const grpc_slice& slice)
+     : slice_detail::BaseSlice(slice) {
+-  DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
++  ABSL_DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
+ }
+
+ MutableSlice::~MutableSlice() { grpc_core::CSliceUnref(c_slice()); }
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc b/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc
+index 2ba754595868b..823952402180f 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc
+@@ -53,8 +53,8 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -215,7 +215,7 @@ bool ResolvedAddressIsV4Mapped(
+ bool ResolvedAddressToV4Mapped(
+     const EventEngine::ResolvedAddress& resolved_addr,
+     EventEngine::ResolvedAddress* resolved_addr6_out) {
+-  CHECK(&resolved_addr != resolved_addr6_out);
++  ABSL_CHECK(&resolved_addr != resolved_addr6_out);
+   const sockaddr* addr = resolved_addr.address();
+   sockaddr_in6* addr6_out = const_cast<sockaddr_in6*>(
+       reinterpret_cast<const sockaddr_in6*>(resolved_addr6_out->address()));
+@@ -237,8 +237,8 @@ EventEngine::ResolvedAddress ResolvedAddressMakeWild6(int port) {
+   EventEngine::ResolvedAddress resolved_wild_out;
+   sockaddr_in6* wild_out = reinterpret_cast<sockaddr_in6*>(
+       const_cast<sockaddr*>(resolved_wild_out.address()));
+-  CHECK_GE(port, 0);
+-  CHECK_LT(port, 65536);
++  ABSL_CHECK_GE(port, 0);
++  ABSL_CHECK_LT(port, 65536);
+   memset(wild_out, 0, sizeof(sockaddr_in6));
+   wild_out->sin6_family = AF_INET6;
+   wild_out->sin6_port = htons(static_cast<uint16_t>(port));
+@@ -251,8 +251,8 @@ EventEngine::ResolvedAddress ResolvedAddressMakeWild4(int port) {
+   EventEngine::ResolvedAddress resolved_wild_out;
+   sockaddr_in* wild_out = reinterpret_cast<sockaddr_in*>(
+       const_cast<sockaddr*>(resolved_wild_out.address()));
+-  CHECK_GE(port, 0);
+-  CHECK_LT(port, 65536);
++  ABSL_CHECK_GE(port, 0);
++  ABSL_CHECK_LT(port, 65536);
+   memset(wild_out, 0, sizeof(sockaddr_in));
+   wild_out->sin_family = AF_INET;
+   wild_out->sin_port = htons(static_cast<uint16_t>(port));
+@@ -277,7 +277,7 @@ int ResolvedAddressGetPort(const EventEngine::ResolvedAddress& resolved_addr) {
+       return 1;
+ #endif
+     default:
+-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
++      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
+                  << " in ResolvedAddressGetPort";
+       abort();
+   }
+@@ -288,19 +288,19 @@ void ResolvedAddressSetPort(EventEngine::ResolvedAddress& resolved_addr,
+   sockaddr* addr = const_cast<sockaddr*>(resolved_addr.address());
+   switch (addr->sa_family) {
+     case AF_INET:
+-      CHECK_GE(port, 0);
+-      CHECK_LT(port, 65536);
++      ABSL_CHECK_GE(port, 0);
++      ABSL_CHECK_LT(port, 65536);
+       (reinterpret_cast<sockaddr_in*>(addr))->sin_port =
+           htons(static_cast<uint16_t>(port));
+       return;
+     case AF_INET6:
+-      CHECK_GE(port, 0);
+-      CHECK_LT(port, 65536);
++      ABSL_CHECK_GE(port, 0);
++      ABSL_CHECK_LT(port, 65536);
+       (reinterpret_cast<sockaddr_in6*>(addr))->sin6_port =
+           htons(static_cast<uint16_t>(port));
+       return;
+     default:
+-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
++      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
+                  << " in grpc_sockaddr_set_port";
+       abort();
+   }
+@@ -437,10 +437,10 @@ absl::StatusOr<EventEngine::ResolvedAddress> URIToResolvedAddress(
+   grpc_resolved_address addr;
+   absl::StatusOr<grpc_core::URI> uri = grpc_core::URI::Parse(address_str);
+   if (!uri.ok()) {
+-    LOG(ERROR) << "Failed to parse URI. Error: " << uri.status();
++    ABSL_LOG(ERROR) << "Failed to parse URI. Error: " << uri.status();
+   }
+   GRPC_RETURN_IF_ERROR(uri.status());
+-  CHECK(grpc_parse_uri(*uri, &addr));
++  ABSL_CHECK(grpc_parse_uri(*uri, &addr));
+   return EventEngine::ResolvedAddress(
+       reinterpret_cast<const sockaddr*>(addr.addr), addr.len);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc
+index 3bf4885eb5b1a..326701427b3cb 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc
+@@ -18,7 +18,7 @@
+
+ #include <cstddef>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/time/clock.h"
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc
+index 955881a52cc50..83324c9247816 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc
+@@ -29,8 +29,8 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/time/clock.h"
+ #include "absl/time/time.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -153,10 +153,10 @@ std::atomic<size_t> g_reported_dump_count{0};
+ void DumpSignalHandler(int /* sig */) {
+   const auto trace = grpc_core::GetCurrentStackTrace();
+   if (!trace.has_value()) {
+-    LOG(ERROR) << "DumpStack::" << gpr_thd_currentid()
++    ABSL_LOG(ERROR) << "DumpStack::" << gpr_thd_currentid()
+                << ": Stack trace not available";
+   } else {
+-    LOG(ERROR) << "DumpStack::" << gpr_thd_currentid() << ": " << trace.value();
++    ABSL_LOG(ERROR) << "DumpStack::" << gpr_thd_currentid() << ": " << trace.value();
+   }
+   g_reported_dump_count.fetch_add(1);
+   grpc_core::Thread::Kill(gpr_thd_currentid());
+@@ -180,7 +180,7 @@ WorkStealingThreadPool::WorkStealingThreadPool(size_t reserve_threads)
+ void WorkStealingThreadPool::Quiesce() { pool_->Quiesce(); }
+
+ WorkStealingThreadPool::~WorkStealingThreadPool() {
+-  CHECK(pool_->IsQuiesced());
++  ABSL_CHECK(pool_->IsQuiesced());
+ }
+
+ void WorkStealingThreadPool::Run(absl::AnyInvocable<void()> callback) {
+@@ -235,7 +235,7 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Start() {
+
+ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Run(
+     EventEngine::Closure* closure) {
+-  CHECK(!IsQuiesced());
++  ABSL_CHECK(!IsQuiesced());
+   if (g_local_queue != nullptr && g_local_queue->owner() == this) {
+     g_local_queue->Add(closure);
+   } else {
+@@ -277,7 +277,7 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Quiesce() {
+   if (!threads_were_shut_down.ok() && g_log_verbose_failures) {
+     DumpStacksAndCrash();
+   }
+-  CHECK(queue_.Empty());
++  ABSL_CHECK(queue_.Empty());
+   quiesced_.store(true, std::memory_order_relaxed);
+   grpc_core::MutexLock lock(&lifeguard_ptr_mu_);
+   lifeguard_.reset();
+@@ -291,14 +291,14 @@ bool WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetThrottled(
+ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetShutdown(
+     bool is_shutdown) {
+   auto was_shutdown = shutdown_.exchange(is_shutdown);
+-  CHECK(is_shutdown != was_shutdown);
++  ABSL_CHECK(is_shutdown != was_shutdown);
+   work_signal_.SignalAll();
+ }
+
+ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetForking(
+     bool is_forking) {
+   auto was_forking = forking_.exchange(is_forking);
+-  CHECK(is_forking != was_forking);
++  ABSL_CHECK(is_forking != was_forking);
+ }
+
+ bool WorkStealingThreadPool::WorkStealingThreadPoolImpl::IsForking() {
+@@ -346,7 +346,7 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::UntrackThread(
+
+ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::DumpStacksAndCrash() {
+   grpc_core::MutexLock lock(&thd_set_mu_);
+-  LOG(ERROR) << "Pool did not quiesce in time, gRPC will not shut down "
++  ABSL_LOG(ERROR) << "Pool did not quiesce in time, gRPC will not shut down "
+                 "cleanly. Dumping all "
+              << thds_.size() << " thread stacks.";
+   for (const auto tid : thds_) {
+@@ -500,7 +500,7 @@ void WorkStealingThreadPool::ThreadState::ThreadBody() {
+   } else if (pool_->IsShutdown()) {
+     FinishDraining();
+   }
+-  CHECK(g_local_queue->Empty());
++  ABSL_CHECK(g_local_queue->Empty());
+   pool_->theft_registry()->Unenroll(g_local_queue);
+   delete g_local_queue;
+   if (g_log_verbose_failures) {
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc
+index c022e35d0ece0..61f710a7b72db 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc
+@@ -23,7 +23,7 @@
+ #include <winsock2.h>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+@@ -129,8 +129,8 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+         << "| ~GrpcPolledFdWindows shutdown_called_: " << shutdown_called_;
+     grpc_core::CSliceUnref(read_buf_);
+     grpc_core::CSliceUnref(write_buf_);
+-    CHECK(read_closure_ == nullptr);
+-    CHECK(write_closure_ == nullptr);
++    ABSL_CHECK(read_closure_ == nullptr);
++    ABSL_CHECK(write_closure_ == nullptr);
+     if (!shutdown_called_) {
+       winsocket_->Shutdown(DEBUG_LOCATION, "~GrpcPolledFdWindows");
+     }
+@@ -138,15 +138,15 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+
+   void RegisterForOnReadableLocked(
+       absl::AnyInvocable<void(absl::Status)> read_closure) override {
+-    CHECK(read_closure_ == nullptr);
++    ABSL_CHECK(read_closure_ == nullptr);
+     read_closure_ = std::move(read_closure);
+     grpc_core::CSliceUnref(read_buf_);
+-    CHECK(!read_buf_has_data_);
++    ABSL_CHECK(!read_buf_has_data_);
+     read_buf_ = GRPC_SLICE_MALLOC(kReadBufferSize);
+     if (connect_done_) {
+       ContinueRegisterForOnReadableLocked();
+     } else {
+-      CHECK(pending_continue_register_for_on_readable_locked_ == false);
++      ABSL_CHECK(pending_continue_register_for_on_readable_locked_ == false);
+       pending_continue_register_for_on_readable_locked_ = true;
+     }
+   }
+@@ -158,17 +158,17 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+           << "(EventEngine c-ares resolver) fd:|" << GetName()
+           << "| RegisterForOnWriteableLocked called";
+     } else {
+-      CHECK(socket_type_ == SOCK_STREAM);
++      ABSL_CHECK(socket_type_ == SOCK_STREAM);
+       GRPC_TRACE_LOG(cares_resolver, INFO)
+           << "(EventEngine c-ares resolver) fd:|" << GetName()
+           << "| RegisterForOnWriteableLocked called tcp_write_state_: "
+           << static_cast<int>(tcp_write_state_)
+           << " connect_done_: " << connect_done_;
+     }
+-    CHECK(write_closure_ == nullptr);
++    ABSL_CHECK(write_closure_ == nullptr);
+     write_closure_ = std::move(write_closure);
+     if (!connect_done_) {
+-      CHECK(!pending_continue_register_for_on_writeable_locked_);
++      ABSL_CHECK(!pending_continue_register_for_on_writeable_locked_);
+       pending_continue_register_for_on_writeable_locked_ = true;
+     } else {
+       ContinueRegisterForOnWriteableLocked();
+@@ -178,7 +178,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+   bool IsFdStillReadableLocked() override { return read_buf_has_data_; }
+
+   bool ShutdownLocked(absl::Status error) override {
+-    CHECK(!shutdown_called_);
++    ABSL_CHECK(!shutdown_called_);
+     if (!absl::IsCancelled(error)) {
+       return false;
+     }
+@@ -223,7 +223,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+     // c-ares overloads this recv_from virtual socket function to receive
+     // data on both UDP and TCP sockets, and from is nullptr for TCP.
+     if (from != nullptr) {
+-      CHECK(*from_len >= recv_from_source_addr_len_);
++      ABSL_CHECK(*from_len >= recv_from_source_addr_len_);
+       memcpy(from, &recv_from_source_addr_, recv_from_source_addr_len_);
+       *from_len = recv_from_source_addr_len_;
+     }
+@@ -292,7 +292,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+         << "(EventEngine c-ares resolver) fd:|" << GetName()
+         << "| ContinueRegisterForOnReadableLocked wsa_connect_error_:"
+         << wsa_connect_error_;
+-    CHECK(connect_done_);
++    ABSL_CHECK(connect_done_);
+     if (wsa_connect_error_ != 0) {
+       ScheduleAndNullReadClosure(GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
+       return;
+@@ -329,7 +329,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+         << "(EventEngine c-ares resolver) fd:|" << GetName()
+         << "| ContinueRegisterForOnWriteableLocked wsa_connect_error_:"
+         << wsa_connect_error_;
+-    CHECK(connect_done_);
++    ABSL_CHECK(connect_done_);
+     if (wsa_connect_error_ != 0) {
+       ScheduleAndNullWriteClosure(
+           GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
+@@ -339,7 +339,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+       ScheduleAndNullWriteClosure(absl::OkStatus());
+       return;
+     }
+-    CHECK(socket_type_ == SOCK_STREAM);
++    ABSL_CHECK(socket_type_ == SOCK_STREAM);
+     int wsa_error_code = 0;
+     switch (tcp_write_state_) {
+       case WRITE_IDLE:
+@@ -388,7 +388,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+     // to write everything inline.
+     GRPC_TRACE_LOG(cares_resolver, INFO) << "(EventEngine c-ares resolver) fd:|"
+                                          << GetName() << "| SendVUDP called";
+-    CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
++    ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
+     grpc_core::CSliceUnref(write_buf_);
+     write_buf_ = FlattenIovec(iov, iov_count);
+     DWORD bytes_sent = 0;
+@@ -439,11 +439,11 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+         // send again. If c-ares still needs to send even more data, we'll get
+         // to it eventually.
+         grpc_slice currently_attempted = FlattenIovec(iov, iov_count);
+-        CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
++        ABSL_CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
+               GRPC_SLICE_LENGTH(write_buf_));
+         ares_ssize_t total_sent = 0;
+         for (size_t i = 0; i < GRPC_SLICE_LENGTH(write_buf_); i++) {
+-          CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
++          ABSL_CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
+                 GRPC_SLICE_START_PTR(write_buf_)[i]);
+           total_sent++;
+         }
+@@ -463,9 +463,9 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+         << pending_continue_register_for_on_readable_locked_
+         << " pending_register_for_writeable:"
+         << pending_continue_register_for_on_writeable_locked_;
+-    CHECK(!connect_done_);
++    ABSL_CHECK(!connect_done_);
+     connect_done_ = true;
+-    CHECK_EQ(wsa_connect_error_, 0);
++    ABSL_CHECK_EQ(wsa_connect_error_, 0);
+     if (shutdown_called_) {
+       wsa_connect_error_ = WSA_OPERATION_ABORTED;
+     } else {
+@@ -474,7 +474,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+       BOOL wsa_success = WSAGetOverlappedResult(
+           winsocket_->raw_socket(), winsocket_->write_info()->overlapped(),
+           &transferred_bytes, FALSE, &flags);
+-      CHECK_EQ(transferred_bytes, 0);
++      ABSL_CHECK_EQ(transferred_bytes, 0);
+       if (!wsa_success) {
+         wsa_connect_error_ = WSAGetLastError();
+         char* msg = gpr_format_message(wsa_connect_error_);
+@@ -497,8 +497,8 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+                  ares_socklen_t target_len) {
+     GRPC_TRACE_LOG(cares_resolver, INFO)
+         << "(EventEngine c-ares resolver) fd:" << GetName() << " ConnectUDP";
+-    CHECK(!connect_done_);
+-    CHECK_EQ(wsa_connect_error_, 0);
++    ABSL_CHECK(!connect_done_);
++    ABSL_CHECK_EQ(wsa_connect_error_, 0);
+     SOCKET s = winsocket_->raw_socket();
+     int out =
+         WSAConnect(s, target, target_len, nullptr, nullptr, nullptr, nullptr);
+@@ -636,7 +636,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+     GRPC_TRACE_LOG(cares_resolver, INFO)
+         << "(EventEngine c-ares resolver) OnIocpWriteableInner. fd:|"
+         << GetName() << "|";
+-    CHECK(socket_type_ == SOCK_STREAM);
++    ABSL_CHECK(socket_type_ == SOCK_STREAM);
+     absl::Status error;
+     if (winsocket_->write_info()->result().wsa_error != 0) {
+       error = GRPC_WSA_ERROR(winsocket_->write_info()->result().wsa_error,
+@@ -648,7 +648,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
+           << winsocket_->write_info()->result().wsa_error << "| msg:|"
+           << grpc_core::StatusToString(error) << "|";
+     }
+-    CHECK(tcp_write_state_ == WRITE_PENDING);
++    ABSL_CHECK(tcp_write_state_ == WRITE_PENDING);
+     if (error.ok()) {
+       tcp_write_state_ = WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY;
+       write_buf_ = grpc_slice_sub_no_ref(
+@@ -735,7 +735,7 @@ class CustomSockFuncs {
+         << "(EventEngine c-ares resolver) fd:" << polled_fd->GetName()
+         << " created with params af:" << af << " type:" << type
+         << " protocol:" << protocol;
+-    CHECK(self->sockets_.insert({s, std::move(polled_fd)}).second);
++    ABSL_CHECK(self->sockets_.insert({s, std::move(polled_fd)}).second);
+     return s;
+   }
+
+@@ -745,7 +745,7 @@ class CustomSockFuncs {
+     GrpcPolledFdFactoryWindows* self =
+         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
+     auto it = self->sockets_.find(as);
+-    CHECK(it != self->sockets_.end());
++    ABSL_CHECK(it != self->sockets_.end());
+     return it->second->Connect(&wsa_error_ctx, target, target_len);
+   }
+
+@@ -755,7 +755,7 @@ class CustomSockFuncs {
+     GrpcPolledFdFactoryWindows* self =
+         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
+     auto it = self->sockets_.find(as);
+-    CHECK(it != self->sockets_.end());
++    ABSL_CHECK(it != self->sockets_.end());
+     return it->second->SendV(&wsa_error_ctx, iov, iovec_count);
+   }
+
+@@ -766,7 +766,7 @@ class CustomSockFuncs {
+     GrpcPolledFdFactoryWindows* self =
+         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
+     auto it = self->sockets_.find(as);
+-    CHECK(it != self->sockets_.end());
++    ABSL_CHECK(it != self->sockets_.end());
+     return it->second->RecvFrom(&wsa_error_ctx, data, data_len, flags, from,
+                                 from_len);
+   }
+@@ -827,7 +827,7 @@ void GrpcPolledFdFactoryWindows::Initialize(grpc_core::Mutex* mutex,
+ std::unique_ptr<GrpcPolledFd> GrpcPolledFdFactoryWindows::NewGrpcPolledFdLocked(
+     ares_socket_t as) {
+   auto it = sockets_.find(as);
+-  CHECK(it != sockets_.end());
++  ABSL_CHECK(it != sockets_.end());
+   return std::make_unique<GrpcPolledFdWrapper>(it->second.get());
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc
+index 45da92053764a..b7e6776580e53 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc
+@@ -20,7 +20,7 @@
+
+ #include <chrono>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/event_engine/thread_pool/thread_pool.h"
+ #include "src/core/lib/event_engine/time_util.h"
+@@ -35,7 +35,7 @@ IOCP::IOCP(ThreadPool* thread_pool) noexcept
+     : thread_pool_(thread_pool),
+       iocp_handle_(CreateIoCompletionPort(INVALID_HANDLE_VALUE, nullptr,
+                                           (ULONG_PTR) nullptr, 0)) {
+-  CHECK(iocp_handle_);
++  ABSL_CHECK(iocp_handle_);
+   WSASocketFlagsInit();
+ }
+
+@@ -52,7 +52,7 @@ std::unique_ptr<WinSocket> IOCP::Watch(SOCKET socket) {
+         GRPC_WSA_ERROR(WSAGetLastError(), "Unable to add socket to iocp")
+             .ToString());
+   }
+-  CHECK(ret == iocp_handle_);
++  ABSL_CHECK(ret == iocp_handle_);
+   return wrapped_socket;
+ }
+
+@@ -63,7 +63,7 @@ void IOCP::Shutdown() {
+   while (outstanding_kicks_.load() > 0) {
+     Work(std::chrono::hours(42), []() {});
+   }
+-  CHECK(CloseHandle(iocp_handle_));
++  ABSL_CHECK(CloseHandle(iocp_handle_));
+ }
+
+ Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,
+@@ -81,8 +81,8 @@ Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,
+         << "IOCP::" << this << " deadline exceeded";
+     return Poller::WorkResult::kDeadlineExceeded;
+   }
+-  CHECK(completion_key);
+-  CHECK(overlapped);
++  ABSL_CHECK(completion_key);
++  ABSL_CHECK(overlapped);
+   if (overlapped == &kick_overlap_) {
+     GRPC_TRACE_LOG(event_engine_poller, INFO) << "IOCP::" << this << " kicked";
+     outstanding_kicks_.fetch_sub(1);
+@@ -101,7 +101,7 @@ Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,
+   // about to register for notification of an overlapped event.
+   auto* socket = reinterpret_cast<WinSocket*>(completion_key);
+   WinSocket::OpState* info = socket->GetOpInfoForOverlapped(overlapped);
+-  CHECK_NE(info, nullptr);
++  ABSL_CHECK_NE(info, nullptr);
+   info->GetOverlappedResult();
+   info->SetReady();
+   schedule_poll_again();
+@@ -110,7 +110,7 @@ Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,
+
+ void IOCP::Kick() {
+   outstanding_kicks_.fetch_add(1);
+-  CHECK(PostQueuedCompletionStatus(iocp_handle_, 0,
++  ABSL_CHECK(PostQueuedCompletionStatus(iocp_handle_, 0,
+                                    reinterpret_cast<ULONG_PTR>(&kick_token_),
+                                    &kick_overlap_));
+ }
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc
+index afc40e5d1150b..e81673b55b503 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc
+@@ -17,8 +17,8 @@
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/log_windows.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/event_engine/tcp_socket_utils.h"
+ #include "src/core/lib/event_engine/thread_pool/thread_pool.h"
+ #include "src/core/lib/event_engine/windows/win_socket.h"
+@@ -45,7 +45,7 @@ WinSocket::WinSocket(SOCKET socket, ThreadPool* thread_pool) noexcept
+       write_info_(this) {}
+
+ WinSocket::~WinSocket() {
+-  CHECK(is_shutdown_.load());
++  ABSL_CHECK(is_shutdown_.load());
+   GRPC_TRACE_LOG(event_engine_endpoint, INFO)
+       << "WinSocket::" << this << " destroyed";
+ }
+@@ -103,7 +103,7 @@ void WinSocket::NotifyOnReady(OpState& info, EventEngine::Closure* closure) {
+     return;
+   };
+   // It is an error if any notification is already registered for this socket.
+-  CHECK_EQ(std::exchange(info.closure_, closure), nullptr);
++  ABSL_CHECK_EQ(std::exchange(info.closure_, closure), nullptr);
+ }
+
+ void WinSocket::NotifyOnRead(EventEngine::Closure* on_read) {
+@@ -115,11 +115,11 @@ void WinSocket::NotifyOnWrite(EventEngine::Closure* on_write) {
+ }
+
+ void WinSocket::UnregisterReadCallback() {
+-  CHECK_NE(std::exchange(read_info_.closure_, nullptr), nullptr);
++  ABSL_CHECK_NE(std::exchange(read_info_.closure_, nullptr), nullptr);
+ }
+
+ void WinSocket::UnregisterWriteCallback() {
+-  CHECK_NE(std::exchange(write_info_.closure_, nullptr), nullptr);
++  ABSL_CHECK_NE(std::exchange(write_info_.closure_, nullptr), nullptr);
+ }
+
+ // ---- WinSocket::OpState ----
+@@ -133,7 +133,7 @@ void WinSocket::OpState::SetReady() {
+   auto* closure = std::exchange(closure_, nullptr);
+   // If an IOCP event is returned for a socket, and no callback has been
+   // registered for notification, this is invalid usage.
+-  CHECK_NE(closure, nullptr);
++  ABSL_CHECK_NE(closure, nullptr);
+   win_socket_->thread_pool_->Run(closure);
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc
+index 38ba017e12e2a..b90c377b1f453 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc
+@@ -20,8 +20,8 @@
+
+ #include "absl/cleanup/cleanup.h"
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/event_engine/tcp_socket_utils.h"
+@@ -86,7 +86,7 @@ void WindowsEndpoint::AsyncIOState::DoTcpRead(SliceBuffer* buffer) {
+     return;
+   }
+   // Prepare the WSABUF struct
+-  CHECK(buffer->Count() <= kMaxWSABUFCount);
++  ABSL_CHECK(buffer->Count() <= kMaxWSABUFCount);
+   WSABUF wsa_buffers[kMaxWSABUFCount];
+   for (size_t i = 0; i < buffer->Count(); i++) {
+     auto& slice = buffer->MutableSliceAt(i);
+@@ -165,11 +165,11 @@ bool WindowsEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,
+           << " WRITE (peer=" << peer_address_string_ << "): " << str;
+     }
+   }
+-  CHECK(data->Count() <= UINT_MAX);
++  ABSL_CHECK(data->Count() <= UINT_MAX);
+   absl::InlinedVector<WSABUF, kMaxWSABUFCount> buffers(data->Count());
+   for (size_t i = 0; i < data->Count(); i++) {
+     auto& slice = data->MutableSliceAt(i);
+-    CHECK(slice.size() <= ULONG_MAX);
++    ABSL_CHECK(slice.size() <= ULONG_MAX);
+     buffers[i].len = slice.size();
+     buffers[i].buf = (char*)slice.begin();
+   }
+@@ -294,10 +294,10 @@ void WindowsEndpoint::HandleReadClosure::Run() {
+     return ResetAndReturnCallback()(status);
+   }
+   if (result.bytes_transferred == 0) {
+-    DCHECK_GT(io_state.use_count(), 0);
++    ABSL_DCHECK_GT(io_state.use_count(), 0);
+     // Either the endpoint is shut down or we've seen the end of the stream
+     if (GRPC_TRACE_FLAG_ENABLED(event_engine_endpoint_data)) {
+-      LOG(INFO) << "WindowsEndpoint::" << this << " read 0 bytes.";
++      ABSL_LOG(INFO) << "WindowsEndpoint::" << this << " read 0 bytes.";
+       DumpSliceBuffer(
+           &last_read_buffer_,
+           absl::StrFormat("WindowsEndpoint::%p READ last_read_buffer_: ",
+@@ -313,8 +313,8 @@ void WindowsEndpoint::HandleReadClosure::Run() {
+     }
+     return ResetAndReturnCallback()(status);
+   }
+-  DCHECK_GT(result.bytes_transferred, 0);
+-  DCHECK(result.bytes_transferred <= buffer_->Length());
++  ABSL_DCHECK_GT(result.bytes_transferred, 0);
++  ABSL_DCHECK(result.bytes_transferred <= buffer_->Length());
+   buffer_->MoveFirstNBytesIntoSliceBuffer(result.bytes_transferred,
+                                           last_read_buffer_);
+   if (buffer_->Length() == 0) {
+@@ -345,9 +345,9 @@ bool WindowsEndpoint::HandleReadClosure::MaybeFinishIfDataHasAlreadyBeenRead() {
+ void WindowsEndpoint::HandleReadClosure::DonateSpareSlices(
+     SliceBuffer* buffer) {
+   // Donee buffer must be empty.
+-  CHECK_EQ(buffer->Length(), 0);
++  ABSL_CHECK_EQ(buffer->Length(), 0);
+   // HandleReadClosure must be in the reset state.
+-  CHECK_EQ(buffer_, nullptr);
++  ABSL_CHECK_EQ(buffer_, nullptr);
+   buffer->Swap(last_read_buffer_);
+ }
+
+@@ -365,7 +365,7 @@ void WindowsEndpoint::HandleWriteClosure::Run() {
+   if (result.wsa_error != 0) {
+     status = GRPC_WSA_ERROR(result.wsa_error, "WSASend");
+   } else {
+-    CHECK(result.bytes_transferred == buffer_->Length());
++    ABSL_CHECK(result.bytes_transferred == buffer_->Length());
+   }
+   return ResetAndReturnCallback()(status);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc
+index c58779a16d31d..03556c57ecde2 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc
+@@ -24,8 +24,8 @@
+ #include <memory>
+ #include <ostream>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+@@ -75,7 +75,7 @@ WindowsEventEngine::ConnectionState::ConnectionState(
+       allocator_(std::move(allocator)),
+       on_connect_user_callback_(std::move(on_connect_user_callback)),
+       engine_(std::move(engine)) {
+-  CHECK(socket_ != nullptr);
++  ABSL_CHECK(socket_ != nullptr);
+   connection_handle_ = ConnectionHandle{reinterpret_cast<intptr_t>(this),
+                                         engine_->aba_token_.fetch_add(1)};
+ }
+@@ -112,7 +112,7 @@ void WindowsEventEngine::ConnectionState::AbortDeadlineTimer() {
+ }
+
+ void WindowsEventEngine::ConnectionState::OnConnectedCallback::Run() {
+-  DCHECK_NE(connection_state_, nullptr)
++  ABSL_DCHECK_NE(connection_state_, nullptr)
+       << "ConnectionState::OnConnectedCallback::" << this
+       << " has already run. It should only ever run once.";
+   bool has_run;
+@@ -131,7 +131,7 @@ void WindowsEventEngine::ConnectionState::OnConnectedCallback::Run() {
+ }
+
+ void WindowsEventEngine::ConnectionState::DeadlineTimerCallback::Run() {
+-  DCHECK_NE(connection_state_, nullptr)
++  ABSL_DCHECK_NE(connection_state_, nullptr)
+       << "ConnectionState::DeadlineTimerCallback::" << this
+       << " has already run. It should only ever run once.";
+   bool has_run;
+@@ -207,7 +207,7 @@ WindowsEventEngine::WindowsEventEngine()
+       iocp_worker_(thread_pool_.get(), &iocp_) {
+   WSADATA wsaData;
+   int status = WSAStartup(MAKEWORD(2, 0), &wsaData);
+-  CHECK_EQ(status, 0);
++  ABSL_CHECK_EQ(status, 0);
+ }
+
+ WindowsEventEngine::~WindowsEventEngine() {
+@@ -217,7 +217,7 @@ WindowsEventEngine::~WindowsEventEngine() {
+     if (!known_handles_.empty()) {
+       if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
+         for (auto handle : known_handles_) {
+-          LOG(ERROR) << "WindowsEventEngine:" << this
++          ABSL_LOG(ERROR) << "WindowsEventEngine:" << this
+                      << " uncleared TaskHandle at shutdown:"
+                      << HandleToString<EventEngine::TaskHandle>(handle);
+         }
+@@ -227,7 +227,7 @@ WindowsEventEngine::~WindowsEventEngine() {
+           timer_manager_.Now() + grpc_core::Duration::FromSecondsAsDouble(10);
+       while (!known_handles_.empty() && timer_manager_.Now() < deadline) {
+         if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
+-          VLOG_EVERY_N_SEC(2, 1) << "Waiting for timers. "
++          ABSL_VLOG_EVERY_N_SEC(2, 1) << "Waiting for timers. "
+                                  << known_handles_.size() << " remaining";
+         }
+         task_mu_.Unlock();
+@@ -235,13 +235,13 @@ WindowsEventEngine::~WindowsEventEngine() {
+         task_mu_.Lock();
+       }
+     }
+-    CHECK(GPR_LIKELY(known_handles_.empty()));
++    ABSL_CHECK(GPR_LIKELY(known_handles_.empty()));
+     task_mu_.Unlock();
+   }
+   iocp_.Kick();
+   iocp_worker_.WaitForShutdown();
+   iocp_.Shutdown();
+-  CHECK_EQ(WSACleanup(), 0);
++  ABSL_CHECK_EQ(WSACleanup(), 0);
+   timer_manager_.Shutdown();
+   thread_pool_->Quiesce();
+ }
+@@ -511,7 +511,7 @@ EventEngine::ConnectionHandle WindowsEventEngine::Connect(
+     erased_handles =
+         known_connection_handles_.erase(connection_state->connection_handle());
+   }
+-  CHECK_EQ(erased_handles, 1) << "Did not find connection handle "
++  ABSL_CHECK_EQ(erased_handles, 1) << "Did not find connection handle "
+                               << connection_state->connection_handle()
+                               << " after a synchronous connection failure. "
+                                  "This should not be possible.";
+diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc
+index f7414f48f693b..36d0241421494 100644
+--- a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc
++++ b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc
+@@ -15,8 +15,8 @@
+
+ #ifdef GPR_WINDOWS
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/event_engine/tcp_socket_utils.h"
+@@ -46,7 +46,7 @@ WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::
+
+ void WindowsEventEngineListener::SinglePortSocketListener::
+     OnAcceptCallbackWrapper::Run() {
+-  CHECK_NE(io_state_, nullptr);
++  ABSL_CHECK_NE(io_state_, nullptr);
+   grpc_core::ReleasableMutexLock lock(&io_state_->mu);
+   if (io_state_->listener_socket->IsShutdown()) {
+     GRPC_TRACE_LOG(event_engine, INFO)
+@@ -122,7 +122,7 @@ WindowsEventEngineListener::SinglePortSocketListener::Create(
+   }
+   auto result = SinglePortSocketListener::PrepareListenerSocket(sock, addr);
+   GRPC_RETURN_IF_ERROR(result.status());
+-  CHECK_GE(result->port, 0);
++  ABSL_CHECK_GE(result->port, 0);
+   // Using `new` to access non-public constructor
+   return absl::WrapUnique(new SinglePortSocketListener(
+       listener, AcceptEx, /*win_socket=*/listener->iocp_->Watch(sock),
+@@ -188,13 +188,13 @@ void WindowsEventEngineListener::SinglePortSocketListener::
+           ABSL_EXCLUSIVE_LOCKS_REQUIRED(io_state_->mu) {
+             if (do_close_socket) closesocket(io_state_->accept_socket);
+             io_state_->accept_socket = INVALID_SOCKET;
+-            CHECK(GRPC_LOG_IF_ERROR("SinglePortSocketListener::Start",
++            ABSL_CHECK(GRPC_LOG_IF_ERROR("SinglePortSocketListener::Start",
+                                     StartLocked()));
+           };
+   const auto& overlapped_result =
+       io_state_->listener_socket->read_info()->result();
+   if (overlapped_result.wsa_error != 0) {
+-    LOG(ERROR) << GRPC_WSA_ERROR(overlapped_result.wsa_error,
++    ABSL_LOG(ERROR) << GRPC_WSA_ERROR(overlapped_result.wsa_error,
+                                  "Skipping on_accept due to error");
+     return close_socket_and_restart();
+   }
+@@ -204,7 +204,7 @@ void WindowsEventEngineListener::SinglePortSocketListener::
+                  reinterpret_cast<char*>(&tmp_listener_socket),
+                  sizeof(tmp_listener_socket));
+   if (err != 0) {
+-    LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "setsockopt");
++    ABSL_LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "setsockopt");
+     return close_socket_and_restart();
+   }
+   EventEngine::ResolvedAddress peer_address;
+@@ -213,7 +213,7 @@ void WindowsEventEngineListener::SinglePortSocketListener::
+                     const_cast<sockaddr*>(peer_address.address()),
+                     &peer_name_len);
+   if (err != 0) {
+-    LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "getpeername");
++    ABSL_LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "getpeername");
+     return close_socket_and_restart();
+   }
+   peer_address =
+@@ -222,7 +222,7 @@ void WindowsEventEngineListener::SinglePortSocketListener::
+   std::string peer_name = "unknown";
+   if (!addr_uri.ok()) {
+     // TODO(hork): test an early exit/restart here with end2end tests
+-    LOG(ERROR) << "invalid peer name: " << addr_uri.status();
++    ABSL_LOG(ERROR) << "invalid peer name: " << addr_uri.status();
+   } else {
+     peer_name = *addr_uri;
+   }
+@@ -256,7 +256,7 @@ absl::StatusOr<WindowsEventEngineListener::SinglePortSocketListener::
+ WindowsEventEngineListener::SinglePortSocketListener::PrepareListenerSocket(
+     SOCKET sock, const EventEngine::ResolvedAddress& addr) {
+   auto fail = [&](absl::Status error) -> absl::Status {
+-    CHECK(!error.ok());
++    ABSL_CHECK(!error.ok());
+     error = grpc_error_set_int(
+         GRPC_ERROR_CREATE_REFERENCING("Failed to prepare server socket", &error,
+                                       1),
+@@ -360,7 +360,7 @@ absl::StatusOr<int> WindowsEventEngineListener::Bind(
+ }
+
+ absl::Status WindowsEventEngineListener::Start() {
+-  CHECK(!started_.exchange(true));
++  ABSL_CHECK(!started_.exchange(true));
+   grpc_core::MutexLock lock(&port_listeners_mu_);
+   for (auto& port_listener : port_listeners_) {
+     GRPC_RETURN_IF_ERROR(port_listener->Start());
+@@ -387,7 +387,7 @@ WindowsEventEngineListener::AddSinglePortSocketListener(
+   grpc_core::MutexLock lock(&port_listeners_mu_);
+   port_listeners_.emplace_back(std::move(*single_port_listener));
+   if (started_.load()) {
+-    LOG(ERROR) << "WindowsEventEngineListener::" << this
++    ABSL_LOG(ERROR) << "WindowsEventEngineListener::" << this
+                << " Bind was called concurrently while the Listener was "
+                   "starting. This is invalid usage, all ports must be bound "
+                   "before the Listener is started.";
+diff --git a/third_party/grpc/source/src/core/lib/experiments/config.cc b/third_party/grpc/source/src/core/lib/experiments/config.cc
+index 0488c5a5da11b..cab0a3556d9d2 100644
+--- a/third_party/grpc/source/src/core/lib/experiments/config.cc
++++ b/third_party/grpc/source/src/core/lib/experiments/config.cc
+@@ -25,8 +25,8 @@
+ #include <vector>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_join.h"
+ #include "absl/strings/str_split.h"
+ #include "absl/strings/string_view.h"
+@@ -134,7 +134,7 @@ GPR_ATTRIBUTE_NOINLINE Experiments LoadExperimentsFromConfigVariableInner() {
+     // If not found log an error, but don't take any other action.
+     // Allows us an easy path to disabling experiments.
+     if (!found) {
+-      LOG(ERROR) << "Unknown experiment: " << experiment;
++      ABSL_LOG(ERROR) << "Unknown experiment: " << experiment;
+     }
+   }
+   for (size_t i = 0; i < kNumExperiments; i++) {
+@@ -143,7 +143,7 @@ GPR_ATTRIBUTE_NOINLINE Experiments LoadExperimentsFromConfigVariableInner() {
+          j++) {
+       // Require that we can check dependent requirements with a linear sweep
+       // (implies the experiments generator must DAG sort the experiments)
+-      CHECK(g_experiment_metadata[i].required_experiments[j] < i);
++      ABSL_CHECK(g_experiment_metadata[i].required_experiments[j] < i);
+       if (!experiments
+                .enabled[g_experiment_metadata[i].required_experiments[j]]) {
+         experiments.enabled[i] = false;
+@@ -217,7 +217,7 @@ bool IsTestExperimentEnabled(size_t experiment_id) {
+   return (*g_test_experiments)[experiment_id];
+ }
+
+-#define GRPC_EXPERIMENT_LOG VLOG(2)
++#define GRPC_EXPERIMENT_LOG ABSL_VLOG(2)
+
+ void PrintExperimentsList() {
+   std::map<std::string, std::string> experiment_status;
+@@ -272,18 +272,18 @@ void PrintExperimentsList() {
+ }
+
+ void ForceEnableExperiment(absl::string_view experiment, bool enable) {
+-  CHECK(Loaded()->load(std::memory_order_relaxed) == false);
++  ABSL_CHECK(Loaded()->load(std::memory_order_relaxed) == false);
+   for (size_t i = 0; i < kNumExperiments; i++) {
+     if (g_experiment_metadata[i].name != experiment) continue;
+     if (ForcedExperiments()[i].forced) {
+-      CHECK(ForcedExperiments()[i].value == enable);
++      ABSL_CHECK(ForcedExperiments()[i].value == enable);
+     } else {
+       ForcedExperiments()[i].forced = true;
+       ForcedExperiments()[i].value = enable;
+     }
+     return;
+   }
+-  LOG(INFO) << "gRPC EXPERIMENT " << experiment << " not found to force "
++  ABSL_LOG(INFO) << "gRPC EXPERIMENT " << experiment << " not found to force "
+             << (enable ? "enable" : "disable");
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc b/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc
+index 73d225a99b081..b9e8c8070b34e 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <grpc/support/time.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/port.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/sync.h"
+@@ -42,7 +42,7 @@ void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {
+
+ void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,
+                                absl::Status /*shutdown_err*/) {
+-  VLOG(2) << "Timestamps callback has not been registered";
++  ABSL_VLOG(2) << "Timestamps callback has not been registered";
+ }
+
+ // The saved callback function that will be invoked when we get all the
+@@ -321,7 +321,7 @@ void grpc_tcp_set_write_timestamps_callback(
+   // Can't comment out the name because some compilers and formatters don't
+   // like the sequence */* , which would arise from */*fn*/.
+   (void)fn;
+-  VLOG(2) << "Timestamps callback is not enabled for this platform";
++  ABSL_VLOG(2) << "Timestamps callback is not enabled for this platform";
+ }
+ }  // namespace grpc_core
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc
+index 8459f415157db..f527ec3f286bb 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc
+@@ -21,8 +21,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <inttypes.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/telemetry/stats.h"
+ #include "src/core/telemetry/stats_data.h"
+ #include "src/core/util/crash.h"
+@@ -84,7 +84,7 @@ void CallCombiner::TsanClosure(void* arg, grpc_error_handle error) {
+   if (lock != nullptr) {
+     TSAN_ANNOTATE_RWLOCK_RELEASED(&lock->taken, true);
+     bool prev = true;
+-    CHECK(lock->taken.compare_exchange_strong(prev, false));
++    ABSL_CHECK(lock->taken.compare_exchange_strong(prev, false));
+   }
+ }
+ #endif
+@@ -141,7 +141,7 @@ void CallCombiner::Stop(DEBUG_ARGS const char* reason) {
+       static_cast<size_t>(gpr_atm_full_fetch_add(&size_, (gpr_atm)-1));
+   GRPC_TRACE_LOG(call_combiner, INFO)
+       << "  size: " << prev_size << " -> " << prev_size - 1;
+-  CHECK_GE(prev_size, 1u);
++  ABSL_CHECK_GE(prev_size, 1u);
+   if (prev_size > 1) {
+     while (true) {
+       GRPC_TRACE_LOG(call_combiner, INFO) << "  checking queue";
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h
+index 9bb8c0ed6fcb9..f661195eb0d12 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h
++++ b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h
+@@ -24,7 +24,7 @@
+ #include <stddef.h>
+
+ #include "absl/container/inlined_vector.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/closure.h"
+ #include "src/core/lib/iomgr/dynamic_annotations.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc b/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc
+index 0b64b87f3ddf2..22d1b33ac9568 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc
+@@ -27,7 +27,7 @@
+ #include <grpc/support/atm.h>
+ #include <grpc/support/sync.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #import "src/core/lib/iomgr/cfstream_handle.h"
+ #include "src/core/lib/iomgr/closure.h"
+@@ -174,7 +174,7 @@ void CFStreamHandle::Shutdown(grpc_error_handle error) {
+ void CFStreamHandle::Ref(const char* file, int line, const char* reason) {
+   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&refcount_.count);
+-    VLOG(2).AtLocation(file, line) << "CFStream Handle ref " << this << " : "
++    ABSL_VLOG(2).AtLocation(file, line) << "CFStream Handle ref " << this << " : "
+                                    << reason << " " << val << " -> " << val + 1;
+   }
+   gpr_ref(&refcount_);
+@@ -183,7 +183,7 @@ void CFStreamHandle::Ref(const char* file, int line, const char* reason) {
+ void CFStreamHandle::Unref(const char* file, int line, const char* reason) {
+   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&refcount_.count);
+-    VLOG(2).AtLocation(file, line) << "CFStream Handle unref " << this << " : "
++    ABSL_VLOG(2).AtLocation(file, line) << "CFStream Handle unref " << this << " : "
+                                    << reason << " " << val << " -> " << val - 1;
+   }
+   if (gpr_unref(&refcount_)) {
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/closure.h b/third_party/grpc/source/src/core/lib/iomgr/closure.h
+index e8f7a0b7812b5..a058c636007d4 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/closure.h
++++ b/third_party/grpc/source/src/core/lib/iomgr/closure.h
+@@ -24,8 +24,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <stdbool.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/error.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/debug_location.h"
+@@ -293,7 +293,7 @@ class Closure {
+         << "running closure " << closure << ": created ["
+         << closure->file_created << ":" << closure->line_created << "]: run ["
+         << location.file() << ":" << location.line() << "]";
+-    CHECK_NE(closure->cb, nullptr);
++    ABSL_CHECK_NE(closure->cb, nullptr);
+ #endif
+     closure->cb(closure->cb_arg, error);
+ #ifndef NDEBUG
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/combiner.cc b/third_party/grpc/source/src/core/lib/iomgr/combiner.cc
+index 81f33c70a2b94..b7cc7f9ca0bc3 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/combiner.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/combiner.cc
+@@ -24,8 +24,8 @@
+ #include <inttypes.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/experiments/experiments.h"
+ #include "src/core/lib/iomgr/executor.h"
+ #include "src/core/lib/iomgr/iomgr_internal.h"
+@@ -55,7 +55,7 @@ grpc_core::Combiner* grpc_combiner_create(
+
+ static void really_destroy(grpc_core::Combiner* lock) {
+   GRPC_TRACE_LOG(combiner, INFO) << "C:" << lock << " really_destroy";
+-  CHECK_EQ(gpr_atm_no_barrier_load(&lock->state), 0);
++  ABSL_CHECK_EQ(gpr_atm_no_barrier_load(&lock->state), 0);
+   delete lock;
+ }
+
+@@ -137,7 +137,7 @@ static void combiner_exec(grpc_core::Combiner* lock, grpc_closure* cl,
+       gpr_atm_no_barrier_store(&lock->initiating_exec_ctx_or_null, 0);
+     }
+   }
+-  CHECK(last & STATE_UNORPHANED);  // ensure lock has not been destroyed
++  ABSL_CHECK(last & STATE_UNORPHANED);  // ensure lock has not been destroyed
+   assert(cl->cb);
+   cl->error_data.error = grpc_core::internal::StatusAllocHeapPtr(error);
+   lock->queue.Push(cl->next_data.mpscq_node.get());
+@@ -217,7 +217,7 @@ bool grpc_combiner_continue_exec_ctx() {
+     cl->cb(cl->cb_arg, std::move(cl_err));
+   } else {
+     grpc_closure* c = lock->final_list.head;
+-    CHECK_NE(c, nullptr);
++    ABSL_CHECK_NE(c, nullptr);
+     grpc_closure_list_init(&lock->final_list);
+     int loops = 0;
+     while (c != nullptr) {
+@@ -280,7 +280,7 @@ static void enqueue_finally(void* closure, grpc_error_handle error);
+ static void combiner_finally_exec(grpc_core::Combiner* lock,
+                                   grpc_closure* closure,
+                                   grpc_error_handle error) {
+-  CHECK_NE(lock, nullptr);
++  ABSL_CHECK_NE(lock, nullptr);
+   GRPC_TRACE_LOG(combiner, INFO)
+       << "C:" << lock << " grpc_combiner_execute_finally c=" << closure
+       << "; ac=" << grpc_core::ExecCtx::Get()->combiner_data()->active_combiner;
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc b/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc
+index 3177567e94829..244c06ea2bbfe 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc
+@@ -27,8 +27,8 @@
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/string_util.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/iomgr/cfstream_handle.h"
+ #include "src/core/lib/iomgr/closure.h"
+@@ -74,7 +74,7 @@ static void CFStreamUnref(CFStreamEndpoint* ep, const char* reason,
+                           const char* file, int line) {
+   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&ep->refcount.count);
+-    VLOG(2).AtLocation(file, line) << "CFStream endpoint unref " << ep << " : "
++    ABSL_VLOG(2).AtLocation(file, line) << "CFStream endpoint unref " << ep << " : "
+                                    << reason << " " << val << " -> " << val - 1;
+   }
+   if (gpr_unref(&ep->refcount)) {
+@@ -85,7 +85,7 @@ static void CFStreamRef(CFStreamEndpoint* ep, const char* reason,
+                         const char* file, int line) {
+   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&ep->refcount.count);
+-    VLOG(2).AtLocation(file, line) << "CFStream endpoint ref " << ep << " : "
++    ABSL_VLOG(2).AtLocation(file, line) << "CFStream endpoint ref " << ep << " : "
+                                    << reason << " " << val << " -> " << val + 1;
+   }
+   gpr_ref(&ep->refcount);
+@@ -108,15 +108,15 @@ static grpc_error_handle CFStreamAnnotateError(grpc_error_handle src_error) {
+
+ static void CallReadCb(CFStreamEndpoint* ep, grpc_error_handle error) {
+   if (GRPC_TRACE_FLAG_ENABLED(tcp) && ABSL_VLOG_IS_ON(2)) {
+-    VLOG(2) << "CFStream endpoint:" << ep << " call_read_cb " << ep->read_cb
++    ABSL_VLOG(2) << "CFStream endpoint:" << ep << " call_read_cb " << ep->read_cb
+             << " " << ep->read_cb->cb << ":" << ep->read_cb->cb_arg;
+     size_t i;
+-    VLOG(2) << "read: error=" << grpc_core::StatusToString(error);
++    ABSL_VLOG(2) << "read: error=" << grpc_core::StatusToString(error);
+
+     for (i = 0; i < ep->read_slices->count; i++) {
+       char* dump = grpc_dump_slice(ep->read_slices->slices[i],
+                                    GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-      VLOG(2) << "READ " << ep << " (peer=" << ep->peer_string << "): " << dump;
++      ABSL_VLOG(2) << "READ " << ep << " (peer=" << ep->peer_string << "): " << dump;
+       gpr_free(dump);
+     }
+   }
+@@ -139,7 +139,7 @@ static void CallWriteCb(CFStreamEndpoint* ep, grpc_error_handle error) {
+
+ static void ReadAction(void* arg, grpc_error_handle error) {
+   CFStreamEndpoint* ep = static_cast<CFStreamEndpoint*>(arg);
+-  CHECK_NE(ep->read_cb, nullptr);
++  ABSL_CHECK_NE(ep->read_cb, nullptr);
+   if (!error.ok()) {
+     grpc_slice_buffer_reset_and_unref(ep->read_slices);
+     CallReadCb(ep, error);
+@@ -147,7 +147,7 @@ static void ReadAction(void* arg, grpc_error_handle error) {
+     return;
+   }
+
+-  CHECK_EQ(ep->read_slices->count, 1);
++  ABSL_CHECK_EQ(ep->read_slices->count, 1);
+   grpc_slice slice = ep->read_slices->slices[0];
+   size_t len = GRPC_SLICE_LENGTH(slice);
+   CFIndex read_size =
+@@ -179,7 +179,7 @@ static void ReadAction(void* arg, grpc_error_handle error) {
+
+ static void WriteAction(void* arg, grpc_error_handle error) {
+   CFStreamEndpoint* ep = static_cast<CFStreamEndpoint*>(arg);
+-  CHECK_NE(ep->write_cb, nullptr);
++  ABSL_CHECK_NE(ep->write_cb, nullptr);
+   if (!error.ok()) {
+     grpc_slice_buffer_reset_and_unref(ep->write_slices);
+     CallWriteCb(ep, error);
+@@ -217,7 +217,7 @@ static void WriteAction(void* arg, grpc_error_handle error) {
+     if (GRPC_TRACE_FLAG_ENABLED(tcp) && ABSL_VLOG_IS_ON(2)) {
+       grpc_slice trace_slice = grpc_slice_sub(slice, 0, write_size);
+       char* dump = grpc_dump_slice(trace_slice, GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-      VLOG(2) << "WRITE " << ep << " (peer=" << ep->peer_string
++      ABSL_VLOG(2) << "WRITE " << ep << " (peer=" << ep->peer_string
+               << "): " << dump;
+       gpr_free(dump);
+       grpc_core::CSliceUnref(trace_slice);
+@@ -233,7 +233,7 @@ static void CFStreamRead(grpc_endpoint* ep, grpc_slice_buffer* slices,
+   GRPC_TRACE_VLOG(tcp, 2) << "CFStream endpoint:" << ep_impl << " read ("
+                           << slices << ", " << cb
+                           << ") length:" << slices->length;
+-  CHECK_EQ(ep_impl->read_cb, nullptr);
++  ABSL_CHECK_EQ(ep_impl->read_cb, nullptr);
+   ep_impl->read_cb = cb;
+   ep_impl->read_slices = slices;
+   grpc_slice_buffer_reset_and_unref(slices);
+@@ -250,7 +250,7 @@ static void CFStreamWrite(grpc_endpoint* ep, grpc_slice_buffer* slices,
+   GRPC_TRACE_VLOG(tcp, 2) << "CFStream endpoint:" << ep_impl << " write ("
+                           << slices << ", " << cb
+                           << ") length:" << slices->length;
+-  CHECK_EQ(ep_impl->write_cb, nullptr);
++  ABSL_CHECK_EQ(ep_impl->write_cb, nullptr);
+   ep_impl->write_cb = cb;
+   ep_impl->write_slices = slices;
+   EP_REF(ep_impl, "write");
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc
+index 04c574560c0f6..a0ce910c2e4f4 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc
+@@ -31,7 +31,7 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/event_engine/channel_args_endpoint_config.h"
+ #include "src/core/lib/iomgr/endpoint_pair.h"
+@@ -46,11 +46,11 @@ static void create_sockets(int sv[2]) {
+   int flags;
+   grpc_create_socketpair_if_unix(sv);
+   flags = fcntl(sv[0], F_GETFL, 0);
+-  CHECK_EQ(fcntl(sv[0], F_SETFL, flags | O_NONBLOCK), 0);
++  ABSL_CHECK_EQ(fcntl(sv[0], F_SETFL, flags | O_NONBLOCK), 0);
+   flags = fcntl(sv[1], F_GETFL, 0);
+-  CHECK_EQ(fcntl(sv[1], F_SETFL, flags | O_NONBLOCK), 0);
+-  CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[0]) == absl::OkStatus());
+-  CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[1]) == absl::OkStatus());
++  ABSL_CHECK_EQ(fcntl(sv[1], F_SETFL, flags | O_NONBLOCK), 0);
++  ABSL_CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[0]) == absl::OkStatus());
++  ABSL_CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[1]) == absl::OkStatus());
+ }
+
+ grpc_endpoint_pair grpc_iomgr_create_endpoint_pair(
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc
+index f30f691323d39..bab7b2b0095ee 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc
+@@ -25,8 +25,8 @@
+ #include <fcntl.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/iomgr/endpoint_pair.h"
+ #include "src/core/lib/iomgr/sockaddr.h"
+@@ -43,34 +43,34 @@ static void create_sockets(SOCKET sv[2]) {
+
+   lst_sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0,
+                        grpc_get_default_wsa_socket_flags());
+-  CHECK(lst_sock != INVALID_SOCKET);
++  ABSL_CHECK(lst_sock != INVALID_SOCKET);
+
+   memset(&addr, 0, sizeof(addr));
+   addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+   addr.sin_family = AF_INET;
+-  CHECK(bind(lst_sock, (grpc_sockaddr*)&addr, sizeof(addr)) != SOCKET_ERROR);
+-  CHECK(listen(lst_sock, SOMAXCONN) != SOCKET_ERROR);
+-  CHECK(getsockname(lst_sock, (grpc_sockaddr*)&addr, &addr_len) !=
++  ABSL_CHECK(bind(lst_sock, (grpc_sockaddr*)&addr, sizeof(addr)) != SOCKET_ERROR);
++  ABSL_CHECK(listen(lst_sock, SOMAXCONN) != SOCKET_ERROR);
++  ABSL_CHECK(getsockname(lst_sock, (grpc_sockaddr*)&addr, &addr_len) !=
+         SOCKET_ERROR);
+
+   cli_sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0,
+                        grpc_get_default_wsa_socket_flags());
+-  CHECK(cli_sock != INVALID_SOCKET);
++  ABSL_CHECK(cli_sock != INVALID_SOCKET);
+
+-  CHECK(WSAConnect(cli_sock, (grpc_sockaddr*)&addr, addr_len, NULL, NULL, NULL,
++  ABSL_CHECK(WSAConnect(cli_sock, (grpc_sockaddr*)&addr, addr_len, NULL, NULL, NULL,
+                    NULL) == 0);
+   svr_sock = accept(lst_sock, (grpc_sockaddr*)&addr, &addr_len);
+-  CHECK(svr_sock != INVALID_SOCKET);
++  ABSL_CHECK(svr_sock != INVALID_SOCKET);
+
+   closesocket(lst_sock);
+   grpc_error_handle error = grpc_tcp_prepare_socket(cli_sock);
+   if (!error.ok()) {
+-    VLOG(2) << "Prepare cli_sock failed with error: "
++    ABSL_VLOG(2) << "Prepare cli_sock failed with error: "
+             << grpc_core::StatusToString(error);
+   }
+   error = grpc_tcp_prepare_socket(svr_sock);
+   if (!error.ok()) {
+-    VLOG(2) << "Prepare svr_sock failed with error: "
++    ABSL_VLOG(2) << "Prepare svr_sock failed with error: "
+             << grpc_core::StatusToString(error);
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/error.cc b/third_party/grpc/source/src/core/lib/iomgr/error.cc
+index f163947fb3a56..8d95690e0780b 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/error.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/error.cc
+@@ -24,8 +24,8 @@
+ #include <inttypes.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/util/crash.h"
+@@ -218,8 +218,8 @@ grpc_error_handle grpc_error_add_child(grpc_error_handle src,
+
+ bool grpc_log_error(const char* what, grpc_error_handle error, const char* file,
+                     int line) {
+-  DCHECK(!error.ok());
+-  LOG(ERROR).AtLocation(file, line)
++  ABSL_DCHECK(!error.ok());
++  ABSL_LOG(ERROR).AtLocation(file, line)
+       << what << ": " << grpc_core::StatusToString(error);
+   return false;
+ }
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/error.h b/third_party/grpc/source/src/core/lib/iomgr/error.h
+index 0171c5048113f..643ec58bc869b 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/error.h
++++ b/third_party/grpc/source/src/core/lib/iomgr/error.h
+@@ -26,7 +26,7 @@
+ #include <inttypes.h>
+ #include <stdbool.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/slice/slice_internal.h"
+@@ -72,7 +72,7 @@ absl::Status grpc_os_error(const grpc_core::DebugLocation& location, int err,
+                            const char* call_name);
+
+ inline absl::Status grpc_assert_never_ok(absl::Status error) {
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   return error;
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc b/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc
+index bc7c3b4b5564e..f441b451f3b80 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc
+@@ -40,8 +40,8 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/str_join.h"
+@@ -97,14 +97,14 @@ static int epoll_create_and_cloexec() {
+ #ifdef GRPC_LINUX_EPOLL_CREATE1
+   int fd = epoll_create1(EPOLL_CLOEXEC);
+   if (fd < 0) {
+-    LOG(ERROR) << "epoll_create1 unavailable";
++    ABSL_LOG(ERROR) << "epoll_create1 unavailable";
+   }
+ #else
+   int fd = epoll_create(MAX_EPOLL_EVENTS);
+   if (fd < 0) {
+-    LOG(ERROR) << "epoll_create unavailable";
++    ABSL_LOG(ERROR) << "epoll_create unavailable";
+   } else if (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {
+-    LOG(ERROR) << "fcntl following epoll_create failed";
++    ABSL_LOG(ERROR) << "fcntl following epoll_create failed";
+     return -1;
+   }
+ #endif
+@@ -372,7 +372,7 @@ static grpc_fd* fd_create(int fd, const char* name, bool track_err) {
+   ev.data.ptr = reinterpret_cast<void*>(reinterpret_cast<intptr_t>(new_fd) |
+                                         (track_err ? 1 : 0));
+   if (epoll_ctl(g_epoll_set.epfd, EPOLL_CTL_ADD, fd, &ev) != 0) {
+-    LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
++    ABSL_LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
+   }
+
+   return new_fd;
+@@ -395,7 +395,7 @@ static void fd_shutdown_internal(grpc_fd* fd, grpc_error_handle why,
+       epoll_event phony_event;
+       if (epoll_ctl(g_epoll_set.epfd, EPOLL_CTL_DEL, fd->fd, &phony_event) !=
+           0) {
+-        LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
++        ABSL_LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
+       }
+     }
+     fd->write_closure->SetShutdown(why);
+@@ -630,8 +630,8 @@ static void pollset_maybe_finish_shutdown(grpc_pollset* pollset) {
+ }
+
+ static void pollset_shutdown(grpc_pollset* pollset, grpc_closure* closure) {
+-  CHECK_EQ(pollset->shutdown_closure, nullptr);
+-  CHECK(!pollset->shutting_down);
++  ABSL_CHECK_EQ(pollset->shutdown_closure, nullptr);
++  ABSL_CHECK(!pollset->shutting_down);
+   pollset->shutdown_closure = closure;
+   pollset->shutting_down = true;
+   GRPC_LOG_IF_ERROR("pollset_shutdown", pollset_kick_all(pollset));
+@@ -799,7 +799,7 @@ static bool begin_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
+       }
+     }
+     if (is_reassigning) {
+-      CHECK(pollset->reassigning_neighborhood);
++      ABSL_CHECK(pollset->reassigning_neighborhood);
+       pollset->reassigning_neighborhood = false;
+     }
+     gpr_mu_unlock(&neighborhood->mu);
+@@ -808,7 +808,7 @@ static bool begin_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
+   worker_insert(pollset, worker);
+   pollset->begin_refs--;
+   if (worker->state == UNKICKED && !pollset->kicked_without_poller) {
+-    CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
++    ABSL_CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
+     worker->initialized_cv = true;
+     gpr_cv_init(&worker->cv);
+     while (worker->state == UNKICKED && !pollset->shutting_down) {
+@@ -860,7 +860,7 @@ static bool check_neighborhood_for_available_poller(
+       break;
+     }
+     gpr_mu_lock(&inspect->mu);
+-    CHECK(!inspect->seen_inactive);
++    ABSL_CHECK(!inspect->seen_inactive);
+     grpc_pollset_worker* inspect_worker = inspect->root_worker;
+     if (inspect_worker != nullptr) {
+       do {
+@@ -922,7 +922,7 @@ static void end_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
+     if (worker->next != worker && worker->next->state == UNKICKED) {
+       GRPC_TRACE_LOG(polling, INFO)
+           << " .. choose next poller to be peer " << worker;
+-      CHECK(worker->next->initialized_cv);
++      ABSL_CHECK(worker->next->initialized_cv);
+       gpr_atm_no_barrier_store(&g_active_poller, (gpr_atm)worker->next);
+       SET_KICK_STATE(worker->next, DESIGNATED_POLLER);
+       gpr_cv_signal(&worker->next->cv);
+@@ -974,7 +974,7 @@ static void end_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
+   if (EMPTIED == worker_remove(pollset, worker)) {
+     pollset_maybe_finish_shutdown(pollset);
+   }
+-  CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
++  ABSL_CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
+ }
+
+ // pollset->po.mu lock must be held by the caller before calling this.
+@@ -995,8 +995,8 @@ static grpc_error_handle pollset_work(grpc_pollset* ps,
+   if (begin_worker(ps, &worker, worker_hdl, deadline)) {
+     g_current_thread_pollset = ps;
+     g_current_thread_worker = &worker;
+-    CHECK(!ps->shutting_down);
+-    CHECK(!ps->seen_inactive);
++    ABSL_CHECK(!ps->shutting_down);
++    ABSL_CHECK(!ps->seen_inactive);
+
+     gpr_mu_unlock(&ps->mu);  // unlock
+     // This is the designated polling thread at this point and should ideally do
+@@ -1051,7 +1051,7 @@ static grpc_error_handle pollset_kick(grpc_pollset* pollset,
+       log.push_back(absl::StrFormat(" worker_kick_state=%s",
+                                     kick_state_string(specific_worker->state)));
+     }
+-    VLOG(2) << absl::StrJoin(log, "");
++    ABSL_VLOG(2) << absl::StrJoin(log, "");
+   }
+
+   if (specific_worker == nullptr) {
+@@ -1082,7 +1082,7 @@ static grpc_error_handle pollset_kick(grpc_pollset* pollset,
+         goto done;
+       } else if (next_worker->state == UNKICKED) {
+         GRPC_TRACE_LOG(polling, INFO) << " .. kicked " << next_worker;
+-        CHECK(next_worker->initialized_cv);
++        ABSL_CHECK(next_worker->initialized_cv);
+         SET_KICK_STATE(next_worker, KICKED);
+         gpr_cv_signal(&next_worker->cv);
+         goto done;
+@@ -1105,7 +1105,7 @@ static grpc_error_handle pollset_kick(grpc_pollset* pollset,
+           goto done;
+         }
+       } else {
+-        CHECK(next_worker->state == KICKED);
++        ABSL_CHECK(next_worker->state == KICKED);
+         SET_KICK_STATE(next_worker, KICKED);
+         goto done;
+       }
+@@ -1234,7 +1234,7 @@ const grpc_event_engine_vtable grpc_ev_epoll1_posix = {
+     /* check_engine_available = */
+     [](bool) { return init_epoll1_linux(); },
+     /* init_engine = */
+-    []() { CHECK(init_epoll1_linux()); },
++    []() { ABSL_CHECK(init_epoll1_linux()); },
+     shutdown_background_closure,
+     /* shutdown_engine = */
+     []() { shutdown_engine(); },
+@@ -1265,7 +1265,7 @@ static void reset_event_manager_on_fork() {
+ static bool init_epoll1_linux() {
+   if (!g_is_shutdown) return true;
+   if (!grpc_has_wakeup_fd()) {
+-    LOG(ERROR) << "Skipping epoll1 because of no wakeup fd.";
++    ABSL_LOG(ERROR) << "Skipping epoll1 because of no wakeup fd.";
+     return false;
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc
+index 32d42c36e27d4..abc91578aac53 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc
+@@ -34,8 +34,8 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/iomgr/block_annotate.h"
+@@ -348,7 +348,7 @@ static void ref_by(grpc_fd* fd, int n, const char* reason, const char* file,
+   } while (0)
+ static void ref_by(grpc_fd* fd, int n) {
+ #endif
+-  CHECK_GT(gpr_atm_no_barrier_fetch_add(&fd->refst, n), 0);
++  ABSL_CHECK_GT(gpr_atm_no_barrier_fetch_add(&fd->refst, n), 0);
+ }
+
+ #ifndef NDEBUG
+@@ -372,14 +372,14 @@ static void unref_by(grpc_fd* fd, int n) {
+     fd->shutdown_error.~Status();
+     gpr_free(fd);
+   } else {
+-    CHECK(old > n);
++    ABSL_CHECK(old > n);
+   }
+ }
+
+ static grpc_fd* fd_create(int fd, const char* name, bool track_err) {
+   // Avoid unused-parameter warning for debug-only parameter
+   (void)track_err;
+-  DCHECK(track_err == false);
++  ABSL_DCHECK(track_err == false);
+   grpc_fd* r = static_cast<grpc_fd*>(gpr_malloc(sizeof(*r)));
+   gpr_mu_init(&r->mu);
+   gpr_atm_rel_store(&r->refst, 1);
+@@ -409,7 +409,7 @@ static bool fd_is_orphaned(grpc_fd* fd) {
+
+ static grpc_error_handle pollset_kick_locked(grpc_fd_watcher* watcher) {
+   gpr_mu_lock(&watcher->pollset->mu);
+-  CHECK(watcher->worker);
++  ABSL_CHECK(watcher->worker);
+   grpc_error_handle err =
+       pollset_kick_ext(watcher->pollset, watcher->worker,
+                        GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP);
+@@ -783,7 +783,7 @@ static grpc_error_handle pollset_kick_ext(grpc_pollset* p,
+   // pollset->mu already held
+   if (specific_worker != nullptr) {
+     if (specific_worker == GRPC_POLLSET_KICK_BROADCAST) {
+-      CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
++      ABSL_CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
+       for (specific_worker = p->root_worker.next;
+            specific_worker != &p->root_worker;
+            specific_worker = specific_worker->next) {
+@@ -807,7 +807,7 @@ static grpc_error_handle pollset_kick_ext(grpc_pollset* p,
+                         grpc_wakeup_fd_wakeup(&specific_worker->wakeup_fd->fd));
+     }
+   } else if (g_current_thread_poller != p) {
+-    CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
++    ABSL_CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
+     specific_worker = pop_front_worker(p);
+     if (specific_worker != nullptr) {
+       if (g_current_thread_worker == specific_worker) {
+@@ -860,7 +860,7 @@ static void pollset_init(grpc_pollset* pollset, gpr_mu** mu) {
+ }
+
+ static void pollset_destroy(grpc_pollset* pollset) {
+-  CHECK(!pollset_has_workers(pollset));
++  ABSL_CHECK(!pollset_has_workers(pollset));
+   while (pollset->local_wakeup_cache) {
+     grpc_cached_wakeup_fd* next = pollset->local_wakeup_cache->next;
+     fork_fd_list_remove_wakeup_fd(pollset->local_wakeup_cache);
+@@ -1138,7 +1138,7 @@ static grpc_error_handle pollset_work(grpc_pollset* pollset,
+ }
+
+ static void pollset_shutdown(grpc_pollset* pollset, grpc_closure* closure) {
+-  CHECK(!pollset->shutting_down);
++  ABSL_CHECK(!pollset->shutting_down);
+   pollset->shutting_down = 1;
+   pollset->shutdown_done = closure;
+   (void)pollset_kick(pollset, GRPC_POLLSET_KICK_BROADCAST);
+@@ -1397,7 +1397,7 @@ const grpc_event_engine_vtable grpc_ev_poll_posix = {
+     // check_engine_available =
+     [](bool) {
+       if (!grpc_has_wakeup_fd()) {
+-        LOG(ERROR) << "Skipping poll because of no wakeup fd.";
++        ABSL_LOG(ERROR) << "Skipping poll because of no wakeup fd.";
+         return false;
+       }
+       if (!GRPC_LOG_IF_ERROR("pollset_global_init", pollset_global_init())) {
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc
+index 532a611d3304d..2f6b844a93bf7 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc
+@@ -27,7 +27,7 @@
+ #include <grpc/support/string_util.h>
+ #include <string.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/str_split.h"
+ #include "src/core/config/config_vars.h"
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc
+index 921401941cf88..98ffb0fdc6205 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc
+@@ -17,7 +17,7 @@
+ #include <grpc/support/port_platform.h>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/lib/iomgr/closure.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc
+index c368db6fa0f3e..d87960ccf9026 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc
+@@ -25,8 +25,8 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+@@ -118,12 +118,12 @@ class EventEngineEndpointWrapper {
+     read_buffer->~SliceBuffer();
+     if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+       size_t i;
+-      LOG(INFO) << "TCP: " << eeep_->wrapper << " READ error=" << status;
++      ABSL_LOG(INFO) << "TCP: " << eeep_->wrapper << " READ error=" << status;
+       if (ABSL_VLOG_IS_ON(2)) {
+         for (i = 0; i < pending_read_buffer_->count; i++) {
+           char* dump = grpc_dump_slice(pending_read_buffer_->slices[i],
+                                        GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-          VLOG(2) << "READ DATA: " << dump;
++          ABSL_VLOG(2) << "READ DATA: " << dump;
+           gpr_free(dump);
+         }
+       }
+@@ -148,12 +148,12 @@ class EventEngineEndpointWrapper {
+     Ref();
+     if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+       size_t i;
+-      LOG(INFO) << "TCP: " << this << " WRITE (peer=" << PeerAddress() << ")";
++      ABSL_LOG(INFO) << "TCP: " << this << " WRITE (peer=" << PeerAddress() << ")";
+       if (ABSL_VLOG_IS_ON(2)) {
+         for (i = 0; i < slices->count; i++) {
+           char* dump =
+               grpc_dump_slice(slices->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-          VLOG(2) << "WRITE DATA: " << dump;
++          ABSL_VLOG(2) << "WRITE DATA: " << dump;
+           gpr_free(dump);
+         }
+       }
+@@ -414,7 +414,7 @@ EventEngineEndpointWrapper::EventEngineEndpointWrapper(
+
+ grpc_endpoint* grpc_event_engine_endpoint_create(
+     std::unique_ptr<EventEngine::Endpoint> ee_endpoint) {
+-  DCHECK(ee_endpoint != nullptr);
++  ABSL_DCHECK(ee_endpoint != nullptr);
+   auto wrapper = new EventEngineEndpointWrapper(std::move(ee_endpoint));
+   return wrapper->GetGrpcEndpoint();
+ }
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc
+index 23d4248eaa948..dd17e688b3cca 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc
+@@ -21,8 +21,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <grpc/support/sync.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/iomgr/combiner.h"
+ #include "src/core/lib/iomgr/error.h"
+@@ -84,7 +84,7 @@ bool ExecCtx::Flush() {
+       break;
+     }
+   }
+-  CHECK_EQ(combiner_data_.active_combiner, nullptr);
++  ABSL_CHECK_EQ(combiner_data_.active_combiner, nullptr);
+   return did_something;
+ }
+
+@@ -107,7 +107,7 @@ void ExecCtx::Run(const DebugLocation& location, grpc_closure* closure,
+   closure->file_initiated = location.file();
+   closure->line_initiated = location.line();
+   closure->run = false;
+-  CHECK_NE(closure->cb, nullptr);
++  ABSL_CHECK_NE(closure->cb, nullptr);
+ #endif
+   closure->error_data.error = internal::StatusAllocHeapPtr(error);
+   exec_ctx_sched(closure);
+@@ -130,7 +130,7 @@ void ExecCtx::RunList(const DebugLocation& location, grpc_closure_list* list) {
+     c->file_initiated = location.file();
+     c->line_initiated = location.line();
+     c->run = false;
+-    CHECK_NE(c->cb, nullptr);
++    ABSL_CHECK_NE(c->cb, nullptr);
+ #endif
+     exec_ctx_sched(c);
+     c = next;
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h
+index dc61faa9e82e5..86b77baf8fdba 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h
++++ b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h
+@@ -33,7 +33,7 @@
+ #include <grpc/support/cpu.h>
+ #include <grpc/support/time.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/experiments/experiments.h"
+ #include "src/core/lib/iomgr/closure.h"
+ #include "src/core/util/debug_location.h"
+@@ -314,8 +314,8 @@ class GRPC_DLL ApplicationCallbackExecCtx {
+         Fork::DecExecCtxCount();
+       }
+     } else {
+-      DCHECK_EQ(head_, nullptr);
+-      DCHECK_EQ(tail_, nullptr);
++      ABSL_DCHECK_EQ(head_, nullptr);
++      ABSL_DCHECK_EQ(tail_, nullptr);
+     }
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/executor.cc b/third_party/grpc/source/src/core/lib/iomgr/executor.cc
+index b9ff3a5f78fac..9bb3dad2d1012 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/executor.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/executor.cc
+@@ -24,8 +24,8 @@
+ #include <grpc/support/sync.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/debug/trace_impl.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -137,7 +137,7 @@ void Executor::SetThreading(bool threading) {
+       return;
+     }
+
+-    CHECK_EQ(num_threads_, 0);
++    ABSL_CHECK_EQ(num_threads_, 0);
+     gpr_atm_rel_store(&num_threads_, 1);
+     thd_state_ = static_cast<ThreadState*>(
+         gpr_zalloc(sizeof(ThreadState) * max_threads_));
+@@ -372,7 +372,7 @@ void Executor::InitAll() {
+
+   // Return if Executor::InitAll() is already called earlier
+   if (executors[static_cast<size_t>(ExecutorType::DEFAULT)] != nullptr) {
+-    CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] != nullptr);
++    ABSL_CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] != nullptr);
+     return;
+   }
+
+@@ -398,7 +398,7 @@ void Executor::ShutdownAll() {
+
+   // Return if Executor:SshutdownAll() is already called earlier
+   if (executors[static_cast<size_t>(ExecutorType::DEFAULT)] == nullptr) {
+-    CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] == nullptr);
++    ABSL_CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] == nullptr);
+     return;
+   }
+
+@@ -426,7 +426,7 @@ void Executor::ShutdownAll() {
+ }
+
+ bool Executor::IsThreaded(ExecutorType executor_type) {
+-  CHECK(executor_type < ExecutorType::NUM_EXECUTORS);
++  ABSL_CHECK(executor_type < ExecutorType::NUM_EXECUTORS);
+   return executors[static_cast<size_t>(executor_type)]->IsThreaded();
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc
+index 0d784ea53ccf5..e211010a26b4b 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc
+@@ -30,7 +30,7 @@
+ #include <grpc/grpc.h>
+ #include <string.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/ev_posix.h"
+ #include "src/core/lib/iomgr/executor.h"
+ #include "src/core/lib/iomgr/timer_manager.h"
+@@ -59,7 +59,7 @@ void grpc_prefork() {
+   }
+   grpc_core::ExecCtx exec_ctx;
+   if (!grpc_core::Fork::Enabled()) {
+-    LOG(ERROR) << "Fork support not enabled; try running with the "
++    ABSL_LOG(ERROR) << "Fork support not enabled; try running with the "
+                   "environment variable GRPC_ENABLE_FORK_SUPPORT=1";
+     return;
+   }
+@@ -67,12 +67,12 @@ void grpc_prefork() {
+   if (poll_strategy_name == nullptr ||
+       (strcmp(poll_strategy_name, "epoll1") != 0 &&
+        strcmp(poll_strategy_name, "poll") != 0)) {
+-    LOG(INFO) << "Fork support is only compatible with the epoll1 and poll "
++    ABSL_LOG(INFO) << "Fork support is only compatible with the epoll1 and poll "
+                  "polling strategies";
+     return;
+   }
+   if (!grpc_core::Fork::BlockExecCtx()) {
+-    LOG(INFO) << "Other threads are currently calling into gRPC, skipping "
++    ABSL_LOG(INFO) << "Other threads are currently calling into gRPC, skipping "
+                  "fork() handlers";
+     return;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc
+index baf9e2124692d..dbc0025a8938b 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc
+@@ -24,14 +24,14 @@
+
+ #include <grpc/fork.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+
+ //
+ // NOTE: FORKING IS NOT GENERALLY SUPPORTED, THIS IS ONLY INTENDED TO WORK
+ //       AROUND VERY SPECIFIC USE CASES.
+ //
+
+-void grpc_prefork() { LOG(ERROR) << "Forking not supported on Windows"; }
++void grpc_prefork() { ABSL_LOG(ERROR) << "Forking not supported on Windows"; }
+
+ void grpc_postfork_parent() {}
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc b/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc
+index d5386498a53e6..0025222800549 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc
+@@ -16,7 +16,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/port.h"
+
+ #ifdef GRPC_POSIX_SOCKET_TCP
+@@ -37,7 +37,7 @@ bool KernelSupportsErrqueue() {
+     // least 4.0.0
+     struct utsname buffer;
+     if (uname(&buffer) != 0) {
+-      LOG(ERROR) << "uname: " << StrError(errno);
++      ABSL_LOG(ERROR) << "uname: " << StrError(errno);
+       return false;
+     }
+     char* release = buffer.release;
+@@ -48,7 +48,7 @@ bool KernelSupportsErrqueue() {
+     if (strtol(release, nullptr, 10) >= 4) {
+       return true;
+     } else {
+-      VLOG(2) << "ERRQUEUE support not enabled";
++      ABSL_VLOG(2) << "ERRQUEUE support not enabled";
+     }
+ #endif  // GRPC_LINUX_ERRQUEUE
+     return false;
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc
+index 12b8cb31c6326..b722e1f5427b2 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc
+@@ -28,8 +28,8 @@
+
+ #include <limits>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/iocp_windows.h"
+ #include "src/core/lib/iomgr/iomgr_internal.h"
+ #include "src/core/lib/iomgr/socket_windows.h"
+@@ -73,8 +73,8 @@ grpc_iocp_work_status grpc_iocp_work(grpc_core::Timestamp deadline) {
+   if (success == 0 && overlapped == NULL) {
+     return GRPC_IOCP_WORK_TIMEOUT;
+   }
+-  CHECK(completion_key);
+-  CHECK(overlapped);
++  ABSL_CHECK(completion_key);
++  ABSL_CHECK(overlapped);
+   if (overlapped == &g_iocp_custom_overlap) {
+     gpr_atm_full_fetch_add(&g_custom_events, -1);
+     if (completion_key == (ULONG_PTR)&g_iocp_kick_token) {
+@@ -102,7 +102,7 @@ grpc_iocp_work_status grpc_iocp_work(grpc_core::Timestamp deadline) {
+     info->bytes_transferred = bytes;
+     info->wsa_error = success ? 0 : WSAGetLastError();
+   }
+-  CHECK(overlapped == &info->overlapped);
++  ABSL_CHECK(overlapped == &info->overlapped);
+   bool should_destroy = grpc_socket_become_ready(socket, info);
+   gpr_mu_unlock(&socket->state_mu);
+   if (should_destroy) {
+@@ -114,7 +114,7 @@ grpc_iocp_work_status grpc_iocp_work(grpc_core::Timestamp deadline) {
+ void grpc_iocp_init(void) {
+   g_iocp =
+       CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, (ULONG_PTR)NULL, 0);
+-  CHECK(g_iocp);
++  ABSL_CHECK(g_iocp);
+ }
+
+ void grpc_iocp_kick(void) {
+@@ -123,7 +123,7 @@ void grpc_iocp_kick(void) {
+   gpr_atm_full_fetch_add(&g_custom_events, 1);
+   success = PostQueuedCompletionStatus(g_iocp, 0, (ULONG_PTR)&g_iocp_kick_token,
+                                        &g_iocp_custom_overlap);
+-  CHECK(success);
++  ABSL_CHECK(success);
+ }
+
+ void grpc_iocp_flush(void) {
+@@ -145,7 +145,7 @@ void grpc_iocp_shutdown(void) {
+     grpc_core::ExecCtx::Get()->Flush();
+   }
+
+-  CHECK(CloseHandle(g_iocp));
++  ABSL_CHECK(CloseHandle(g_iocp));
+ }
+
+ void grpc_iocp_add_socket(grpc_winsocket* socket) {
+@@ -155,13 +155,13 @@ void grpc_iocp_add_socket(grpc_winsocket* socket) {
+                                (uintptr_t)socket, 0);
+   if (!ret) {
+     char* utf8_message = gpr_format_message(WSAGetLastError());
+-    LOG(ERROR) << "Unable to add socket to iocp: " << utf8_message;
++    ABSL_LOG(ERROR) << "Unable to add socket to iocp: " << utf8_message;
+     gpr_free(utf8_message);
+     __debugbreak();
+     abort();
+   }
+   socket->added_to_iocp = 1;
+-  CHECK(ret == g_iocp);
++  ABSL_CHECK(ret == g_iocp);
+ }
+
+ void grpc_iocp_register_socket_shutdown_socket_locked(grpc_winsocket* socket) {
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc b/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc
+index 3b571df5687e6..c9abbbdada41f 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc
+@@ -26,7 +26,7 @@
+ #include <stdlib.h>
+ #include <string.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/config/config_vars.h"
+ #include "src/core/lib/iomgr/buffer_list.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -81,7 +81,7 @@ size_t grpc_iomgr_count_objects_for_testing(void) {
+ static void dump_objects(const char* kind) {
+   grpc_iomgr_object* obj;
+   for (obj = g_root_object.next; obj != &g_root_object; obj = obj->next) {
+-    VLOG(2) << kind << " OBJECT: " << obj->name << " " << obj;
++    ABSL_VLOG(2) << kind << " OBJECT: " << obj->name << " " << obj;
+   }
+ }
+
+@@ -101,7 +101,7 @@ void grpc_iomgr_shutdown() {
+               gpr_time_sub(gpr_now(GPR_CLOCK_REALTIME), last_warning_time),
+               gpr_time_from_seconds(1, GPR_TIMESPAN)) >= 0) {
+         if (g_root_object.next != &g_root_object) {
+-          VLOG(2) << "Waiting for " << count_objects()
++          ABSL_VLOG(2) << "Waiting for " << count_objects()
+                   << " iomgr objects to be destroyed";
+         }
+         last_warning_time = gpr_now(GPR_CLOCK_REALTIME);
+@@ -116,7 +116,7 @@ void grpc_iomgr_shutdown() {
+       }
+       if (g_root_object.next != &g_root_object) {
+         if (grpc_iomgr_abort_on_leaks()) {
+-          VLOG(2) << "Failed to free " << count_objects()
++          ABSL_VLOG(2) << "Failed to free " << count_objects()
+                   << " iomgr objects before shutdown deadline: "
+                   << "memory leaks are likely";
+           dump_objects("LEAKED");
+@@ -129,7 +129,7 @@ void grpc_iomgr_shutdown() {
+           if (gpr_time_cmp(gpr_now(GPR_CLOCK_REALTIME), shutdown_deadline) >
+               0) {
+             if (g_root_object.next != &g_root_object) {
+-              VLOG(2) << "Failed to free " << count_objects()
++              ABSL_VLOG(2) << "Failed to free " << count_objects()
+                       << " iomgr objects before shutdown deadline: "
+                       << "memory leaks are likely";
+               dump_objects("LEAKED");
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc
+index 38e61b8122547..a7d8c9b9567aa 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc
+@@ -22,7 +22,7 @@
+
+ #ifdef GRPC_WINSOCK_SOCKET
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/experiments/experiments.h"
+ #include "src/core/lib/iomgr/iocp_windows.h"
+ #include "src/core/lib/iomgr/iomgr.h"
+@@ -50,12 +50,12 @@ extern grpc_pollset_set_vtable grpc_windows_pollset_set_vtable;
+ static void winsock_init(void) {
+   WSADATA wsaData;
+   int status = WSAStartup(MAKEWORD(2, 0), &wsaData);
+-  CHECK_EQ(status, 0);
++  ABSL_CHECK_EQ(status, 0);
+ }
+
+ static void winsock_shutdown(void) {
+   int status = WSACleanup();
+-  CHECK_EQ(status, 0);
++  ABSL_CHECK_EQ(status, 0);
+ }
+
+ static void iomgr_platform_init(void) {
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc b/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc
+index 42023ef4615e2..eec7ade9f7e6d 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc
+@@ -20,8 +20,8 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/util/crash.h"
+@@ -78,7 +78,7 @@ void LockfreeEvent::DestroyEvent() {
+     if (curr & kShutdownBit) {
+       internal::StatusFreeHeapPtr(curr & ~kShutdownBit);
+     } else {
+-      CHECK(curr == kClosureNotReady || curr == kClosureReady);
++      ABSL_CHECK(curr == kClosureNotReady || curr == kClosureReady);
+     }
+     // we CAS in a shutdown, no error value here. If this event is interacted
+     // with post-deletion (see the note in the constructor) we want the bit
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc b/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc
+index 8a5ad277f24a5..8ee128244e2c3 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/util/crash.h"
+
+@@ -73,7 +73,7 @@ void grpc_polling_entity_add_to_pollset_set(grpc_polling_entity* pollent,
+       grpc_pollset_set_add_pollset(pss_dst, pollent->pollent.pollset);
+     }
+   } else if (pollent->tag == GRPC_POLLS_POLLSET_SET) {
+-    CHECK_NE(pollent->pollent.pollset_set, nullptr);
++    ABSL_CHECK_NE(pollent->pollent.pollset_set, nullptr);
+     grpc_pollset_set_add_pollset_set(pss_dst, pollent->pollent.pollset_set);
+   } else if (pollent->tag == GRPC_POLLS_NONE) {
+     // Do nothing.
+@@ -91,11 +91,11 @@ void grpc_polling_entity_del_from_pollset_set(grpc_polling_entity* pollent,
+       grpc_pollset_set_del_pollset(pss_dst, pollent->pollent.pollset);
+     }
+ #else
+-    CHECK_NE(pollent->pollent.pollset, nullptr);
++    ABSL_CHECK_NE(pollent->pollent.pollset, nullptr);
+     grpc_pollset_set_del_pollset(pss_dst, pollent->pollent.pollset);
+ #endif
+   } else if (pollent->tag == GRPC_POLLS_POLLSET_SET) {
+-    CHECK_NE(pollent->pollent.pollset_set, nullptr);
++    ABSL_CHECK_NE(pollent->pollent.pollset_set, nullptr);
+     grpc_pollset_set_del_pollset_set(pss_dst, pollent->pollent.pollset_set);
+   } else if (pollent->tag == GRPC_POLLS_NONE) {
+     // Do nothing.
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc
+index a522df8aecda0..82f26aa7a594a 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc
+@@ -39,7 +39,7 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/iomgr/sockaddr.h"
+ #include "src/core/util/crash.h"
+
+@@ -56,7 +56,7 @@ int grpc_inet_pton(int af, const char* src, void* dst) {
+ }
+
+ const char* grpc_inet_ntop(int af, const void* src, char* dst, size_t size) {
+-  CHECK(size <= (socklen_t)-1);
++  ABSL_CHECK(size <= (socklen_t)-1);
+   return inet_ntop(af, src, dst, static_cast<socklen_t>(size));
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc
+index 8b1af9db7298d..b5160c4ea7f34 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc
+@@ -46,8 +46,8 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/iomgr/sockaddr.h"
+@@ -388,12 +388,12 @@ grpc_error_handle grpc_set_socket_tcp_user_timeout(
+             << " ms";
+         if (0 != setsockopt(fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &timeout,
+                             sizeof(timeout))) {
+-          LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
++          ABSL_LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
+                      << grpc_core::StrError(errno);
+           return absl::OkStatus();
+         }
+         if (0 != getsockopt(fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &newval, &len)) {
+-          LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
++          ABSL_LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
+                      << grpc_core::StrError(errno);
+           return absl::OkStatus();
+         }
+@@ -415,7 +415,7 @@ grpc_error_handle grpc_set_socket_tcp_user_timeout(
+ // set a socket using a grpc_socket_mutator
+ grpc_error_handle grpc_set_socket_with_mutator(int fd, grpc_fd_usage usage,
+                                                grpc_socket_mutator* mutator) {
+-  CHECK(mutator);
++  ABSL_CHECK(mutator);
+   if (!grpc_socket_mutator_mutate_fd(mutator, fd, usage)) {
+     return GRPC_ERROR_CREATE("grpc_socket_mutator failed.");
+   }
+@@ -478,7 +478,7 @@ static int create_socket(grpc_socket_factory* factory, int domain, int type,
+                 : socket(domain, type, protocol);
+   if (res < 0 && errno == EMFILE) {
+     int saved_errno = errno;
+-    LOG_EVERY_N_SEC(ERROR, 10)
++    ABSL_LOG_EVERY_N_SEC(ERROR, 10)
+         << "socket(" << domain << ", " << type << ", " << protocol
+         << ") returned " << res << " with error: |"
+         << grpc_core::StrError(errno)
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc
+index 8ec4eaa1366f2..8816d94a72d5d 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc
+@@ -29,8 +29,8 @@
+ #include <grpc/support/log_windows.h>
+ #include <mswsock.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/iomgr/iocp_windows.h"
+ #include "src/core/lib/iomgr/iomgr_internal.h"
+@@ -130,7 +130,7 @@ void grpc_winsocket_shutdown(grpc_winsocket* winsocket) {
+     DisconnectEx(winsocket->socket, NULL, 0, 0);
+   } else {
+     char* utf8_message = gpr_format_message(WSAGetLastError());
+-    VLOG(2) << "Unable to retrieve DisconnectEx pointer : " << utf8_message;
++    ABSL_VLOG(2) << "Unable to retrieve DisconnectEx pointer : " << utf8_message;
+     gpr_free(utf8_message);
+   }
+   // Calling closesocket triggers invocation of any pending I/O operations with
+@@ -157,7 +157,7 @@ void grpc_winsocket_finish(grpc_winsocket* winsocket) {
+
+ void grpc_winsocket_destroy(grpc_winsocket* winsocket) {
+   gpr_mu_lock(&winsocket->state_mu);
+-  CHECK(!winsocket->destroy_called);
++  ABSL_CHECK(!winsocket->destroy_called);
+   winsocket->destroy_called = true;
+   bool should_destroy = check_destroyable(winsocket);
+   gpr_mu_unlock(&winsocket->state_mu);
+@@ -172,7 +172,7 @@ void grpc_winsocket_destroy(grpc_winsocket* winsocket) {
+ //-) The IOCP hasn't completed yet, and we're queuing it for later.
+ static void socket_notify_on_iocp(grpc_winsocket* socket, grpc_closure* closure,
+                                   grpc_winsocket_callback_info* info) {
+-  CHECK(info->closure == NULL);
++  ABSL_CHECK(info->closure == NULL);
+   gpr_mu_lock(&socket->state_mu);
+   if (info->has_pending_iocp) {
+     info->has_pending_iocp = 0;
+@@ -194,7 +194,7 @@ void grpc_socket_notify_on_read(grpc_winsocket* socket, grpc_closure* closure) {
+
+ bool grpc_socket_become_ready(grpc_winsocket* socket,
+                               grpc_winsocket_callback_info* info) {
+-  CHECK(!info->has_pending_iocp);
++  ABSL_CHECK(!info->has_pending_iocp);
+   if (info->closure) {
+     // Only run the closure once at shutdown.
+     if (!info->closure_already_executed_at_shutdown) {
+@@ -214,7 +214,7 @@ static void probe_ipv6_once(void) {
+   SOCKET s = socket(AF_INET6, SOCK_STREAM, 0);
+   g_ipv6_loopback_available = 0;
+   if (s == INVALID_SOCKET) {
+-    VLOG(2) << "Disabling AF_INET6 sockets because socket() failed.";
++    ABSL_VLOG(2) << "Disabling AF_INET6 sockets because socket() failed.";
+   } else {
+     grpc_sockaddr_in6 addr;
+     memset(&addr, 0, sizeof(addr));
+@@ -223,7 +223,7 @@ static void probe_ipv6_once(void) {
+     if (bind(s, reinterpret_cast<grpc_sockaddr*>(&addr), sizeof(addr)) == 0) {
+       g_ipv6_loopback_available = 1;
+     } else {
+-      VLOG(2) << "Disabling AF_INET6 sockets because ::1 is not available.";
++      ABSL_VLOG(2) << "Disabling AF_INET6 sockets because ::1 is not available.";
+     }
+     closesocket(s);
+   }
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc
+index 141a9c76f5242..5242895ffcb29 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc
+@@ -30,7 +30,7 @@
+ #include <netinet/in.h>
+ #include <string.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/event_engine/shim.h"
+ #include "src/core/lib/iomgr/cfstream_handle.h"
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc
+index 4a01cf5a969cf..9b04859db2608 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc
+@@ -31,8 +31,8 @@
+ #include <unistd.h>
+
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/event_engine/resolved_address_internal.h"
+@@ -99,7 +99,7 @@ static grpc_error_handle prepare_socket(
+     const grpc_core::PosixTcpOptions& options) {
+   grpc_error_handle err;
+
+-  CHECK_GE(fd, 0);
++  ABSL_CHECK_GE(fd, 0);
+
+   err = grpc_set_socket_nonblocking(fd, 1);
+   if (!err.ok()) goto error;
+@@ -182,7 +182,7 @@ static void on_writable(void* acp, grpc_error_handle error) {
+       << ": on_writable: error=" << grpc_core::StatusToString(error);
+
+   gpr_mu_lock(&ac->mu);
+-  CHECK(ac->fd);
++  ABSL_CHECK(ac->fd);
+   fd = ac->fd;
+   ac->fd = nullptr;
+   bool connect_cancelled = ac->connect_cancelled;
+@@ -233,7 +233,7 @@ static void on_writable(void* acp, grpc_error_handle error) {
+       // your program or another program on the same computer
+       // opened too many network connections.  The "easy" fix:
+       // don't do that!
+-      LOG(ERROR) << "kernel out of buffers";
++      ABSL_LOG(ERROR) << "kernel out of buffers";
+       gpr_mu_unlock(&ac->mu);
+       grpc_fd_notify_on_write(fd, &ac->write_closure);
+       return;
+@@ -268,7 +268,7 @@ finish:
+     std::string str;
+     bool ret = grpc_error_get_str(
+         error, grpc_core::StatusStrProperty::kDescription, &str);
+-    CHECK(ret);
++    ABSL_CHECK(ret);
+     std::string description =
+         absl::StrCat("Failed to connect to remote host: ", str);
+     error = grpc_error_set_str(
+@@ -434,7 +434,7 @@ static bool tcp_cancel_connect(int64_t connection_handle) {
+     auto it = shard->pending_connections.find(connection_handle);
+     if (it != shard->pending_connections.end()) {
+       ac = it->second;
+-      CHECK_NE(ac, nullptr);
++      ABSL_CHECK_NE(ac, nullptr);
+       // Trying to acquire ac->mu here would could cause a deadlock because
+       // the on_writable method tries to acquire the two mutexes used
+       // here in the reverse order. But we dont need to acquire ac->mu before
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc
+index 7d464759575ab..4749875c19de8 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc
+@@ -28,7 +28,7 @@
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/log_windows.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/event_engine/shim.h"
+ #include "src/core/lib/iomgr/event_engine_shims/tcp_client.h"
+@@ -82,7 +82,7 @@ static void on_alarm(void* acp, grpc_error_handle /* error */) {
+ static void on_connect(void* acp, grpc_error_handle error) {
+   async_connect* ac = (async_connect*)acp;
+   grpc_endpoint** ep = ac->endpoint;
+-  CHECK(*ep == NULL);
++  ABSL_CHECK(*ep == NULL);
+   grpc_closure* on_done = ac->on_done;
+
+   gpr_mu_lock(&ac->mu);
+@@ -101,7 +101,7 @@ static void on_connect(void* acp, grpc_error_handle error) {
+       BOOL wsa_success =
+           WSAGetOverlappedResult(socket->socket, &socket->write_info.overlapped,
+                                  &transferred_bytes, FALSE, &flags);
+-      CHECK_EQ(transferred_bytes, 0);
++      ABSL_CHECK_EQ(transferred_bytes, 0);
+       if (!wsa_success) {
+         error = GRPC_WSA_ERROR(WSAGetLastError(), "ConnectEx");
+         closesocket(socket->socket);
+@@ -242,7 +242,7 @@ static int64_t tcp_connect(grpc_closure* on_done, grpc_endpoint** endpoint,
+   return 0;
+
+ failure:
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   grpc_error_handle final_error =
+       GRPC_ERROR_CREATE_REFERENCING("Failed to connect", &error, 1);
+   if (socket != NULL) {
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc
+index 9da71b5b2cd87..0147ad52e9190 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc
+@@ -50,8 +50,8 @@
+ #include <algorithm>
+ #include <unordered_map>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/experiments/experiments.h"
+@@ -155,7 +155,7 @@ class TcpZerocopySendRecord {
+   //  sendmsg() failed or when tcp_write() is done.
+   bool Unref() {
+     const intptr_t prior = ref_.fetch_sub(1, std::memory_order_acq_rel);
+-    DCHECK_GT(prior, 0);
++    ABSL_DCHECK_GT(prior, 0);
+     if (prior == 1) {
+       AllSendsComplete();
+       return true;
+@@ -170,9 +170,9 @@ class TcpZerocopySendRecord {
+   };
+
+   void AssertEmpty() {
+-    DCHECK_EQ(buf_.count, 0u);
+-    DCHECK_EQ(buf_.length, 0u);
+-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
++    ABSL_DCHECK_EQ(buf_.count, 0u);
++    ABSL_DCHECK_EQ(buf_.length, 0u);
++    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+   }
+
+   // When all sendmsg() calls associated with this tcp_write() have been
+@@ -180,7 +180,7 @@ class TcpZerocopySendRecord {
+   // for each sendmsg()) and all reference counts have been dropped, drop our
+   // reference to the underlying data since we no longer need it.
+   void AllSendsComplete() {
+-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
++    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+     grpc_slice_buffer_reset_and_unref(&buf_);
+   }
+
+@@ -260,7 +260,7 @@ class TcpZerocopySendCtx {
+     --last_send_;
+     if (ReleaseSendRecord(last_send_)->Unref()) {
+       // We should still be holding the ref taken by tcp_write().
+-      DCHECK(0);
++      ABSL_DCHECK(0);
+     }
+   }
+
+@@ -296,8 +296,8 @@ class TcpZerocopySendCtx {
+   // max_sends_ tcp_write() instances with zerocopy enabled in flight at the
+   // same time.
+   void PutSendRecord(TcpZerocopySendRecord* record) {
+-    DCHECK(record >= send_records_);
+-    DCHECK(record < send_records_ + max_sends_);
++    ABSL_DCHECK(record >= send_records_);
++    ABSL_DCHECK(record < send_records_ + max_sends_);
+     MutexLock guard(&lock_);
+     PutSendRecordLocked(record);
+   }
+@@ -316,7 +316,7 @@ class TcpZerocopySendCtx {
+   bool enabled() const { return enabled_; }
+
+   void set_enabled(bool enabled) {
+-    DCHECK(!enabled || !memory_limited());
++    ABSL_DCHECK(!enabled || !memory_limited());
+     enabled_ = enabled;
+   }
+
+@@ -354,7 +354,7 @@ class TcpZerocopySendCtx {
+       zcopy_enobuf_state_ = OMemState::CHECK;
+       return false;
+     }
+-    DCHECK(zcopy_enobuf_state_ != OMemState::CHECK);
++    ABSL_DCHECK(zcopy_enobuf_state_ != OMemState::CHECK);
+     if (zcopy_enobuf_state_ == OMemState::FULL) {
+       // A previous sendmsg attempt was blocked by ENOBUFS. Return true to
+       // mark the fd as writable so the next write attempt could be made.
+@@ -428,7 +428,7 @@ class TcpZerocopySendCtx {
+
+   TcpZerocopySendRecord* ReleaseSendRecordLocked(uint32_t seq) {
+     auto iter = ctx_lookup_.find(seq);
+-    DCHECK(iter != ctx_lookup_.end());
++    ABSL_DCHECK(iter != ctx_lookup_.end());
+     TcpZerocopySendRecord* record = iter->second;
+     ctx_lookup_.erase(iter);
+     return record;
+@@ -446,7 +446,7 @@ class TcpZerocopySendCtx {
+   }
+
+   void PutSendRecordLocked(TcpZerocopySendRecord* record) {
+-    DCHECK(free_send_records_size_ < max_sends_);
++    ABSL_DCHECK(free_send_records_size_ < max_sends_);
+     free_send_records_[free_send_records_size_] = record;
+     free_send_records_size_++;
+   }
+@@ -591,7 +591,7 @@ void LogCommonIOErrors(absl::string_view prefix, int error_no) {
+       return;
+     default:
+       grpc_core::global_stats().IncrementUncommonIoErrorCount();
+-      LOG_EVERY_N_SEC(ERROR, 1)
++      ABSL_LOG_EVERY_N_SEC(ERROR, 1)
+           << prefix.data()
+           << " encountered uncommon error: " << grpc_core::StrError(error_no);
+       return;
+@@ -634,7 +634,7 @@ static void run_poller(void* bp, grpc_error_handle /*error_ignored*/) {
+   g_backup_poller_mu->Lock();
+   // last "uncovered" notification is the ref that keeps us polling
+   if (g_uncovered_notifications_pending == 1) {
+-    CHECK(g_backup_poller == p);
++    ABSL_CHECK(g_backup_poller == p);
+     g_backup_poller = nullptr;
+     g_uncovered_notifications_pending = 0;
+     g_backup_poller_mu->Unlock();
+@@ -658,7 +658,7 @@ static void drop_uncovered(grpc_tcp* /*tcp*/) {
+   p = g_backup_poller;
+   old_count = g_uncovered_notifications_pending--;
+   g_backup_poller_mu->Unlock();
+-  CHECK_GT(old_count, 1);
++  ABSL_CHECK_GT(old_count, 1);
+   GRPC_TRACE_LOG(tcp, INFO) << "BACKUP_POLLER:" << p << " uncover cnt "
+                             << old_count << "->" << old_count - 1;
+ }
+@@ -829,16 +829,16 @@ static void tcp_trace_read(grpc_tcp* tcp, grpc_error_handle error)
+     ABSL_EXCLUSIVE_LOCKS_REQUIRED(tcp->read_mu) {
+   grpc_closure* cb = tcp->read_cb;
+   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+-    LOG(INFO) << "TCP:" << tcp << " call_cb " << cb << " " << cb->cb << ":"
++    ABSL_LOG(INFO) << "TCP:" << tcp << " call_cb " << cb << " " << cb->cb << ":"
+               << cb->cb_arg;
+     size_t i;
+-    LOG(INFO) << "READ " << tcp << " (peer=" << tcp->peer_string
++    ABSL_LOG(INFO) << "READ " << tcp << " (peer=" << tcp->peer_string
+               << ") error=" << grpc_core::StatusToString(error);
+     if (ABSL_VLOG_IS_ON(2)) {
+       for (i = 0; i < tcp->incoming_buffer->count; i++) {
+         char* dump = grpc_dump_slice(tcp->incoming_buffer->slices[i],
+                                      GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-        VLOG(2) << "READ DATA: " << dump;
++        ABSL_VLOG(2) << "READ DATA: " << dump;
+         gpr_free(dump);
+       }
+     }
+@@ -881,7 +881,7 @@ static void update_rcvlowat(grpc_tcp* tcp)
+   }
+   if (setsockopt(tcp->fd, SOL_SOCKET, SO_RCVLOWAT, &remaining,
+                  sizeof(remaining)) != 0) {
+-    LOG(ERROR) << "Cannot set SO_RCVLOWAT on fd=" << tcp->fd
++    ABSL_LOG(ERROR) << "Cannot set SO_RCVLOWAT on fd=" << tcp->fd
+                << " err=" << grpc_core::StrError(errno);
+     return;
+   }
+@@ -912,8 +912,8 @@ static bool tcp_do_read(grpc_tcp* tcp, grpc_error_handle* error)
+     iov[i].iov_len = GRPC_SLICE_LENGTH(tcp->incoming_buffer->slices[i]);
+   }
+
+-  CHECK_NE(tcp->incoming_buffer->length, 0u);
+-  DCHECK_GT(tcp->min_progress_size, 0);
++  ABSL_CHECK_NE(tcp->incoming_buffer->length, 0u);
++  ABSL_DCHECK_GT(tcp->min_progress_size, 0);
+
+   do {
+     // Assume there is something on the queue. If we receive TCP_INQ from
+@@ -981,12 +981,12 @@ static bool tcp_do_read(grpc_tcp* tcp, grpc_error_handle* error)
+
+     grpc_core::global_stats().IncrementTcpReadSize(read_bytes);
+     add_to_estimate(tcp, static_cast<size_t>(read_bytes));
+-    DCHECK((size_t)read_bytes <=
++    ABSL_DCHECK((size_t)read_bytes <=
+            tcp->incoming_buffer->length - total_read_bytes);
+
+ #ifdef GRPC_HAVE_TCP_INQ
+     if (tcp->inq_capable) {
+-      DCHECK(!(msg.msg_flags & MSG_CTRUNC));
++      ABSL_DCHECK(!(msg.msg_flags & MSG_CTRUNC));
+       struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
+       for (; cmsg != nullptr; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+         if (cmsg->cmsg_level == SOL_TCP && cmsg->cmsg_type == TCP_CM_INQ &&
+@@ -1029,7 +1029,7 @@ static bool tcp_do_read(grpc_tcp* tcp, grpc_error_handle* error)
+     finish_estimate(tcp);
+   }
+
+-  DCHECK_GT(total_read_bytes, 0u);
++  ABSL_DCHECK_GT(total_read_bytes, 0u);
+   *error = absl::OkStatus();
+   if (grpc_core::IsTcpFrameSizeTuningEnabled()) {
+     // Update min progress size based on the total number of bytes read in
+@@ -1147,7 +1147,7 @@ static void tcp_handle_read(void* arg /* grpc_tcp */, grpc_error_handle error) {
+ static void tcp_read(grpc_endpoint* ep, grpc_slice_buffer* incoming_buffer,
+                      grpc_closure* cb, bool urgent, int min_progress_size) {
+   grpc_tcp* tcp = reinterpret_cast<grpc_tcp*>(ep);
+-  CHECK_EQ(tcp->read_cb, nullptr);
++  ABSL_CHECK_EQ(tcp->read_cb, nullptr);
+   tcp->read_cb = cb;
+   tcp->read_mu.Lock();
+   tcp->incoming_buffer = incoming_buffer;
+@@ -1229,8 +1229,8 @@ static TcpZerocopySendRecord* tcp_get_send_zerocopy_record(
+     }
+     if (zerocopy_send_record != nullptr) {
+       zerocopy_send_record->PrepareForSends(buf);
+-      DCHECK_EQ(buf->count, 0u);
+-      DCHECK_EQ(buf->length, 0u);
++      ABSL_DCHECK_EQ(buf->count, 0u);
++      ABSL_DCHECK_EQ(buf->length, 0u);
+       tcp->outgoing_byte_idx = 0;
+       tcp->outgoing_buffer = nullptr;
+     }
+@@ -1291,10 +1291,10 @@ static void UnrefMaybePutZerocopySendRecord(grpc_tcp* tcp,
+                                             uint32_t seq, const char* tag);
+ // Reads \a cmsg to process zerocopy control messages.
+ static void process_zerocopy(grpc_tcp* tcp, struct cmsghdr* cmsg) {
+-  DCHECK(cmsg);
++  ABSL_DCHECK(cmsg);
+   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(cmsg));
+-  DCHECK_EQ(serr->ee_errno, 0u);
+-  DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
++  ABSL_DCHECK_EQ(serr->ee_errno, 0u);
++  ABSL_DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
+   const uint32_t lo = serr->ee_info;
+   const uint32_t hi = serr->ee_data;
+   for (uint32_t seq = lo; seq <= hi; ++seq) {
+@@ -1304,7 +1304,7 @@ static void process_zerocopy(grpc_tcp* tcp, struct cmsghdr* cmsg) {
+     // both; if so, batch the unref/put.
+     TcpZerocopySendRecord* record =
+         tcp->tcp_zerocopy_send_ctx.ReleaseSendRecord(seq);
+-    DCHECK(record);
++    ABSL_DCHECK(record);
+     UnrefMaybePutZerocopySendRecord(tcp, record, seq, "CALLBACK RCVD");
+   }
+   if (tcp->tcp_zerocopy_send_ctx.UpdateZeroCopyOMemStateAfterFree()) {
+@@ -1365,7 +1365,7 @@ struct cmsghdr* process_timestamp(grpc_tcp* tcp, msghdr* msg,
+   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(next_cmsg));
+   if (serr->ee_errno != ENOMSG ||
+       serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {
+-    LOG(ERROR) << "Unexpected control message";
++    ABSL_LOG(ERROR) << "Unexpected control message";
+     return cmsg;
+   }
+   tcp->tb_list.ProcessTimestamp(serr, opt_stats, tss);
+@@ -1416,7 +1416,7 @@ static bool process_errors(grpc_tcp* tcp) {
+       return processed_err;
+     }
+     if (GPR_UNLIKELY((msg.msg_flags & MSG_CTRUNC) != 0)) {
+-      LOG(ERROR) << "Error message was truncated.";
++      ABSL_LOG(ERROR) << "Error message was truncated.";
+     }
+
+     if (msg.msg_controllen == 0) {
+@@ -1488,15 +1488,15 @@ static bool tcp_write_with_timestamps(grpc_tcp* /*tcp*/, struct msghdr* /*msg*/,
+                                       ssize_t* /*sent_length*/,
+                                       int* /* saved_errno */,
+                                       int /*additional_flags*/) {
+-  LOG(ERROR) << "Write with timestamps not supported for this platform";
+-  CHECK(0);
++  ABSL_LOG(ERROR) << "Write with timestamps not supported for this platform";
++  ABSL_CHECK(0);
+   return false;
+ }
+
+ static void tcp_handle_error(void* /*arg*/ /* grpc_tcp */,
+                              grpc_error_handle /*error*/) {
+-  LOG(ERROR) << "Error handling is not supported for this platform";
+-  CHECK(0);
++  ABSL_LOG(ERROR) << "Error handling is not supported for this platform";
++  ABSL_CHECK(0);
+ }
+ #endif  // GRPC_LINUX_ERRQUEUE
+
+@@ -1535,7 +1535,7 @@ msg_iovlen_type TcpZerocopySendRecord::PopulateIovs(size_t* unwind_slice_idx,
+     ++(out_offset_.slice_idx);
+     out_offset_.byte_idx = 0;
+   }
+-  DCHECK_GT(iov_size, 0u);
++  ABSL_DCHECK_GT(iov_size, 0u);
+   return iov_size;
+ }
+
+@@ -1686,7 +1686,7 @@ static bool tcp_flush(grpc_tcp* tcp, grpc_error_handle* error) {
+       outgoing_slice_idx++;
+       tcp->outgoing_byte_idx = 0;
+     }
+-    CHECK_GT(iov_size, 0u);
++    ABSL_CHECK_GT(iov_size, 0u);
+
+     msg.msg_name = nullptr;
+     msg.msg_namelen = 0;
+@@ -1734,7 +1734,7 @@ static bool tcp_flush(grpc_tcp* tcp, grpc_error_handle* error) {
+       }
+     }
+
+-    CHECK_EQ(tcp->outgoing_byte_idx, 0u);
++    ABSL_CHECK_EQ(tcp->outgoing_byte_idx, 0u);
+     grpc_core::EventLog::Append("tcp-write-outstanding", -sent_length);
+     tcp->bytes_counter += sent_length;
+     trailing = sending_length - static_cast<size_t>(sent_length);
+@@ -1784,7 +1784,7 @@ static void tcp_handle_write(void* arg /* grpc_tcp */,
+     GRPC_TRACE_LOG(tcp, INFO) << "write: delayed";
+     notify_on_write(tcp);
+     // tcp_flush does not populate error if it has returned false.
+-    DCHECK(error.ok());
++    ABSL_DCHECK(error.ok());
+   } else {
+     cb = tcp->write_cb;
+     tcp->write_cb = nullptr;
+@@ -1808,18 +1808,18 @@ static void tcp_write(grpc_endpoint* ep, grpc_slice_buffer* buf,
+     size_t i;
+
+     for (i = 0; i < buf->count; i++) {
+-      LOG(INFO) << "WRITE " << tcp << " (peer=" << tcp->peer_string << ")";
++      ABSL_LOG(INFO) << "WRITE " << tcp << " (peer=" << tcp->peer_string << ")";
+       if (ABSL_VLOG_IS_ON(2)) {
+         char* data =
+             grpc_dump_slice(buf->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-        VLOG(2) << "WRITE DATA: " << data;
++        ABSL_VLOG(2) << "WRITE DATA: " << data;
+         gpr_free(data);
+       }
+     }
+   }
+
+-  CHECK_EQ(tcp->write_cb, nullptr);
+-  DCHECK_EQ(tcp->current_zerocopy_send, nullptr);
++  ABSL_CHECK_EQ(tcp->write_cb, nullptr);
++  ABSL_DCHECK_EQ(tcp->current_zerocopy_send, nullptr);
+
+   if (buf->length == 0) {
+     grpc_core::Closure::Run(
+@@ -1839,7 +1839,7 @@ static void tcp_write(grpc_endpoint* ep, grpc_slice_buffer* buf,
+   }
+   tcp->outgoing_buffer_arg = arg;
+   if (arg) {
+-    CHECK(grpc_event_engine_can_track_errors());
++    ABSL_CHECK(grpc_event_engine_can_track_errors());
+   }
+
+   bool flush_result =
+@@ -1921,7 +1921,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,
+   tcp->base.vtable = &vtable;
+   tcp->peer_string = std::string(peer_string);
+   tcp->fd = grpc_fd_wrapped_fd(em_fd);
+-  CHECK(options.resource_quota != nullptr);
++  ABSL_CHECK(options.resource_quota != nullptr);
+   tcp->memory_owner =
+       options.resource_quota->memory_quota()->CreateMemoryOwner();
+   tcp->self_reservation = tcp->memory_owner.MakeReservation(sizeof(grpc_tcp));
+@@ -1960,7 +1960,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,
+     if (err == 0) {
+       tcp->tcp_zerocopy_send_ctx.set_enabled(true);
+     } else {
+-      LOG(ERROR) << "Failed to set zerocopy options on the socket.";
++      ABSL_LOG(ERROR) << "Failed to set zerocopy options on the socket.";
+     }
+ #endif
+   }
+@@ -1989,7 +1989,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,
+   if (setsockopt(tcp->fd, SOL_TCP, TCP_INQ, &one, sizeof(one)) == 0) {
+     tcp->inq_capable = true;
+   } else {
+-    VLOG(2) << "cannot set inq fd=" << tcp->fd << " errno=" << errno;
++    ABSL_VLOG(2) << "cannot set inq fd=" << tcp->fd << " errno=" << errno;
+     tcp->inq_capable = false;
+   }
+ #else
+@@ -2012,7 +2012,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,
+
+ int grpc_tcp_fd(grpc_endpoint* ep) {
+   grpc_tcp* tcp = reinterpret_cast<grpc_tcp*>(ep);
+-  CHECK(ep->vtable == &vtable);
++  ABSL_CHECK(ep->vtable == &vtable);
+   return grpc_fd_wrapped_fd(tcp->em_fd);
+ }
+
+@@ -2023,7 +2023,7 @@ void grpc_tcp_destroy_and_release_fd(grpc_endpoint* ep, int* fd,
+         grpc_event_engine_endpoint_destroy_and_release_fd(ep, fd, done);
+   }
+   grpc_tcp* tcp = reinterpret_cast<grpc_tcp*>(ep);
+-  CHECK(ep->vtable == &vtable);
++  ABSL_CHECK(ep->vtable == &vtable);
+   tcp->release_fd = fd;
+   tcp->release_fd_cb = done;
+   grpc_slice_buffer_reset_and_unref(&tcp->last_read_buffer);
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc
+index 357412fa9eefe..9497baba69f7a 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc
+@@ -49,8 +49,8 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+@@ -88,7 +88,7 @@ using ::grpc_event_engine::experimental::SliceBuffer;
+
+ static void finish_shutdown(grpc_tcp_server* s) {
+   gpr_mu_lock(&s->mu);
+-  CHECK(s->shutdown);
++  ABSL_CHECK(s->shutdown);
+   gpr_mu_unlock(&s->mu);
+   if (s->shutdown_complete != nullptr) {
+     grpc_core::ExecCtx::Run(DEBUG_LOCATION, s->shutdown_complete,
+@@ -163,7 +163,7 @@ static grpc_error_handle CreateEventEngineListener(
+                       ->GetWrappedFd();
+               if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),
+                               &(addr.len)) < 0) {
+-                LOG(ERROR) << "Failed getpeername: "
++                ABSL_LOG(ERROR) << "Failed getpeername: "
+                            << grpc_core::StrError(errno);
+                 close(fd);
+                 return;
+@@ -171,7 +171,7 @@ static grpc_error_handle CreateEventEngineListener(
+               (void)grpc_set_socket_no_sigpipe_if_possible(fd);
+               auto addr_uri = grpc_sockaddr_to_uri(&addr);
+               if (!addr_uri.ok()) {
+-                LOG(ERROR) << "Invalid address: "
++                ABSL_LOG(ERROR) << "Invalid address: "
+                            << addr_uri.status().ToString();
+                 return;
+               }
+@@ -231,7 +231,7 @@ static grpc_error_handle CreateEventEngineListener(
+     listener = engine->CreateListener(
+         std::move(accept_cb),
+         [s, ee = keeper, shutdown_complete](absl::Status status) {
+-          CHECK_EQ(gpr_atm_no_barrier_load(&s->refs.count), 0);
++          ABSL_CHECK_EQ(gpr_atm_no_barrier_load(&s->refs.count), 0);
+           grpc_event_engine::experimental::RunEventEngineClosure(
+               shutdown_complete, absl_status_to_grpc_error(status));
+           finish_shutdown(s);
+@@ -284,8 +284,8 @@ static grpc_error_handle tcp_server_create(grpc_closure* shutdown_complete,
+   s->nports = 0;
+   s->options = ::TcpOptionsFromEndpointConfig(config);
+   s->fd_handler = nullptr;
+-  CHECK(s->options.resource_quota != nullptr);
+-  CHECK(s->on_accept_cb);
++  ABSL_CHECK(s->options.resource_quota != nullptr);
++  ABSL_CHECK(s->on_accept_cb);
+   s->memory_quota = s->options.resource_quota->memory_quota();
+   s->pre_allocated_fd = -1;
+   gpr_atm_no_barrier_store(&s->next_pollset_to_assign, 0);
+@@ -307,7 +307,7 @@ static void destroyed_port(void* server, grpc_error_handle /*error*/) {
+     gpr_mu_unlock(&s->mu);
+     finish_shutdown(s);
+   } else {
+-    CHECK(s->destroyed_ports < s->nports);
++    ABSL_CHECK(s->destroyed_ports < s->nports);
+     gpr_mu_unlock(&s->mu);
+   }
+ }
+@@ -319,7 +319,7 @@ static void deactivated_all_ports(grpc_tcp_server* s) {
+   // delete ALL the things
+   gpr_mu_lock(&s->mu);
+
+-  CHECK(s->shutdown);
++  ABSL_CHECK(s->shutdown);
+
+   if (s->head) {
+     grpc_tcp_listener* sp;
+@@ -348,7 +348,7 @@ static void deactivated_all_ports(grpc_tcp_server* s) {
+
+ static void tcp_server_destroy(grpc_tcp_server* s) {
+   gpr_mu_lock(&s->mu);
+-  CHECK(!s->shutdown);
++  ABSL_CHECK(!s->shutdown);
+   s->shutdown = true;
+   // shutdown all fd's
+   if (s->active_ports) {
+@@ -391,7 +391,7 @@ static void on_read(void* arg, grpc_error_handle err) {
+       // This is not a performant code path, but if an fd limit has been
+       // reached, the system is likely in an unhappy state regardless.
+       if (errno == EMFILE) {
+-        LOG_EVERY_N_SEC(ERROR, 1) << "File descriptor limit reached. Retrying.";
++        ABSL_LOG_EVERY_N_SEC(ERROR, 1) << "File descriptor limit reached. Retrying.";
+         grpc_fd_notify_on_read(sp->emfd, &sp->read_closure);
+         if (gpr_atm_full_xchg(&sp->retry_timer_armed, true)) return;
+         grpc_timer_init(&sp->retry_timer,
+@@ -405,7 +405,7 @@ static void on_read(void* arg, grpc_error_handle err) {
+       }
+       gpr_mu_lock(&sp->server->mu);
+       if (!sp->server->shutdown_listeners) {
+-        LOG(ERROR) << "Failed accept4: " << grpc_core::StrError(errno);
++        ABSL_LOG(ERROR) << "Failed accept4: " << grpc_core::StrError(errno);
+       } else {
+         // if we have shutdown listeners, accept4 could fail, and we
+         // needn't notify users
+@@ -434,7 +434,7 @@ static void on_read(void* arg, grpc_error_handle err) {
+       if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),
+                       &(addr.len)) < 0) {
+         auto listener_addr_uri = grpc_sockaddr_to_uri(&sp->addr);
+-        LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
++        ABSL_LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
+                    << ". Dropping the connection, and continuing to listen on "
+                    << (listener_addr_uri.ok() ? *listener_addr_uri
+                                               : "<unknown>")
+@@ -454,7 +454,7 @@ static void on_read(void* arg, grpc_error_handle err) {
+
+     auto addr_uri = grpc_sockaddr_to_uri(&addr);
+     if (!addr_uri.ok()) {
+-      LOG(ERROR) << "Invalid address: " << addr_uri.status();
++      ABSL_LOG(ERROR) << "Invalid address: " << addr_uri.status();
+       goto error;
+     }
+     GRPC_TRACE_LOG(tcp, INFO)
+@@ -550,8 +550,8 @@ static grpc_error_handle add_wildcard_addrs_to_server(grpc_tcp_server* s,
+   } else {
+     grpc_error_handle root_err =
+         GRPC_ERROR_CREATE("Failed to add any wildcard listeners");
+-    CHECK(!v6_err.ok());
+-    CHECK(!v4_err.ok());
++    ABSL_CHECK(!v6_err.ok());
++    ABSL_CHECK(!v4_err.ok());
+     root_err = grpc_error_add_child(root_err, v6_err);
+     root_err = grpc_error_add_child(root_err, v4_err);
+     return root_err;
+@@ -602,7 +602,7 @@ static grpc_error_handle clone_port(grpc_tcp_listener* listener,
+     sp->port = port;
+     sp->port_index = listener->port_index;
+     sp->fd_index = listener->fd_index + count - i;
+-    CHECK(sp->emfd);
++    ABSL_CHECK(sp->emfd);
+     grpc_tcp_server_listener_initialize_retry_timer(sp);
+     while (listener->server->tail->next != nullptr) {
+       listener->server->tail = listener->server->tail->next;
+@@ -634,7 +634,7 @@ static grpc_error_handle tcp_server_add_port(grpc_tcp_server* s,
+             if (!listen_fd.ok()) {
+               return;
+             }
+-            DCHECK_GT(*listen_fd, 0);
++            ABSL_DCHECK_GT(*listen_fd, 0);
+             s->listen_fd_to_index_map.insert_or_assign(
+                 *listen_fd, std::make_tuple(s->n_bind_ports, fd_index++));
+           });
+@@ -649,7 +649,7 @@ static grpc_error_handle tcp_server_add_port(grpc_tcp_server* s,
+     gpr_mu_unlock(&s->mu);
+     return port.status();
+   }
+-  CHECK(addr->len <= GRPC_MAX_SOCKADDR_SIZE);
++  ABSL_CHECK(addr->len <= GRPC_MAX_SOCKADDR_SIZE);
+   grpc_tcp_listener* sp;
+   grpc_resolved_address sockname_temp;
+   grpc_resolved_address addr6_v4mapped;
+@@ -777,12 +777,12 @@ static void tcp_server_start(grpc_tcp_server* s,
+   size_t i;
+   grpc_tcp_listener* sp;
+   gpr_mu_lock(&s->mu);
+-  CHECK(s->on_accept_cb);
+-  CHECK_EQ(s->active_ports, 0u);
++  ABSL_CHECK(s->on_accept_cb);
++  ABSL_CHECK_EQ(s->active_ports, 0u);
+   s->pollsets = pollsets;
+   if (grpc_event_engine::experimental::UseEventEngineListener()) {
+-    CHECK(!s->shutdown_listeners);
+-    CHECK(GRPC_LOG_IF_ERROR("listener_start", s->ee_listener->Start()));
++    ABSL_CHECK(!s->shutdown_listeners);
++    ABSL_CHECK(GRPC_LOG_IF_ERROR("listener_start", s->ee_listener->Start()));
+     gpr_mu_unlock(&s->mu);
+     return;
+   }
+@@ -790,7 +790,7 @@ static void tcp_server_start(grpc_tcp_server* s,
+   while (sp != nullptr) {
+     if (s->so_reuseport && !grpc_is_unix_socket(&sp->addr) &&
+         !grpc_is_vsock(&sp->addr) && pollsets->size() > 1) {
+-      CHECK(GRPC_LOG_IF_ERROR(
++      ABSL_CHECK(GRPC_LOG_IF_ERROR(
+           "clone_port", clone_port(sp, (unsigned)(pollsets->size() - 1))));
+       for (i = 0; i < pollsets->size(); i++) {
+         grpc_pollset_add_fd((*pollsets)[i], sp->emfd);
+@@ -882,14 +882,14 @@ class ExternalConnectionHandler : public grpc_core::TcpServerFdHandler {
+           grpc_event_engine::experimental::QueryExtension<
+               grpc_event_engine::experimental::ListenerSupportsFdExtension>(
+               s_->ee_listener.get());
+-      CHECK_NE(listener_supports_fd, nullptr);
++      ABSL_CHECK_NE(listener_supports_fd, nullptr);
+       grpc_event_engine::experimental::SliceBuffer pending_data;
+       if (buf != nullptr) {
+         pending_data =
+             grpc_event_engine::experimental::SliceBuffer::TakeCSliceBuffer(
+                 buf->data.raw.slice_buffer);
+       }
+-      CHECK(GRPC_LOG_IF_ERROR("listener_handle_external_connection",
++      ABSL_CHECK(GRPC_LOG_IF_ERROR("listener_handle_external_connection",
+                               listener_supports_fd->HandleExternalConnection(
+                                   listener_fd, fd, &pending_data)));
+       return;
+@@ -902,14 +902,14 @@ class ExternalConnectionHandler : public grpc_core::TcpServerFdHandler {
+
+     if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),
+                     &(addr.len)) < 0) {
+-      LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno);
++      ABSL_LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno);
+       close(fd);
+       return;
+     }
+     (void)grpc_set_socket_no_sigpipe_if_possible(fd);
+     auto addr_uri = grpc_sockaddr_to_uri(&addr);
+     if (!addr_uri.ok()) {
+-      LOG(ERROR) << "Invalid address: " << addr_uri.status();
++      ABSL_LOG(ERROR) << "Invalid address: " << addr_uri.status();
+       return;
+     }
+     GRPC_TRACE_LOG(tcp, INFO)
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
+index 638e32216143f..f2b790b690570 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
+@@ -33,8 +33,8 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/iomgr/error.h"
+@@ -70,7 +70,7 @@ static void init_max_accept_queue_size(void) {
+   s_max_accept_queue_size = n;
+
+   if (s_max_accept_queue_size < MIN_SAFE_ACCEPT_QUEUE_SIZE) {
+-    LOG(INFO) << "Suspiciously small accept queue (" << s_max_accept_queue_size
++    ABSL_LOG(INFO) << "Suspiciously small accept queue (" << s_max_accept_queue_size
+               << ") will probably lead to connection drops";
+   }
+ }
+@@ -109,7 +109,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
+   grpc_error_handle err =
+       grpc_tcp_server_prepare_socket(s, fd, addr, s->so_reuseport, &port);
+   if (!err.ok()) return err;
+-  CHECK_GT(port, 0);
++  ABSL_CHECK_GT(port, 0);
+   absl::StatusOr<std::string> addr_str = grpc_sockaddr_to_string(addr, true);
+   if (!addr_str.ok()) {
+     return GRPC_ERROR_CREATE(addr_str.status().ToString());
+@@ -142,7 +142,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
+   sp->fd_index = fd_index;
+   sp->is_sibling = 0;
+   sp->sibling = nullptr;
+-  CHECK(sp->emfd);
++  ABSL_CHECK(sp->emfd);
+   gpr_mu_unlock(&s->mu);
+
+   *listener = sp;
+@@ -206,7 +206,7 @@ grpc_error_handle grpc_tcp_server_prepare_socket(
+   grpc_resolved_address sockname_temp;
+   grpc_error_handle err;
+
+-  CHECK_GE(fd, 0);
++  ABSL_CHECK_GE(fd, 0);
+
+   if (so_reuseport && !grpc_is_unix_socket(addr) && !grpc_is_vsock(addr)) {
+     err = grpc_set_socket_reuse_port(fd, 1);
+@@ -217,7 +217,7 @@ grpc_error_handle grpc_tcp_server_prepare_socket(
+   err = grpc_set_socket_zerocopy(fd);
+   if (!err.ok()) {
+     // it's not fatal, so just log it.
+-    VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
++    ABSL_VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
+   }
+ #endif
+   err = grpc_set_socket_nonblocking(fd, 1);
+@@ -269,7 +269,7 @@ grpc_error_handle grpc_tcp_server_prepare_socket(
+   return absl::OkStatus();
+
+ error:
+-  CHECK(!err.ok());
++  ABSL_CHECK(!err.ok());
+   if (fd >= 0) {
+     close(fd);
+   }
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc
+index 1f130682fbc33..c8d5a8e650ef0 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc
+@@ -31,8 +31,8 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/iomgr/error.h"
+@@ -113,7 +113,7 @@ grpc_error_handle grpc_tcp_server_add_all_local_addrs(grpc_tcp_server* s,
+     } else if (requested_port <= 0) {
+       return GRPC_ERROR_CREATE("Bad get_unused_port()");
+     }
+-    VLOG(2) << "Picked unused port " << requested_port;
++    ABSL_VLOG(2) << "Picked unused port " << requested_port;
+   }
+
+   static bool v4_available = grpc_is_ipv4_available();
+@@ -148,13 +148,13 @@ grpc_error_handle grpc_tcp_server_add_all_local_addrs(grpc_tcp_server* s,
+     if (!addr_str.ok()) {
+       return GRPC_ERROR_CREATE(addr_str.status().ToString());
+     }
+-    VLOG(2) << absl::StrFormat(
++    ABSL_VLOG(2) << absl::StrFormat(
+         "Adding local addr from interface %s flags 0x%x to server: %s",
+         ifa_name, ifa_it->ifa_flags, addr_str->c_str());
+     // We could have multiple interfaces with the same address (e.g., bonding),
+     // so look for duplicates.
+     if (find_listener_with_addr(s, &addr) != nullptr) {
+-      VLOG(2) << "Skipping duplicate addr " << *addr_str << " on interface "
++      ABSL_VLOG(2) << "Skipping duplicate addr " << *addr_str << " on interface "
+               << ifa_name;
+       continue;
+     }
+@@ -165,7 +165,7 @@ grpc_error_handle grpc_tcp_server_add_all_local_addrs(grpc_tcp_server* s,
+       err = grpc_error_add_child(root_err, err);
+       break;
+     } else {
+-      CHECK(requested_port == new_sp->port);
++      ABSL_CHECK(requested_port == new_sp->port);
+       ++fd_index;
+       if (sp != nullptr) {
+         new_sp->is_sibling = 1;
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc
+index e4abafb296cc2..dcd580f9f189f 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc
+@@ -35,8 +35,8 @@
+
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/event_engine/memory_allocator_factory.h"
+@@ -291,7 +291,7 @@ static grpc_error_handle prepare_socket(SOCKET sock,
+   return absl::OkStatus();
+
+ failure:
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   error = grpc_error_set_int(GRPC_ERROR_CREATE_REFERENCING(
+                                  "Failed to prepare server socket", &error, 1),
+                              grpc_core::StatusIntProperty::kFd, (intptr_t)sock);
+@@ -301,7 +301,7 @@ failure:
+
+ static void decrement_active_ports_and_notify_locked(grpc_tcp_listener* sp) {
+   sp->shutting_down = 0;
+-  CHECK_GT(sp->server->active_ports, 0u);
++  ABSL_CHECK_GT(sp->server->active_ports, 0u);
+   if (0 == --sp->server->active_ports) {
+     finish_shutdown_locked(sp->server);
+   }
+@@ -359,7 +359,7 @@ static grpc_error_handle start_accept_locked(grpc_tcp_listener* port) {
+   return error;
+
+ failure:
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   if (sock != INVALID_SOCKET) closesocket(sock);
+   return error;
+ }
+@@ -384,7 +384,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
+   // this is necessary in the read/write case, it's useless for the accept
+   // case. We only need to adjust the pending callback count
+   if (!error.ok()) {
+-    VLOG(2) << "Skipping on_accept due to error: "
++    ABSL_VLOG(2) << "Skipping on_accept due to error: "
+             << grpc_core::StatusToString(error);
+
+     gpr_mu_unlock(&sp->server->mu);
+@@ -398,7 +398,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
+   if (!wsa_success) {
+     if (!sp->shutting_down) {
+       char* utf8_message = gpr_format_message(WSAGetLastError());
+-      LOG(ERROR) << "on_accept error: " << utf8_message;
++      ABSL_LOG(ERROR) << "on_accept error: " << utf8_message;
+       gpr_free(utf8_message);
+     }
+     closesocket(sock);
+@@ -408,7 +408,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
+                        (char*)&sp->socket->socket, sizeof(sp->socket->socket));
+       if (err) {
+         char* utf8_message = gpr_format_message(WSAGetLastError());
+-        LOG(ERROR) << "setsockopt error: " << utf8_message;
++        ABSL_LOG(ERROR) << "setsockopt error: " << utf8_message;
+         gpr_free(utf8_message);
+       }
+       int peer_name_len = (int)peer_name.len;
+@@ -420,11 +420,11 @@ static void on_accept(void* arg, grpc_error_handle error) {
+         if (addr_uri.ok()) {
+           peer_name_string = addr_uri.value();
+         } else {
+-          LOG(ERROR) << "invalid peer name: " << addr_uri.status();
++          ABSL_LOG(ERROR) << "invalid peer name: " << addr_uri.status();
+         }
+       } else {
+         char* utf8_message = gpr_format_message(WSAGetLastError());
+-        LOG(ERROR) << "getpeername error: " << utf8_message;
++        ABSL_LOG(ERROR) << "getpeername error: " << utf8_message;
+         gpr_free(utf8_message);
+       }
+       std::string fd_name = absl::StrCat("tcp_server:", peer_name_string);
+@@ -451,7 +451,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
+   // the former socked we created has now either been destroy or assigned
+   // to the new connection. We need to create a new one for the next
+   // connection.
+-  CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
++  ABSL_CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
+   if (0 == --sp->outstanding_calls) {
+     decrement_active_ports_and_notify_locked(sp);
+   }
+@@ -487,7 +487,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, SOCKET sock,
+     return error;
+   }
+
+-  CHECK_GE(port, 0);
++  ABSL_CHECK_GE(port, 0);
+   gpr_mu_lock(&s->mu);
+   sp = (grpc_tcp_listener*)gpr_malloc(sizeof(grpc_tcp_listener));
+   sp->next = NULL;
+@@ -507,7 +507,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, SOCKET sock,
+   sp->port = port;
+   sp->port_index = port_index;
+   GRPC_CLOSURE_INIT(&sp->on_accept, on_accept, sp, grpc_schedule_on_exec_ctx);
+-  CHECK(sp->socket);
++  ABSL_CHECK(sp->socket);
+   gpr_mu_unlock(&s->mu);
+   *listener = sp;
+
+@@ -584,7 +584,7 @@ done:
+     error = error_out;
+     *port = -1;
+   } else {
+-    CHECK(sp != NULL);
++    ABSL_CHECK(sp != NULL);
+     *port = sp->port;
+   }
+   return error;
+@@ -594,9 +594,9 @@ static void tcp_server_start(grpc_tcp_server* s,
+                              const std::vector<grpc_pollset*>* /*pollsets*/) {
+   grpc_tcp_listener* sp;
+   gpr_mu_lock(&s->mu);
+-  CHECK_EQ(s->active_ports, 0u);
++  ABSL_CHECK_EQ(s->active_ports, 0u);
+   for (sp = s->head; sp; sp = sp->next) {
+-    CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
++    ABSL_CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
+     s->active_ports++;
+   }
+   gpr_mu_unlock(&s->mu);
+@@ -646,7 +646,7 @@ static grpc_error_handle event_engine_create(grpc_closure* shutdown_complete,
+   WindowsEventEngine* engine_ptr = reinterpret_cast<WindowsEventEngine*>(
+       config.GetVoidPointer(GRPC_INTERNAL_ARG_EVENT_ENGINE));
+   grpc_tcp_server* s = (grpc_tcp_server*)gpr_malloc(sizeof(grpc_tcp_server));
+-  CHECK_NE(on_accept_cb, nullptr);
++  ABSL_CHECK_NE(on_accept_cb, nullptr);
+   auto accept_cb = [s, on_accept_cb, on_accept_cb_arg](
+                        std::unique_ptr<EventEngine::Endpoint> endpoint,
+                        MemoryAllocator memory_allocator) {
+@@ -668,7 +668,7 @@ static grpc_error_handle event_engine_create(grpc_closure* shutdown_complete,
+   grpc_core::RefCountedPtr<grpc_core::ResourceQuota> resource_quota;
+   {
+     void* tmp_quota = config.GetVoidPointer(GRPC_ARG_RESOURCE_QUOTA);
+-    CHECK_NE(tmp_quota, nullptr);
++    ABSL_CHECK_NE(tmp_quota, nullptr);
+     resource_quota =
+         reinterpret_cast<grpc_core::ResourceQuota*>(tmp_quota)->Ref();
+   }
+@@ -699,13 +699,13 @@ static grpc_error_handle event_engine_create(grpc_closure* shutdown_complete,
+
+ static void event_engine_start(grpc_tcp_server* s,
+                                const std::vector<grpc_pollset*>* /*pollsets*/) {
+-  CHECK(s->ee_listener->Start().ok());
++  ABSL_CHECK(s->ee_listener->Start().ok());
+ }
+
+ static grpc_error_handle event_engine_add_port(
+     grpc_tcp_server* s, const grpc_resolved_address* addr, int* port) {
+-  CHECK_NE(addr, nullptr);
+-  CHECK_NE(port, nullptr);
++  ABSL_CHECK_NE(addr, nullptr);
++  ABSL_CHECK_NE(port, nullptr);
+   auto ee_addr = CreateResolvedAddress(*addr);
+   auto out_port = s->ee_listener->Bind(ee_addr);
+   *port = out_port.ok() ? *out_port : -1;
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc
+index e52ca28089f3d..bc9ccc91226e5 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc
+@@ -27,8 +27,8 @@
+ #include <grpc/support/string_util.h>
+ #include <limits.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/iomgr/iocp_windows.h"
+ #include "src/core/lib/iomgr/sockaddr.h"
+@@ -138,7 +138,7 @@ static void tcp_unref(grpc_tcp* tcp, const char* reason, const char* file,
+                       int line) {
+   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&tcp->refcount.count);
+-    VLOG(2).AtLocation(file, line) << "TCP unref " << tcp << " : " << reason
++    ABSL_VLOG(2).AtLocation(file, line) << "TCP unref " << tcp << " : " << reason
+                                    << " " << val << " -> " << val - 1;
+   }
+   if (gpr_unref(&tcp->refcount)) {
+@@ -150,7 +150,7 @@ static void tcp_ref(grpc_tcp* tcp, const char* reason, const char* file,
+                     int line) {
+   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
+     gpr_atm val = gpr_atm_no_barrier_load(&tcp->refcount.count);
+-    VLOG(2).AtLocation(file, line) << "TCP   ref " << tcp << " : " << reason
++    ABSL_VLOG(2).AtLocation(file, line) << "TCP   ref " << tcp << " : " << reason
+                                    << " " << val << " -> " << val + 1;
+   }
+   gpr_ref(&tcp->refcount);
+@@ -182,7 +182,7 @@ static void on_read(void* tcpp, grpc_error_handle error) {
+       grpc_slice_buffer_reset_and_unref(tcp->read_slices);
+     } else {
+       if (info->bytes_transferred != 0 && !tcp->shutting_down) {
+-        CHECK((size_t)info->bytes_transferred <= tcp->read_slices->length);
++        ABSL_CHECK((size_t)info->bytes_transferred <= tcp->read_slices->length);
+         if (static_cast<size_t>(info->bytes_transferred) !=
+             tcp->read_slices->length) {
+           grpc_slice_buffer_trim_end(
+@@ -191,14 +191,14 @@ static void on_read(void* tcpp, grpc_error_handle error) {
+                   static_cast<size_t>(info->bytes_transferred),
+               &tcp->last_read_buffer);
+         }
+-        CHECK((size_t)info->bytes_transferred == tcp->read_slices->length);
++        ABSL_CHECK((size_t)info->bytes_transferred == tcp->read_slices->length);
+
+         if (GRPC_TRACE_FLAG_ENABLED(tcp) && ABSL_VLOG_IS_ON(2)) {
+           size_t i;
+           for (i = 0; i < tcp->read_slices->count; i++) {
+             char* dump = grpc_dump_slice(tcp->read_slices->slices[i],
+                                          GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-            VLOG(2) << "READ " << tcp << " (peer=" << tcp->peer_string
++            ABSL_VLOG(2) << "READ " << tcp << " (peer=" << tcp->peer_string
+                     << "): " << dump;
+             gpr_free(dump);
+           }
+@@ -256,7 +256,7 @@ static void win_read(grpc_endpoint* ep, grpc_slice_buffer* read_slices,
+                           GRPC_SLICE_MALLOC(DEFAULT_TARGET_READ_SIZE));
+   }
+
+-  CHECK(tcp->read_slices->count <= MAX_WSABUF_COUNT);
++  ABSL_CHECK(tcp->read_slices->count <= MAX_WSABUF_COUNT);
+   for (i = 0; i < tcp->read_slices->count; i++) {
+     buffers[i].len = (ULONG)GRPC_SLICE_LENGTH(
+         tcp->read_slices->slices[i]);  // we know slice size fits in 32bit.
+@@ -313,7 +313,7 @@ static void on_write(void* tcpp, grpc_error_handle error) {
+     if (info->wsa_error != 0) {
+       error = GRPC_WSA_ERROR(info->wsa_error, "WSASend");
+     } else {
+-      CHECK(info->bytes_transferred <= tcp->write_slices->length);
++      ABSL_CHECK(info->bytes_transferred <= tcp->write_slices->length);
+     }
+   }
+
+@@ -341,7 +341,7 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,
+     for (i = 0; i < slices->count; i++) {
+       char* data =
+           grpc_dump_slice(slices->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
+-      VLOG(2) << "WRITE " << tcp << " (peer=" << tcp->peer_string
++      ABSL_VLOG(2) << "WRITE " << tcp << " (peer=" << tcp->peer_string
+               << "): " << data;
+       gpr_free(data);
+     }
+@@ -358,7 +358,7 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,
+
+   tcp->write_cb = cb;
+   tcp->write_slices = slices;
+-  CHECK(tcp->write_slices->count <= UINT_MAX);
++  ABSL_CHECK(tcp->write_slices->count <= UINT_MAX);
+   if (tcp->write_slices->count > GPR_ARRAY_SIZE(local_buffers)) {
+     buffers = (WSABUF*)gpr_malloc(sizeof(WSABUF) * tcp->write_slices->count);
+     allocated = buffers;
+@@ -366,7 +366,7 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,
+
+   for (i = 0; i < tcp->write_slices->count; i++) {
+     len = GRPC_SLICE_LENGTH(tcp->write_slices->slices[i]);
+-    CHECK(len <= ULONG_MAX);
++    ABSL_CHECK(len <= ULONG_MAX);
+     buffers[i].len = (ULONG)len;
+     buffers[i].buf = (char*)GRPC_SLICE_START_PTR(tcp->write_slices->slices[i]);
+   }
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc b/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc
+index 19f9e67f22cf0..f6fc400fe90a0 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc
+@@ -24,8 +24,8 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -116,7 +116,7 @@ static bool is_in_ht(grpc_timer* t) {
+ }
+
+ static void add_to_ht(grpc_timer* t) {
+-  CHECK(!t->hash_table_next);
++  ABSL_CHECK(!t->hash_table_next);
+   size_t i = grpc_core::HashPointer(t, NUM_HASH_BUCKETS);
+
+   gpr_mu_lock(&g_hash_mu[i]);
+@@ -661,7 +661,7 @@ static grpc_timer_check_result timer_check(grpc_core::Timestamp* next) {
+       next_str = absl::StrCat(next->milliseconds_after_process_epoch());
+     }
+ #if GPR_ARCH_64
+-    VLOG(2) << "TIMER CHECK BEGIN: now="
++    ABSL_VLOG(2) << "TIMER CHECK BEGIN: now="
+             << now.milliseconds_after_process_epoch() << " next=" << next_str
+             << " tls_min=" << min_timer.milliseconds_after_process_epoch()
+             << " glob_min="
+@@ -670,7 +670,7 @@ static grpc_timer_check_result timer_check(grpc_core::Timestamp* next) {
+                        (gpr_atm*)(&g_shared_mutables.min_timer)))
+                    .milliseconds_after_process_epoch();
+ #else
+-    VLOG(2) << "TIMER CHECK BEGIN: now="
++    ABSL_VLOG(2) << "TIMER CHECK BEGIN: now="
+             << now.milliseconds_after_process_epoch() << " next=" << next_str
+             << " min=" << min_timer.milliseconds_after_process_epoch();
+ #endif
+@@ -686,7 +686,7 @@ static grpc_timer_check_result timer_check(grpc_core::Timestamp* next) {
+     } else {
+       next_str = absl::StrCat(next->milliseconds_after_process_epoch());
+     }
+-    VLOG(2) << "TIMER CHECK END: r=" << r << "; next=" << next_str.c_str();
++    ABSL_VLOG(2) << "TIMER CHECK END: r=" << r << "; next=" << next_str.c_str();
+   }
+   return r;
+ }
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc b/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc
+index 81d1e8816c0d2..edcd7cbb26a8d 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc
+@@ -22,8 +22,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <inttypes.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/timer.h"
+ #include "src/core/util/crash.h"
+@@ -80,7 +80,7 @@ static void gc_completed_threads(void) {
+ }
+
+ static void start_timer_thread_and_unlock(void) {
+-  CHECK(g_threaded);
++  ABSL_CHECK(g_threaded);
+   ++g_waiter_count;
+   ++g_thread_count;
+   gpr_mu_unlock(&g_mu);
+@@ -179,7 +179,7 @@ static bool wait_until(grpc_core::Timestamp next) {
+
+         if (GRPC_TRACE_FLAG_ENABLED(timer_check)) {
+           grpc_core::Duration wait_time = next - grpc_core::Timestamp::Now();
+-          LOG(INFO) << "sleep for a " << wait_time.millis() << " milliseconds";
++          ABSL_LOG(INFO) << "sleep for a " << wait_time.millis() << " milliseconds";
+         }
+       } else {  // g_timed_waiter == true && next >= g_timed_waiter_deadline
+         next = grpc_core::Timestamp::InfFuture();
+@@ -188,7 +188,7 @@ static bool wait_until(grpc_core::Timestamp next) {
+
+     if (GRPC_TRACE_FLAG_ENABLED(timer_check) &&
+         next == grpc_core::Timestamp::InfFuture()) {
+-      LOG(INFO) << "sleep until kicked";
++      ABSL_LOG(INFO) << "sleep until kicked";
+     }
+
+     gpr_cv_wait(&g_cv_wait, &g_mu, next.as_timespec(GPR_CLOCK_MONOTONIC));
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc
+index 90ae7817d7818..6a81053a13a07 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc
+@@ -35,7 +35,7 @@
+
+ #include <grpc/support/alloc.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/address_utils/parse_address.h"
+ #include "src/core/lib/iomgr/sockaddr.h"
+@@ -48,7 +48,7 @@ void grpc_create_socketpair_if_unix(int sv[2]) {
+ #ifdef GPR_WINDOWS
+   grpc_core::Crash("AF_UNIX socket pairs are not supported on Windows");
+ #else
+-  CHECK_EQ(socketpair(AF_UNIX, SOCK_STREAM, 0, sv), 0);
++  ABSL_CHECK_EQ(socketpair(AF_UNIX, SOCK_STREAM, 0, sv), 0);
+ #endif
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc
+index ca5086d9f70d6..24c1bea974eea 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc
+@@ -24,13 +24,13 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ void grpc_create_socketpair_if_unix(int /* sv */[2]) {
+   // TODO: Either implement this for the non-Unix socket case or make
+   // sure that it is never called in any such case. Until then, leave an
+   // assertion to notify if this gets called inadvertently
+-  CHECK(0);
++  ABSL_CHECK(0);
+ }
+
+ absl::StatusOr<std::vector<grpc_resolved_address>>
+diff --git a/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc b/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc
+index e48aafaf361c6..e1bec23c39a52 100644
+--- a/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc
++++ b/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc
+@@ -26,7 +26,7 @@
+ #include <string.h>
+ #include <unistd.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/socket_utils_posix.h"
+ #include "src/core/lib/iomgr/wakeup_fd_pipe.h"
+ #include "src/core/lib/iomgr/wakeup_fd_posix.h"
+@@ -37,7 +37,7 @@ static grpc_error_handle pipe_init(grpc_wakeup_fd* fd_info) {
+   int pipefd[2];
+   int r = pipe(pipefd);
+   if (0 != r) {
+-    LOG(ERROR) << "pipe creation failed (" << errno
++    ABSL_LOG(ERROR) << "pipe creation failed (" << errno
+                << "): " << grpc_core::StrError(errno);
+     return GRPC_OS_ERROR(errno, "pipe");
+   }
+diff --git a/third_party/grpc/source/src/core/lib/promise/activity.cc b/third_party/grpc/source/src/core/lib/promise/activity.cc
+index 5c067f46c7933..50f95ee00bed8 100644
+--- a/third_party/grpc/source/src/core/lib/promise/activity.cc
++++ b/third_party/grpc/source/src/core/lib/promise/activity.cc
+@@ -19,7 +19,7 @@
+
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/str_join.h"
+@@ -55,7 +55,7 @@ class FreestandingActivity::Handle final : public Wakeable {
+   // Activity is going away... drop its reference and sever the connection back.
+   void DropActivity() ABSL_LOCKS_EXCLUDED(mu_) {
+     mu_.Lock();
+-    CHECK_NE(activity_, nullptr);
++    ABSL_CHECK_NE(activity_, nullptr);
+     activity_ = nullptr;
+     mu_.Unlock();
+     Unref();
+diff --git a/third_party/grpc/source/src/core/lib/promise/activity.h b/third_party/grpc/source/src/core/lib/promise/activity.h
+index d08ef2dd6a4d4..362ce86d5364b 100644
+--- a/third_party/grpc/source/src/core/lib/promise/activity.h
++++ b/third_party/grpc/source/src/core/lib/promise/activity.h
+@@ -26,7 +26,7 @@
+ #include <utility>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -511,11 +511,11 @@ class PromiseActivity final
+     // We shouldn't destruct without calling Cancel() first, and that must get
+     // us to be done_, so we assume that and have no logic to destruct the
+     // promise here.
+-    CHECK(done_);
++    ABSL_CHECK(done_);
+   }
+
+   void RunScheduledWakeup() {
+-    CHECK(wakeup_scheduled_.exchange(false, std::memory_order_acq_rel));
++    ABSL_CHECK(wakeup_scheduled_.exchange(false, std::memory_order_acq_rel));
+     Step();
+     WakeupComplete();
+   }
+@@ -581,7 +581,7 @@ class PromiseActivity final
+   // Notification that we're no longer executing - it's ok to destruct the
+   // promise.
+   void MarkDone() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()) {
+-    CHECK(!std::exchange(done_, true));
++    ABSL_CHECK(!std::exchange(done_, true));
+     ScopedContext contexts(this);
+     Destruct(&promise_holder_.promise);
+   }
+@@ -628,10 +628,10 @@ class PromiseActivity final
+   // Until there are no wakeups from within and the promise is incomplete:
+   // poll the promise.
+   std::optional<ResultType> StepLoop() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()) {
+-    CHECK(is_current());
++    ABSL_CHECK(is_current());
+     while (true) {
+       // Run the promise.
+-      CHECK(!done_);
++      ABSL_CHECK(!done_);
+       auto r = promise_holder_.promise();
+       if (auto* status = r.value_if_ready()) {
+         // If complete, destroy the promise, flag done, and exit this loop.
+diff --git a/third_party/grpc/source/src/core/lib/promise/context.h b/third_party/grpc/source/src/core/lib/promise/context.h
+index 65ee6f1a4a8ab..ab806ae72df1e 100644
+--- a/third_party/grpc/source/src/core/lib/promise/context.h
++++ b/third_party/grpc/source/src/core/lib/promise/context.h
+@@ -19,7 +19,7 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/meta/type_traits.h"
+ #include "src/core/util/down_cast.h"
+
+@@ -113,7 +113,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline bool HasContext() {
+ template <typename T>
+ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline T* GetContext() {
+   auto* p = promise_detail::Context<T>::get();
+-  DCHECK_NE(p, nullptr);
++  ABSL_DCHECK_NE(p, nullptr);
+   return p;
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/promise/detail/join_state.h b/third_party/grpc/source/src/core/lib/promise/detail/join_state.h
+index 767ca8d787dfe..44695690d150b 100644
+--- a/third_party/grpc/source/src/core/lib/promise/detail/join_state.h
++++ b/third_party/grpc/source/src/core/lib/promise/detail/join_state.h
+@@ -23,8 +23,8 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/promise/detail/promise_like.h"
+ #include "src/core/lib/promise/poll.h"
+@@ -58,14 +58,14 @@ struct JoinState<Traits, P0, P1> {
+     Construct(&promise1, std::forward<P1>(p1));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+   }
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+   }
+@@ -164,7 +164,7 @@ struct JoinState<Traits, P0, P1, P2> {
+     Construct(&promise2, std::forward<P2>(p2));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+     Construct(&promise2, other.promise2);
+@@ -172,7 +172,7 @@ struct JoinState<Traits, P0, P1, P2> {
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+     Construct(&promise2, std::move(other.promise2));
+@@ -308,7 +308,7 @@ struct JoinState<Traits, P0, P1, P2, P3> {
+     Construct(&promise3, std::forward<P3>(p3));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+     Construct(&promise2, other.promise2);
+@@ -317,7 +317,7 @@ struct JoinState<Traits, P0, P1, P2, P3> {
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+     Construct(&promise2, std::move(other.promise2));
+@@ -489,7 +489,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4> {
+     Construct(&promise4, std::forward<P4>(p4));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+     Construct(&promise2, other.promise2);
+@@ -499,7 +499,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4> {
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+     Construct(&promise2, std::move(other.promise2));
+@@ -707,7 +707,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5> {
+     Construct(&promise5, std::forward<P5>(p5));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+     Construct(&promise2, other.promise2);
+@@ -718,7 +718,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5> {
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+     Construct(&promise2, std::move(other.promise2));
+@@ -962,7 +962,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6> {
+     Construct(&promise6, std::forward<P6>(p6));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+     Construct(&promise2, other.promise2);
+@@ -974,7 +974,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6> {
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+     Construct(&promise2, std::move(other.promise2));
+@@ -1254,7 +1254,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7> {
+     Construct(&promise7, std::forward<P7>(p7));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+     Construct(&promise2, other.promise2);
+@@ -1267,7 +1267,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7> {
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+     Construct(&promise2, std::move(other.promise2));
+@@ -1582,7 +1582,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7, P8> {
+     Construct(&promise8, std::forward<P8>(p8));
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, other.promise0);
+     Construct(&promise1, other.promise1);
+     Construct(&promise2, other.promise2);
+@@ -1596,7 +1596,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7, P8> {
+   JoinState& operator=(const JoinState& other) = delete;
+   JoinState& operator=(JoinState&& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
+-    DCHECK(other.ready.none());
++    ABSL_DCHECK(other.ready.none());
+     Construct(&promise0, std::move(other.promise0));
+     Construct(&promise1, std::move(other.promise1));
+     Construct(&promise2, std::move(other.promise2));
+diff --git a/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h b/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h
+index db42681018c40..d2d2b5ad4f6ac 100644
+--- a/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h
++++ b/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h
+@@ -23,8 +23,8 @@
+ #include <utility>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/promise/detail/promise_factory.h"
+@@ -120,14 +120,14 @@ struct SeqState<Traits, P, F0> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.current_promise, other.prior.current_promise);
+     Construct(&prior.next_factory, other.prior.next_factory);
+   }
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.current_promise, std::move(other.prior.current_promise));
+     Construct(&prior.next_factory, std::move(other.prior.next_factory));
+   }
+@@ -244,7 +244,7 @@ struct SeqState<Traits, P, F0, F1> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.current_promise, other.prior.prior.current_promise);
+     Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
+     Construct(&prior.next_factory, other.prior.next_factory);
+@@ -252,7 +252,7 @@ struct SeqState<Traits, P, F0, F1> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.current_promise,
+               std::move(other.prior.prior.current_promise));
+     Construct(&prior.prior.next_factory,
+@@ -420,7 +420,7 @@ struct SeqState<Traits, P, F0, F1, F2> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.current_promise,
+               other.prior.prior.prior.current_promise);
+     Construct(&prior.prior.prior.next_factory,
+@@ -431,7 +431,7 @@ struct SeqState<Traits, P, F0, F1, F2> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.current_promise,
+               std::move(other.prior.prior.prior.current_promise));
+     Construct(&prior.prior.prior.next_factory,
+@@ -648,7 +648,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.current_promise,
+               other.prior.prior.prior.prior.current_promise);
+     Construct(&prior.prior.prior.prior.next_factory,
+@@ -661,7 +661,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.current_promise,
+               std::move(other.prior.prior.prior.prior.current_promise));
+     Construct(&prior.prior.prior.prior.next_factory,
+@@ -936,7 +936,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.current_promise,
+               other.prior.prior.prior.prior.prior.current_promise);
+     Construct(&prior.prior.prior.prior.prior.next_factory,
+@@ -951,7 +951,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.current_promise,
+               std::move(other.prior.prior.prior.prior.prior.current_promise));
+     Construct(&prior.prior.prior.prior.prior.next_factory,
+@@ -1279,7 +1279,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.current_promise,
+               other.prior.prior.prior.prior.prior.prior.current_promise);
+     Construct(&prior.prior.prior.prior.prior.prior.next_factory,
+@@ -1296,7 +1296,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(
+         &prior.prior.prior.prior.prior.prior.current_promise,
+         std::move(other.prior.prior.prior.prior.prior.prior.current_promise));
+@@ -1679,7 +1679,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
+               other.prior.prior.prior.prior.prior.prior.prior.current_promise);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
+@@ -1698,7 +1698,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(
+         &prior.prior.prior.prior.prior.prior.prior.current_promise,
+         std::move(
+@@ -2139,7 +2139,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(
+         &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
+         other.prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
+@@ -2162,7 +2162,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
+               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
+                             .current_promise));
+@@ -2663,7 +2663,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(
+         &prior.prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
+         other.prior.prior.prior.prior.prior.prior.prior.prior.prior
+@@ -2691,7 +2691,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(
+         &prior.prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
+         std::move(other.prior.prior.prior.prior.prior.prior.prior.prior.prior
+@@ -3255,7 +3255,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+                    .current_promise,
+               other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+@@ -3287,7 +3287,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+                    .current_promise,
+               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
+@@ -3914,7 +3914,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+                    .current_promise,
+               other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+@@ -3950,7 +3950,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+                    .current_promise,
+               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
+@@ -4643,7 +4643,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> {
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+                    .prior.current_promise,
+               other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+@@ -4683,7 +4683,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> {
+   SeqState& operator=(const SeqState& other) = delete;
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
+       : state(other.state), whence(other.whence) {
+-    DCHECK(state == State::kState0);
++    ABSL_DCHECK(state == State::kState0);
+     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
+                    .prior.current_promise,
+               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
+diff --git a/third_party/grpc/source/src/core/lib/promise/detail/status.h b/third_party/grpc/source/src/core/lib/promise/detail/status.h
+index 335c5365c2bc4..33096b5620243 100644
+--- a/third_party/grpc/source/src/core/lib/promise/detail/status.h
++++ b/third_party/grpc/source/src/core/lib/promise/detail/status.h
+@@ -19,7 +19,7 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+
+@@ -128,7 +128,7 @@ struct FailureStatusCastImpl<absl::StatusOr<T>, const absl::Status&> {
+
+ template <typename To, typename From>
+ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline To FailureStatusCast(From&& from) {
+-  DCHECK(!IsStatusOk(from));
++  ABSL_DCHECK(!IsStatusOk(from));
+   return FailureStatusCastImpl<To, From>::Cast(std::forward<From>(from));
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h b/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h
+index 3e494beaa6fe1..0193564f15b04 100644
+--- a/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h
++++ b/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h
+@@ -21,7 +21,7 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+
+ namespace grpc_core {
+@@ -34,7 +34,7 @@ class EventEngineWakeupScheduler {
+       std::shared_ptr<grpc_event_engine::experimental::EventEngine>
+           event_engine)
+       : event_engine_(std::move(event_engine)) {
+-    CHECK_NE(event_engine_, nullptr);
++    ABSL_CHECK_NE(event_engine_, nullptr);
+   }
+
+   template <typename ActivityType>
+diff --git a/third_party/grpc/source/src/core/lib/promise/for_each.h b/third_party/grpc/source/src/core/lib/promise/for_each.h
+index 5219995962bca..2801b7238d6a0 100644
+--- a/third_party/grpc/source/src/core/lib/promise/for_each.h
++++ b/third_party/grpc/source/src/core/lib/promise/for_each.h
+@@ -21,8 +21,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -145,13 +145,13 @@ class ForEach {
+       : reader_(std::move(other.reader_)),
+         action_factory_(std::move(other.action_factory_)),
+         whence_(other.whence_) {
+-    DCHECK(reading_next_);
+-    DCHECK(other.reading_next_);
++    ABSL_DCHECK(reading_next_);
++    ABSL_DCHECK(other.reading_next_);
+     Construct(&reader_next_, std::move(other.reader_next_));
+   }
+   ForEach& operator=(ForEach&& other) noexcept {
+-    DCHECK(reading_next_);
+-    DCHECK(other.reading_next_);
++    ABSL_DCHECK(reading_next_);
++    ABSL_DCHECK(other.reading_next_);
+     reader_ = std::move(other.reader_);
+     action_factory_ = std::move(other.action_factory_);
+     reader_next_ = std::move(other.reader_next_);
+diff --git a/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h b/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h
+index a5a614dcf9f54..926be7a2e2580 100644
+--- a/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h
++++ b/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h
+@@ -21,7 +21,7 @@
+ #include <string>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/promise/activity.h"
+diff --git a/third_party/grpc/source/src/core/lib/promise/interceptor_list.h b/third_party/grpc/source/src/core/lib/promise/interceptor_list.h
+index dbdd738e648da..2b4820111391d 100644
+--- a/third_party/grpc/source/src/core/lib/promise/interceptor_list.h
++++ b/third_party/grpc/source/src/core/lib/promise/interceptor_list.h
+@@ -24,8 +24,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/promise/context.h"
+@@ -64,7 +64,7 @@ class InterceptorList {
+     // Update the next pointer stored with this map.
+     // This is only valid to call once, and only before the map is used.
+     void SetNext(Map* next) {
+-      DCHECK_EQ(next_, nullptr);
++      ABSL_DCHECK_EQ(next_, nullptr);
+       next_ = next;
+     }
+
+diff --git a/third_party/grpc/source/src/core/lib/promise/latch.h b/third_party/grpc/source/src/core/lib/promise/latch.h
+index 772204547d609..f1f97a836fb44 100644
+--- a/third_party/grpc/source/src/core/lib/promise/latch.h
++++ b/third_party/grpc/source/src/core/lib/promise/latch.h
+@@ -22,8 +22,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/promise/activity.h"
+@@ -54,12 +54,12 @@ class Latch {
+   Latch(Latch&& other) noexcept
+       : value_(std::move(other.value_)), has_value_(other.has_value_) {
+ #ifndef NDEBUG
+-    DCHECK(!other.has_had_waiters_);
++    ABSL_DCHECK(!other.has_had_waiters_);
+ #endif
+   }
+   Latch& operator=(Latch&& other) noexcept {
+ #ifndef NDEBUG
+-    DCHECK(!other.has_had_waiters_);
++    ABSL_DCHECK(!other.has_had_waiters_);
+ #endif
+     value_ = std::move(other.value_);
+     has_value_ = other.has_value_;
+@@ -104,7 +104,7 @@ class Latch {
+   void Set(T value) {
+     GRPC_TRACE_LOG(promise_primitives, INFO)
+         << DebugTag() << "Set " << StateString();
+-    DCHECK(!has_value_);
++    ABSL_DCHECK(!has_value_);
+     value_ = std::move(value);
+     has_value_ = true;
+     waiter_.Wake();
+@@ -147,12 +147,12 @@ class Latch<void> {
+   Latch& operator=(const Latch&) = delete;
+   Latch(Latch&& other) noexcept : is_set_(other.is_set_) {
+ #ifndef NDEBUG
+-    DCHECK(!other.has_had_waiters_);
++    ABSL_DCHECK(!other.has_had_waiters_);
+ #endif
+   }
+   Latch& operator=(Latch&& other) noexcept {
+ #ifndef NDEBUG
+-    DCHECK(!other.has_had_waiters_);
++    ABSL_DCHECK(!other.has_had_waiters_);
+ #endif
+     is_set_ = other.is_set_;
+     return *this;
+@@ -178,7 +178,7 @@ class Latch<void> {
+   void Set() {
+     GRPC_TRACE_LOG(promise_primitives, INFO)
+         << DebugTag() << "Set " << StateString();
+-    DCHECK(!is_set_);
++    ABSL_DCHECK(!is_set_);
+     is_set_ = true;
+     waiter_.Wake();
+   }
+diff --git a/third_party/grpc/source/src/core/lib/promise/map_pipe.h b/third_party/grpc/source/src/core/lib/promise/map_pipe.h
+index 13ab7a688bca6..f46ca7c6e4fb8 100644
+--- a/third_party/grpc/source/src/core/lib/promise/map_pipe.h
++++ b/third_party/grpc/source/src/core/lib/promise/map_pipe.h
+@@ -17,7 +17,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/lib/promise/detail/promise_factory.h"
+ #include "src/core/lib/promise/for_each.h"
+diff --git a/third_party/grpc/source/src/core/lib/promise/mpsc.h b/third_party/grpc/source/src/core/lib/promise/mpsc.h
+index 3b51274a1f76b..b290604153246 100644
+--- a/third_party/grpc/source/src/core/lib/promise/mpsc.h
++++ b/third_party/grpc/source/src/core/lib/promise/mpsc.h
+@@ -25,7 +25,7 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/promise/activity.h"
+ #include "src/core/lib/promise/poll.h"
+ #include "src/core/lib/promise/status_flag.h"
+@@ -172,7 +172,7 @@ class MpscSender {
+       if (center == nullptr) return false;
+       if (batch == 0) {
+         batch = center->Send(std::move(t), kAwaitReceipt);
+-        CHECK_NE(batch, 0u);
++        ABSL_CHECK_NE(batch, 0u);
+         if (batch == mpscpipe_detail::Center<T>::kClosedBatch) return false;
+       }
+       auto p = center->PollReceiveBatch(batch);
+@@ -212,10 +212,10 @@ class MpscReceiver {
+   // a non-empty buffer during a legal move!
+   MpscReceiver(MpscReceiver&& other) noexcept
+       : center_(std::move(other.center_)) {
+-    DCHECK(other.buffer_.empty());
++    ABSL_DCHECK(other.buffer_.empty());
+   }
+   MpscReceiver& operator=(MpscReceiver&& other) noexcept {
+-    DCHECK(other.buffer_.empty());
++    ABSL_DCHECK(other.buffer_.empty());
+     center_ = std::move(other.center_);
+     return *this;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/promise/observable.h b/third_party/grpc/source/src/core/lib/promise/observable.h
+index 671348ff9a25c..bed3a9607b620 100644
+--- a/third_party/grpc/source/src/core/lib/promise/observable.h
++++ b/third_party/grpc/source/src/core/lib/promise/observable.h
+@@ -19,7 +19,7 @@
+
+ #include "absl/container/flat_hash_set.h"
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/promise/activity.h"
+ #include "src/core/lib/promise/poll.h"
+ #include "src/core/util/sync.h"
+@@ -123,9 +123,9 @@ class Observable {
+     Observer(const Observer&) = delete;
+     Observer& operator=(const Observer&) = delete;
+     Observer(Observer&& other) noexcept : state_(std::move(other.state_)) {
+-      CHECK(other.waker_.is_unwakeable());
+-      DCHECK(waker_.is_unwakeable());
+-      CHECK(!other.saw_pending_);
++      ABSL_CHECK(other.waker_.is_unwakeable());
++      ABSL_DCHECK(waker_.is_unwakeable());
++      ABSL_CHECK(!other.saw_pending_);
+     }
+     Observer& operator=(Observer&& other) noexcept = delete;
+
+diff --git a/third_party/grpc/source/src/core/lib/promise/party.cc b/third_party/grpc/source/src/core/lib/promise/party.cc
+index 28a7ac8724932..26c6fa05e58a0 100644
+--- a/third_party/grpc/source/src/core/lib/promise/party.cc
++++ b/third_party/grpc/source/src/core/lib/promise/party.cc
+@@ -21,8 +21,8 @@
+ #include <limits>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/event_engine/event_engine_context.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -72,7 +72,7 @@ class Party::Handle final : public Wakeable {
+   // Activity is going away... drop its reference and sever the connection back.
+   void DropActivity() ABSL_LOCKS_EXCLUDED(mu_) {
+     mu_.Lock();
+-    CHECK_NE(party_, nullptr);
++    ABSL_CHECK_NE(party_, nullptr);
+     party_ = nullptr;
+     mu_.Unlock();
+     Unref();
+@@ -213,13 +213,13 @@ std::string Party::ActivityDebugTag(WakeupMask wakeup_mask) const {
+ }
+
+ Waker Party::MakeOwningWaker() {
+-  DCHECK(currently_polling_ != kNotPolling);
++  ABSL_DCHECK(currently_polling_ != kNotPolling);
+   IncrementRefCount();
+   return Waker(this, 1u << currently_polling_);
+ }
+
+ Waker Party::MakeNonOwningWaker() {
+-  DCHECK(currently_polling_ != kNotPolling);
++  ABSL_DCHECK(currently_polling_ != kNotPolling);
+   return Waker(participants_[currently_polling_]
+                    .load(std::memory_order_relaxed)
+                    ->MakeNonOwningWakeable(this),
+@@ -227,7 +227,7 @@ Waker Party::MakeNonOwningWaker() {
+ }
+
+ void Party::ForceImmediateRepoll(WakeupMask mask) {
+-  DCHECK(is_current());
++  ABSL_DCHECK(is_current());
+   wakeup_mask_ |= mask;
+ }
+
+@@ -264,7 +264,7 @@ void Party::RunLockedAndUnref(Party* party, uint64_t prev_state) {
+         first.party->RunPartyAndUnref(first.prev_state);
+         first = std::exchange(next, PartyWakeup{});
+       } while (first.party != nullptr);
+-      DCHECK(g_run_state == this);
++      ABSL_DCHECK(g_run_state == this);
+       g_run_state = nullptr;
+     }
+   };
+@@ -294,7 +294,7 @@ void Party::RunLockedAndUnref(Party* party, uint64_t prev_state) {
+       auto arena = party->arena_.get();
+       auto* event_engine =
+           arena->GetContext<grpc_event_engine::experimental::EventEngine>();
+-      CHECK(event_engine != nullptr) << "; " << GRPC_DUMP_ARGS(party, arena);
++      ABSL_CHECK(event_engine != nullptr) << "; " << GRPC_DUMP_ARGS(party, arena);
+       event_engine->Run([wakeup]() {
+         GRPC_LATENT_SEE_PARENT_SCOPE("Party::RunLocked offload");
+         ApplicationCallbackExecCtx app_exec_ctx;
+@@ -313,11 +313,11 @@ void Party::RunLockedAndUnref(Party* party, uint64_t prev_state) {
+ void Party::RunPartyAndUnref(uint64_t prev_state) {
+   ScopedActivity activity(this);
+   promise_detail::Context<Arena> arena_ctx(arena_.get());
+-  DCHECK_EQ(prev_state & kLocked, 0u)
++  ABSL_DCHECK_EQ(prev_state & kLocked, 0u)
+       << "Party should be unlocked prior to first wakeup";
+-  DCHECK_GE(prev_state & kRefMask, kOneRef);
++  ABSL_DCHECK_GE(prev_state & kRefMask, kOneRef);
+   // Now update prev_state to be what we want the CAS to see below.
+-  DCHECK_EQ(prev_state & ~(kRefMask | kAllocatedMask), 0u)
++  ABSL_DCHECK_EQ(prev_state & ~(kRefMask | kAllocatedMask), 0u)
+       << "Party should have contained no wakeups on lock";
+   prev_state |= kLocked;
+ #if !TARGET_OS_IPHONE
+@@ -385,9 +385,9 @@ void Party::RunPartyAndUnref(uint64_t prev_state) {
+     }
+     LogStateChange("Run:Continue", prev_state,
+                    prev_state & (kRefMask | kLocked | keep_allocated_mask));
+-    DCHECK(prev_state & kLocked)
++    ABSL_DCHECK(prev_state & kLocked)
+         << "Party should be locked; prev_state=" << prev_state;
+-    DCHECK_GE(prev_state & kRefMask, kOneRef);
++    ABSL_DCHECK_GE(prev_state & kRefMask, kOneRef);
+     // From the previous state, extract which participants we're to wakeup.
+     wakeup_mask_ |= prev_state & kWakeupMask;
+     // Now update prev_state to be what we want the CAS to see once wakeups
+@@ -410,7 +410,7 @@ uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
+ }
+ #else
+ uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
+-  CHECK_EQ(current_allocation_mask & ~kWakeupMask, 0);
++  ABSL_CHECK_EQ(current_allocation_mask & ~kWakeupMask, 0);
+   if (current_allocation_mask == kWakeupMask) return kWakeupMask + 1;
+   // Count number of unset bits in the wakeup mask
+   size_t unset_bits = 0;
+@@ -418,7 +418,7 @@ uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
+     if (current_allocation_mask & (1ull << i)) continue;
+     ++unset_bits;
+   }
+-  CHECK_GT(unset_bits, 0);
++  ABSL_CHECK_GT(unset_bits, 0);
+   absl::BitGen bitgen;
+   size_t selected = absl::Uniform<size_t>(bitgen, 0, unset_bits);
+   for (size_t i = 0; i < party_detail::kMaxParticipants; i++) {
+@@ -426,7 +426,7 @@ uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
+     if (selected == 0) return 1ull << i;
+     --selected;
+   }
+-  LOG(FATAL) << "unreachable";
++  ABSL_LOG(FATAL) << "unreachable";
+ }
+ #endif
+
+@@ -447,7 +447,7 @@ size_t Party::AddParticipant(Participant* participant) {
+     if (GPR_UNLIKELY((wakeup_mask & kWakeupMask) == 0)) {
+       return std::numeric_limits<size_t>::max();
+     }
+-    DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
++    ABSL_DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
+         << "No available slots for new participant; allocated=" << allocated
+         << " state=" << state << " wakeup_mask=" << wakeup_mask;
+     allocated |= wakeup_mask;
+@@ -473,7 +473,7 @@ void Party::MaybeAsyncAddParticipant(Participant* participant) {
+   if (slot != std::numeric_limits<size_t>::max()) return;
+   // We need to delay the addition of participants.
+   IncrementRefCount();
+-  VLOG_EVERY_N_SEC(2, 10) << "Delaying addition of participant to party "
++  ABSL_VLOG_EVERY_N_SEC(2, 10) << "Delaying addition of participant to party "
+                           << this << " because it is full.";
+   arena_->GetContext<grpc_event_engine::experimental::EventEngine>()->Run(
+       [this, participant]() mutable {
+diff --git a/third_party/grpc/source/src/core/lib/promise/party.h b/third_party/grpc/source/src/core/lib/promise/party.h
+index c53d5f774bc4d..59d71a3d976a9 100644
+--- a/third_party/grpc/source/src/core/lib/promise/party.h
++++ b/third_party/grpc/source/src/core/lib/promise/party.h
+@@ -26,7 +26,7 @@
+ #include <utility>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/event_engine/event_engine_context.h"
+@@ -97,7 +97,7 @@ class Party : public Activity, private Wakeable {
+           party->state_.compare_exchange_weak(prev_state_,
+                                               (prev_state_ | kLocked) + kOneRef,
+                                               std::memory_order_relaxed)) {
+-        DCHECK_EQ(prev_state_ & ~(kRefMask | kAllocatedMask), 0u)
++        ABSL_DCHECK_EQ(prev_state_ & ~(kRefMask | kAllocatedMask), 0u)
+             << "Party should have contained no wakeups on lock";
+         // If we win, record that fact for the destructor
+         party->LogStateChange("WakeupHold", prev_state_,
+@@ -223,7 +223,7 @@ class Party : public Activity, private Wakeable {
+   // Activity implementation: not allowed to be overridden by derived types.
+   void ForceImmediateRepoll(WakeupMask mask) final;
+   WakeupMask CurrentParticipant() const final {
+-    DCHECK(currently_polling_ != kNotPolling);
++    ABSL_DCHECK(currently_polling_ != kNotPolling);
+     return 1u << currently_polling_;
+   }
+   Waker MakeOwningWaker() final;
+@@ -257,7 +257,7 @@ class Party : public Activity, private Wakeable {
+   SpawnSerializer* MakeSpawnSerializer() {
+     auto* const serializer = arena_->New<SpawnSerializer>(this);
+     const size_t slot = AddParticipant(serializer);
+-    DCHECK_NE(slot, std::numeric_limits<size_t>::max());
++    ABSL_DCHECK_NE(slot, std::numeric_limits<size_t>::max());
+     serializer->wakeup_mask_ = 1ull << slot;
+     return serializer;
+   }
+@@ -267,7 +267,7 @@ class Party : public Activity, private Wakeable {
+
+   // Derived types should be constructed upon `arena`.
+   explicit Party(RefCountedPtr<Arena> arena) : arena_(std::move(arena)) {
+-    CHECK(arena_->GetContext<grpc_event_engine::experimental::EventEngine>() !=
++    ABSL_CHECK(arena_->GetContext<grpc_event_engine::experimental::EventEngine>() !=
+           nullptr);
+   }
+   ~Party() override;
+@@ -468,7 +468,7 @@ class Party : public Activity, private Wakeable {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION void WakeupFromState(
+       uint64_t cur_state, WakeupMask wakeup_mask) {
+     GRPC_LATENT_SEE_INNER_SCOPE("Party::WakeupFromState");
+-    DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
++    ABSL_DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
+         << "Wakeup mask must be non-zero: " << wakeup_mask;
+     while (true) {
+       if (cur_state & kLocked) {
+@@ -476,9 +476,9 @@ class Party : public Activity, private Wakeable {
+         // we'll immediately unref. Since something is running this should never
+         // bring the refcount to zero.
+         if (kReffed) {
+-          DCHECK_GT(cur_state & kRefMask, kOneRef);
++          ABSL_DCHECK_GT(cur_state & kRefMask, kOneRef);
+         } else {
+-          DCHECK_GE(cur_state & kRefMask, kOneRef);
++          ABSL_DCHECK_GE(cur_state & kRefMask, kOneRef);
+         }
+         const uint64_t new_state =
+             (cur_state | wakeup_mask) - (kReffed ? kOneRef : 0);
+@@ -489,7 +489,7 @@ class Party : public Activity, private Wakeable {
+         }
+       } else {
+         // If the party is not locked, we need to lock it and run.
+-        DCHECK_EQ(cur_state & kWakeupMask, 0u);
++        ABSL_DCHECK_EQ(cur_state & kWakeupMask, 0u);
+         const uint64_t new_state =
+             (cur_state | kLocked) + (kReffed ? 0 : kOneRef);
+         if (state_.compare_exchange_weak(cur_state, new_state,
+diff --git a/third_party/grpc/source/src/core/lib/promise/pipe.h b/third_party/grpc/source/src/core/lib/promise/pipe.h
+index 95799f39ef472..ec6f4f3b922ac 100644
+--- a/third_party/grpc/source/src/core/lib/promise/pipe.h
++++ b/third_party/grpc/source/src/core/lib/promise/pipe.h
+@@ -25,8 +25,8 @@
+ #include <utility>
+ #include <variant>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/promise/activity.h"
+ #include "src/core/lib/promise/context.h"
+@@ -61,7 +61,7 @@ class NextResult final {
+   NextResult() : center_(nullptr) {}
+   explicit NextResult(RefCountedPtr<pipe_detail::Center<T>> center)
+       : center_(std::move(center)) {
+-    CHECK(center_ != nullptr);
++    ABSL_CHECK(center_ != nullptr);
+   }
+   explicit NextResult(bool cancelled)
+       : center_(nullptr), cancelled_(cancelled) {}
+@@ -77,11 +77,11 @@ class NextResult final {
+   bool has_value() const;
+   // Only valid if has_value()
+   const T& value() const {
+-    CHECK(has_value());
++    ABSL_CHECK(has_value());
+     return **this;
+   }
+   T& value() {
+-    CHECK(has_value());
++    ABSL_CHECK(has_value());
+     return **this;
+   }
+   const T& operator*() const;
+@@ -118,7 +118,7 @@ class Center : public InterceptorList<T> {
+     GRPC_TRACE_VLOG(promise_primitives, 2)
+         << DebugOpString("IncrementRefCount");
+     refs_++;
+-    DCHECK_NE(refs_, 0);
++    ABSL_DCHECK_NE(refs_, 0);
+   }
+
+   RefCountedPtr<Center> Ref() {
+@@ -130,7 +130,7 @@ class Center : public InterceptorList<T> {
+   // If no refs remain, destroy this object
+   void Unref() {
+     GRPC_TRACE_VLOG(promise_primitives, 2) << DebugOpString("Unref");
+-    DCHECK_GT(refs_, 0);
++    ABSL_DCHECK_GT(refs_, 0);
+     refs_--;
+     if (0 == refs_) {
+       this->~Center();
+@@ -143,7 +143,7 @@ class Center : public InterceptorList<T> {
+   // Return false if the recv end is closed.
+   Poll<bool> Push(T* value) {
+     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("Push");
+-    DCHECK_NE(refs_, 0);
++    ABSL_DCHECK_NE(refs_, 0);
+     switch (value_state_) {
+       case ValueState::kClosed:
+       case ValueState::kReadyClosed:
+@@ -165,7 +165,7 @@ class Center : public InterceptorList<T> {
+
+   Poll<bool> PollAck() {
+     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("PollAck");
+-    DCHECK_NE(refs_, 0);
++    ABSL_DCHECK_NE(refs_, 0);
+     switch (value_state_) {
+       case ValueState::kClosed:
+         return true;
+@@ -191,7 +191,7 @@ class Center : public InterceptorList<T> {
+   // Return nullopt if the send end is closed and no value had been pushed.
+   Poll<std::optional<T>> Next() {
+     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("Next");
+-    DCHECK_NE(refs_, 0);
++    ABSL_DCHECK_NE(refs_, 0);
+     switch (value_state_) {
+       case ValueState::kEmpty:
+       case ValueState::kAcked:
+@@ -216,7 +216,7 @@ class Center : public InterceptorList<T> {
+   Poll<bool> PollClosedForSender() {
+     GRPC_TRACE_LOG(promise_primitives, INFO)
+         << DebugOpString("PollClosedForSender");
+-    DCHECK_NE(refs_, 0);
++    ABSL_DCHECK_NE(refs_, 0);
+     switch (value_state_) {
+       case ValueState::kEmpty:
+       case ValueState::kAcked:
+@@ -238,7 +238,7 @@ class Center : public InterceptorList<T> {
+   Poll<bool> PollClosedForReceiver() {
+     GRPC_TRACE_LOG(promise_primitives, INFO)
+         << DebugOpString("PollClosedForReceiver");
+-    DCHECK_NE(refs_, 0);
++    ABSL_DCHECK_NE(refs_, 0);
+     switch (value_state_) {
+       case ValueState::kEmpty:
+       case ValueState::kAcked:
+@@ -257,7 +257,7 @@ class Center : public InterceptorList<T> {
+
+   Poll<Empty> PollEmpty() {
+     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("PollEmpty");
+-    DCHECK_NE(refs_, 0);
++    ABSL_DCHECK_NE(refs_, 0);
+     switch (value_state_) {
+       case ValueState::kReady:
+       case ValueState::kReadyClosed:
+@@ -646,7 +646,7 @@ class Push {
+         return Pending{};
+       }
+     }
+-    DCHECK(std::holds_alternative<AwaitingAck>(state_));
++    ABSL_DCHECK(std::holds_alternative<AwaitingAck>(state_));
+     return center_->PollAck();
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/promise/poll.h b/third_party/grpc/source/src/core/lib/promise/poll.h
+index b530bf32fd3b5..1bbf3627afb39 100644
+--- a/third_party/grpc/source/src/core/lib/promise/poll.h
++++ b/third_party/grpc/source/src/core/lib/promise/poll.h
+@@ -21,7 +21,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/util/construct_destruct.h"
+
+@@ -111,12 +111,12 @@ class Poll {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION bool ready() const { return ready_; }
+
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION T& value() {
+-    DCHECK(ready());
++    ABSL_DCHECK(ready());
+     return value_;
+   }
+
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION const T& value() const {
+-    DCHECK(ready());
++    ABSL_DCHECK(ready());
+     return value_;
+   }
+
+@@ -173,7 +173,7 @@ class Poll<Empty> {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION bool ready() const { return ready_; }
+
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Empty value() const {
+-    DCHECK(ready());
++    ABSL_DCHECK(ready());
+     return Empty{};
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/promise/promise_mutex.h b/third_party/grpc/source/src/core/lib/promise/promise_mutex.h
+index c17750ff06625..9a9515c94fcec 100644
+--- a/third_party/grpc/source/src/core/lib/promise/promise_mutex.h
++++ b/third_party/grpc/source/src/core/lib/promise/promise_mutex.h
+@@ -19,7 +19,7 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/promise/activity.h"
+ #include "src/core/lib/promise/poll.h"
+
+@@ -35,7 +35,7 @@ class PromiseMutex {
+     Lock() {}
+     ~Lock() {
+       if (mutex_ != nullptr) {
+-        CHECK(mutex_->locked_);
++        ABSL_CHECK(mutex_->locked_);
+         mutex_->locked_ = false;
+         mutex_->waiter_.Wake();
+       }
+@@ -52,18 +52,18 @@ class PromiseMutex {
+     Lock& operator=(const Lock&) noexcept = delete;
+
+     T* operator->() {
+-      DCHECK_NE(mutex_, nullptr);
++      ABSL_DCHECK_NE(mutex_, nullptr);
+       return &mutex_->value_;
+     }
+     T& operator*() {
+-      DCHECK_NE(mutex_, nullptr);
++      ABSL_DCHECK_NE(mutex_, nullptr);
+       return mutex_->value_;
+     }
+
+    private:
+     friend class PromiseMutex;
+     explicit Lock(PromiseMutex* mutex) : mutex_(mutex) {
+-      DCHECK(!mutex_->locked_);
++      ABSL_DCHECK(!mutex_->locked_);
+       mutex_->locked_ = true;
+     }
+     PromiseMutex* mutex_ = nullptr;
+@@ -71,7 +71,7 @@ class PromiseMutex {
+
+   PromiseMutex() = default;
+   explicit PromiseMutex(T value) : value_(std::move(value)) {}
+-  ~PromiseMutex() { DCHECK(!locked_); }
++  ~PromiseMutex() { ABSL_DCHECK(!locked_); }
+
+   auto Acquire() {
+     return [this]() -> Poll<Lock> {
+diff --git a/third_party/grpc/source/src/core/lib/promise/status_flag.h b/third_party/grpc/source/src/core/lib/promise/status_flag.h
+index 13419817b4576..232b2d366e995 100644
+--- a/third_party/grpc/source/src/core/lib/promise/status_flag.h
++++ b/third_party/grpc/source/src/core/lib/promise/status_flag.h
+@@ -20,7 +20,7 @@
+ #include <optional>
+ #include <ostream>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -197,7 +197,7 @@ template <typename T>
+ struct FailureStatusCastImpl<absl::StatusOr<T>, StatusFlag> {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static absl::StatusOr<T> Cast(
+       StatusFlag flag) {
+-    DCHECK(!flag.ok());
++    ABSL_DCHECK(!flag.ok());
+     return absl::CancelledError();
+   }
+ };
+@@ -206,7 +206,7 @@ template <typename T>
+ struct FailureStatusCastImpl<absl::StatusOr<T>, StatusFlag&> {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static absl::StatusOr<T> Cast(
+       StatusFlag flag) {
+-    DCHECK(!flag.ok());
++    ABSL_DCHECK(!flag.ok());
+     return absl::CancelledError();
+   }
+ };
+@@ -215,7 +215,7 @@ template <typename T>
+ struct FailureStatusCastImpl<absl::StatusOr<T>, const StatusFlag&> {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static absl::StatusOr<T> Cast(
+       StatusFlag flag) {
+-    DCHECK(!flag.ok());
++    ABSL_DCHECK(!flag.ok());
+     return absl::CancelledError();
+   }
+ };
+@@ -229,7 +229,7 @@ class ValueOrFailure {
+   // NOLINTNEXTLINE(google-explicit-constructor)
+   ValueOrFailure(Failure) {}
+   // NOLINTNEXTLINE(google-explicit-constructor)
+-  ValueOrFailure(StatusFlag status) { CHECK(!status.ok()); }
++  ValueOrFailure(StatusFlag status) { ABSL_CHECK(!status.ok()); }
+
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static ValueOrFailure FromOptional(
+       std::optional<T> value) {
+@@ -331,7 +331,7 @@ template <typename T>
+ struct StatusCastImpl<ValueOrFailure<T>, StatusFlag&> {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static ValueOrFailure<T> Cast(
+       StatusFlag f) {
+-    CHECK(!f.ok());
++    ABSL_CHECK(!f.ok());
+     return ValueOrFailure<T>(Failure{});
+   }
+ };
+@@ -340,7 +340,7 @@ template <typename T>
+ struct StatusCastImpl<ValueOrFailure<T>, StatusFlag> {
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static ValueOrFailure<T> Cast(
+       StatusFlag f) {
+-    CHECK(!f.ok());
++    ABSL_CHECK(!f.ok());
+     return ValueOrFailure<T>(Failure{});
+   }
+ };
+diff --git a/third_party/grpc/source/src/core/lib/promise/try_join.h b/third_party/grpc/source/src/core/lib/promise/try_join.h
+index 6a7b3fd256714..12f649db22279 100644
+--- a/third_party/grpc/source/src/core/lib/promise/try_join.h
++++ b/third_party/grpc/source/src/core/lib/promise/try_join.h
+@@ -20,7 +20,7 @@
+ #include <tuple>
+ #include <variant>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -212,7 +212,7 @@ struct TryJoinTraits {
+   template <typename R, typename T>
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static R EarlyReturn(
+       const ValueOrFailure<T>& x) {
+-    CHECK(!x.ok());
++    ABSL_CHECK(!x.ok());
+     return FailureStatusCast<R>(Failure{});
+   }
+   template <typename... A>
+diff --git a/third_party/grpc/source/src/core/lib/promise/try_seq.h b/third_party/grpc/source/src/core/lib/promise/try_seq.h
+index 7501af89055ff..69830d85169e5 100644
+--- a/third_party/grpc/source/src/core/lib/promise/try_seq.h
++++ b/third_party/grpc/source/src/core/lib/promise/try_seq.h
+@@ -21,7 +21,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -208,7 +208,7 @@ struct TrySeqTraitsWithSfinae<
+   }
+   template <typename R>
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static R ReturnValue(T&& status) {
+-    DCHECK(!IsStatusOk(status));
++    ABSL_DCHECK(!IsStatusOk(status));
+     return FailureStatusCast<R>(status.status());
+   }
+   template <typename Result, typename RunNext>
+diff --git a/third_party/grpc/source/src/core/lib/resource_quota/arena.cc b/third_party/grpc/source/src/core/lib/resource_quota/arena.cc
+index e3b24dc739b3e..8bb1756952911 100644
+--- a/third_party/grpc/source/src/core/lib/resource_quota/arena.cc
++++ b/third_party/grpc/source/src/core/lib/resource_quota/arena.cc
+@@ -24,7 +24,7 @@
+ #include <atomic>
+ #include <new>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/resource_quota/resource_quota.h"
+ #include "src/core/util/alloc.h"
+ namespace grpc_core {
+@@ -82,7 +82,7 @@ Arena::Arena(size_t initial_size, RefCountedPtr<ArenaFactory> arena_factory)
+        ++i) {
+     contexts()[i] = nullptr;
+   }
+-  CHECK_GE(initial_size, arena_detail::BaseArenaContextTraits::ContextSize());
++  ABSL_CHECK_GE(initial_size, arena_detail::BaseArenaContextTraits::ContextSize());
+   arena_factory_->allocator().Reserve(initial_size);
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/resource_quota/arena.h b/third_party/grpc/source/src/core/lib/resource_quota/arena.h
+index 4ad87ec6afcff..dd915a2720158 100644
+--- a/third_party/grpc/source/src/core/lib/resource_quota/arena.h
++++ b/third_party/grpc/source/src/core/lib/resource_quota/arena.h
+@@ -303,7 +303,7 @@ class Arena final : public RefCounted<Arena, NonPolymorphicRefCount,
+       ArenaContextType<T>::Destroy(static_cast<T*>(slot));
+     }
+     slot = context;
+-    DCHECK_EQ(GetContext<T>(), context);
++    ABSL_DCHECK_EQ(GetContext<T>(), context);
+   }
+
+   static size_t ArenaOverhead() {
+diff --git a/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc b/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc
+index 021628c3695e9..a0fd6f5d1af5d 100644
+--- a/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc
++++ b/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc
+@@ -19,7 +19,7 @@
+ #include <atomic>
+ #include <cstdint>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -27,8 +27,8 @@ ConnectionQuota::ConnectionQuota() = default;
+
+ void ConnectionQuota::SetMaxIncomingConnections(int max_incoming_connections) {
+   // The maximum can only be configured once.
+-  CHECK_LT(max_incoming_connections, INT_MAX);
+-  CHECK(max_incoming_connections_.exchange(
++  ABSL_CHECK_LT(max_incoming_connections, INT_MAX);
++  ABSL_CHECK(max_incoming_connections_.exchange(
+             max_incoming_connections, std::memory_order_release) == INT_MAX);
+ }
+
+@@ -62,7 +62,7 @@ void ConnectionQuota::ReleaseConnections(int num_connections) {
+   if (max_incoming_connections_.load(std::memory_order_relaxed) == INT_MAX) {
+     return;
+   }
+-  CHECK(active_incoming_connections_.fetch_sub(
++  ABSL_CHECK(active_incoming_connections_.fetch_sub(
+             num_connections, std::memory_order_acq_rel) >= num_connections);
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc
+index 92e4d38caf4fe..19268f8911042 100644
+--- a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc
++++ b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc
+@@ -28,8 +28,8 @@
+ #include <tuple>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -261,7 +261,7 @@ GrpcMemoryAllocatorImpl::GrpcMemoryAllocatorImpl(
+ }
+
+ GrpcMemoryAllocatorImpl::~GrpcMemoryAllocatorImpl() {
+-  CHECK_EQ(free_bytes_.load(std::memory_order_acquire) +
++  ABSL_CHECK_EQ(free_bytes_.load(std::memory_order_acquire) +
+                sizeof(GrpcMemoryAllocatorImpl),
+            taken_bytes_.load(std::memory_order_relaxed));
+   memory_quota_->Return(taken_bytes_.load(std::memory_order_relaxed));
+@@ -274,7 +274,7 @@ void GrpcMemoryAllocatorImpl::Shutdown() {
+       reclamation_handles[kNumReclamationPasses];
+   {
+     MutexLock lock(&reclaimer_mu_);
+-    CHECK(!shutdown_);
++    ABSL_CHECK(!shutdown_);
+     shutdown_ = true;
+     memory_quota = memory_quota_;
+     for (size_t i = 0; i < kNumReclamationPasses; i++) {
+@@ -286,8 +286,8 @@ void GrpcMemoryAllocatorImpl::Shutdown() {
+ size_t GrpcMemoryAllocatorImpl::Reserve(MemoryRequest request) {
+   // Validate request - performed here so we don't bloat the generated code with
+   // inlined asserts.
+-  CHECK(request.min() <= request.max());
+-  CHECK(request.max() <= MemoryRequest::max_allowed_size());
++  ABSL_CHECK(request.min() <= request.max());
++  ABSL_CHECK(request.max() <= MemoryRequest::max_allowed_size());
+   size_t old_free = free_bytes_.load(std::memory_order_relaxed);
+
+   while (true) {
+@@ -365,7 +365,7 @@ void GrpcMemoryAllocatorImpl::MaybeDonateBack() {
+                                           std::memory_order_acquire)) {
+       GRPC_TRACE_LOG(resource_quota, INFO)
+           << "[" << this << "] Early return " << ret << " bytes";
+-      CHECK(taken_bytes_.fetch_sub(ret, std::memory_order_relaxed) >= ret);
++      ABSL_CHECK(taken_bytes_.fetch_sub(ret, std::memory_order_relaxed) >= ret);
+       memory_quota_->Return(ret);
+       return;
+     }
+@@ -460,7 +460,7 @@ void BasicMemoryQuota::Start() {
+         if (GRPC_TRACE_FLAG_ENABLED(resource_quota)) {
+           double free = std::max(intptr_t{0}, self->free_bytes_.load());
+           size_t quota_size = self->quota_size_.load();
+-          LOG(INFO) << "RQ: " << self->name_ << " perform " << std::get<0>(arg)
++          ABSL_LOG(INFO) << "RQ: " << self->name_ << " perform " << std::get<0>(arg)
+                     << " reclamation. Available free bytes: " << free
+                     << ", total quota_size: " << quota_size;
+         }
+@@ -485,7 +485,7 @@ void BasicMemoryQuota::Start() {
+   reclaimer_activity_ =
+       MakeActivity(std::move(reclamation_loop), ExecCtxWakeupScheduler(),
+                    [](absl::Status status) {
+-                     CHECK(status.code() == absl::StatusCode::kCancelled);
++                     ABSL_CHECK(status.code() == absl::StatusCode::kCancelled);
+                    });
+ }
+
+@@ -505,7 +505,7 @@ void BasicMemoryQuota::SetSize(size_t new_size) {
+ void BasicMemoryQuota::Take(GrpcMemoryAllocatorImpl* allocator, size_t amount) {
+   // If there's a request for nothing, then do nothing!
+   if (amount == 0) return;
+-  DCHECK(amount <= std::numeric_limits<intptr_t>::max());
++  ABSL_DCHECK(amount <= std::numeric_limits<intptr_t>::max());
+   // Grab memory from the quota.
+   auto prior = free_bytes_.fetch_sub(amount, std::memory_order_acq_rel);
+   // If we push into overcommit, awake the reclaimer.
+@@ -542,7 +542,7 @@ void BasicMemoryQuota::FinishReclamation(uint64_t token, Waker waker) {
+     if (GRPC_TRACE_FLAG_ENABLED(resource_quota)) {
+       double free = std::max(intptr_t{0}, free_bytes_.load());
+       size_t quota_size = quota_size_.load();
+-      LOG(INFO) << "RQ: " << name_
++      ABSL_LOG(INFO) << "RQ: " << name_
+                 << " reclamation complete. Available free bytes: " << free
+                 << ", total quota_size: " << quota_size;
+     }
+diff --git a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h
+index 0a786c01cf499..69b0b3b9be479 100644
+--- a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h
++++ b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h
+@@ -32,8 +32,8 @@
+
+ #include "absl/base/thread_annotations.h"
+ #include "absl/container/flat_hash_set.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/experiments/experiments.h"
+@@ -135,7 +135,7 @@ class ReclaimerQueue {
+     explicit Handle(F reclaimer, std::shared_ptr<State> state)
+         : sweep_(new SweepFn<F>(std::move(reclaimer), std::move(state))) {}
+     ~Handle() override {
+-      DCHECK_EQ(sweep_.load(std::memory_order_relaxed), nullptr);
++      ABSL_DCHECK_EQ(sweep_.load(std::memory_order_relaxed), nullptr);
+     }
+
+     Handle(const Handle&) = delete;
+@@ -435,7 +435,7 @@ class GrpcMemoryAllocatorImpl final : public EventEngineMemoryAllocatorImpl {
+   template <typename F>
+   void PostReclaimer(ReclamationPass pass, F fn) {
+     MutexLock lock(&reclaimer_mu_);
+-    CHECK(!shutdown_);
++    ABSL_CHECK(!shutdown_);
+     InsertReclaimer(static_cast<size_t>(pass), std::move(fn));
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc b/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc
+index 381375427e2ad..9ac627b8bf8eb 100644
+--- a/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc
++++ b/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc
+@@ -16,7 +16,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -38,7 +38,7 @@ bool ThreadQuota::Reserve(size_t num_threads) {
+
+ void ThreadQuota::Release(size_t num_threads) {
+   MutexLock lock(&mu_);
+-  CHECK(num_threads <= allocated_);
++  ABSL_CHECK(num_threads <= allocated_);
+   allocated_ -= num_threads;
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc b/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc
+index 4a6b8b97b25e1..6f4bec9284325 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc
+@@ -26,7 +26,7 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+@@ -44,15 +44,15 @@ AuditLoggerRegistry* AuditLoggerRegistry::registry = new AuditLoggerRegistry();
+ AuditLoggerRegistry::AuditLoggerRegistry() {
+   auto factory = std::make_unique<StdoutAuditLoggerFactory>();
+   absl::string_view name = factory->name();
+-  CHECK(logger_factories_map_.emplace(name, std::move(factory)).second);
++  ABSL_CHECK(logger_factories_map_.emplace(name, std::move(factory)).second);
+ }
+
+ void AuditLoggerRegistry::RegisterFactory(
+     std::unique_ptr<AuditLoggerFactory> factory) {
+-  CHECK(factory != nullptr);
++  ABSL_CHECK(factory != nullptr);
+   MutexLock lock(mu);
+   absl::string_view name = factory->name();
+-  CHECK(
++  ABSL_CHECK(
+       registry->logger_factories_map_.emplace(name, std::move(factory)).second);
+ }
+
+@@ -77,7 +77,7 @@ std::unique_ptr<AuditLogger> AuditLoggerRegistry::CreateAuditLogger(
+     std::unique_ptr<AuditLoggerFactory::Config> config) {
+   MutexLock lock(mu);
+   auto it = registry->logger_factories_map_.find(config->name());
+-  CHECK(it != registry->logger_factories_map_.end());
++  ABSL_CHECK(it != registry->logger_factories_map_.end());
+   return it->second->CreateAuditLogger(std::move(config));
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc b/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc
+index c81887b5f4f4e..d582d99ac3686 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc
+@@ -21,7 +21,7 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "absl/types/span.h"
+ #include "upb/base/string_view.h"
+@@ -49,13 +49,13 @@ std::unique_ptr<CelAuthorizationEngine>
+ CelAuthorizationEngine::CreateCelAuthorizationEngine(
+     const std::vector<envoy_config_rbac_v3_RBAC*>& rbac_policies) {
+   if (rbac_policies.empty() || rbac_policies.size() > 2) {
+-    LOG(ERROR) << "Invalid rbac policies vector. Must contain either one or "
++    ABSL_LOG(ERROR) << "Invalid rbac policies vector. Must contain either one or "
+                   "two rbac policies.";
+     return nullptr;
+   } else if (rbac_policies.size() == 2 &&
+              (envoy_config_rbac_v3_RBAC_action(rbac_policies[0]) != kDeny ||
+               envoy_config_rbac_v3_RBAC_action(rbac_policies[1]) != kAllow)) {
+-    LOG(ERROR) << "Invalid rbac policies vector. Must contain one deny policy "
++    ABSL_LOG(ERROR) << "Invalid rbac policies vector. Must contain one deny policy "
+                   "and one allow policy, in that order.";
+     return nullptr;
+   } else {
+@@ -172,7 +172,7 @@ std::unique_ptr<mock_cel::Activation> CelAuthorizationEngine::CreateActivation(
+             mock_cel::CelValue::CreateStringView(cert_server_name));
+       }
+     } else {
+-      LOG(ERROR) << "Error: Authorization engine does not support evaluating "
++      ABSL_LOG(ERROR) << "Error: Authorization engine does not support evaluating "
+                     "attribute "
+                  << elem;
+     }
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc b/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc
+index 9e7cb8cc6a924..96d84ce129935 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc
+@@ -18,7 +18,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <string.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+@@ -39,22 +39,22 @@ EvaluateArgs::PerChannelArgs::Address ParseEndpointUri(
+   EvaluateArgs::PerChannelArgs::Address address;
+   absl::StatusOr<URI> uri = URI::Parse(uri_text);
+   if (!uri.ok()) {
+-    VLOG(2) << "Failed to parse uri.";
++    ABSL_VLOG(2) << "Failed to parse uri.";
+     return address;
+   }
+   absl::string_view host_view;
+   absl::string_view port_view;
+   if (!SplitHostPort(uri->path(), &host_view, &port_view)) {
+-    VLOG(2) << "Failed to split " << uri->path() << " into host and port.";
++    ABSL_VLOG(2) << "Failed to split " << uri->path() << " into host and port.";
+     return address;
+   }
+   if (!absl::SimpleAtoi(port_view, &address.port)) {
+-    VLOG(2) << "Port " << port_view << " is out of range or null.";
++    ABSL_VLOG(2) << "Port " << port_view << " is out of range or null.";
+   }
+   address.address_str = std::string(host_view);
+   auto resolved_address = StringToSockaddr(uri->path());
+   if (!resolved_address.ok()) {
+-    VLOG(2) << "Address \"" << uri->path()
++    ABSL_VLOG(2) << "Address \"" << uri->path()
+             << "\" is not IPv4/IPv6. Error: " << resolved_address.status();
+     memset(&address.address, 0, sizeof(address.address));
+   } else {
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc
+index a2b38af3d399b..c36d46e091456 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc
+@@ -20,7 +20,7 @@
+ #include <map>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/security/authorization/audit_logging.h"
+ #include "src/core/lib/security/authorization/authorization_engine.h"
+
+@@ -58,7 +58,7 @@ GrpcAuthorizationEngine::GrpcAuthorizationEngine(Rbac policy)
+   for (auto& logger_config : policy.logger_configs) {
+     auto logger =
+         AuditLoggerRegistry::CreateAuditLogger(std::move(logger_config));
+-    CHECK(logger != nullptr);
++    ABSL_CHECK(logger != nullptr);
+     audit_loggers_.push_back(std::move(logger));
+   }
+ }
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc
+index 6b7a1ccec9f1c..edab3011b58cb 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc
+@@ -25,8 +25,8 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/error.h"
+ #include "src/core/lib/security/authorization/grpc_authorization_engine.h"
+@@ -79,8 +79,8 @@ gpr_timespec TimeoutSecondsToDeadline(int64_t seconds) {
+ absl::StatusOr<RefCountedPtr<grpc_authorization_policy_provider>>
+ FileWatcherAuthorizationPolicyProvider::Create(
+     absl::string_view authz_policy_path, unsigned int refresh_interval_sec) {
+-  CHECK(!authz_policy_path.empty());
+-  CHECK_GT(refresh_interval_sec, 0u);
++  ABSL_CHECK(!authz_policy_path.empty());
++  ABSL_CHECK_GT(refresh_interval_sec, 0u);
+   absl::Status status;
+   auto provider = MakeRefCounted<FileWatcherAuthorizationPolicyProvider>(
+       authz_policy_path, refresh_interval_sec, &status);
+@@ -102,7 +102,7 @@ FileWatcherAuthorizationPolicyProvider::FileWatcherAuthorizationPolicyProvider(
+   auto thread_lambda = [](void* arg) {
+     WeakRefCountedPtr<FileWatcherAuthorizationPolicyProvider> provider(
+         static_cast<FileWatcherAuthorizationPolicyProvider*>(arg));
+-    CHECK(provider != nullptr);
++    ABSL_CHECK(provider != nullptr);
+     while (true) {
+       void* value = gpr_event_wait(
+           &provider->shutdown_event_,
+@@ -112,7 +112,7 @@ FileWatcherAuthorizationPolicyProvider::FileWatcherAuthorizationPolicyProvider(
+       }
+       absl::Status status = provider->ForceUpdate();
+       if (GRPC_TRACE_FLAG_ENABLED(grpc_authz_api) && !status.ok()) {
+-        LOG(ERROR) << "authorization policy reload status. code="
++        ABSL_LOG(ERROR) << "authorization policy reload status. code="
+                    << static_cast<int>(status.code())
+                    << " error_details=" << status.message();
+       }
+@@ -187,7 +187,7 @@ grpc_authorization_policy_provider*
+ grpc_authorization_policy_provider_static_data_create(
+     const char* authz_policy, grpc_status_code* code,
+     const char** error_details) {
+-  CHECK_NE(authz_policy, nullptr);
++  ABSL_CHECK_NE(authz_policy, nullptr);
+   auto provider_or =
+       grpc_core::StaticDataAuthorizationPolicyProvider::Create(authz_policy);
+   if (!provider_or.ok()) {
+@@ -203,7 +203,7 @@ grpc_authorization_policy_provider*
+ grpc_authorization_policy_provider_file_watcher_create(
+     const char* authz_policy_path, unsigned int refresh_interval_sec,
+     grpc_status_code* code, const char** error_details) {
+-  CHECK_NE(authz_policy_path, nullptr);
++  ABSL_CHECK_NE(authz_policy_path, nullptr);
+   auto provider_or = grpc_core::FileWatcherAuthorizationPolicyProvider::Create(
+       authz_policy_path, refresh_interval_sec);
+   if (!provider_or.ok()) {
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc b/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc
+index 6548d807fae24..67b1401cbba8a 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc
+@@ -21,7 +21,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_join.h"
+ #include "src/core/lib/channel/channel_stack.h"
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc b/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc
+index c113514f2334b..31f07264ce055 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc
+@@ -20,7 +20,7 @@
+
+ #include <string>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+@@ -155,7 +155,7 @@ IpAuthorizationMatcher::IpAuthorizationMatcher(Type type, Rbac::CidrRange range)
+   auto address =
+       StringToSockaddr(range.address_prefix, 0);  // Port does not matter here.
+   if (!address.ok()) {
+-    VLOG(2) << "CidrRange address \"" << range.address_prefix
++    ABSL_VLOG(2) << "CidrRange address \"" << range.address_prefix
+             << "\" is not IPv4/IPv6. Error: " << address.status();
+     memset(&subnet_address_, 0, sizeof(subnet_address_));
+     return;
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc b/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc
+index 21e6358e5f405..8805d5123b373 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc
+@@ -26,7 +26,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+@@ -419,7 +419,7 @@ ParseAuditLogger(const Json& json, size_t pos) {
+ }
+
+ absl::Status ParseAuditLoggingOptions(const Json& json, RbacPolicies* rbacs) {
+-  CHECK_NE(rbacs, nullptr);
++  ABSL_CHECK_NE(rbacs, nullptr);
+   for (auto it = json.object().begin(); it != json.object().end(); ++it) {
+     if (it->first == "audit_condition") {
+       if (it->second.type() != Json::Type::kString) {
+@@ -473,7 +473,7 @@ absl::Status ParseAuditLoggingOptions(const Json& json, RbacPolicies* rbacs) {
+             // Parse again since it returns unique_ptr, but result should be ok
+             // this time.
+             auto result = ParseAuditLogger(loggers.at(i), i);
+-            CHECK(result.ok());
++            ABSL_CHECK(result.ok());
+             rbacs->deny_policy->logger_configs.push_back(
+                 std::move(result.value()));
+           }
+diff --git a/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc b/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc
+index f2fc5eaa6a623..3d2bcd42a6c33 100644
+--- a/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc
++++ b/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc
+@@ -22,7 +22,7 @@
+ #include <memory>
+ #include <string>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+@@ -65,8 +65,8 @@ StdoutAuditLoggerFactory::ParseAuditLoggerConfig(const Json&) {
+ std::unique_ptr<AuditLogger> StdoutAuditLoggerFactory::CreateAuditLogger(
+     std::unique_ptr<AuditLoggerFactory::Config> config) {
+   // Sanity check.
+-  CHECK(config != nullptr);
+-  CHECK(config->name() == name());
++  ABSL_CHECK(config != nullptr);
++  ABSL_CHECK(config->name() == name());
+   return std::make_unique<StdoutAuditLogger>();
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc b/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc
+index 40b9a6a90c9c1..dc25f6f17f2b4 100644
+--- a/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc
++++ b/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc
+@@ -23,16 +23,16 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+
+ namespace grpc_core {
+
+ void CertificateProviderRegistry::Builder::RegisterCertificateProviderFactory(
+     std::unique_ptr<CertificateProviderFactory> factory) {
+   absl::string_view name = factory->name();
+-  VLOG(2) << "registering certificate provider factory for \"" << name << "\"";
+-  CHECK(factories_.emplace(name, std::move(factory)).second);
++  ABSL_VLOG(2) << "registering certificate provider factory for \"" << name << "\"";
++  ABSL_CHECK(factories_.emplace(name, std::move(factory)).second);
+ }
+
+ CertificateProviderRegistry CertificateProviderRegistry::Builder::Build() {
+diff --git a/third_party/grpc/source/src/core/lib/security/context/security_context.cc b/third_party/grpc/source/src/core/lib/security/context/security_context.cc
+index 46fe754b72824..cabbfd125dfad 100644
+--- a/third_party/grpc/source/src/core/lib/security/context/security_context.cc
++++ b/third_party/grpc/source/src/core/lib/security/context/security_context.cc
+@@ -27,8 +27,8 @@
+
+ #include <algorithm>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -46,7 +46,7 @@ grpc_call_error grpc_call_set_credentials(grpc_call* call,
+   GRPC_TRACE_LOG(api, INFO) << "grpc_call_set_credentials(call=" << call
+                             << ", creds=" << creds << ")";
+   if (!grpc_call_is_client(call)) {
+-    LOG(ERROR) << "Method is client-side only.";
++    ABSL_LOG(ERROR) << "Method is client-side only.";
+     return GRPC_CALL_ERROR_NOT_ON_SERVER;
+   }
+   auto* arena = grpc_call_get_arena(call);
+@@ -154,7 +154,7 @@ int grpc_auth_context_set_peer_identity_property_name(grpc_auth_context* ctx,
+       << "grpc_auth_context_set_peer_identity_property_name(ctx=" << ctx
+       << ", name=" << name << ")";
+   if (prop == nullptr) {
+-    LOG(ERROR) << "Property name " << (name != nullptr ? name : "NULL")
++    ABSL_LOG(ERROR) << "Property name " << (name != nullptr ? name : "NULL")
+                << " not found in auth context.";
+     return 0;
+   }
+@@ -194,7 +194,7 @@ const grpc_auth_property* grpc_auth_property_iterator_next(
+     while (it->index < it->ctx->properties().count) {
+       const grpc_auth_property* prop =
+           &it->ctx->properties().array[it->index++];
+-      CHECK_NE(prop->name, nullptr);
++      ABSL_CHECK_NE(prop->name, nullptr);
+       if (strcmp(it->name, prop->name) == 0) {
+         return prop;
+       }
+@@ -312,7 +312,7 @@ grpc_arg grpc_auth_context_to_arg(grpc_auth_context* c) {
+ grpc_auth_context* grpc_auth_context_from_arg(const grpc_arg* arg) {
+   if (strcmp(arg->key, GRPC_AUTH_CONTEXT_ARG) != 0) return nullptr;
+   if (arg->type != GRPC_ARG_POINTER) {
+-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
++    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+                << GRPC_AUTH_CONTEXT_ARG;
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc
+index 37628d18321ae..b89db66dfe7a9 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc
+@@ -24,7 +24,7 @@
+ #include <stdio.h>
+ #include <string.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+
+ const size_t kBiosDataBufferSize = 256;
+
+@@ -56,7 +56,7 @@ namespace internal {
+ char* read_bios_file(const char* bios_file) {
+   FILE* fp = fopen(bios_file, "r");
+   if (!fp) {
+-    VLOG(2) << "BIOS data file does not exist or cannot be opened.";
++    ABSL_VLOG(2) << "BIOS data file does not exist or cannot be opened.";
+     return nullptr;
+   }
+   char buf[kBiosDataBufferSize + 1];
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc
+index bf64fe60a36ae..583d1f4067cbc 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc
+@@ -20,12 +20,12 @@
+
+ #if !defined(GPR_LINUX) && !defined(GPR_WINDOWS)
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/security/credentials/alts/check_gcp_environment.h"
+ #include "src/core/util/crash.h"
+
+ bool grpc_alts_is_running_on_gcp() {
+-  VLOG(2) << "ALTS: Platforms other than Linux and Windows are not supported";
++  ABSL_VLOG(2) << "ALTS: Platforms other than Linux and Windows are not supported";
+   return false;
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc
+index 37a1856713a62..e801ae1987cdf 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <grpc/support/string_util.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/security/credentials/alts/grpc_alts_credentials_options.h"
+ #include "src/core/tsi/alts/handshaker/transport_security_common_api.h"
+
+@@ -44,7 +44,7 @@ static target_service_account* target_service_account_create(
+ void grpc_alts_credentials_client_options_add_target_service_account(
+     grpc_alts_credentials_options* options, const char* service_account) {
+   if (options == nullptr || service_account == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to "
+            "grpc_alts_credentials_client_options_add_target_service_account()";
+     return;
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc
+index a52dfe9617395..2d19d93602600 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+
+ grpc_alts_credentials_options* grpc_alts_credentials_options_copy(
+     const grpc_alts_credentials_options* options) {
+@@ -30,7 +30,7 @@ grpc_alts_credentials_options* grpc_alts_credentials_options_copy(
+     return options->vtable->copy(options);
+   }
+   // An error occurred.
+-  LOG(ERROR) << "Invalid arguments to grpc_alts_credentials_options_copy()";
++  ABSL_LOG(ERROR) << "Invalid arguments to grpc_alts_credentials_options_copy()";
+   return nullptr;
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc b/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc
+index e97ba305f17d4..54be4273852fb 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc
+@@ -20,8 +20,8 @@
+ #include <grpc/support/string_util.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/security/context/security_context.h"
+@@ -41,13 +41,13 @@ struct ServiceUrlAndMethod {
+ ServiceUrlAndMethod MakeServiceUrlAndMethod(
+     const ClientMetadataHandle& initial_metadata,
+     const grpc_call_credentials::GetRequestMetadataArgs* args) {
+-  DCHECK(initial_metadata->get_pointer(HttpPathMetadata()) != nullptr);
++  ABSL_DCHECK(initial_metadata->get_pointer(HttpPathMetadata()) != nullptr);
+   auto service =
+       initial_metadata->get_pointer(HttpPathMetadata())->as_string_view();
+   auto last_slash = service.find_last_of('/');
+   absl::string_view method_name;
+   if (last_slash == absl::string_view::npos) {
+-    LOG(ERROR) << "No '/' found in fully qualified method name";
++    ABSL_LOG(ERROR) << "No '/' found in fully qualified method name";
+     service = "";
+     method_name = "";
+   } else if (last_slash == 0) {
+@@ -56,7 +56,7 @@ ServiceUrlAndMethod MakeServiceUrlAndMethod(
+     method_name = service.substr(last_slash + 1);
+     service = service.substr(0, last_slash);
+   }
+-  DCHECK(initial_metadata->get_pointer(HttpAuthorityMetadata()) != nullptr);
++  ABSL_DCHECK(initial_metadata->get_pointer(HttpAuthorityMetadata()) != nullptr);
+   auto host_and_port =
+       initial_metadata->get_pointer(HttpAuthorityMetadata())->as_string_view();
+   absl::string_view url_scheme = args->security_connector->url_scheme();
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc
+index 81b6463421fa4..d10f4a1c0addd 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc
+@@ -24,7 +24,7 @@
+ #include <memory>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -127,9 +127,9 @@ grpc_call_credentials* grpc_composite_call_credentials_create(
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_composite_call_credentials_create(creds1=" << creds1
+       << ", creds2=" << creds2 << ", reserved=" << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
+-  CHECK_NE(creds1, nullptr);
+-  CHECK_NE(creds2, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_NE(creds1, nullptr);
++  ABSL_CHECK_NE(creds2, nullptr);
+
+   return composite_call_credentials_create(creds1->Ref(), creds2->Ref())
+       .release();
+@@ -141,8 +141,8 @@ grpc_core::RefCountedPtr<grpc_channel_security_connector>
+ grpc_composite_channel_credentials::create_security_connector(
+     grpc_core::RefCountedPtr<grpc_call_credentials> call_creds,
+     const char* target, grpc_core::ChannelArgs* args) {
+-  CHECK(inner_creds_ != nullptr);
+-  CHECK(call_creds_ != nullptr);
++  ABSL_CHECK(inner_creds_ != nullptr);
++  ABSL_CHECK(call_creds_ != nullptr);
+   // If we are passed a call_creds, create a call composite to pass it
+   // downstream.
+   if (call_creds != nullptr) {
+@@ -157,7 +157,7 @@ grpc_composite_channel_credentials::create_security_connector(
+ grpc_channel_credentials* grpc_composite_channel_credentials_create(
+     grpc_channel_credentials* channel_creds, grpc_call_credentials* call_creds,
+     void* reserved) {
+-  CHECK(channel_creds != nullptr && call_creds != nullptr &&
++  ABSL_CHECK(channel_creds != nullptr && call_creds != nullptr &&
+         reserved == nullptr);
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_composite_channel_credentials_create(channel_creds="
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc
+index 69a0180b93c18..4154cdceee102 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc
+@@ -22,8 +22,8 @@
+ #include <stdint.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -73,7 +73,7 @@ grpc_channel_credentials* grpc_channel_credentials_from_arg(
+     const grpc_arg* arg) {
+   if (strcmp(arg->key, GRPC_ARG_CHANNEL_CREDENTIALS) != 0) return nullptr;
+   if (arg->type != GRPC_ARG_POINTER) {
+-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
++    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+                << GRPC_ARG_CHANNEL_CREDENTIALS;
+     return nullptr;
+   }
+@@ -112,7 +112,7 @@ void grpc_server_credentials::set_auth_metadata_processor(
+
+ void grpc_server_credentials_set_auth_metadata_processor(
+     grpc_server_credentials* creds, grpc_auth_metadata_processor processor) {
+-  DCHECK_NE(creds, nullptr);
++  ABSL_DCHECK_NE(creds, nullptr);
+   creds->set_auth_metadata_processor(processor);
+ }
+
+@@ -140,7 +140,7 @@ grpc_arg grpc_server_credentials_to_arg(grpc_server_credentials* c) {
+ grpc_server_credentials* grpc_server_credentials_from_arg(const grpc_arg* arg) {
+   if (strcmp(arg->key, GRPC_SERVER_CREDENTIALS_ARG) != 0) return nullptr;
+   if (arg->type != GRPC_ARG_POINTER) {
+-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
++    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+                << GRPC_SERVER_CREDENTIALS_ARG;
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/credentials.h b/third_party/grpc/source/src/core/lib/security/credentials/credentials.h
+index 2daef3c6b0088..b08d81f3752ce 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/credentials.h
++++ b/third_party/grpc/source/src/core/lib/security/credentials/credentials.h
+@@ -30,7 +30,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/channel/channel_args.h"
+@@ -136,7 +136,7 @@ struct grpc_channel_credentials
+   // two different `grpc_channel_credentials` objects are used but they compare
+   // as equal (assuming other channel args match).
+   int cmp(const grpc_channel_credentials* other) const {
+-    CHECK_NE(other, nullptr);
++    ABSL_CHECK_NE(other, nullptr);
+     int r = type().Compare(other->type());
+     if (r != 0) return r;
+     return cmp_impl(other);
+@@ -217,7 +217,7 @@ struct grpc_call_credentials
+   // If this method returns 0, it means that gRPC can treat the two call
+   // credentials as effectively the same..
+   int cmp(const grpc_call_credentials* other) const {
+-    CHECK_NE(other, nullptr);
++    ABSL_CHECK_NE(other, nullptr);
+     int r = type().Compare(other->type());
+     if (r != 0) return r;
+     return cmp_impl(other);
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
+index e14088496a62a..3a2bb78d9094f 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
+@@ -28,7 +28,7 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -423,8 +423,8 @@ void AwsExternalAccountCredentials::AwsFetchBody::BuildSubjectToken() {
+ void AwsExternalAccountCredentials::AwsFetchBody::AddMetadataRequestHeaders(
+     grpc_http_request* request) {
+   if (!imdsv2_session_token_.empty()) {
+-    CHECK_EQ(request->hdr_count, 0u);
+-    CHECK_EQ(request->hdrs, nullptr);
++    ABSL_CHECK_EQ(request->hdr_count, 0u);
++    ABSL_CHECK_EQ(request->hdrs, nullptr);
+     grpc_http_header* headers =
+         static_cast<grpc_http_header*>(gpr_malloc(sizeof(grpc_http_header)));
+     headers[0].key = gpr_strdup("x-aws-ec2-metadata-token");
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc
+index f05cd63f9e674..8889707658173 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc
+@@ -29,8 +29,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/escaping.h"
+@@ -392,7 +392,7 @@ void ExternalAccountCredentials::ExternalFetchRequest::FinishTokenFetch(
+     absl::StatusOr<std::string> response_body) {
+   absl::StatusOr<RefCountedPtr<Token>> result;
+   if (!response_body.ok()) {
+-    LOG(ERROR) << "Fetch external account credentials access token: "
++    ABSL_LOG(ERROR) << "Fetch external account credentials access token: "
+                << response_body.status();
+     result = absl::Status(response_body.status().code(),
+                           absl::StrCat("error fetching oauth2 token: ",
+@@ -627,7 +627,7 @@ grpc_call_credentials* grpc_external_account_credentials_create(
+     const char* json_string, const char* scopes_string) {
+   auto json = grpc_core::JsonParse(json_string);
+   if (!json.ok()) {
+-    LOG(ERROR) << "External account credentials creation failed. Error: "
++    ABSL_LOG(ERROR) << "External account credentials creation failed. Error: "
+                << json.status();
+     return nullptr;
+   }
+@@ -635,7 +635,7 @@ grpc_call_credentials* grpc_external_account_credentials_create(
+   auto creds =
+       grpc_core::ExternalAccountCredentials::Create(*json, std::move(scopes));
+   if (!creds.ok()) {
+-    LOG(ERROR) << "External account credentials creation failed. Error: "
++    ABSL_LOG(ERROR) << "External account credentials creation failed. Error: "
+                << grpc_core::StatusToString(creds.status());
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc
+index 502700a4d64d2..689efe1a6ddc5 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc
+@@ -27,7 +27,7 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
+index 31d00e7bfd39f..595436c453f1c 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
+@@ -182,7 +182,7 @@ GcpServiceAccountIdentityCallCredentials::StartHttpRequest(
+       "http", "metadata.google.internal.",
+       "/computeMetadata/v1/instance/service-accounts/default/identity",
+       {{"audience", audience_}}, /*fragment=*/"");
+-  CHECK_OK(uri);  // params are hardcoded
++  ABSL_CHECK_OK(uri);  // params are hardcoded
+   auto http_request =
+       HttpRequest::Get(std::move(*uri), /*args=*/nullptr, pollent, &request,
+                        deadline, on_complete, response,
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc b/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc
+index 771f9c128acf0..6a40ca908cd65 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc
+@@ -21,7 +21,7 @@
+ #include <optional>
+ #include <string>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/security/credentials/credentials.h"
+ #include "src/core/lib/security/credentials/google_default/google_default_credentials.h"
+@@ -30,7 +30,7 @@
+ std::string grpc_get_well_known_google_credentials_file_path_impl(void) {
+   auto base = grpc_core::GetEnv(GRPC_GOOGLE_CREDENTIALS_PATH_ENV_VAR);
+   if (!base.has_value()) {
+-    LOG(ERROR) << "Could not get " << GRPC_GOOGLE_CREDENTIALS_PATH_ENV_VAR
++    ABSL_LOG(ERROR) << "Could not get " << GRPC_GOOGLE_CREDENTIALS_PATH_ENV_VAR
+                << " environment variable.";
+     return "";
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc
+index 8c4dfed149616..8b4db2ac9775a 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc
+@@ -32,8 +32,8 @@
+ #include <optional>
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+@@ -135,7 +135,7 @@ grpc_google_default_channel_credentials::create_security_connector(
+                         is_xds_non_cfe_cluster;
+   // Return failure if ALTS is selected but not running on GCE.
+   if (use_alts && alts_creds_ == nullptr) {
+-    LOG(ERROR) << "ALTS is selected, but not running on GCE.";
++    ABSL_LOG(ERROR) << "ALTS is selected, but not running on GCE.";
+     return nullptr;
+   }
+   grpc_core::RefCountedPtr<grpc_channel_security_connector> sc =
+@@ -213,7 +213,7 @@ static int is_metadata_server_reachable() {
+   auto uri =
+       grpc_core::URI::Create("http", GRPC_COMPUTE_ENGINE_DETECTION_HOST, "/",
+                              {} /* query params */, "" /* fragment */);
+-  CHECK(uri.ok());  // params are hardcoded
++  ABSL_CHECK(uri.ok());  // params are hardcoded
+   auto http_request = grpc_core::HttpRequest::Get(
+       std::move(*uri), nullptr /* channel args */, &detector.pollent, &request,
+       grpc_core::Timestamp::Now() + max_detection_delay,
+@@ -378,7 +378,7 @@ grpc_channel_credentials* grpc_google_default_credentials_create(
+     // Create google default credentials.
+     grpc_channel_credentials* ssl_creds =
+         grpc_ssl_credentials_create(nullptr, nullptr, nullptr, nullptr);
+-    CHECK_NE(ssl_creds, nullptr);
++    ABSL_CHECK_NE(ssl_creds, nullptr);
+     grpc_alts_credentials_options* options =
+         grpc_alts_credentials_client_options_create();
+     grpc_channel_credentials* alts_creds =
+@@ -390,9 +390,9 @@ grpc_channel_credentials* grpc_google_default_credentials_create(
+             grpc_core::RefCountedPtr<grpc_channel_credentials>(ssl_creds));
+     result = grpc_composite_channel_credentials_create(
+         creds.get(), call_creds.get(), nullptr);
+-    CHECK_NE(result, nullptr);
++    ABSL_CHECK_NE(result, nullptr);
+   } else {
+-    LOG(ERROR) << "Could not create google default credentials: "
++    ABSL_LOG(ERROR) << "Could not create google default credentials: "
+                << grpc_core::StatusToString(error);
+   }
+   return result;
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc
+index 3d1acd4a037fa..03e2eb20e6152 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc
+@@ -24,7 +24,7 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -69,9 +69,9 @@ grpc_call_credentials* grpc_google_iam_credentials_create(
+   GRPC_TRACE_LOG(api, INFO) << "grpc_iam_credentials_create(token=" << token
+                             << ", authority_selector=" << authority_selector
+                             << ", reserved=" << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
+-  CHECK_NE(token, nullptr);
+-  CHECK_NE(authority_selector, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_NE(token, nullptr);
++  ABSL_CHECK_NE(authority_selector, nullptr);
+   return grpc_core::MakeRefCounted<grpc_google_iam_credentials>(
+              token, authority_selector)
+       .release();
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc b/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc
+index eac638a1283c9..5295693f670bb 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc
+@@ -35,8 +35,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/escaping.h"
+@@ -83,7 +83,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_json(const Json& json) {
+   memset(&result, 0, sizeof(grpc_auth_json_key));
+   result.type = GRPC_AUTH_JSON_TYPE_INVALID;
+   if (json.type() == Json::Type::kNull) {
+-    LOG(ERROR) << "Invalid json.";
++    ABSL_LOG(ERROR) << "Invalid json.";
+     goto end;
+   }
+
+@@ -111,7 +111,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_json(const Json& json) {
+   bio = BIO_new(BIO_s_mem());
+   success = BIO_puts(bio, prop_value);
+   if ((success < 0) || (static_cast<size_t>(success) != strlen(prop_value))) {
+-    LOG(ERROR) << "Could not write into openssl BIO.";
++    ABSL_LOG(ERROR) << "Could not write into openssl BIO.";
+     goto end;
+   }
+ #if OPENSSL_VERSION_NUMBER < 0x30000000L
+@@ -121,7 +121,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_json(const Json& json) {
+   result.private_key = PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);
+ #endif
+   if (result.private_key == nullptr) {
+-    LOG(ERROR) << "Could not deserialize private key.";
++    ABSL_LOG(ERROR) << "Could not deserialize private key.";
+     goto end;
+   }
+   success = 1;
+@@ -137,7 +137,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_string(
+   Json json;
+   auto json_or = grpc_core::JsonParse(json_string);
+   if (!json_or.ok()) {
+-    LOG(ERROR) << "JSON key parsing error: " << json_or.status();
++    ABSL_LOG(ERROR) << "JSON key parsing error: " << json_or.status();
+   } else {
+     json = std::move(*json_or);
+   }
+@@ -187,7 +187,7 @@ static char* encoded_jwt_claim(const grpc_auth_json_key* json_key,
+   gpr_timespec now = gpr_now(GPR_CLOCK_REALTIME);
+   gpr_timespec expiration = gpr_time_add(now, token_lifetime);
+   if (gpr_time_cmp(token_lifetime, grpc_max_auth_token_lifetime()) > 0) {
+-    VLOG(2) << "Cropping token lifetime to maximum allowed value.";
++    ABSL_VLOG(2) << "Cropping token lifetime to maximum allowed value.";
+     expiration = gpr_time_add(now, grpc_max_auth_token_lifetime());
+   }
+
+@@ -221,8 +221,8 @@ static char* dot_concat_and_free_strings(char* str1, char* str2) {
+   *(current++) = '.';
+   memcpy(current, str2, str2_len);
+   current += str2_len;
+-  CHECK(current >= result);
+-  CHECK((uintptr_t)(current - result) == result_len);
++  ABSL_CHECK(current >= result);
++  ABSL_CHECK((uintptr_t)(current - result) == result_len);
+   *current = '\0';
+   gpr_free(str1);
+   gpr_free(str2);
+@@ -233,7 +233,7 @@ const EVP_MD* openssl_digest_from_algorithm(const char* algorithm) {
+   if (strcmp(algorithm, GRPC_JWT_RSA_SHA256_ALGORITHM) == 0) {
+     return EVP_sha256();
+   } else {
+-    LOG(ERROR) << "Unknown algorithm " << algorithm;
++    ABSL_LOG(ERROR) << "Unknown algorithm " << algorithm;
+     return nullptr;
+   }
+ }
+@@ -252,7 +252,7 @@ char* compute_and_encode_signature(const grpc_auth_json_key* json_key,
+   if (md == nullptr) return nullptr;
+   md_ctx = EVP_MD_CTX_create();
+   if (md_ctx == nullptr) {
+-    LOG(ERROR) << "Could not create MD_CTX";
++    ABSL_LOG(ERROR) << "Could not create MD_CTX";
+     goto end;
+   }
+ #if OPENSSL_VERSION_NUMBER < 0x30000000L
+@@ -262,20 +262,20 @@ char* compute_and_encode_signature(const grpc_auth_json_key* json_key,
+   if (EVP_DigestSignInit(md_ctx, nullptr, md, nullptr, json_key->private_key) !=
+       1) {
+ #endif
+-    LOG(ERROR) << "DigestInit failed.";
++    ABSL_LOG(ERROR) << "DigestInit failed.";
+     goto end;
+   }
+   if (EVP_DigestSignUpdate(md_ctx, to_sign, strlen(to_sign)) != 1) {
+-    LOG(ERROR) << "DigestUpdate failed.";
++    ABSL_LOG(ERROR) << "DigestUpdate failed.";
+     goto end;
+   }
+   if (EVP_DigestSignFinal(md_ctx, nullptr, &sig_len) != 1) {
+-    LOG(ERROR) << "DigestFinal (get signature length) failed.";
++    ABSL_LOG(ERROR) << "DigestFinal (get signature length) failed.";
+     goto end;
+   }
+   sig = static_cast<unsigned char*>(gpr_malloc(sig_len));
+   if (EVP_DigestSignFinal(md_ctx, sig, &sig_len) != 1) {
+-    LOG(ERROR) << "DigestFinal (signature compute) failed.";
++    ABSL_LOG(ERROR) << "DigestFinal (signature compute) failed.";
+     goto end;
+   }
+   result =
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc
+index 7047365e9059e..08be171465495 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc
+@@ -30,8 +30,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -113,7 +113,7 @@ grpc_service_account_jwt_access_credentials::
+     : key_(key) {
+   gpr_timespec max_token_lifetime = grpc_max_auth_token_lifetime();
+   if (gpr_time_cmp(token_lifetime, max_token_lifetime) > 0) {
+-    VLOG(2) << "Cropping token lifetime to maximum allowed value ("
++    ABSL_VLOG(2) << "Cropping token lifetime to maximum allowed value ("
+             << max_token_lifetime.tv_sec << " secs).";
+     token_lifetime = grpc_max_auth_token_lifetime();
+   }
+@@ -130,7 +130,7 @@ grpc_core::RefCountedPtr<grpc_call_credentials>
+ grpc_service_account_jwt_access_credentials_create_from_auth_json_key(
+     grpc_auth_json_key key, gpr_timespec token_lifetime) {
+   if (!grpc_auth_json_key_is_valid(&key)) {
+-    LOG(ERROR) << "Invalid input for jwt credentials creation";
++    ABSL_LOG(ERROR) << "Invalid input for jwt credentials creation";
+     return nullptr;
+   }
+   return grpc_core::MakeRefCounted<grpc_service_account_jwt_access_credentials>(
+@@ -153,7 +153,7 @@ grpc_call_credentials* grpc_service_account_jwt_access_credentials_create(
+     const char* json_key, gpr_timespec token_lifetime, void* reserved) {
+   if (GRPC_TRACE_FLAG_ENABLED(api)) {
+     char* clean_json = redact_private_key(json_key);
+-    VLOG(2) << "grpc_service_account_jwt_access_credentials_create("
++    ABSL_VLOG(2) << "grpc_service_account_jwt_access_credentials_create("
+             << "json_key=" << clean_json
+             << ", token_lifetime=gpr_timespec { tv_sec: "
+             << token_lifetime.tv_sec << ", tv_nsec: " << token_lifetime.tv_nsec
+@@ -161,7 +161,7 @@ grpc_call_credentials* grpc_service_account_jwt_access_credentials_create(
+             << " }, reserved=" << reserved << ")";
+     gpr_free(clean_json);
+   }
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
+   grpc_core::ExecCtx exec_ctx;
+   return grpc_service_account_jwt_access_credentials_create_from_auth_json_key(
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc
+index 845a179b89001..f778b2a679732 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc
+@@ -45,8 +45,8 @@
+ #include <grpc/support/string_util.h>
+ #include <grpc/support/time.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/escaping.h"
+@@ -111,12 +111,12 @@ static const EVP_MD* evp_md_from_alg(const char* alg) {
+ static Json parse_json_part_from_jwt(const char* str, size_t len) {
+   std::string string;
+   if (!absl::WebSafeBase64Unescape(absl::string_view(str, len), &string)) {
+-    LOG(ERROR) << "Invalid base64.";
++    ABSL_LOG(ERROR) << "Invalid base64.";
+     return Json();  // JSON null
+   }
+   auto json = grpc_core::JsonParse(string);
+   if (!json.ok()) {
+-    LOG(ERROR) << "JSON parse error: " << json.status();
++    ABSL_LOG(ERROR) << "JSON parse error: " << json.status();
+     return Json();  // JSON null
+   }
+   return std::move(*json);
+@@ -124,7 +124,7 @@ static Json parse_json_part_from_jwt(const char* str, size_t len) {
+
+ static const char* validate_string_field(const Json& json, const char* key) {
+   if (json.type() != Json::Type::kString) {
+-    LOG(ERROR) << "Invalid " << key << " field";
++    ABSL_LOG(ERROR) << "Invalid " << key << " field";
+     return nullptr;
+   }
+   return json.string().c_str();
+@@ -133,7 +133,7 @@ static const char* validate_string_field(const Json& json, const char* key) {
+ static gpr_timespec validate_time_field(const Json& json, const char* key) {
+   gpr_timespec result = gpr_time_0(GPR_CLOCK_REALTIME);
+   if (json.type() != Json::Type::kNumber) {
+-    LOG(ERROR) << "Invalid " << key << " field";
++    ABSL_LOG(ERROR) << "Invalid " << key << " field";
+     return result;
+   }
+   result.tv_sec = strtol(json.string().c_str(), nullptr, 10);
+@@ -159,13 +159,13 @@ static jose_header* jose_header_from_json(Json json) {
+   Json::Object::const_iterator it;
+   jose_header* h = grpc_core::Zalloc<jose_header>();
+   if (json.type() != Json::Type::kObject) {
+-    LOG(ERROR) << "JSON value is not an object";
++    ABSL_LOG(ERROR) << "JSON value is not an object";
+     goto error;
+   }
+   // Check alg field.
+   it = json.object().find("alg");
+   if (it == json.object().end()) {
+-    LOG(ERROR) << "Missing alg field.";
++    ABSL_LOG(ERROR) << "Missing alg field.";
+     goto error;
+   }
+   // We only support RSA-1.5 signatures for now.
+@@ -176,7 +176,7 @@ static jose_header* jose_header_from_json(Json json) {
+   if (it->second.type() != Json::Type::kString ||
+       strncmp(alg_value, "RS", 2) != 0 ||
+       evp_md_from_alg(alg_value) == nullptr) {
+-    LOG(ERROR) << "Invalid alg field";
++    ABSL_LOG(ERROR) << "Invalid alg field";
+     goto error;
+   }
+   h->alg = alg_value;
+@@ -310,18 +310,18 @@ grpc_jwt_verifier_status grpc_jwt_claims_check(const grpc_jwt_claims* claims,
+   gpr_timespec skewed_now;
+   int audience_ok;
+
+-  CHECK_NE(claims, nullptr);
++  ABSL_CHECK_NE(claims, nullptr);
+
+   skewed_now =
+       gpr_time_add(gpr_now(GPR_CLOCK_REALTIME), grpc_jwt_verifier_clock_skew);
+   if (gpr_time_cmp(skewed_now, claims->nbf) < 0) {
+-    LOG(ERROR) << "JWT is not valid yet.";
++    ABSL_LOG(ERROR) << "JWT is not valid yet.";
+     return GRPC_JWT_VERIFIER_TIME_CONSTRAINT_FAILURE;
+   }
+   skewed_now =
+       gpr_time_sub(gpr_now(GPR_CLOCK_REALTIME), grpc_jwt_verifier_clock_skew);
+   if (gpr_time_cmp(skewed_now, claims->exp) > 0) {
+-    LOG(ERROR) << "JWT is expired.";
++    ABSL_LOG(ERROR) << "JWT is expired.";
+     return GRPC_JWT_VERIFIER_TIME_CONSTRAINT_FAILURE;
+   }
+
+@@ -330,7 +330,7 @@ grpc_jwt_verifier_status grpc_jwt_claims_check(const grpc_jwt_claims* claims,
+   // issued.
+   if (grpc_jwt_issuer_email_domain(claims->iss) != nullptr &&
+       claims->sub != nullptr && strcmp(claims->iss, claims->sub) != 0) {
+-    LOG(ERROR) << "Email issuer (" << claims->iss
++    ABSL_LOG(ERROR) << "Email issuer (" << claims->iss
+                << ") cannot assert another subject (" << claims->sub
+                << ") than itself.";
+     return GRPC_JWT_VERIFIER_BAD_SUBJECT;
+@@ -342,7 +342,7 @@ grpc_jwt_verifier_status grpc_jwt_claims_check(const grpc_jwt_claims* claims,
+     audience_ok = claims->aud != nullptr && strcmp(audience, claims->aud) == 0;
+   }
+   if (!audience_ok) {
+-    LOG(ERROR) << "Audience mismatch: expected "
++    ABSL_LOG(ERROR) << "Audience mismatch: expected "
+                << (audience == nullptr ? "NULL" : audience) << " and found "
+                << (claims->aud == nullptr ? "NULL" : claims->aud);
+     return GRPC_JWT_VERIFIER_BAD_AUDIENCE;
+@@ -426,17 +426,17 @@ struct grpc_jwt_verifier {
+
+ static Json json_from_http(const grpc_http_response* response) {
+   if (response == nullptr) {
+-    LOG(ERROR) << "HTTP response is NULL.";
++    ABSL_LOG(ERROR) << "HTTP response is NULL.";
+     return Json();  // JSON null
+   }
+   if (response->status != 200) {
+-    LOG(ERROR) << "Call to http server failed with error " << response->status;
++    ABSL_LOG(ERROR) << "Call to http server failed with error " << response->status;
+     return Json();  // JSON null
+   }
+   auto json = grpc_core::JsonParse(
+       absl::string_view(response->body, response->body_length));
+   if (!json.ok()) {
+-    LOG(ERROR) << "Invalid JSON found in response.";
++    ABSL_LOG(ERROR) << "Invalid JSON found in response.";
+     return Json();  // JSON null
+   }
+   return std::move(*json);
+@@ -455,16 +455,16 @@ static EVP_PKEY* extract_pkey_from_x509(const char* x509_str) {
+   EVP_PKEY* result = nullptr;
+   BIO* bio = BIO_new(BIO_s_mem());
+   size_t len = strlen(x509_str);
+-  CHECK_LT(len, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LT(len, static_cast<size_t>(INT_MAX));
+   BIO_write(bio, x509_str, static_cast<int>(len));
+   x509 = PEM_read_bio_X509(bio, nullptr, nullptr, nullptr);
+   if (x509 == nullptr) {
+-    LOG(ERROR) << "Unable to parse x509 cert.";
++    ABSL_LOG(ERROR) << "Unable to parse x509 cert.";
+     goto end;
+   }
+   result = X509_get_pubkey(x509);
+   if (result == nullptr) {
+-    LOG(ERROR) << "Cannot find public key in X509 cert.";
++    ABSL_LOG(ERROR) << "Cannot find public key in X509 cert.";
+   }
+
+ end:
+@@ -477,7 +477,7 @@ static BIGNUM* bignum_from_base64(const char* b64) {
+   if (b64 == nullptr) return nullptr;
+   std::string string;
+   if (!absl::WebSafeBase64Unescape(b64, &string)) {
+-    LOG(ERROR) << "Invalid base64 for big num.";
++    ABSL_LOG(ERROR) << "Invalid base64 for big num.";
+     return nullptr;
+   }
+   return BN_bin2bn(reinterpret_cast<const uint8_t*>(string.data()),
+@@ -526,36 +526,36 @@ static EVP_PKEY* pkey_from_jwk(const Json& json, const char* kty) {
+   BIGNUM* tmp_e = nullptr;
+   Json::Object::const_iterator it;
+
+-  CHECK(json.type() == Json::Type::kObject);
+-  CHECK_NE(kty, nullptr);
++  ABSL_CHECK(json.type() == Json::Type::kObject);
++  ABSL_CHECK_NE(kty, nullptr);
+   if (strcmp(kty, "RSA") != 0) {
+-    LOG(ERROR) << "Unsupported key type " << kty;
++    ABSL_LOG(ERROR) << "Unsupported key type " << kty;
+     goto end;
+   }
+ #if OPENSSL_VERSION_NUMBER < 0x30000000L
+   rsa = RSA_new();
+   if (rsa == nullptr) {
+-    LOG(ERROR) << "Could not create rsa key.";
++    ABSL_LOG(ERROR) << "Could not create rsa key.";
+     goto end;
+   }
+ #endif
+   it = json.object().find("n");
+   if (it == json.object().end()) {
+-    LOG(ERROR) << "Missing RSA public key field.";
++    ABSL_LOG(ERROR) << "Missing RSA public key field.";
+     goto end;
+   }
+   tmp_n = bignum_from_base64(validate_string_field(it->second, "n"));
+   if (tmp_n == nullptr) goto end;
+   it = json.object().find("e");
+   if (it == json.object().end()) {
+-    LOG(ERROR) << "Missing RSA public key field.";
++    ABSL_LOG(ERROR) << "Missing RSA public key field.";
+     goto end;
+   }
+   tmp_e = bignum_from_base64(validate_string_field(it->second, "e"));
+   if (tmp_e == nullptr) goto end;
+ #if OPENSSL_VERSION_NUMBER < 0x30000000L
+   if (!RSA_set0_key(rsa, tmp_n, tmp_e, nullptr)) {
+-    LOG(ERROR) << "Cannot set RSA key from inputs.";
++    ABSL_LOG(ERROR) << "Cannot set RSA key from inputs.";
+     goto end;
+   }
+   // RSA_set0_key takes ownership on success.
+@@ -568,21 +568,21 @@ static EVP_PKEY* pkey_from_jwk(const Json& json, const char* kty) {
+   if (!OSSL_PARAM_BLD_push_BN(bld, "n", tmp_n) ||
+       !OSSL_PARAM_BLD_push_BN(bld, "e", tmp_e) ||
+       (params = OSSL_PARAM_BLD_to_param(bld)) == NULL) {
+-    LOG(ERROR) << "Could not create OSSL_PARAM";
++    ABSL_LOG(ERROR) << "Could not create OSSL_PARAM";
+     goto end;
+   }
+
+   ctx = EVP_PKEY_CTX_new_from_name(nullptr, "RSA", nullptr);
+   if (ctx == nullptr) {
+-    LOG(ERROR) << "Could not create rsa key.";
++    ABSL_LOG(ERROR) << "Could not create rsa key.";
+     goto end;
+   }
+   if (EVP_PKEY_fromdata_init(ctx) <= 0) {
+-    LOG(ERROR) << "Could not create rsa key.";
++    ABSL_LOG(ERROR) << "Could not create rsa key.";
+     goto end;
+   }
+   if (EVP_PKEY_fromdata(ctx, &result, EVP_PKEY_KEYPAIR, params) <= 0) {
+-    LOG(ERROR) << "Cannot set RSA key from inputs.";
++    ABSL_LOG(ERROR) << "Cannot set RSA key from inputs.";
+     goto end;
+   }
+ #endif
+@@ -613,7 +613,7 @@ static EVP_PKEY* find_verification_key(const Json& json, const char* header_alg,
+     return extract_pkey_from_x509(cur->string().c_str());
+   }
+   if (jwt_keys->type() != Json::Type::kArray) {
+-    LOG(ERROR) << "Unexpected value type of keys property in jwks key set.";
++    ABSL_LOG(ERROR) << "Unexpected value type of keys property in jwks key set.";
+     return nullptr;
+   }
+   // Key format is specified in:
+@@ -640,7 +640,7 @@ static EVP_PKEY* find_verification_key(const Json& json, const char* header_alg,
+       return pkey_from_jwk(jkey, kty);
+     }
+   }
+-  LOG(ERROR) << "Could not find matching key in key set for kid=" << header_kid
++  ABSL_LOG(ERROR) << "Could not find matching key in key set for kid=" << header_kid
+              << " and alg=" << header_alg;
+   return nullptr;
+ }
+@@ -652,23 +652,23 @@ static int verify_jwt_signature(EVP_PKEY* key, const char* alg,
+   const EVP_MD* md = evp_md_from_alg(alg);
+   int result = 0;
+
+-  CHECK_NE(md, nullptr);  // Checked before.
++  ABSL_CHECK_NE(md, nullptr);  // Checked before.
+   if (md_ctx == nullptr) {
+-    LOG(ERROR) << "Could not create EVP_MD_CTX.";
++    ABSL_LOG(ERROR) << "Could not create EVP_MD_CTX.";
+     goto end;
+   }
+   if (EVP_DigestVerifyInit(md_ctx, nullptr, md, nullptr, key) != 1) {
+-    LOG(ERROR) << "EVP_DigestVerifyInit failed.";
++    ABSL_LOG(ERROR) << "EVP_DigestVerifyInit failed.";
+     goto end;
+   }
+   if (EVP_DigestVerifyUpdate(md_ctx, GRPC_SLICE_START_PTR(signed_data),
+                              GRPC_SLICE_LENGTH(signed_data)) != 1) {
+-    LOG(ERROR) << "EVP_DigestVerifyUpdate failed.";
++    ABSL_LOG(ERROR) << "EVP_DigestVerifyUpdate failed.";
+     goto end;
+   }
+   if (EVP_DigestVerifyFinal(md_ctx, GRPC_SLICE_START_PTR(signature),
+                             GRPC_SLICE_LENGTH(signature)) != 1) {
+-    LOG(ERROR) << "JWT signature verification failed.";
++    ABSL_LOG(ERROR) << "JWT signature verification failed.";
+
+     goto end;
+   }
+@@ -693,7 +693,7 @@ static void on_keys_retrieved(void* user_data, grpc_error_handle /*error*/) {
+   verification_key =
+       find_verification_key(json, ctx->header->alg, ctx->header->kid);
+   if (verification_key == nullptr) {
+-    LOG(ERROR) << "Could not find verification key with kid "
++    ABSL_LOG(ERROR) << "Could not find verification key with kid "
+                << ctx->header->kid;
+     status = GRPC_JWT_VERIFIER_KEY_RETRIEVAL_ERROR;
+     goto end;
+@@ -735,13 +735,13 @@ static void on_openid_config_retrieved(void* user_data,
+   if (json.type() == Json::Type::kNull) goto error;
+   cur = find_property_by_name(json, "jwks_uri");
+   if (cur == nullptr) {
+-    LOG(ERROR) << "Could not find jwks_uri in openid config.";
++    ABSL_LOG(ERROR) << "Could not find jwks_uri in openid config.";
+     goto error;
+   }
+   jwks_uri = validate_string_field(*cur, "jwks_uri");
+   if (jwks_uri == nullptr) goto error;
+   if (strstr(jwks_uri, "https://") != jwks_uri) {
+-    LOG(ERROR) << "Invalid non https jwks_uri: " << jwks_uri;
++    ABSL_LOG(ERROR) << "Invalid non https jwks_uri: " << jwks_uri;
+     goto error;
+   }
+   jwks_uri += 8;
+@@ -791,7 +791,7 @@ static email_key_mapping* verifier_get_mapping(grpc_jwt_verifier* v,
+ static void verifier_put_mapping(grpc_jwt_verifier* v, const char* email_domain,
+                                  const char* key_url_prefix) {
+   email_key_mapping* mapping = verifier_get_mapping(v, email_domain);
+-  CHECK(v->num_mappings < v->allocated_mappings);
++  ABSL_CHECK(v->num_mappings < v->allocated_mappings);
+   if (mapping != nullptr) {
+     gpr_free(mapping->key_url_prefix);
+     mapping->key_url_prefix = gpr_strdup(key_url_prefix);
+@@ -800,7 +800,7 @@ static void verifier_put_mapping(grpc_jwt_verifier* v, const char* email_domain,
+   v->mappings[v->num_mappings].email_domain = gpr_strdup(email_domain);
+   v->mappings[v->num_mappings].key_url_prefix = gpr_strdup(key_url_prefix);
+   v->num_mappings++;
+-  CHECK(v->num_mappings <= v->allocated_mappings);
++  ABSL_CHECK(v->num_mappings <= v->allocated_mappings);
+ }
+
+ // Very non-sophisticated way to detect an email address. Should be good
+@@ -812,7 +812,7 @@ const char* grpc_jwt_issuer_email_domain(const char* issuer) {
+   if (*email_domain == '\0') return nullptr;
+   const char* dot = strrchr(email_domain, '.');
+   if (dot == nullptr || dot == email_domain) return email_domain;
+-  CHECK(dot > email_domain);
++  ABSL_CHECK(dot > email_domain);
+   // There may be a subdomain, we just want the domain.
+   dot = static_cast<const char*>(
+       gpr_memrchr(email_domain, '.', static_cast<size_t>(dot - email_domain)));
+@@ -833,14 +833,14 @@ static void retrieve_key_and_verify(verifier_cb_ctx* ctx) {
+   char* path;
+   absl::StatusOr<grpc_core::URI> uri;
+
+-  CHECK(ctx != nullptr && ctx->header != nullptr && ctx->claims != nullptr);
++  ABSL_CHECK(ctx != nullptr && ctx->header != nullptr && ctx->claims != nullptr);
+   iss = ctx->claims->iss;
+   if (ctx->header->kid == nullptr) {
+-    LOG(ERROR) << "Missing kid in jose header.";
++    ABSL_LOG(ERROR) << "Missing kid in jose header.";
+     goto error;
+   }
+   if (iss == nullptr) {
+-    LOG(ERROR) << "Missing iss in claims.";
++    ABSL_LOG(ERROR) << "Missing iss in claims.";
+     goto error;
+   }
+
+@@ -852,10 +852,10 @@ static void retrieve_key_and_verify(verifier_cb_ctx* ctx) {
+   email_domain = grpc_jwt_issuer_email_domain(iss);
+   if (email_domain != nullptr) {
+     email_key_mapping* mapping;
+-    CHECK_NE(ctx->verifier, nullptr);
++    ABSL_CHECK_NE(ctx->verifier, nullptr);
+     mapping = verifier_get_mapping(ctx->verifier, email_domain);
+     if (mapping == nullptr) {
+-      LOG(ERROR) << "Missing mapping for issuer email.";
++      ABSL_LOG(ERROR) << "Missing mapping for issuer email.";
+       goto error;
+     }
+     host = gpr_strdup(mapping->key_url_prefix);
+@@ -919,7 +919,7 @@ void grpc_jwt_verifier_verify(grpc_jwt_verifier* verifier,
+   Json json;
+   std::string signature_str;
+
+-  CHECK(verifier != nullptr && jwt != nullptr && audience != nullptr &&
++  ABSL_CHECK(verifier != nullptr && jwt != nullptr && audience != nullptr &&
+         cb != nullptr);
+   dot = strchr(cur, '.');
+   if (dot == nullptr) goto error;
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
+index 7414b25cdd58d..8bc3906d97343 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
+@@ -35,8 +35,8 @@
+ #include <memory>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/numbers.h"
+ #include "absl/strings/str_cat.h"
+@@ -83,7 +83,7 @@ grpc_auth_refresh_token grpc_auth_refresh_token_create_from_json(
+   memset(&result, 0, sizeof(grpc_auth_refresh_token));
+   result.type = GRPC_AUTH_JSON_TYPE_INVALID;
+   if (json.type() != Json::Type::kObject) {
+-    LOG(ERROR) << "Invalid json.";
++    ABSL_LOG(ERROR) << "Invalid json.";
+     goto end;
+   }
+
+@@ -114,7 +114,7 @@ grpc_auth_refresh_token grpc_auth_refresh_token_create_from_string(
+   Json json;
+   auto json_or = grpc_core::JsonParse(json_string);
+   if (!json_or.ok()) {
+-    LOG(ERROR) << "JSON parsing failed: " << json_or.status();
++    ABSL_LOG(ERROR) << "JSON parsing failed: " << json_or.status();
+   } else {
+     json = std::move(*json_or);
+   }
+@@ -148,34 +148,34 @@ grpc_oauth2_token_fetcher_credentials_parse_server_response_body(
+     grpc_core::Duration* token_lifetime) {
+   auto json = grpc_core::JsonParse(body);
+   if (!json.ok()) {
+-    LOG(ERROR) << "Could not parse JSON from " << body << ": " << json.status();
++    ABSL_LOG(ERROR) << "Could not parse JSON from " << body << ": " << json.status();
+     return GRPC_CREDENTIALS_ERROR;
+   }
+   if (json->type() != Json::Type::kObject) {
+-    LOG(ERROR) << "Response should be a JSON object";
++    ABSL_LOG(ERROR) << "Response should be a JSON object";
+     return GRPC_CREDENTIALS_ERROR;
+   }
+   auto it = json->object().find("access_token");
+   if (it == json->object().end() || it->second.type() != Json::Type::kString) {
+-    LOG(ERROR) << "Missing or invalid access_token in JSON.";
++    ABSL_LOG(ERROR) << "Missing or invalid access_token in JSON.";
+     return GRPC_CREDENTIALS_ERROR;
+   }
+   absl::string_view access_token = it->second.string();
+   it = json->object().find("token_type");
+   if (it == json->object().end() || it->second.type() != Json::Type::kString) {
+-    LOG(ERROR) << "Missing or invalid token_type in JSON.";
++    ABSL_LOG(ERROR) << "Missing or invalid token_type in JSON.";
+     return GRPC_CREDENTIALS_ERROR;
+   }
+   absl::string_view token_type = it->second.string();
+   it = json->object().find("expires_in");
+   if (it == json->object().end() || it->second.type() != Json::Type::kNumber) {
+-    LOG(ERROR) << "Missing or invalid expires_in in JSON.";
++    ABSL_LOG(ERROR) << "Missing or invalid expires_in in JSON.";
+     return GRPC_CREDENTIALS_ERROR;
+   }
+   absl::string_view expires_in = it->second.string();
+   long seconds;
+   if (!absl::SimpleAtoi(expires_in, &seconds)) {
+-    LOG(ERROR) << "Invalid expires_in in JSON.";
++    ABSL_LOG(ERROR) << "Invalid expires_in in JSON.";
+     return GRPC_CREDENTIALS_ERROR;
+   }
+   *token_lifetime = grpc_core::Duration::Seconds(seconds);
+@@ -191,12 +191,12 @@ grpc_oauth2_token_fetcher_credentials_parse_server_response(
+     grpc_core::Duration* token_lifetime) {
+   *token_value = std::nullopt;
+   if (response == nullptr) {
+-    LOG(ERROR) << "Received NULL response.";
++    ABSL_LOG(ERROR) << "Received NULL response.";
+     return GRPC_CREDENTIALS_ERROR;
+   }
+   absl::string_view body(response->body, response->body_length);
+   if (response->status != 200) {
+-    LOG(ERROR) << "Call to http server ended with error " << response->status
++    ABSL_LOG(ERROR) << "Call to http server ended with error " << response->status
+                << " [" << body << "]";
+     return GRPC_CREDENTIALS_ERROR;
+   }
+@@ -316,7 +316,7 @@ class grpc_compute_engine_token_fetcher_credentials
+     auto uri = grpc_core::URI::Create("http", GRPC_COMPUTE_ENGINE_METADATA_HOST,
+                                       GRPC_COMPUTE_ENGINE_METADATA_TOKEN_PATH,
+                                       {} /* query params */, "" /* fragment */);
+-    CHECK(uri.ok());  // params are hardcoded
++    ABSL_CHECK(uri.ok());  // params are hardcoded
+     auto http_request = grpc_core::HttpRequest::Get(
+         std::move(*uri), /*args=*/nullptr, pollent, &request, deadline,
+         on_complete, response,
+@@ -333,7 +333,7 @@ grpc_call_credentials* grpc_google_compute_engine_credentials_create(
+     void* reserved) {
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_compute_engine_credentials_create(reserved=" << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   return grpc_core::MakeRefCounted<
+              grpc_compute_engine_token_fetcher_credentials>()
+       .release();
+@@ -374,7 +374,7 @@ grpc_google_refresh_token_credentials::StartHttpRequest(
+   auto uri = grpc_core::URI::Create("https", GRPC_GOOGLE_OAUTH2_SERVICE_HOST,
+                                     GRPC_GOOGLE_OAUTH2_SERVICE_TOKEN_PATH,
+                                     {} /* query params */, "" /* fragment */);
+-  CHECK(uri.ok());  // params are hardcoded
++  ABSL_CHECK(uri.ok());  // params are hardcoded
+   auto http_request = grpc_core::HttpRequest::Post(
+       std::move(*uri), /*args=*/nullptr, pollent, &request, deadline,
+       on_complete, response, grpc_core::CreateHttpRequestSSLCredentials());
+@@ -386,7 +386,7 @@ grpc_core::RefCountedPtr<grpc_call_credentials>
+ grpc_refresh_token_credentials_create_from_auth_refresh_token(
+     grpc_auth_refresh_token refresh_token) {
+   if (!grpc_auth_refresh_token_is_valid(&refresh_token)) {
+-    LOG(ERROR) << "Invalid input for refresh token credentials creation";
++    ABSL_LOG(ERROR) << "Invalid input for refresh token credentials creation";
+     return nullptr;
+   }
+   return grpc_core::MakeRefCounted<grpc_google_refresh_token_credentials>(
+@@ -423,7 +423,7 @@ grpc_call_credentials* grpc_google_refresh_token_credentials_create(
+       << "grpc_refresh_token_credentials_create(json_refresh_token="
+       << create_loggable_refresh_token(&token) << ", reserved=" << reserved
+       << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   return grpc_refresh_token_credentials_create_from_auth_refresh_token(token)
+       .release();
+ }
+@@ -446,7 +446,7 @@ grpc_error_handle LoadTokenFile(const char* path, grpc_slice* token) {
+   auto slice = LoadFile(path, /*add_null_terminator=*/true);
+   if (!slice.ok()) return slice.status();
+   if (slice->empty()) {
+-    LOG(ERROR) << "Token file " << path << " is empty";
++    ABSL_LOG(ERROR) << "Token file " << path << " is empty";
+     return GRPC_ERROR_CREATE("Token file is empty.");
+   }
+   *token = slice->TakeCSlice();
+@@ -601,11 +601,11 @@ absl::StatusOr<URI> ValidateStsCredentialsOptions(
+
+ grpc_call_credentials* grpc_sts_credentials_create(
+     const grpc_sts_credentials_options* options, void* reserved) {
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   absl::StatusOr<grpc_core::URI> sts_url =
+       grpc_core::ValidateStsCredentialsOptions(options);
+   if (!sts_url.ok()) {
+-    LOG(ERROR) << "STS Credentials creation failed. Error: "
++    ABSL_LOG(ERROR) << "STS Credentials creation failed. Error: "
+                << sts_url.status();
+     return nullptr;
+   }
+@@ -647,7 +647,7 @@ grpc_call_credentials* grpc_access_token_credentials_create(
+   GRPC_TRACE_LOG(api, INFO) << "grpc_access_token_credentials_create(access_"
+                                "token=<redacted>, reserved="
+                             << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   return grpc_core::MakeRefCounted<grpc_access_token_credentials>(access_token)
+       .release();
+ }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc
+index 1e0bae22f94f9..53d68ea02cdc5 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc
+@@ -24,8 +24,8 @@
+ #include <atomic>
+ #include <memory>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -79,7 +79,7 @@ grpc_plugin_credentials::PendingRequest::ProcessPluginResult(
+                  !GRPC_LOG_IF_ERROR(
+                      "validate_metadata_from_plugin",
+                      grpc_validate_header_nonbin_value_is_legal(md[i].value))) {
+-        LOG(ERROR) << "Plugin added invalid metadata value.";
++        ABSL_LOG(ERROR) << "Plugin added invalid metadata value.";
+         seen_illegal_header = true;
+         break;
+       }
+@@ -197,6 +197,6 @@ grpc_call_credentials* grpc_metadata_credentials_create_from_plugin(
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_metadata_credentials_create_from_plugin(reserved=" << reserved
+       << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   return new grpc_plugin_credentials(plugin, min_security_level);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc
+index 7747f4a5476be..3952644786b13 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc
+@@ -28,8 +28,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/security/security_connector/ssl_utils.h"
+@@ -51,7 +51,7 @@ grpc_ssl_credentials::grpc_ssl_credentials(
+     const char* pem_root_certs =
+         grpc_core::DefaultSslRootStore::GetPemRootCerts();
+     if (pem_root_certs == nullptr) {
+-      LOG(ERROR) << "Could not get default pem root certs.";
++      ABSL_LOG(ERROR) << "Could not get default pem root certs.";
+     } else {
+       char* default_roots = gpr_strdup(pem_root_certs);
+       config_.pem_root_certs = default_roots;
+@@ -82,7 +82,7 @@ grpc_ssl_credentials::create_security_connector(
+     grpc_core::RefCountedPtr<grpc_call_credentials> call_creds,
+     const char* target, grpc_core::ChannelArgs* args) {
+   if (config_.pem_root_certs == nullptr) {
+-    LOG(ERROR) << "No root certs in config. Client-side security connector "
++    ABSL_LOG(ERROR) << "No root certs in config. Client-side security connector "
+                   "must have root certs.";
+     return nullptr;
+   }
+@@ -107,7 +107,7 @@ grpc_ssl_credentials::create_security_connector(
+         &config_, config_.pem_root_certs, root_store_, session_cache,
+         &factory_with_cache);
+     if (status != GRPC_SECURITY_OK) {
+-      LOG(ERROR) << "InitializeClientHandshakerFactory returned bad status.";
++      ABSL_LOG(ERROR) << "InitializeClientHandshakerFactory returned bad status.";
+       return nullptr;
+     }
+     security_connector = grpc_ssl_channel_security_connector_create(
+@@ -144,8 +144,8 @@ void grpc_ssl_credentials::build_config(
+     const grpc_ssl_verify_peer_options* verify_options) {
+   config_.pem_root_certs = gpr_strdup(pem_root_certs);
+   if (pem_key_cert_pair != nullptr) {
+-    CHECK_NE(pem_key_cert_pair->private_key, nullptr);
+-    CHECK_NE(pem_key_cert_pair->cert_chain, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pair->private_key, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pair->cert_chain, nullptr);
+     config_.pem_key_cert_pair = static_cast<tsi_ssl_pem_key_cert_pair*>(
+         gpr_zalloc(sizeof(tsi_ssl_pem_key_cert_pair)));
+     config_.pem_key_cert_pair->cert_chain =
+@@ -190,7 +190,7 @@ grpc_security_status grpc_ssl_credentials::InitializeClientHandshakerFactory(
+                            config->pem_key_cert_pair->cert_chain != nullptr;
+   tsi_ssl_client_handshaker_options options;
+   if (pem_root_certs == nullptr) {
+-    LOG(ERROR) << "Handshaker factory creation failed. pem_root_certs cannot "
++    ABSL_LOG(ERROR) << "Handshaker factory creation failed. pem_root_certs cannot "
+                   "be nullptr";
+     return GRPC_SECURITY_ERROR;
+   }
+@@ -210,7 +210,7 @@ grpc_security_status grpc_ssl_credentials::InitializeClientHandshakerFactory(
+                                                             handshaker_factory);
+   gpr_free(options.alpn_protocols);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "Handshaker factory creation failed with "
++    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
+                << tsi_result_to_string(result);
+     return GRPC_SECURITY_ERROR;
+   }
+@@ -227,7 +227,7 @@ grpc_channel_credentials* grpc_ssl_credentials_create(
+       << ", pem_key_cert_pair=" << pem_key_cert_pair
+       << ", verify_options=" << verify_options << ", reserved=" << reserved
+       << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+
+   return new grpc_ssl_credentials(
+       pem_root_certs, pem_key_cert_pair,
+@@ -242,7 +242,7 @@ grpc_channel_credentials* grpc_ssl_credentials_create_ex(
+       << ", pem_key_cert_pair=" << pem_key_cert_pair
+       << ", verify_options=" << verify_options << ", reserved=" << reserved
+       << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+
+   return new grpc_ssl_credentials(pem_root_certs, pem_key_cert_pair,
+                                   verify_options);
+@@ -292,13 +292,13 @@ tsi_ssl_pem_key_cert_pair* grpc_convert_grpc_to_tsi_cert_pairs(
+     size_t num_key_cert_pairs) {
+   tsi_ssl_pem_key_cert_pair* tsi_pairs = nullptr;
+   if (num_key_cert_pairs > 0) {
+-    CHECK_NE(pem_key_cert_pairs, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pairs, nullptr);
+     tsi_pairs = static_cast<tsi_ssl_pem_key_cert_pair*>(
+         gpr_zalloc(num_key_cert_pairs * sizeof(tsi_ssl_pem_key_cert_pair)));
+   }
+   for (size_t i = 0; i < num_key_cert_pairs; i++) {
+-    CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
+-    CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
+     tsi_pairs[i].cert_chain = gpr_strdup(pem_key_cert_pairs[i].cert_chain);
+     tsi_pairs[i].private_key = gpr_strdup(pem_key_cert_pairs[i].private_key);
+   }
+@@ -335,14 +335,14 @@ grpc_ssl_server_certificate_config* grpc_ssl_server_certificate_config_create(
+           gpr_zalloc(sizeof(grpc_ssl_server_certificate_config)));
+   config->pem_root_certs = gpr_strdup(pem_root_certs);
+   if (num_key_cert_pairs > 0) {
+-    CHECK_NE(pem_key_cert_pairs, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pairs, nullptr);
+     config->pem_key_cert_pairs = static_cast<grpc_ssl_pem_key_cert_pair*>(
+         gpr_zalloc(num_key_cert_pairs * sizeof(grpc_ssl_pem_key_cert_pair)));
+   }
+   config->num_key_cert_pairs = num_key_cert_pairs;
+   for (size_t i = 0; i < num_key_cert_pairs; i++) {
+-    CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
+-    CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
++    ABSL_CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
+     config->pem_key_cert_pairs[i].cert_chain =
+         gpr_strdup(pem_key_cert_pairs[i].cert_chain);
+     config->pem_key_cert_pairs[i].private_key =
+@@ -369,7 +369,7 @@ grpc_ssl_server_credentials_create_options_using_config(
+     grpc_ssl_server_certificate_config* config) {
+   grpc_ssl_server_credentials_options* options = nullptr;
+   if (config == nullptr) {
+-    LOG(ERROR) << "Certificate config must not be NULL.";
++    ABSL_LOG(ERROR) << "Certificate config must not be NULL.";
+     goto done;
+   }
+   options = static_cast<grpc_ssl_server_credentials_options*>(
+@@ -385,7 +385,7 @@ grpc_ssl_server_credentials_create_options_using_config_fetcher(
+     grpc_ssl_client_certificate_request_type client_certificate_request,
+     grpc_ssl_server_certificate_config_callback cb, void* user_data) {
+   if (cb == nullptr) {
+-    LOG(ERROR) << "Invalid certificate config callback parameter.";
++    ABSL_LOG(ERROR) << "Invalid certificate config callback parameter.";
+     return nullptr;
+   }
+
+@@ -426,7 +426,7 @@ grpc_server_credentials* grpc_ssl_server_credentials_create_ex(
+       << ", num_key_cert_pairs=" << (unsigned long)num_key_cert_pairs
+       << ", client_certificate_request=" << client_certificate_request
+       << ", reserved=" << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+
+   grpc_ssl_server_certificate_config* cert_config =
+       grpc_ssl_server_certificate_config_create(
+@@ -443,18 +443,18 @@ grpc_server_credentials* grpc_ssl_server_credentials_create_with_options(
+   grpc_server_credentials* retval = nullptr;
+
+   if (options == nullptr) {
+-    LOG(ERROR) << "Invalid options trying to create SSL server credentials.";
++    ABSL_LOG(ERROR) << "Invalid options trying to create SSL server credentials.";
+     goto done;
+   }
+
+   if (options->certificate_config == nullptr &&
+       options->certificate_config_fetcher == nullptr) {
+-    LOG(ERROR) << "SSL server credentials options must specify either "
++    ABSL_LOG(ERROR) << "SSL server credentials options must specify either "
+                   "certificate config or fetcher.";
+     goto done;
+   } else if (options->certificate_config_fetcher != nullptr &&
+              options->certificate_config_fetcher->cb == nullptr) {
+-    LOG(ERROR) << "Certificate config fetcher callback must not be NULL.";
++    ABSL_LOG(ERROR) << "Certificate config fetcher callback must not be NULL.";
+     goto done;
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h
+index d0f947a537c2a..f6a5ba8f5c4a0 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h
++++ b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h
+@@ -25,7 +25,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <stddef.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/security/credentials/credentials.h"
+ #include "src/core/lib/security/security_connector/security_connector.h"
+@@ -115,7 +115,7 @@ class grpc_ssl_server_credentials final : public grpc_server_credentials {
+
+   grpc_ssl_certificate_config_reload_status FetchCertConfig(
+       grpc_ssl_server_certificate_config** config) {
+-    DCHECK(has_cert_config_fetcher());
++    ABSL_DCHECK(has_cert_config_fetcher());
+     return certificate_config_fetcher_.cb(certificate_config_fetcher_.user_data,
+                                           config);
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc
+index 2b3cc4c36a84e..9b0a11610177a 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc
+@@ -20,23 +20,23 @@
+ #include <grpc/grpc_security.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+
+ void grpc_tls_certificate_distributor::SetKeyMaterials(
+     const std::string& cert_name, std::optional<std::string> pem_root_certs,
+     std::optional<grpc_core::PemKeyCertPairList> pem_key_cert_pairs) {
+-  CHECK(pem_root_certs.has_value() || pem_key_cert_pairs.has_value());
++  ABSL_CHECK(pem_root_certs.has_value() || pem_key_cert_pairs.has_value());
+   grpc_core::MutexLock lock(&mu_);
+   auto& cert_info = certificate_info_map_[cert_name];
+   if (pem_root_certs.has_value()) {
+     // Successful credential updates will clear any pre-existing error.
+     cert_info.SetRootError(absl::OkStatus());
+     for (auto* watcher_ptr : cert_info.root_cert_watchers) {
+-      CHECK_NE(watcher_ptr, nullptr);
++      ABSL_CHECK_NE(watcher_ptr, nullptr);
+       const auto watcher_it = watchers_.find(watcher_ptr);
+-      CHECK(watcher_it != watchers_.end());
+-      CHECK(watcher_it->second.root_cert_name.has_value());
++      ABSL_CHECK(watcher_it != watchers_.end());
++      ABSL_CHECK(watcher_it->second.root_cert_name.has_value());
+       std::optional<grpc_core::PemKeyCertPairList> pem_key_cert_pairs_to_report;
+       if (pem_key_cert_pairs.has_value() &&
+           watcher_it->second.identity_cert_name == cert_name) {
+@@ -57,10 +57,10 @@ void grpc_tls_certificate_distributor::SetKeyMaterials(
+     // Successful credential updates will clear any pre-existing error.
+     cert_info.SetIdentityError(absl::OkStatus());
+     for (const auto watcher_ptr : cert_info.identity_cert_watchers) {
+-      CHECK_NE(watcher_ptr, nullptr);
++      ABSL_CHECK_NE(watcher_ptr, nullptr);
+       const auto watcher_it = watchers_.find(watcher_ptr);
+-      CHECK(watcher_it != watchers_.end());
+-      CHECK(watcher_it->second.identity_cert_name.has_value());
++      ABSL_CHECK(watcher_it != watchers_.end());
++      ABSL_CHECK(watcher_it->second.identity_cert_name.has_value());
+       std::optional<absl::string_view> pem_root_certs_to_report;
+       if (pem_root_certs.has_value() &&
+           watcher_it->second.root_cert_name == cert_name) {
+@@ -101,14 +101,14 @@ void grpc_tls_certificate_distributor::SetErrorForCert(
+     const std::string& cert_name,
+     std::optional<grpc_error_handle> root_cert_error,
+     std::optional<grpc_error_handle> identity_cert_error) {
+-  CHECK(root_cert_error.has_value() || identity_cert_error.has_value());
++  ABSL_CHECK(root_cert_error.has_value() || identity_cert_error.has_value());
+   grpc_core::MutexLock lock(&mu_);
+   CertificateInfo& cert_info = certificate_info_map_[cert_name];
+   if (root_cert_error.has_value()) {
+     for (auto* watcher_ptr : cert_info.root_cert_watchers) {
+-      CHECK_NE(watcher_ptr, nullptr);
++      ABSL_CHECK_NE(watcher_ptr, nullptr);
+       const auto watcher_it = watchers_.find(watcher_ptr);
+-      CHECK(watcher_it != watchers_.end());
++      ABSL_CHECK(watcher_it != watchers_.end());
+       // identity_cert_error_to_report is the error of the identity cert this
+       // watcher is watching, if there is any.
+       grpc_error_handle identity_cert_error_to_report;
+@@ -126,9 +126,9 @@ void grpc_tls_certificate_distributor::SetErrorForCert(
+   }
+   if (identity_cert_error.has_value()) {
+     for (auto* watcher_ptr : cert_info.identity_cert_watchers) {
+-      CHECK_NE(watcher_ptr, nullptr);
++      ABSL_CHECK_NE(watcher_ptr, nullptr);
+       const auto watcher_it = watchers_.find(watcher_ptr);
+-      CHECK(watcher_it != watchers_.end());
++      ABSL_CHECK(watcher_it != watchers_.end());
+       // root_cert_error_to_report is the error of the root cert this watcher is
+       // watching, if there is any.
+       grpc_error_handle root_cert_error_to_report;
+@@ -149,11 +149,11 @@ void grpc_tls_certificate_distributor::SetErrorForCert(
+ };
+
+ void grpc_tls_certificate_distributor::SetError(grpc_error_handle error) {
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   grpc_core::MutexLock lock(&mu_);
+   for (const auto& watcher : watchers_) {
+     const auto watcher_ptr = watcher.first;
+-    CHECK_NE(watcher_ptr, nullptr);
++    ABSL_CHECK_NE(watcher_ptr, nullptr);
+     const auto& watcher_info = watcher.second;
+     watcher_ptr->OnError(
+         watcher_info.root_cert_name.has_value() ? error : absl::OkStatus(),
+@@ -174,16 +174,16 @@ void grpc_tls_certificate_distributor::WatchTlsCertificates(
+   bool already_watching_identity_for_root_cert = false;
+   bool start_watching_identity_cert = false;
+   bool already_watching_root_for_identity_cert = false;
+-  CHECK(root_cert_name.has_value() || identity_cert_name.has_value());
++  ABSL_CHECK(root_cert_name.has_value() || identity_cert_name.has_value());
+   TlsCertificatesWatcherInterface* watcher_ptr = watcher.get();
+-  CHECK_NE(watcher_ptr, nullptr);
++  ABSL_CHECK_NE(watcher_ptr, nullptr);
+   // Update watchers_ and certificate_info_map_.
+   {
+     grpc_core::MutexLock lock(&mu_);
+     const auto watcher_it = watchers_.find(watcher_ptr);
+     // The caller needs to cancel the watcher first if it wants to re-register
+     // the watcher.
+-    CHECK(watcher_it == watchers_.end());
++    ABSL_CHECK(watcher_it == watchers_.end());
+     watchers_[watcher_ptr] = {std::move(watcher), root_cert_name,
+                               identity_cert_name};
+     std::optional<absl::string_view> updated_root_certs;
+@@ -269,7 +269,7 @@ void grpc_tls_certificate_distributor::CancelTlsCertificatesWatch(
+     watchers_.erase(it);
+     if (root_cert_name.has_value()) {
+       auto it = certificate_info_map_.find(*root_cert_name);
+-      CHECK(it != certificate_info_map_.end());
++      ABSL_CHECK(it != certificate_info_map_.end());
+       CertificateInfo& cert_info = it->second;
+       cert_info.root_cert_watchers.erase(watcher);
+       stop_watching_root_cert = cert_info.root_cert_watchers.empty();
+@@ -281,7 +281,7 @@ void grpc_tls_certificate_distributor::CancelTlsCertificatesWatch(
+     }
+     if (identity_cert_name.has_value()) {
+       auto it = certificate_info_map_.find(*identity_cert_name);
+-      CHECK(it != certificate_info_map_.end());
++      ABSL_CHECK(it != certificate_info_map_.end());
+       CertificateInfo& cert_info = it->second;
+       cert_info.identity_cert_watchers.erase(watcher);
+       stop_watching_identity_cert = cert_info.identity_cert_watchers.empty();
+@@ -325,13 +325,13 @@ grpc_tls_identity_pairs* grpc_tls_identity_pairs_create() {
+ void grpc_tls_identity_pairs_add_pair(grpc_tls_identity_pairs* pairs,
+                                       const char* private_key,
+                                       const char* cert_chain) {
+-  CHECK_NE(pairs, nullptr);
+-  CHECK_NE(private_key, nullptr);
+-  CHECK_NE(cert_chain, nullptr);
++  ABSL_CHECK_NE(pairs, nullptr);
++  ABSL_CHECK_NE(private_key, nullptr);
++  ABSL_CHECK_NE(cert_chain, nullptr);
+   pairs->pem_key_cert_pairs.emplace_back(private_key, cert_chain);
+ }
+
+ void grpc_tls_identity_pairs_destroy(grpc_tls_identity_pairs* pairs) {
+-  CHECK_NE(pairs, nullptr);
++  ABSL_CHECK_NE(pairs, nullptr);
+   delete pairs;
+ }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc
+index 5bde40009fdb0..2d030092db1bc 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc
+@@ -27,8 +27,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -184,21 +184,21 @@ FileWatcherCertificateProvider::FileWatcherCertificateProvider(
+       refresh_interval_sec_(refresh_interval_sec),
+       distributor_(MakeRefCounted<grpc_tls_certificate_distributor>()) {
+   if (refresh_interval_sec_ < kMinimumFileWatcherRefreshIntervalSeconds) {
+-    VLOG(2) << "FileWatcherCertificateProvider refresh_interval_sec_ set to "
++    ABSL_VLOG(2) << "FileWatcherCertificateProvider refresh_interval_sec_ set to "
+                "value less than minimum. Overriding configured value to "
+                "minimum.";
+     refresh_interval_sec_ = kMinimumFileWatcherRefreshIntervalSeconds;
+   }
+   // Private key and identity cert files must be both set or both unset.
+-  CHECK(private_key_path_.empty() == identity_certificate_path_.empty());
++  ABSL_CHECK(private_key_path_.empty() == identity_certificate_path_.empty());
+   // Must be watching either root or identity certs.
+-  CHECK(!private_key_path_.empty() || !root_cert_path_.empty());
++  ABSL_CHECK(!private_key_path_.empty() || !root_cert_path_.empty());
+   gpr_event_init(&shutdown_event_);
+   ForceUpdate();
+   auto thread_lambda = [](void* arg) {
+     FileWatcherCertificateProvider* provider =
+         static_cast<FileWatcherCertificateProvider*>(arg);
+-    CHECK_NE(provider, nullptr);
++    ABSL_CHECK_NE(provider, nullptr);
+     while (true) {
+       void* value = gpr_event_wait(
+           &provider->shutdown_event_,
+@@ -361,7 +361,7 @@ FileWatcherCertificateProvider::ReadRootCertificatesFromFile(
+   auto root_slice =
+       LoadFile(root_cert_full_path, /*add_null_terminator=*/false);
+   if (!root_slice.ok()) {
+-    LOG(ERROR) << "Reading file " << root_cert_full_path
++    ABSL_LOG(ERROR) << "Reading file " << root_cert_full_path
+                << " failed: " << root_slice.status();
+     return std::nullopt;
+   }
+@@ -392,28 +392,28 @@ FileWatcherCertificateProvider::ReadIdentityKeyCertPairFromFiles(
+     time_t identity_key_ts_before =
+         GetModificationTime(private_key_path.c_str());
+     if (identity_key_ts_before == 0) {
+-      LOG(ERROR) << "Failed to get the file's modification time of "
++      ABSL_LOG(ERROR) << "Failed to get the file's modification time of "
+                  << private_key_path << ". Start retrying...";
+       continue;
+     }
+     time_t identity_cert_ts_before =
+         GetModificationTime(identity_certificate_path.c_str());
+     if (identity_cert_ts_before == 0) {
+-      LOG(ERROR) << "Failed to get the file's modification time of "
++      ABSL_LOG(ERROR) << "Failed to get the file's modification time of "
+                  << identity_certificate_path << ". Start retrying...";
+       continue;
+     }
+     // Read the identity files.
+     auto key_slice = LoadFile(private_key_path, /*add_null_terminator=*/false);
+     if (!key_slice.ok()) {
+-      LOG(ERROR) << "Reading file " << private_key_path
++      ABSL_LOG(ERROR) << "Reading file " << private_key_path
+                  << " failed: " << key_slice.status() << ". Start retrying...";
+       continue;
+     }
+     auto cert_slice =
+         LoadFile(identity_certificate_path, /*add_null_terminator=*/false);
+     if (!cert_slice.ok()) {
+-      LOG(ERROR) << "Reading file " << identity_certificate_path
++      ABSL_LOG(ERROR) << "Reading file " << identity_certificate_path
+                  << " failed: " << cert_slice.status() << ". Start retrying...";
+       continue;
+     }
+@@ -425,21 +425,21 @@ FileWatcherCertificateProvider::ReadIdentityKeyCertPairFromFiles(
+     time_t identity_key_ts_after =
+         GetModificationTime(private_key_path.c_str());
+     if (identity_key_ts_before != identity_key_ts_after) {
+-      LOG(ERROR) << "Last modified time before and after reading "
++      ABSL_LOG(ERROR) << "Last modified time before and after reading "
+                  << private_key_path << " is not the same. Start retrying...";
+       continue;
+     }
+     time_t identity_cert_ts_after =
+         GetModificationTime(identity_certificate_path.c_str());
+     if (identity_cert_ts_before != identity_cert_ts_after) {
+-      LOG(ERROR) << "Last modified time before and after reading "
++      ABSL_LOG(ERROR) << "Last modified time before and after reading "
+                  << identity_certificate_path
+                  << " is not the same. Start retrying...";
+       continue;
+     }
+     return identity_pairs;
+   }
+-  LOG(ERROR) << "All retry attempts failed. Will try again after the next "
++  ABSL_LOG(ERROR) << "All retry attempts failed. Will try again after the next "
+                 "interval.";
+   return std::nullopt;
+ }
+@@ -455,7 +455,7 @@ int64_t FileWatcherCertificateProvider::TestOnlyGetRefreshIntervalSecond()
+
+ grpc_tls_certificate_provider* grpc_tls_certificate_provider_static_data_create(
+     const char* root_certificate, grpc_tls_identity_pairs* pem_key_cert_pairs) {
+-  CHECK(root_certificate != nullptr || pem_key_cert_pairs != nullptr);
++  ABSL_CHECK(root_certificate != nullptr || pem_key_cert_pairs != nullptr);
+   grpc_core::ExecCtx exec_ctx;
+   grpc_core::PemKeyCertPairList identity_pairs_core;
+   if (pem_key_cert_pairs != nullptr) {
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h
+index f002013aefd66..893de19722783 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h
+@@ -27,7 +27,7 @@
+ #include <string>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.h"
+@@ -63,7 +63,7 @@ struct grpc_tls_certificate_provider
+   // be reused when two different `grpc_tls_certificate_provider` objects are
+   // used but they compare as equal (assuming other channel args match).
+   int Compare(const grpc_tls_certificate_provider* other) const {
+-    CHECK_NE(other, nullptr);
++    ABSL_CHECK_NE(other, nullptr);
+     int r = type().Compare(other->type());
+     if (r != 0) return r;
+     return CompareImpl(other);
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc
+index 47447ed536c26..465796faacc12 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc
+@@ -24,7 +24,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -108,7 +108,7 @@ UniqueTypeName NoOpCertificateVerifier::type() const {
+ bool HostNameCertificateVerifier::Verify(
+     grpc_tls_custom_verification_check_request* request,
+     std::function<void(absl::Status)>, absl::Status* sync_status) {
+-  CHECK_NE(request, nullptr);
++  ABSL_CHECK_NE(request, nullptr);
+   // Extract the target name, and remove its port.
+   const char* target_name = request->target_name;
+   if (target_name == nullptr) {
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h
+index 3b80d9bc852c2..237d01ae8de26 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h
+@@ -26,7 +26,7 @@
+ #include <map>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "src/core/util/ref_counted.h"
+ #include "src/core/util/sync.h"
+@@ -57,7 +57,7 @@ struct grpc_tls_certificate_verifier
+   // If this method returns 0, it means that gRPC can treat the two certificate
+   // verifiers as effectively the same.
+   int Compare(const grpc_tls_certificate_verifier* other) const {
+-    CHECK_NE(other, nullptr);
++    ABSL_CHECK_NE(other, nullptr);
+     int r = type().Compare(other->type());
+     if (r != 0) return r;
+     return CompareImpl(other);
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc
+index 69f73476cae38..6170af24b3a30 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc
+@@ -23,8 +23,8 @@
+
+ #include <memory>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/tsi/ssl_transport_security.h"
+@@ -39,7 +39,7 @@ grpc_tls_credentials_options* grpc_tls_credentials_options_create() {
+
+ grpc_tls_credentials_options* grpc_tls_credentials_options_copy(
+     grpc_tls_credentials_options* options) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   return new grpc_tls_credentials_options(*options);
+ }
+
+@@ -51,21 +51,21 @@ void grpc_tls_credentials_options_destroy(
+ void grpc_tls_credentials_options_set_cert_request_type(
+     grpc_tls_credentials_options* options,
+     grpc_ssl_client_certificate_request_type type) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_cert_request_type(type);
+ }
+
+ void grpc_tls_credentials_options_set_verify_server_cert(
+     grpc_tls_credentials_options* options, int verify_server_cert) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_verify_server_cert(verify_server_cert);
+ }
+
+ void grpc_tls_credentials_options_set_certificate_provider(
+     grpc_tls_credentials_options* options,
+     grpc_tls_certificate_provider* provider) {
+-  CHECK_NE(options, nullptr);
+-  CHECK_NE(provider, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(provider, nullptr);
+   grpc_core::ExecCtx exec_ctx;
+   options->set_certificate_provider(
+       provider->Ref(DEBUG_LOCATION, "set_certificate_provider"));
+@@ -73,45 +73,45 @@ void grpc_tls_credentials_options_set_certificate_provider(
+
+ void grpc_tls_credentials_options_watch_root_certs(
+     grpc_tls_credentials_options* options) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_watch_root_cert(true);
+ }
+
+ void grpc_tls_credentials_options_set_root_cert_name(
+     grpc_tls_credentials_options* options, const char* root_cert_name) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_root_cert_name(root_cert_name);
+ }
+
+ void grpc_tls_credentials_options_watch_identity_key_cert_pairs(
+     grpc_tls_credentials_options* options) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_watch_identity_pair(true);
+ }
+
+ void grpc_tls_credentials_options_set_identity_cert_name(
+     grpc_tls_credentials_options* options, const char* identity_cert_name) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_identity_cert_name(identity_cert_name);
+ }
+
+ void grpc_tls_credentials_options_set_certificate_verifier(
+     grpc_tls_credentials_options* options,
+     grpc_tls_certificate_verifier* verifier) {
+-  CHECK_NE(options, nullptr);
+-  CHECK_NE(verifier, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(verifier, nullptr);
+   options->set_certificate_verifier(verifier->Ref());
+ }
+
+ void grpc_tls_credentials_options_set_crl_directory(
+     grpc_tls_credentials_options* options, const char* crl_directory) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_crl_directory(crl_directory);
+ }
+
+ void grpc_tls_credentials_options_set_check_call_host(
+     grpc_tls_credentials_options* options, int check_call_host) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_check_call_host(check_call_host);
+ }
+
+@@ -126,9 +126,9 @@ void grpc_tls_credentials_options_set_tls_session_key_log_file_path(
+   // Tls session key logging is assumed to be enabled if the specified log
+   // file is non-empty.
+   if (path != nullptr) {
+-    VLOG(2) << "Enabling TLS session key logging with keys stored at: " << path;
++    ABSL_VLOG(2) << "Enabling TLS session key logging with keys stored at: " << path;
+   } else {
+-    VLOG(2) << "Disabling TLS session key logging";
++    ABSL_VLOG(2) << "Disabling TLS session key logging";
+   }
+   options->set_tls_session_key_log_file_path(path != nullptr ? path : "");
+ }
+@@ -144,18 +144,18 @@ void grpc_tls_credentials_options_set_send_client_ca_list(
+ void grpc_tls_credentials_options_set_crl_provider(
+     grpc_tls_credentials_options* options,
+     std::shared_ptr<grpc_core::experimental::CrlProvider> provider) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_crl_provider(provider);
+ }
+
+ void grpc_tls_credentials_options_set_min_tls_version(
+     grpc_tls_credentials_options* options, grpc_tls_version min_tls_version) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_min_tls_version(min_tls_version);
+ }
+
+ void grpc_tls_credentials_options_set_max_tls_version(
+     grpc_tls_credentials_options* options, grpc_tls_version max_tls_version) {
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   options->set_max_tls_version(max_tls_version);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
+index 72a113cd5922e..4fec5db6fbd5a 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
+@@ -34,7 +34,7 @@
+ #include <openssl/x509.h>
+
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -127,7 +127,7 @@ absl::StatusOr<std::shared_ptr<CrlProvider>> CreateStaticCrlProvider(
+     }
+     bool inserted = crl_map.emplace((*crl)->Issuer(), std::move(*crl)).second;
+     if (!inserted) {
+-      LOG(ERROR) << "StaticCrlProvider received multiple CRLs with the same "
++      ABSL_LOG(ERROR) << "StaticCrlProvider received multiple CRLs with the same "
+                     "issuer. The first one in the span will be used.";
+     }
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc
+index fe543c574b28a..ffb6d16072360 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc
+@@ -28,7 +28,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h"
+ #include "src/core/lib/security/credentials/tls/grpc_tls_credentials_options.h"
+@@ -41,27 +41,27 @@ namespace {
+ bool CredentialOptionSanityCheck(grpc_tls_credentials_options* options,
+                                  bool is_client) {
+   if (options == nullptr) {
+-    LOG(ERROR) << "TLS credentials options is nullptr.";
++    ABSL_LOG(ERROR) << "TLS credentials options is nullptr.";
+     return false;
+   }
+   // In this case, there will be non-retriable handshake errors.
+   if (options->min_tls_version() > options->max_tls_version()) {
+-    LOG(ERROR) << "TLS min version must not be higher than max version.";
++    ABSL_LOG(ERROR) << "TLS min version must not be higher than max version.";
+     grpc_tls_credentials_options_destroy(options);
+     return false;
+   }
+   if (options->max_tls_version() > grpc_tls_version::TLS1_3) {
+-    LOG(ERROR) << "TLS max version must not be higher than v1.3.";
++    ABSL_LOG(ERROR) << "TLS max version must not be higher than v1.3.";
+     grpc_tls_credentials_options_destroy(options);
+     return false;
+   }
+   if (options->min_tls_version() < grpc_tls_version::TLS1_2) {
+-    LOG(ERROR) << "TLS min version must not be lower than v1.2.";
++    ABSL_LOG(ERROR) << "TLS min version must not be lower than v1.2.";
+     grpc_tls_credentials_options_destroy(options);
+     return false;
+   }
+   if (!options->crl_directory().empty() && options->crl_provider() != nullptr) {
+-    LOG(ERROR) << "Setting crl_directory and crl_provider not supported. Using "
++    ABSL_LOG(ERROR) << "Setting crl_directory and crl_provider not supported. Using "
+                   "the crl_provider.";
+     // TODO(gtcooke94) - Maybe return false here. Right now object lifetime of
+     // this options struct is leaky if false is returned and represents a more
+@@ -71,11 +71,11 @@ bool CredentialOptionSanityCheck(grpc_tls_credentials_options* options,
+   // indicate callers are doing something wrong with the API.
+   if (is_client && options->cert_request_type() !=
+                        GRPC_SSL_DONT_REQUEST_CLIENT_CERTIFICATE) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Client's credentials options should not set cert_request_type.";
+   }
+   if (!is_client && !options->verify_server_cert()) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Server's credentials options should not set verify_server_cert.";
+   }
+   // In the following conditions, there could be severe security issues.
+@@ -83,7 +83,7 @@ bool CredentialOptionSanityCheck(grpc_tls_credentials_options* options,
+     // If no verifier is specified on the client side, use the hostname verifier
+     // as default. Users who want to bypass all the verifier check should
+     // implement an external verifier instead.
+-    VLOG(2) << "No verifier specified on the client side. Using default "
++    ABSL_VLOG(2) << "No verifier specified on the client side. Using default "
+                "hostname verifier";
+     options->set_certificate_verifier(
+         grpc_core::MakeRefCounted<grpc_core::HostNameCertificateVerifier>());
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc
+index 296839a8aea6b..4f109221c6061 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc
+@@ -23,7 +23,7 @@
+
+ #include <algorithm>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/ascii.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+@@ -98,11 +98,11 @@ absl::string_view GetAuthPropertyValue(grpc_auth_context* context,
+       grpc_auth_context_find_properties_by_name(context, property_name);
+   const grpc_auth_property* prop = grpc_auth_property_iterator_next(&it);
+   if (prop == nullptr) {
+-    VLOG(2) << "No value found for " << property_name << " property.";
++    ABSL_VLOG(2) << "No value found for " << property_name << " property.";
+     return "";
+   }
+   if (grpc_auth_property_iterator_next(&it) != nullptr) {
+-    VLOG(2) << "Multiple values found for " << property_name << " property.";
++    ABSL_VLOG(2) << "Multiple values found for " << property_name << " property.";
+     return "";
+   }
+   return absl::string_view(prop->value, prop->value_length);
+@@ -119,7 +119,7 @@ std::vector<absl::string_view> GetAuthPropertyArray(grpc_auth_context* context,
+     prop = grpc_auth_property_iterator_next(&it);
+   }
+   if (values.empty()) {
+-    VLOG(2) << "No value found for " << property_name << " property.";
++    ABSL_VLOG(2) << "No value found for " << property_name << " property.";
+   }
+   return values;
+ }
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc
+index 402a41c733d54..e3e1153545a38 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc
+@@ -24,7 +24,7 @@
+
+ #include <optional>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h"
+ #include "src/core/lib/security/credentials/tls/grpc_tls_credentials_options.h"
+@@ -79,7 +79,7 @@ XdsCertificateVerifier::XdsCertificateVerifier(
+ bool XdsCertificateVerifier::Verify(
+     grpc_tls_custom_verification_check_request* request,
+     std::function<void(absl::Status)>, absl::Status* sync_status) {
+-  CHECK_NE(request, nullptr);
++  ABSL_CHECK_NE(request, nullptr);
+   if (!XdsVerifySubjectAlternativeNames(
+           request->peer_info.san_names.uri_names,
+           request->peer_info.san_names.uri_names_size,
+@@ -169,7 +169,7 @@ XdsCredentials::create_security_connector(
+                                                         target_name, args);
+     }
+   }
+-  CHECK(fallback_credentials_ != nullptr);
++  ABSL_CHECK(fallback_credentials_ != nullptr);
+   return fallback_credentials_->create_security_connector(std::move(call_creds),
+                                                           target_name, args);
+ }
+@@ -220,12 +220,12 @@ UniqueTypeName XdsServerCredentials::Type() {
+
+ grpc_channel_credentials* grpc_xds_credentials_create(
+     grpc_channel_credentials* fallback_credentials) {
+-  CHECK_NE(fallback_credentials, nullptr);
++  ABSL_CHECK_NE(fallback_credentials, nullptr);
+   return new grpc_core::XdsCredentials(fallback_credentials->Ref());
+ }
+
+ grpc_server_credentials* grpc_xds_server_credentials_create(
+     grpc_server_credentials* fallback_credentials) {
+-  CHECK_NE(fallback_credentials, nullptr);
++  ABSL_CHECK_NE(fallback_credentials, nullptr);
+   return new grpc_core::XdsServerCredentials(fallback_credentials->Ref());
+ }
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc
+index bc9d14e38b5ec..5496aaa3c10af 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc
+@@ -31,8 +31,8 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/handshaker/handshaker.h"
+@@ -102,7 +102,7 @@ class grpc_alts_channel_security_connector final
+         static_cast<const grpc_alts_credentials*>(channel_creds());
+     const size_t user_specified_max_frame_size =
+         std::max(0, args.GetInt(GRPC_ARG_TSI_MAX_FRAME_SIZE).value_or(0));
+-    CHECK(alts_tsi_handshaker_create(creds->options(), target_name_,
++    ABSL_CHECK(alts_tsi_handshaker_create(creds->options(), target_name_,
+                                      creds->handshaker_service_url(), true,
+                                      interested_parties, &handshaker,
+                                      user_specified_max_frame_size) == TSI_OK);
+@@ -155,7 +155,7 @@ class grpc_alts_server_security_connector final
+         static_cast<const grpc_alts_server_credentials*>(server_creds());
+     size_t user_specified_max_frame_size =
+         std::max(0, args.GetInt(GRPC_ARG_TSI_MAX_FRAME_SIZE).value_or(0));
+-    CHECK(alts_tsi_handshaker_create(creds->options(), nullptr,
++    ABSL_CHECK(alts_tsi_handshaker_create(creds->options(), nullptr,
+                                      creds->handshaker_service_url(), false,
+                                      interested_parties, &handshaker,
+                                      user_specified_max_frame_size) == TSI_OK);
+@@ -185,7 +185,7 @@ namespace internal {
+ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
+     const tsi_peer* peer) {
+   if (peer == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to grpc_alts_auth_context_from_tsi_peer()";
++    ABSL_LOG(ERROR) << "Invalid arguments to grpc_alts_auth_context_from_tsi_peer()";
+     return nullptr;
+   }
+   // Validate certificate type.
+@@ -194,21 +194,21 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
+   if (cert_type_prop == nullptr ||
+       strncmp(cert_type_prop->value.data, TSI_ALTS_CERTIFICATE_TYPE,
+               cert_type_prop->value.length) != 0) {
+-    LOG(ERROR) << "Invalid or missing certificate type property.";
++    ABSL_LOG(ERROR) << "Invalid or missing certificate type property.";
+     return nullptr;
+   }
+   // Check if security level exists.
+   const tsi_peer_property* security_level_prop =
+       tsi_peer_get_property_by_name(peer, TSI_SECURITY_LEVEL_PEER_PROPERTY);
+   if (security_level_prop == nullptr) {
+-    LOG(ERROR) << "Missing security level property.";
++    ABSL_LOG(ERROR) << "Missing security level property.";
+     return nullptr;
+   }
+   // Validate RPC protocol versions.
+   const tsi_peer_property* rpc_versions_prop =
+       tsi_peer_get_property_by_name(peer, TSI_ALTS_RPC_VERSIONS);
+   if (rpc_versions_prop == nullptr) {
+-    LOG(ERROR) << "Missing rpc protocol versions property.";
++    ABSL_LOG(ERROR) << "Missing rpc protocol versions property.";
+     return nullptr;
+   }
+   grpc_gcp_rpc_protocol_versions local_versions, peer_versions;
+@@ -219,21 +219,21 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
+       grpc_gcp_rpc_protocol_versions_decode(slice, &peer_versions);
+   CSliceUnref(slice);
+   if (!decode_result) {
+-    LOG(ERROR) << "Invalid peer rpc protocol versions.";
++    ABSL_LOG(ERROR) << "Invalid peer rpc protocol versions.";
+     return nullptr;
+   }
+   // TODO(unknown): Pass highest common rpc protocol version to grpc caller.
+   bool check_result = grpc_gcp_rpc_protocol_versions_check(
+       &local_versions, &peer_versions, nullptr);
+   if (!check_result) {
+-    LOG(ERROR) << "Mismatch of local and peer rpc protocol versions.";
++    ABSL_LOG(ERROR) << "Mismatch of local and peer rpc protocol versions.";
+     return nullptr;
+   }
+   // Validate ALTS Context.
+   const tsi_peer_property* alts_context_prop =
+       tsi_peer_get_property_by_name(peer, TSI_ALTS_CONTEXT);
+   if (alts_context_prop == nullptr) {
+-    LOG(ERROR) << "Missing alts context property.";
++    ABSL_LOG(ERROR) << "Missing alts context property.";
+     return nullptr;
+   }
+   // Create auth context.
+@@ -249,7 +249,7 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
+       grpc_auth_context_add_property(
+           ctx.get(), TSI_ALTS_SERVICE_ACCOUNT_PEER_PROPERTY,
+           tsi_prop->value.data, tsi_prop->value.length);
+-      CHECK(grpc_auth_context_set_peer_identity_property_name(
++      ABSL_CHECK(grpc_auth_context_set_peer_identity_property_name(
+                 ctx.get(), TSI_ALTS_SERVICE_ACCOUNT_PEER_PROPERTY) == 1);
+     }
+     // Add alts context to auth context.
+@@ -266,7 +266,7 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
+     }
+   }
+   if (!grpc_auth_context_peer_is_authenticated(ctx.get())) {
+-    LOG(ERROR) << "Invalid unauthenticated peer.";
++    ABSL_LOG(ERROR) << "Invalid unauthenticated peer.";
+     ctx.reset(DEBUG_LOCATION, "test");
+     return nullptr;
+   }
+@@ -282,7 +282,7 @@ grpc_alts_channel_security_connector_create(
+     grpc_core::RefCountedPtr<grpc_call_credentials> request_metadata_creds,
+     const char* target_name) {
+   if (channel_creds == nullptr || target_name == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid arguments to grpc_alts_channel_security_connector_create()";
+     return nullptr;
+   }
+@@ -294,7 +294,7 @@ grpc_core::RefCountedPtr<grpc_server_security_connector>
+ grpc_alts_server_security_connector_create(
+     grpc_core::RefCountedPtr<grpc_server_credentials> server_creds) {
+   if (server_creds == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid arguments to grpc_alts_server_security_connector_create()";
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc
+index 66051e2401872..05141197b6bf3 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc
+@@ -30,8 +30,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -140,7 +140,7 @@ class grpc_fake_channel_security_connector final
+
+  private:
+   bool fake_check_target(const char* target, const char* set_str) const {
+-    CHECK_NE(target, nullptr);
++    ABSL_CHECK_NE(target, nullptr);
+     char** set = nullptr;
+     size_t set_size = 0;
+     gpr_string_split(set_str, ",", &set, &set_size);
+@@ -163,20 +163,20 @@ class grpc_fake_channel_security_connector final
+     gpr_string_split(expected_targets_->c_str(), ";", &lbs_and_backends,
+                      &lbs_and_backends_size);
+     if (lbs_and_backends_size > 2 || lbs_and_backends_size == 0) {
+-      LOG(ERROR) << "Invalid expected targets arg value: '"
++      ABSL_LOG(ERROR) << "Invalid expected targets arg value: '"
+                  << expected_targets_->c_str() << "'";
+       goto done;
+     }
+     if (is_lb_channel_) {
+       if (lbs_and_backends_size != 2) {
+-        LOG(ERROR) << "Invalid expected targets arg value: '"
++        ABSL_LOG(ERROR) << "Invalid expected targets arg value: '"
+                    << expected_targets_->c_str()
+                    << "'. Expectations for LB channels must be of the form "
+                       "'be1,be2,be3,...;lb1,lb2,...";
+         goto done;
+       }
+       if (!fake_check_target(target_, lbs_and_backends[1])) {
+-        LOG(ERROR) << "LB target '" << target_
++        ABSL_LOG(ERROR) << "LB target '" << target_
+                    << "' not found in expected set '" << lbs_and_backends[1]
+                    << "'";
+         goto done;
+@@ -184,7 +184,7 @@ class grpc_fake_channel_security_connector final
+       success = true;
+     } else {
+       if (!fake_check_target(target_, lbs_and_backends[0])) {
+-        LOG(ERROR) << "Backend target '" << target_
++        ABSL_LOG(ERROR) << "Backend target '" << target_
+                    << "' not found in expected set '" << lbs_and_backends[0]
+                    << "'";
+         goto done;
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc
+index da250fea5988a..7af11057cce4a 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc
+@@ -22,7 +22,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/handshaker/security/security_handshaker.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -69,7 +69,7 @@ void InsecureChannelSecurityConnector::add_handshakers(
+     HandshakeManager* handshake_manager) {
+   tsi_handshaker* handshaker = nullptr;
+   // Re-use local_tsi_handshaker_create as a minimalist handshaker.
+-  CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
++  ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+   handshake_manager->Add(SecurityHandshakerCreate(handshaker, this, args));
+ }
+
+@@ -96,7 +96,7 @@ void InsecureServerSecurityConnector::add_handshakers(
+     HandshakeManager* handshake_manager) {
+   tsi_handshaker* handshaker = nullptr;
+   // Re-use local_tsi_handshaker_create as a minimalist handshaker.
+-  CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
++  ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+   handshake_manager->Add(SecurityHandshakerCreate(handshaker, this, args));
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc b/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc
+index c1cf3ab2a2ebf..36b57fee15dad 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc
+@@ -33,7 +33,7 @@
+ #include <sys/stat.h>
+ #include <unistd.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/config/config_vars.h"
+ #include "src/core/lib/iomgr/error.h"
+ #include "src/core/lib/security/security_connector/load_system_roots.h"
+@@ -78,7 +78,7 @@ void GetAbsoluteFilePath(const char* valid_file_dir,
+     int path_len = snprintf(path_buffer, MAXPATHLEN, "%s/%s", valid_file_dir,
+                             file_entry_name);
+     if (path_len == 0) {
+-      LOG(ERROR) << "failed to get absolute path for file: " << file_entry_name;
++      ABSL_LOG(ERROR) << "failed to get absolute path for file: " << file_entry_name;
+     }
+   }
+ }
+@@ -108,7 +108,7 @@ grpc_slice CreateRootCertsBundle(const char* certs_directory) {
+     if (stat_return == -1 || !S_ISREG(dir_entry_stat.st_mode)) {
+       // no subdirectories.
+       if (stat_return == -1) {
+-        LOG(ERROR) << "failed to get status for file: " << file_data.path;
++        ABSL_LOG(ERROR) << "failed to get status for file: " << file_data.path;
+       }
+       continue;
+     }
+@@ -129,7 +129,7 @@ grpc_slice CreateRootCertsBundle(const char* certs_directory) {
+       if (read_ret != -1) {
+         bytes_read += read_ret;
+       } else {
+-        LOG(ERROR) << "failed to read file: " << roots_filenames[i].path;
++        ABSL_LOG(ERROR) << "failed to read file: " << roots_filenames[i].path;
+       }
+     }
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc
+index 657bcaf47d9da..86d192844cfab 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc
+@@ -29,8 +29,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+@@ -77,12 +77,12 @@ grpc_core::RefCountedPtr<grpc_auth_context> local_auth_context_create(
+   grpc_auth_context_add_cstring_property(
+       ctx.get(), GRPC_TRANSPORT_SECURITY_TYPE_PROPERTY_NAME,
+       GRPC_LOCAL_TRANSPORT_SECURITY_TYPE);
+-  CHECK(grpc_auth_context_set_peer_identity_property_name(
++  ABSL_CHECK(grpc_auth_context_set_peer_identity_property_name(
+             ctx.get(), GRPC_TRANSPORT_SECURITY_TYPE_PROPERTY_NAME) == 1);
+-  CHECK_EQ(peer->property_count, 1u);
++  ABSL_CHECK_EQ(peer->property_count, 1u);
+   const tsi_peer_property* prop = &peer->properties[0];
+-  CHECK_NE(prop, nullptr);
+-  CHECK_EQ(strcmp(prop->name, TSI_SECURITY_LEVEL_PEER_PROPERTY), 0);
++  ABSL_CHECK_NE(prop, nullptr);
++  ABSL_CHECK_EQ(strcmp(prop->name, TSI_SECURITY_LEVEL_PEER_PROPERTY), 0);
+   grpc_auth_context_add_property(ctx.get(),
+                                  GRPC_TRANSPORT_SECURITY_LEVEL_PROPERTY_NAME,
+                                  prop->value.data, prop->value.length);
+@@ -98,7 +98,7 @@ void local_check_peer(tsi_peer peer, grpc_endpoint* ep,
+   absl::string_view local_addr = grpc_endpoint_get_local_address(ep);
+   absl::StatusOr<grpc_core::URI> uri = grpc_core::URI::Parse(local_addr);
+   if (!uri.ok() || !grpc_parse_uri(*uri, &resolved_addr)) {
+-    LOG(ERROR) << "Could not parse endpoint address: " << local_addr;
++    ABSL_LOG(ERROR) << "Could not parse endpoint address: " << local_addr;
+   } else {
+     grpc_resolved_address addr_normalized;
+     grpc_resolved_address* addr =
+@@ -186,7 +186,7 @@ class grpc_local_channel_security_connector final
+       grpc_pollset_set* /*interested_parties*/,
+       grpc_core::HandshakeManager* handshake_manager) override {
+     tsi_handshaker* handshaker = nullptr;
+-    CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
++    ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+     handshake_manager->Add(
+         grpc_core::SecurityHandshakerCreate(handshaker, this, args));
+   }
+@@ -241,7 +241,7 @@ class grpc_local_server_security_connector final
+       grpc_pollset_set* /*interested_parties*/,
+       grpc_core::HandshakeManager* handshake_manager) override {
+     tsi_handshaker* handshaker = nullptr;
+-    CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
++    ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+     handshake_manager->Add(
+         grpc_core::SecurityHandshakerCreate(handshaker, this, args));
+   }
+@@ -272,7 +272,7 @@ grpc_local_channel_security_connector_create(
+     grpc_core::RefCountedPtr<grpc_call_credentials> request_metadata_creds,
+     const grpc_core::ChannelArgs& args, const char* target_name) {
+   if (channel_creds == nullptr || target_name == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to "
++    ABSL_LOG(ERROR) << "Invalid arguments to "
+                   "grpc_local_channel_security_connector_create()";
+     return nullptr;
+   }
+@@ -285,7 +285,7 @@ grpc_local_channel_security_connector_create(
+   if (creds->connect_type() == UDS &&
+       !absl::StartsWith(server_uri_str, GRPC_UDS_URI_PATTERN) &&
+       !absl::StartsWith(server_uri_str, GRPC_ABSTRACT_UDS_URI_PATTERN)) {
+-    LOG(ERROR) << "Invalid UDS target name to "
++    ABSL_LOG(ERROR) << "Invalid UDS target name to "
+                   "grpc_local_channel_security_connector_create()";
+     return nullptr;
+   }
+@@ -297,7 +297,7 @@ grpc_core::RefCountedPtr<grpc_server_security_connector>
+ grpc_local_server_security_connector_create(
+     grpc_core::RefCountedPtr<grpc_server_credentials> server_creds) {
+   if (server_creds == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid arguments to grpc_local_server_security_connector_create()";
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc
+index 481175c76e08d..167701bc77b1c 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc
+@@ -23,8 +23,8 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/security/credentials/credentials.h"
+ #include "src/core/util/debug_location.h"
+@@ -42,8 +42,8 @@ int grpc_channel_security_connector::channel_security_connector_cmp(
+     const grpc_channel_security_connector* other) const {
+   const grpc_channel_security_connector* other_sc =
+       static_cast<const grpc_channel_security_connector*>(other);
+-  CHECK_NE(channel_creds(), nullptr);
+-  CHECK_NE(other_sc->channel_creds(), nullptr);
++  ABSL_CHECK_NE(channel_creds(), nullptr);
++  ABSL_CHECK_NE(other_sc->channel_creds(), nullptr);
+   int c = channel_creds()->cmp(other_sc->channel_creds());
+   if (c != 0) return c;
+   return grpc_core::QsortCompare(request_metadata_creds(),
+@@ -64,8 +64,8 @@ int grpc_server_security_connector::server_security_connector_cmp(
+     const grpc_server_security_connector* other) const {
+   const grpc_server_security_connector* other_sc =
+       static_cast<const grpc_server_security_connector*>(other);
+-  CHECK_NE(server_creds(), nullptr);
+-  CHECK_NE(other_sc->server_creds(), nullptr);
++  ABSL_CHECK_NE(server_creds(), nullptr);
++  ABSL_CHECK_NE(other_sc->server_creds(), nullptr);
+   return grpc_core::QsortCompare(server_creds(), other_sc->server_creds());
+ }
+
+@@ -103,7 +103,7 @@ grpc_arg grpc_security_connector_to_arg(grpc_security_connector* sc) {
+ grpc_security_connector* grpc_security_connector_from_arg(const grpc_arg* arg) {
+   if (strcmp(arg->key, GRPC_ARG_SECURITY_CONNECTOR) != 0) return nullptr;
+   if (arg->type != GRPC_ARG_POINTER) {
+-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
++    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+                << GRPC_ARG_SECURITY_CONNECTOR;
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc
+index 0c8dc6043f865..eb59cc5f22764 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc
+@@ -26,8 +26,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -110,7 +110,7 @@ class grpc_ssl_channel_security_connector final
+         /*network_bio_buf_size=*/0,
+         /*ssl_bio_buf_size=*/0, &tsi_hs);
+     if (result != TSI_OK) {
+-      LOG(ERROR) << "Handshaker creation failed with error "
++      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
+                  << tsi_result_to_string(result);
+       return;
+     }
+@@ -202,7 +202,7 @@ class grpc_ssl_server_security_connector
+     if (has_cert_config_fetcher()) {
+       // Load initial credentials from certificate_config_fetcher:
+       if (!try_fetch_ssl_server_credentials()) {
+-        LOG(ERROR) << "Failed loading SSL server credentials from fetcher.";
++        ABSL_LOG(ERROR) << "Failed loading SSL server credentials from fetcher.";
+         return GRPC_SECURITY_ERROR;
+       }
+     } else {
+@@ -233,7 +233,7 @@ class grpc_ssl_server_security_connector
+               &options, &server_handshaker_factory_);
+       gpr_free(alpn_protocol_strings);
+       if (result != TSI_OK) {
+-        LOG(ERROR) << "Handshaker factory creation failed with "
++        ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
+                    << tsi_result_to_string(result);
+         return GRPC_SECURITY_ERROR;
+       }
+@@ -251,7 +251,7 @@ class grpc_ssl_server_security_connector
+         server_handshaker_factory_, /*network_bio_buf_size=*/0,
+         /*ssl_bio_buf_size=*/0, &tsi_hs);
+     if (result != TSI_OK) {
+-      LOG(ERROR) << "Handshaker creation failed with error "
++      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
+                  << tsi_result_to_string(result);
+       return;
+     }
+@@ -296,7 +296,7 @@ class grpc_ssl_server_security_connector
+       status = try_replace_server_handshaker_factory(certificate_config);
+     } else {
+       // Log error, continue using previously-loaded credentials.
+-      LOG(ERROR) << "Failed fetching new server credentials, continuing to "
++      ABSL_LOG(ERROR) << "Failed fetching new server credentials, continuing to "
+                     "use previously-loaded credentials.";
+       status = false;
+     }
+@@ -314,12 +314,12 @@ class grpc_ssl_server_security_connector
+   bool try_replace_server_handshaker_factory(
+       const grpc_ssl_server_certificate_config* config) {
+     if (config == nullptr) {
+-      LOG(ERROR)
++      ABSL_LOG(ERROR)
+           << "Server certificate config callback returned invalid (NULL) "
+              "config.";
+       return false;
+     }
+-    VLOG(2) << "Using new server certificate config (" << config << ").";
++    ABSL_VLOG(2) << "Using new server certificate config (" << config << ").";
+
+     size_t num_alpn_protocols = 0;
+     const char** alpn_protocol_strings =
+@@ -327,7 +327,7 @@ class grpc_ssl_server_security_connector
+     tsi_ssl_server_handshaker_factory* new_handshaker_factory = nullptr;
+     const grpc_ssl_server_credentials* server_creds =
+         static_cast<const grpc_ssl_server_credentials*>(this->server_creds());
+-    DCHECK_NE(config->pem_root_certs, nullptr);
++    ABSL_DCHECK_NE(config->pem_root_certs, nullptr);
+     tsi_ssl_server_handshaker_options options;
+     options.pem_key_cert_pairs = grpc_convert_grpc_to_tsi_cert_pairs(
+         config->pem_key_cert_pairs, config->num_key_cert_pairs);
+@@ -347,7 +347,7 @@ class grpc_ssl_server_security_connector
+     gpr_free(alpn_protocol_strings);
+
+     if (result != TSI_OK) {
+-      LOG(ERROR) << "Handshaker factory creation failed with "
++      ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
+                  << tsi_result_to_string(result);
+       return false;
+     }
+@@ -376,7 +376,7 @@ grpc_ssl_channel_security_connector_create(
+     const char* overridden_target_name,
+     tsi_ssl_client_handshaker_factory* client_factory) {
+   if (config == nullptr || target_name == nullptr) {
+-    LOG(ERROR) << "An ssl channel needs a config and a target name.";
++    ABSL_LOG(ERROR) << "An ssl channel needs a config and a target name.";
+     return nullptr;
+   }
+
+@@ -391,7 +391,7 @@ grpc_ssl_channel_security_connector_create(
+ grpc_core::RefCountedPtr<grpc_server_security_connector>
+ grpc_ssl_server_security_connector_create(
+     grpc_core::RefCountedPtr<grpc_server_credentials> server_credentials) {
+-  CHECK(server_credentials != nullptr);
++  ABSL_CHECK(server_credentials != nullptr);
+   grpc_core::RefCountedPtr<grpc_ssl_server_security_connector> c =
+       grpc_core::MakeRefCounted<grpc_ssl_server_security_connector>(
+           std::move(server_credentials));
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc b/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc
+index 09962b3eec910..07eeeef1de207 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc
+@@ -33,8 +33,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_split.h"
+@@ -121,7 +121,7 @@ tsi_tls_version grpc_get_tsi_tls_version(grpc_tls_version tls_version) {
+     case grpc_tls_version::TLS1_3:
+       return tsi_tls_version::TSI_TLS1_3;
+     default:
+-      LOG(INFO) << "Falling back to TLS 1.2.";
++      ABSL_LOG(INFO) << "Falling back to TLS 1.2.";
+       return tsi_tls_version::TSI_TLS1_2;
+   }
+ }
+@@ -178,7 +178,7 @@ absl::Status SslCheckCallHost(absl::string_view host,
+     status = GRPC_SECURITY_OK;
+   }
+   if (status != GRPC_SECURITY_OK) {
+-    LOG(ERROR) << "call host does not match SSL server name";
++    ABSL_LOG(ERROR) << "call host does not match SSL server name";
+     grpc_shallow_peer_destruct(&peer);
+     return absl::UnauthenticatedError(
+         "call host does not match SSL server name");
+@@ -190,7 +190,7 @@ absl::Status SslCheckCallHost(absl::string_view host,
+ }  // namespace grpc_core
+
+ const char** grpc_fill_alpn_protocol_strings(size_t* num_alpn_protocols) {
+-  CHECK_NE(num_alpn_protocols, nullptr);
++  ABSL_CHECK_NE(num_alpn_protocols, nullptr);
+   *num_alpn_protocols = grpc_chttp2_num_alpn_versions();
+   const char** alpn_protocol_strings = static_cast<const char**>(
+       gpr_malloc(sizeof(const char*) * (*num_alpn_protocols)));
+@@ -253,7 +253,7 @@ grpc_core::RefCountedPtr<grpc_auth_context> grpc_ssl_peer_to_auth_context(
+   const char* peer_identity_property_name = nullptr;
+
+   // The caller has checked the certificate type property.
+-  CHECK_GE(peer->property_count, 1u);
++  ABSL_CHECK_GE(peer->property_count, 1u);
+   grpc_core::RefCountedPtr<grpc_auth_context> ctx =
+       grpc_core::MakeRefCounted<grpc_auth_context>(nullptr);
+   grpc_auth_context_add_cstring_property(
+@@ -320,14 +320,14 @@ grpc_core::RefCountedPtr<grpc_auth_context> grpc_ssl_peer_to_auth_context(
+     }
+   }
+   if (peer_identity_property_name != nullptr) {
+-    CHECK(grpc_auth_context_set_peer_identity_property_name(
++    ABSL_CHECK(grpc_auth_context_set_peer_identity_property_name(
+               ctx.get(), peer_identity_property_name) == 1);
+   }
+   // A valid SPIFFE certificate can only have exact one URI SAN field.
+   if (has_spiffe_id) {
+     if (uri_count == 1) {
+-      CHECK_GT(spiffe_length, 0u);
+-      CHECK_NE(spiffe_data, nullptr);
++      ABSL_CHECK_GT(spiffe_length, 0u);
++      ABSL_CHECK_NE(spiffe_data, nullptr);
+       grpc_auth_context_add_property(ctx.get(),
+                                      GRPC_PEER_SPIFFE_ID_PROPERTY_NAME,
+                                      spiffe_data, spiffe_length);
+@@ -425,7 +425,7 @@ grpc_security_status grpc_ssl_tsi_client_handshaker_factory_init(
+     // Use default root certificates.
+     root_certs = grpc_core::DefaultSslRootStore::GetPemRootCerts();
+     if (root_certs == nullptr) {
+-      LOG(ERROR) << "Could not get default pem root certs.";
++      ABSL_LOG(ERROR) << "Could not get default pem root certs.";
+       return GRPC_SECURITY_ERROR;
+     }
+     root_store = grpc_core::DefaultSslRootStore::GetRootStore();
+@@ -458,7 +458,7 @@ grpc_security_status grpc_ssl_tsi_client_handshaker_factory_init(
+                                                             handshaker_factory);
+   gpr_free(options.alpn_protocols);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "Handshaker factory creation failed with "
++    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
+                << tsi_result_to_string(result);
+     return GRPC_SECURITY_ERROR;
+   }
+@@ -497,7 +497,7 @@ grpc_security_status grpc_ssl_tsi_server_handshaker_factory_init(
+                                                             handshaker_factory);
+   gpr_free(alpn_protocol_strings);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "Handshaker factory creation failed with "
++    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
+                << tsi_result_to_string(result);
+     return GRPC_SECURITY_ERROR;
+   }
+@@ -575,7 +575,7 @@ grpc_slice DefaultSslRootStore::ComputePemRootCerts() {
+     auto slice =
+         LoadFile(default_root_certs_path, /*add_null_terminator=*/true);
+     if (!slice.ok()) {
+-      LOG(ERROR) << "error loading file " << default_root_certs_path << ": "
++      ABSL_LOG(ERROR) << "error loading file " << default_root_certs_path << ": "
+                  << slice.status();
+     } else {
+       result = std::move(*slice);
+@@ -587,7 +587,7 @@ grpc_slice DefaultSslRootStore::ComputePemRootCerts() {
+     char* pem_root_certs = nullptr;
+     ovrd_res = ssl_roots_override_cb(&pem_root_certs);
+     if (ovrd_res == GRPC_SSL_ROOTS_OVERRIDE_OK) {
+-      CHECK_NE(pem_root_certs, nullptr);
++      ABSL_CHECK_NE(pem_root_certs, nullptr);
+       result = Slice::FromCopiedBuffer(
+           pem_root_certs,
+           strlen(pem_root_certs) + 1);  // nullptr terminator.
+@@ -602,7 +602,7 @@ grpc_slice DefaultSslRootStore::ComputePemRootCerts() {
+   if (result.empty() && ovrd_res != GRPC_SSL_ROOTS_OVERRIDE_FAIL_PERMANENTLY) {
+     auto slice = LoadFile(installed_roots_path, /*add_null_terminator=*/true);
+     if (!slice.ok()) {
+-      LOG(ERROR) << "error loading file " << installed_roots_path << ": "
++      ABSL_LOG(ERROR) << "error loading file " << installed_roots_path << ": "
+                  << slice.status();
+     } else {
+       result = std::move(*slice);
+diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc
+index 40fc246a72dc4..3a9a810d4c063 100644
+--- a/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc
++++ b/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc
+@@ -30,8 +30,8 @@
+ #include <vector>
+
+ #include "absl/functional/bind_front.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/handshaker/security/security_handshaker.h"
+@@ -62,7 +62,7 @@ char* CopyCoreString(char* src, size_t length) {
+ void PendingVerifierRequestInit(
+     const char* target_name, tsi_peer peer,
+     grpc_tls_custom_verification_check_request* request) {
+-  CHECK_NE(request, nullptr);
++  ABSL_CHECK_NE(request, nullptr);
+   // The verifier holds a ref to the security connector, so it's fine to
+   // directly point this to the name cached in the security connector.
+   request->target_name = target_name;
+@@ -174,7 +174,7 @@ void PendingVerifierRequestInit(
+
+ void PendingVerifierRequestDestroy(
+     grpc_tls_custom_verification_check_request* request) {
+-  CHECK_NE(request, nullptr);
++  ABSL_CHECK_NE(request, nullptr);
+   if (request->peer_info.common_name != nullptr) {
+     gpr_free(const_cast<char*>(request->peer_info.common_name));
+   }
+@@ -218,13 +218,13 @@ tsi_ssl_pem_key_cert_pair* ConvertToTsiPemKeyCertPair(
+   tsi_ssl_pem_key_cert_pair* tsi_pairs = nullptr;
+   size_t num_key_cert_pairs = cert_pair_list.size();
+   if (num_key_cert_pairs > 0) {
+-    CHECK_NE(cert_pair_list.data(), nullptr);
++    ABSL_CHECK_NE(cert_pair_list.data(), nullptr);
+     tsi_pairs = static_cast<tsi_ssl_pem_key_cert_pair*>(
+         gpr_zalloc(num_key_cert_pairs * sizeof(tsi_ssl_pem_key_cert_pair)));
+   }
+   for (size_t i = 0; i < num_key_cert_pairs; i++) {
+-    CHECK(!cert_pair_list[i].private_key().empty());
+-    CHECK(!cert_pair_list[i].cert_chain().empty());
++    ABSL_CHECK(!cert_pair_list[i].private_key().empty());
++    ABSL_CHECK(!cert_pair_list[i].cert_chain().empty());
+     tsi_pairs[i].cert_chain =
+         gpr_strdup(cert_pair_list[i].cert_chain().c_str());
+     tsi_pairs[i].private_key =
+@@ -244,17 +244,17 @@ TlsChannelSecurityConnector::CreateTlsChannelSecurityConnector(
+     const char* target_name, const char* overridden_target_name,
+     tsi_ssl_session_cache* ssl_session_cache) {
+   if (channel_creds == nullptr) {
+-    LOG(ERROR) << "channel_creds is nullptr in "
++    ABSL_LOG(ERROR) << "channel_creds is nullptr in "
+                   "TlsChannelSecurityConnectorCreate()";
+     return nullptr;
+   }
+   if (options == nullptr) {
+-    LOG(ERROR) << "options is nullptr in "
++    ABSL_LOG(ERROR) << "options is nullptr in "
+                   "TlsChannelSecurityConnectorCreate()";
+     return nullptr;
+   }
+   if (target_name == nullptr) {
+-    LOG(ERROR) << "target_name is nullptr in "
++    ABSL_LOG(ERROR) << "target_name is nullptr in "
+                   "TlsChannelSecurityConnectorCreate()";
+     return nullptr;
+   }
+@@ -349,7 +349,7 @@ void TlsChannelSecurityConnector::add_handshakers(
+         /*network_bio_buf_size=*/0,
+         /*ssl_bio_buf_size=*/0, &tsi_hs);
+     if (result != TSI_OK) {
+-      LOG(ERROR) << "Handshaker creation failed with error "
++      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
+                  << tsi_result_to_string(result);
+     }
+   }
+@@ -372,7 +372,7 @@ void TlsChannelSecurityConnector::check_peer(
+   }
+   *auth_context =
+       grpc_ssl_peer_to_auth_context(&peer, GRPC_TLS_TRANSPORT_SECURITY_TYPE);
+-  CHECK_NE(options_->certificate_verifier(), nullptr);
++  ABSL_CHECK_NE(options_->certificate_verifier(), nullptr);
+   auto* pending_request = new ChannelPendingVerifierRequest(
+       RefAsSubclass<TlsChannelSecurityConnector>(), on_peer_checked, peer,
+       target_name);
+@@ -395,7 +395,7 @@ void TlsChannelSecurityConnector::cancel_check_peer(
+       if (it != pending_verifier_requests_.end()) {
+         pending_verifier_request = it->second->request();
+       } else {
+-        VLOG(2) << "TlsChannelSecurityConnector::cancel_check_peer: no "
++        ABSL_VLOG(2) << "TlsChannelSecurityConnector::cancel_check_peer: no "
+                    "corresponding pending request found";
+       }
+     }
+@@ -430,7 +430,7 @@ ArenaPromise<absl::Status> TlsChannelSecurityConnector::CheckCallHost(
+ void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::
+     OnCertificatesChanged(std::optional<absl::string_view> root_certs,
+                           std::optional<PemKeyCertPairList> key_cert_pairs) {
+-  CHECK_NE(security_connector_, nullptr);
++  ABSL_CHECK_NE(security_connector_, nullptr);
+   MutexLock lock(&security_connector_->mu_);
+   if (root_certs.has_value()) {
+     security_connector_->pem_root_certs_ = root_certs;
+@@ -446,7 +446,7 @@ void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::
+   if (root_ready && identity_ready) {
+     if (security_connector_->UpdateHandshakerFactoryLocked() !=
+         GRPC_SECURITY_OK) {
+-      LOG(ERROR) << "Update handshaker factory failed.";
++      ABSL_LOG(ERROR) << "Update handshaker factory failed.";
+     }
+   }
+ }
+@@ -456,11 +456,11 @@ void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::
+ void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::OnError(
+     grpc_error_handle root_cert_error, grpc_error_handle identity_cert_error) {
+   if (!root_cert_error.ok()) {
+-    LOG(ERROR) << "TlsChannelCertificateWatcher getting root_cert_error: "
++    ABSL_LOG(ERROR) << "TlsChannelCertificateWatcher getting root_cert_error: "
+                << StatusToString(root_cert_error);
+   }
+   if (!identity_cert_error.ok()) {
+-    LOG(ERROR) << "TlsChannelCertificateWatcher getting identity_cert_error: "
++    ABSL_LOG(ERROR) << "TlsChannelCertificateWatcher getting identity_cert_error: "
+                << StatusToString(identity_cert_error);
+   }
+ }
+@@ -557,12 +557,12 @@ TlsServerSecurityConnector::CreateTlsServerSecurityConnector(
+     RefCountedPtr<grpc_server_credentials> server_creds,
+     RefCountedPtr<grpc_tls_credentials_options> options) {
+   if (server_creds == nullptr) {
+-    LOG(ERROR) << "server_creds is nullptr in "
++    ABSL_LOG(ERROR) << "server_creds is nullptr in "
+                   "TlsServerSecurityConnectorCreate()";
+     return nullptr;
+   }
+   if (options == nullptr) {
+-    LOG(ERROR) << "options is nullptr in "
++    ABSL_LOG(ERROR) << "options is nullptr in "
+                   "TlsServerSecurityConnectorCreate()";
+     return nullptr;
+   }
+@@ -623,7 +623,7 @@ void TlsServerSecurityConnector::add_handshakers(
+         server_handshaker_factory_, /*network_bio_buf_size=*/0,
+         /*ssl_bio_buf_size=*/0, &tsi_hs);
+     if (result != TSI_OK) {
+-      LOG(ERROR) << "Handshaker creation failed with error "
++      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
+                  << tsi_result_to_string(result);
+     }
+   }
+@@ -669,7 +669,7 @@ void TlsServerSecurityConnector::cancel_check_peer(
+       if (it != pending_verifier_requests_.end()) {
+         pending_verifier_request = it->second->request();
+       } else {
+-        LOG(INFO) << "TlsServerSecurityConnector::cancel_check_peer: no "
++        ABSL_LOG(INFO) << "TlsServerSecurityConnector::cancel_check_peer: no "
+                      "corresponding pending request found";
+       }
+     }
+@@ -690,7 +690,7 @@ int TlsServerSecurityConnector::cmp(
+ void TlsServerSecurityConnector::TlsServerCertificateWatcher::
+     OnCertificatesChanged(std::optional<absl::string_view> root_certs,
+                           std::optional<PemKeyCertPairList> key_cert_pairs) {
+-  CHECK_NE(security_connector_, nullptr);
++  ABSL_CHECK_NE(security_connector_, nullptr);
+   MutexLock lock(&security_connector_->mu_);
+   if (root_certs.has_value()) {
+     security_connector_->pem_root_certs_ = root_certs;
+@@ -710,7 +710,7 @@ void TlsServerSecurityConnector::TlsServerCertificateWatcher::
+       (!root_being_watched && identity_being_watched && identity_has_value)) {
+     if (security_connector_->UpdateHandshakerFactoryLocked() !=
+         GRPC_SECURITY_OK) {
+-      LOG(ERROR) << "Update handshaker factory failed.";
++      ABSL_LOG(ERROR) << "Update handshaker factory failed.";
+     }
+   }
+ }
+@@ -720,11 +720,11 @@ void TlsServerSecurityConnector::TlsServerCertificateWatcher::
+ void TlsServerSecurityConnector::TlsServerCertificateWatcher::OnError(
+     grpc_error_handle root_cert_error, grpc_error_handle identity_cert_error) {
+   if (!root_cert_error.ok()) {
+-    LOG(ERROR) << "TlsServerCertificateWatcher getting root_cert_error: "
++    ABSL_LOG(ERROR) << "TlsServerCertificateWatcher getting root_cert_error: "
+                << StatusToString(root_cert_error);
+   }
+   if (!identity_cert_error.ok()) {
+-    LOG(ERROR) << "TlsServerCertificateWatcher getting identity_cert_error: "
++    ABSL_LOG(ERROR) << "TlsServerCertificateWatcher getting identity_cert_error: "
+                << StatusToString(identity_cert_error);
+   }
+ }
+@@ -787,8 +787,8 @@ TlsServerSecurityConnector::UpdateHandshakerFactoryLocked() {
+     tsi_ssl_server_handshaker_factory_unref(server_handshaker_factory_);
+   }
+   // The identity certs on the server side shouldn't be empty.
+-  CHECK(pem_key_cert_pair_list_.has_value());
+-  CHECK(!(*pem_key_cert_pair_list_).empty());
++  ABSL_CHECK(pem_key_cert_pair_list_.has_value());
++  ABSL_CHECK(!(*pem_key_cert_pair_list_).empty());
+   std::string pem_root_certs;
+   if (pem_root_certs_.has_value()) {
+     // TODO(ZhenLian): update the underlying TSI layer to use C++ types like
+diff --git a/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc b/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc
+index ebd3ee467c8cd..c0c08c7044808 100644
+--- a/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc
++++ b/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc
+@@ -30,8 +30,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/lib/channel/channel_args.h"
+@@ -151,7 +151,7 @@ void ServerAuthFilter::RunApplicationCode::OnMdProcessingDone(
+
+   // TODO(ZhenLian): Implement support for response_md.
+   if (response_md != nullptr && num_response_md > 0) {
+-    LOG(ERROR) << "response_md in auth metadata processing not supported for "
++    ABSL_LOG(ERROR) << "response_md in auth metadata processing not supported for "
+                   "now. Ignoring...";
+   }
+
+@@ -199,7 +199,7 @@ ServerAuthFilter::ServerAuthFilter(
+ absl::StatusOr<std::unique_ptr<ServerAuthFilter>> ServerAuthFilter::Create(
+     const ChannelArgs& args, ChannelFilter::Args) {
+   auto auth_context = args.GetObjectRef<grpc_auth_context>();
+-  CHECK(auth_context != nullptr);
++  ABSL_CHECK(auth_context != nullptr);
+   auto creds = args.GetObjectRef<grpc_server_credentials>();
+   return std::make_unique<ServerAuthFilter>(std::move(creds),
+                                             std::move(auth_context));
+diff --git a/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc b/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc
+index 88af7e0a20fde..ba74e24c4607d 100644
+--- a/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc
++++ b/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc
+@@ -24,7 +24,7 @@
+ #include <cstdint>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/util/bitset.h"
+
+ namespace grpc_core {
+@@ -99,7 +99,7 @@ Slice PercentEncodeSlice(Slice slice, PercentEncodingType type) {
+       *q++ = hex[c & 15];
+     }
+   }
+-  CHECK(q == out.end());
++  ABSL_CHECK(q == out.end());
+   return Slice(std::move(out));
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/slice/slice.cc b/third_party/grpc/source/src/core/lib/slice/slice.cc
+index 52af6a4e28875..237fb6f422b41 100644
+--- a/third_party/grpc/source/src/core/lib/slice/slice.cc
++++ b/third_party/grpc/source/src/core/lib/slice/slice.cc
+@@ -25,7 +25,7 @@
+
+ #include <new>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/lib/slice/slice_refcount.h"
+ #include "src/core/util/memory.h"
+@@ -243,11 +243,11 @@ static grpc_slice sub_no_ref(const grpc_slice& source, size_t begin,
+                              size_t end) {
+   grpc_slice subset;
+
+-  CHECK(end >= begin);
++  ABSL_CHECK(end >= begin);
+
+   if (source.refcount != nullptr) {
+     // Enforce preconditions
+-    CHECK(source.data.refcounted.length >= end);
++    ABSL_CHECK(source.data.refcounted.length >= end);
+
+     // Build the result
+     subset.refcount = source.refcount;
+@@ -256,7 +256,7 @@ static grpc_slice sub_no_ref(const grpc_slice& source, size_t begin,
+     subset.data.refcounted.length = end - begin;
+   } else {
+     // Enforce preconditions
+-    CHECK(source.data.inlined.length >= end);
++    ABSL_CHECK(source.data.inlined.length >= end);
+     subset.refcount = nullptr;
+     subset.data.inlined.length = static_cast<uint8_t>(end - begin);
+     memcpy(subset.data.inlined.bytes, source.data.inlined.bytes + begin,
+@@ -295,7 +295,7 @@ grpc_slice grpc_slice_split_tail_maybe_ref_impl(grpc_slice* source,
+
+   if (source->refcount == nullptr) {
+     // inlined data, copy it out
+-    CHECK(source->data.inlined.length >= split);
++    ABSL_CHECK(source->data.inlined.length >= split);
+     tail.refcount = nullptr;
+     tail.data.inlined.length =
+         static_cast<uint8_t>(source->data.inlined.length - split);
+@@ -310,7 +310,7 @@ grpc_slice grpc_slice_split_tail_maybe_ref_impl(grpc_slice* source,
+     source->data.refcounted.length = split;
+   } else {
+     size_t tail_length = source->data.refcounted.length - split;
+-    CHECK(source->data.refcounted.length >= split);
++    ABSL_CHECK(source->data.refcounted.length >= split);
+     if (allow_inline && tail_length < sizeof(tail.data.inlined.bytes) &&
+         ref_whom != GRPC_SLICE_REF_TAIL) {
+       // Copy out the bytes - it'll be cheaper than refcounting
+@@ -370,7 +370,7 @@ grpc_slice grpc_slice_split_head_impl(grpc_slice* source, size_t split) {
+   grpc_slice head;
+
+   if (source->refcount == nullptr) {
+-    CHECK(source->data.inlined.length >= split);
++    ABSL_CHECK(source->data.inlined.length >= split);
+
+     head.refcount = nullptr;
+     head.data.inlined.length = static_cast<uint8_t>(split);
+@@ -380,7 +380,7 @@ grpc_slice grpc_slice_split_head_impl(grpc_slice* source, size_t split) {
+     memmove(source->data.inlined.bytes, source->data.inlined.bytes + split,
+             source->data.inlined.length);
+   } else if (allow_inline && split < sizeof(head.data.inlined.bytes)) {
+-    CHECK(source->data.refcounted.length >= split);
++    ABSL_CHECK(source->data.refcounted.length >= split);
+
+     head.refcount = nullptr;
+     head.data.inlined.length = static_cast<uint8_t>(split);
+@@ -388,7 +388,7 @@ grpc_slice grpc_slice_split_head_impl(grpc_slice* source, size_t split) {
+     source->data.refcounted.bytes += split;
+     source->data.refcounted.length -= split;
+   } else {
+-    CHECK(source->data.refcounted.length >= split);
++    ABSL_CHECK(source->data.refcounted.length >= split);
+
+     // Build the result
+     head.refcount = source->refcount;
+diff --git a/third_party/grpc/source/src/core/lib/slice/slice.h b/third_party/grpc/source/src/core/lib/slice/slice.h
+index 6a84345d8382c..2ac37a686a6b4 100644
+--- a/third_party/grpc/source/src/core/lib/slice/slice.h
++++ b/third_party/grpc/source/src/core/lib/slice/slice.h
+@@ -25,7 +25,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/lib/slice/slice_refcount.h"
+@@ -241,7 +241,7 @@ class StaticSlice : public slice_detail::BaseSlice,
+   StaticSlice() = default;
+   explicit StaticSlice(const grpc_slice& slice)
+       : slice_detail::BaseSlice(slice) {
+-    DCHECK(slice.refcount == grpc_slice_refcount::NoopRefcount());
++    ABSL_DCHECK(slice.refcount == grpc_slice_refcount::NoopRefcount());
+   }
+
+   StaticSlice(const StaticSlice& other)
+@@ -265,7 +265,7 @@ class GPR_MSVC_EMPTY_BASE_CLASS_WORKAROUND MutableSlice
+   MutableSlice() = default;
+   explicit MutableSlice(const grpc_slice& slice)
+       : slice_detail::BaseSlice(slice) {
+-    DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
++    ABSL_DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
+   }
+   ~MutableSlice() { CSliceUnref(c_slice()); }
+
+diff --git a/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc b/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc
+index 9b6b3a3f69b39..3edba3437a5af 100644
+--- a/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc
++++ b/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc
+@@ -26,7 +26,7 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/slice/slice_internal.h"
+
+ namespace grpc_core {
+@@ -79,7 +79,7 @@ Slice SliceBuffer::JoinIntoSlice() const {
+            GRPC_SLICE_LENGTH(slice_buffer_.slices[i]));
+     ofs += GRPC_SLICE_LENGTH(slice_buffer_.slices[i]);
+   }
+-  CHECK(ofs == slice_buffer_.length);
++  ABSL_CHECK(ofs == slice_buffer_.length);
+   return Slice(slice);
+ }
+
+@@ -329,7 +329,7 @@ static void slice_buffer_move_first_maybe_ref(grpc_slice_buffer* src, size_t n,
+     return;
+   }
+
+-  CHECK(src->length >= n);
++  ABSL_CHECK(src->length >= n);
+   if (src->length == n) {
+     grpc_slice_buffer_move_into(src, dst);
+     return;
+@@ -357,7 +357,7 @@ static void slice_buffer_move_first_maybe_ref(grpc_slice_buffer* src, size_t n,
+             src, grpc_slice_split_tail_maybe_ref_no_inline(
+                      &slice, n, GRPC_SLICE_REF_BOTH));
+       }
+-      CHECK(GRPC_SLICE_LENGTH(slice) == n);
++      ABSL_CHECK(GRPC_SLICE_LENGTH(slice) == n);
+       grpc_slice_buffer_add(dst, slice);
+       break;
+     } else {  // n < slice_len
+@@ -370,14 +370,14 @@ static void slice_buffer_move_first_maybe_ref(grpc_slice_buffer* src, size_t n,
+             src, grpc_slice_split_tail_maybe_ref_no_inline(
+                      &slice, n, GRPC_SLICE_REF_TAIL));
+       }
+-      CHECK(GRPC_SLICE_LENGTH(slice) == n);
++      ABSL_CHECK(GRPC_SLICE_LENGTH(slice) == n);
+       grpc_slice_buffer_add_indexed(dst, slice);
+       break;
+     }
+   }
+-  CHECK(dst->length == output_len);
+-  CHECK(src->length == new_input_len);
+-  CHECK_GT(src->count, 0u);
++  ABSL_CHECK(dst->length == output_len);
++  ABSL_CHECK(src->length == new_input_len);
++  ABSL_CHECK_GT(src->count, 0u);
+ }
+
+ void grpc_slice_buffer_move_first_no_inline(grpc_slice_buffer* src, size_t n,
+@@ -398,7 +398,7 @@ void grpc_slice_buffer_move_first_no_ref(grpc_slice_buffer* src, size_t n,
+ void grpc_slice_buffer_move_first_into_buffer(grpc_slice_buffer* src, size_t n,
+                                               void* dst) {
+   char* dstp = static_cast<char*>(dst);
+-  CHECK(src->length >= n);
++  ABSL_CHECK(src->length >= n);
+
+   while (n > 0) {
+     grpc_slice slice = grpc_slice_buffer_take_first(src);
+@@ -424,7 +424,7 @@ void grpc_slice_buffer_move_first_into_buffer(grpc_slice_buffer* src, size_t n,
+ void grpc_slice_buffer_copy_first_into_buffer(const grpc_slice_buffer* src,
+                                               size_t n, void* dst) {
+   uint8_t* dstp = static_cast<uint8_t*>(dst);
+-  CHECK(src->length >= n);
++  ABSL_CHECK(src->length >= n);
+
+   for (size_t i = 0; i < src->count; i++) {
+     grpc_slice slice = src->slices[i];
+@@ -442,7 +442,7 @@ template <bool allow_inline>
+ void grpc_slice_buffer_trim_end_impl(grpc_slice_buffer* sb, size_t n,
+                                      grpc_slice_buffer* garbage) {
+   if (n == 0) return;
+-  CHECK(n <= sb->length);
++  ABSL_CHECK(n <= sb->length);
+   sb->length -= n;
+   for (;;) {
+     size_t idx = sb->count - 1;
+@@ -493,7 +493,7 @@ void grpc_slice_buffer_trim_end(grpc_slice_buffer* sb, size_t n,
+
+ grpc_slice grpc_slice_buffer_take_first(grpc_slice_buffer* sb) {
+   grpc_slice slice;
+-  CHECK_GT(sb->count, 0u);
++  ABSL_CHECK_GT(sb->count, 0u);
+   slice = sb->slices[0];
+   sb->slices++;
+   sb->count--;
+@@ -503,7 +503,7 @@ grpc_slice grpc_slice_buffer_take_first(grpc_slice_buffer* sb) {
+ }
+
+ void grpc_slice_buffer_remove_first(grpc_slice_buffer* sb) {
+-  DCHECK_GT(sb->count, 0u);
++  ABSL_DCHECK_GT(sb->count, 0u);
+   sb->length -= GRPC_SLICE_LENGTH(sb->slices[0]);
+   grpc_core::CSliceUnref(sb->slices[0]);
+   sb->slices++;
+diff --git a/third_party/grpc/source/src/core/lib/slice/slice_internal.h b/third_party/grpc/source/src/core/lib/slice/slice_internal.h
+index 9c05f6fdacdeb..98e37186e96c8 100644
+--- a/third_party/grpc/source/src/core/lib/slice/slice_internal.h
++++ b/third_party/grpc/source/src/core/lib/slice/slice_internal.h
+@@ -27,14 +27,14 @@
+ #include <string>
+
+ #include "absl/hash/hash.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/util/memory.h"
+
+ // Returns a pointer to the first slice in the slice buffer without giving
+ // ownership to or a reference count on that slice.
+ inline grpc_slice* grpc_slice_buffer_peek_first(grpc_slice_buffer* sb) {
+-  DCHECK_GT(sb->count, 0u);
++  ABSL_DCHECK_GT(sb->count, 0u);
+   return &sb->slices[0];
+ }
+
+diff --git a/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc b/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc
+index 52bf3795c905e..4d90ec97b248e 100644
+--- a/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc
++++ b/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc
+@@ -24,7 +24,7 @@
+ #include <stdint.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/lib/slice/slice.h"
+
+@@ -92,7 +92,7 @@ grpc_slice grpc_byte_buffer_reader_readall(grpc_byte_buffer_reader* reader) {
+     memcpy(&(outbuf[bytes_read]), GRPC_SLICE_START_PTR(in_slice), slice_length);
+     bytes_read += slice_length;
+     grpc_core::CSliceUnref(in_slice);
+-    CHECK(bytes_read <= input_size);
++    ABSL_CHECK(bytes_read <= input_size);
+   }
+
+   return out_slice;
+diff --git a/third_party/grpc/source/src/core/lib/surface/call.cc b/third_party/grpc/source/src/core/lib/surface/call.cc
+index 95f42cf41f877..745756f7b0ae6 100644
+--- a/third_party/grpc/source/src/core/lib/surface/call.cc
++++ b/third_party/grpc/source/src/core/lib/surface/call.cc
+@@ -48,8 +48,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -119,8 +119,8 @@ Call::Call(bool is_client, Timestamp send_deadline, RefCountedPtr<Arena> arena)
+     : arena_(std::move(arena)),
+       send_deadline_(send_deadline),
+       is_client_(is_client) {
+-  DCHECK_NE(arena_.get(), nullptr);
+-  DCHECK_NE(arena_->GetContext<grpc_event_engine::experimental::EventEngine>(),
++  ABSL_DCHECK_NE(arena_.get(), nullptr);
++  ABSL_DCHECK_NE(arena_->GetContext<grpc_event_engine::experimental::EventEngine>(),
+             nullptr);
+   arena_->SetContext<Call>(this);
+ }
+@@ -148,8 +148,8 @@ absl::Status Call::InitParent(Call* parent, uint32_t propagation_mask) {
+   child_ = arena()->New<ChildCall>(parent);
+
+   parent->InternalRef("child");
+-  CHECK(is_client_);
+-  CHECK(!parent->is_client_);
++  ABSL_CHECK(is_client_);
++  ABSL_CHECK(!parent->is_client_);
+
+   if (propagation_mask & GRPC_PROPAGATE_DEADLINE) {
+     send_deadline_ = std::min(send_deadline_, parent->send_deadline_);
+@@ -303,7 +303,7 @@ void Call::ProcessIncomingInitialMetadata(grpc_metadata_batch& md) {
+     HandleCompressionAlgorithmDisabled(compression_algorithm);
+   }
+   // GRPC_COMPRESS_NONE is always set.
+-  DCHECK(encodings_accepted_by_peer_.IsSet(GRPC_COMPRESS_NONE));
++  ABSL_DCHECK(encodings_accepted_by_peer_.IsSet(GRPC_COMPRESS_NONE));
+   if (GPR_UNLIKELY(!encodings_accepted_by_peer_.IsSet(compression_algorithm))) {
+     if (GRPC_TRACE_FLAG_ENABLED(compression)) {
+       HandleCompressionAlgorithmNotAccepted(compression_algorithm);
+@@ -315,7 +315,7 @@ void Call::HandleCompressionAlgorithmNotAccepted(
+     grpc_compression_algorithm compression_algorithm) {
+   const char* algo_name = nullptr;
+   grpc_compression_algorithm_name(compression_algorithm, &algo_name);
+-  LOG(ERROR) << "Compression algorithm ('" << algo_name
++  ABSL_LOG(ERROR) << "Compression algorithm ('" << algo_name
+              << "') not present in the accepted encodings ("
+              << encodings_accepted_by_peer_.ToString() << ")";
+ }
+@@ -326,7 +326,7 @@ void Call::HandleCompressionAlgorithmDisabled(
+   grpc_compression_algorithm_name(compression_algorithm, &algo_name);
+   std::string error_msg =
+       absl::StrFormat("Compression algorithm '%s' is disabled.", algo_name);
+-  LOG(ERROR) << error_msg;
++  ABSL_LOG(ERROR) << error_msg;
+   CancelWithError(grpc_error_set_int(absl::UnimplementedError(error_msg),
+                                      StatusIntProperty::kRpcStatus,
+                                      GRPC_STATUS_UNIMPLEMENTED));
+@@ -410,7 +410,7 @@ char* grpc_call_get_peer(grpc_call* call) {
+ grpc_call_error grpc_call_cancel(grpc_call* call, void* reserved) {
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_call_cancel(call=" << call << ", reserved=" << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   if (call == nullptr) {
+     return GRPC_CALL_ERROR;
+   }
+@@ -427,7 +427,7 @@ grpc_call_error grpc_call_cancel_with_status(grpc_call* c,
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_call_cancel_with_status(c=" << c << ", status=" << (int)status
+       << ", description=" << description << ", reserved=" << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   if (c == nullptr) {
+     return GRPC_CALL_ERROR;
+   }
+diff --git a/third_party/grpc/source/src/core/lib/surface/call.h b/third_party/grpc/source/src/core/lib/surface/call.h
+index bc7220ac60918..280443aa01d40 100644
+--- a/third_party/grpc/source/src/core/lib/surface/call.h
++++ b/third_party/grpc/source/src/core/lib/surface/call.h
+@@ -30,7 +30,7 @@
+
+ #include "absl/functional/any_invocable.h"
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/channel/channel_fwd.h"
+ #include "src/core/lib/channel/channel_stack.h"
+diff --git a/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc b/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc
+index 2162ac2831b1a..1aa82121b0120 100644
+--- a/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc
++++ b/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc
+@@ -106,7 +106,7 @@ static std::string grpc_op_string(const grpc_op* op) {
+ void grpc_call_log_batch(const char* file, int line, const grpc_op* ops,
+                          size_t nops) {
+   for (size_t i = 0; i < nops; i++) {
+-    LOG(INFO).AtLocation(file, line)
++    ABSL_LOG(INFO).AtLocation(file, line)
+         << "ops[" << i << "]: " << grpc_op_string(&ops[i]);
+   }
+ }
+diff --git a/third_party/grpc/source/src/core/lib/surface/call_utils.cc b/third_party/grpc/source/src/core/lib/surface/call_utils.cc
+index bb67b1b4f559d..b070e7c8ba5a3 100644
+--- a/third_party/grpc/source/src/core/lib/surface/call_utils.cc
++++ b/third_party/grpc/source/src/core/lib/surface/call_utils.cc
+@@ -40,8 +40,8 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -86,7 +86,7 @@ void CToMetadata(grpc_metadata* metadata, size_t count,
+     if (key == "content-length") continue;
+     b->Append(key, Slice(CSliceRef(md->value)),
+               [md](absl::string_view error, const Slice& value) {
+-                VLOG(2) << "Append error: key=" << StringViewFromSlice(md->key)
++                ABSL_VLOG(2) << "Append error: key=" << StringViewFromSlice(md->key)
+                         << " error=" << error
+                         << " value=" << value.as_string_view();
+               });
+@@ -215,7 +215,7 @@ bool ValidateMetadata(size_t count, grpc_metadata* metadata) {
+ void EndOpImmediately(grpc_completion_queue* cq, void* notify_tag,
+                       bool is_notify_tag_closure) {
+   if (!is_notify_tag_closure) {
+-    CHECK(grpc_cq_begin_op(cq, notify_tag));
++    ABSL_CHECK(grpc_cq_begin_op(cq, notify_tag));
+     grpc_cq_end_op(
+         cq, notify_tag, absl::OkStatus(),
+         [](void*, grpc_cq_completion* completion) { gpr_free(completion); },
+diff --git a/third_party/grpc/source/src/core/lib/surface/call_utils.h b/third_party/grpc/source/src/core/lib/surface/call_utils.h
+index 1f92267b1fe74..362b6b1ba9a0f 100644
+--- a/third_party/grpc/source/src/core/lib/surface/call_utils.h
++++ b/third_party/grpc/source/src/core/lib/surface/call_utils.h
+@@ -40,7 +40,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -428,7 +428,7 @@ class MessageReceiver {
+
+   template <typename Puller>
+   auto MakeBatchOp(const grpc_op& op, Puller* puller) {
+-    CHECK_EQ(recv_message_, nullptr);
++    ABSL_CHECK_EQ(recv_message_, nullptr);
+     recv_message_ = op.data.recv_message.recv_message;
+     return [this, puller]() mutable {
+       return Map(puller->PullMessage(),
+diff --git a/third_party/grpc/source/src/core/lib/surface/channel.cc b/third_party/grpc/source/src/core/lib/surface/channel.cc
+index bc2b62c134016..db90c7604b3d2 100644
+--- a/third_party/grpc/source/src/core/lib/surface/channel.cc
++++ b/third_party/grpc/source/src/core/lib/surface/channel.cc
+@@ -22,7 +22,7 @@
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/channelz/channel_trace.h"
+ #include "src/core/channelz/channelz.h"
+ #include "src/core/lib/channel/channel_args.h"
+@@ -103,7 +103,7 @@ grpc_call* grpc_channel_create_call(grpc_channel* channel,
+                                     grpc_completion_queue* completion_queue,
+                                     grpc_slice method, const grpc_slice* host,
+                                     gpr_timespec deadline, void* reserved) {
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
+   grpc_core::ExecCtx exec_ctx;
+   return grpc_core::Channel::FromC(channel)->CreateCall(
+@@ -121,7 +121,7 @@ void* grpc_channel_register_call(grpc_channel* channel, const char* method,
+   GRPC_TRACE_LOG(api, INFO) << "grpc_channel_register_call(channel=" << channel
+                             << ", method=" << method << ", host=" << host
+                             << ", reserved=" << reserved << ")";
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
+   grpc_core::ExecCtx exec_ctx;
+   return grpc_core::Channel::FromC(channel)->RegisterCall(method, host);
+@@ -216,6 +216,6 @@ void grpc_channel_ping(grpc_channel* channel, grpc_completion_queue* cq,
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_channel_ping(channel=" << channel << ", cq=" << cq
+       << ", tag=" << tag << ", reserved=" << reserved << ")";
+-  CHECK_EQ(reserved, nullptr);
++  ABSL_CHECK_EQ(reserved, nullptr);
+   grpc_core::Channel::FromC(channel)->Ping(cq, tag);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/surface/channel_create.cc b/third_party/grpc/source/src/core/lib/surface/channel_create.cc
+index e14b3aa3683c1..242950cc51bf9 100644
+--- a/third_party/grpc/source/src/core/lib/surface/channel_create.cc
++++ b/third_party/grpc/source/src/core/lib/surface/channel_create.cc
+@@ -20,7 +20,7 @@
+ #include <grpc/impl/channel_arg_names.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/channelz/channelz.h"
+ #include "src/core/client_channel/client_channel.h"
+ #include "src/core/client_channel/direct_channel.h"
+@@ -120,6 +120,6 @@ grpc_channel* grpc_lame_client_channel_create(const char* target,
+   auto channel =
+       grpc_core::ChannelCreate(target == nullptr ? "" : target, std::move(args),
+                                GRPC_CLIENT_LAME_CHANNEL, nullptr);
+-  CHECK(channel.ok());
++  ABSL_CHECK(channel.ok());
+   return channel->release()->c_ptr();
+ }
+diff --git a/third_party/grpc/source/src/core/lib/surface/channel_init.cc b/third_party/grpc/source/src/core/lib/surface/channel_init.cc
+index d458888bcd8d6..f41078174f0a2 100644
+--- a/third_party/grpc/source/src/core/lib/surface/channel_init.cc
++++ b/third_party/grpc/source/src/core/lib/surface/channel_init.cc
+@@ -29,8 +29,8 @@
+ #include <string>
+ #include <type_traits>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+ #include "absl/strings/string_view.h"
+@@ -152,7 +152,7 @@ class ChannelInit::DependencyTracker {
+
+   FilterRegistration* Next() {
+     if (ready_dependencies_.empty()) {
+-      CHECK_EQ(nodes_taken_, nodes_.size()) << "Unresolvable graph of channel "
++      ABSL_CHECK_EQ(nodes_taken_, nodes_.size()) << "Unresolvable graph of channel "
+                                                "filters:\n"
+                                             << GraphString();
+       return nullptr;
+@@ -164,13 +164,13 @@ class ChannelInit::DependencyTracker {
+       // Constraint: if we use ordering other than default, then we must have an
+       // unambiguous pick. If there is ambiguity, we must fix it by adding
+       // explicit ordering constraints.
+-      CHECK_NE(next.node->ordering(),
++      ABSL_CHECK_NE(next.node->ordering(),
+                ready_dependencies_.top().node->ordering())
+           << "Ambiguous ordering between " << next.node->name() << " and "
+           << ready_dependencies_.top().node->name();
+     }
+     for (Node* dependent : next.node->dependents) {
+-      CHECK_GT(dependent->waiting_dependencies, 0u);
++      ABSL_CHECK_GT(dependent->waiting_dependencies, 0u);
+       --dependent->waiting_dependencies;
+       if (dependent->waiting_dependencies == 0) {
+         ready_dependencies_.emplace(dependent);
+@@ -195,7 +195,7 @@ class ChannelInit::DependencyTracker {
+
+   absl::Span<const UniqueTypeName> DependenciesFor(UniqueTypeName name) const {
+     auto it = nodes_.find(name);
+-    CHECK(it != nodes_.end()) << "Filter " << name.name() << " not found";
++    ABSL_CHECK(it != nodes_.end()) << "Filter " << name.name() << " not found";
+     return it->second.all_dependencies;
+   }
+
+@@ -246,10 +246,10 @@ ChannelInit::StackConfig ChannelInit::BuildStackConfig(
+   std::vector<Filter> terminal_filters;
+   for (const auto& registration : registrations) {
+     if (registration->terminal_) {
+-      CHECK(registration->after_.empty());
+-      CHECK(registration->before_.empty());
+-      CHECK(!registration->before_all_);
+-      CHECK_EQ(registration->ordering_, Ordering::kDefault);
++      ABSL_CHECK(registration->after_.empty());
++      ABSL_CHECK(registration->before_.empty());
++      ABSL_CHECK(!registration->before_all_);
++      ABSL_CHECK_EQ(registration->ordering_, Ordering::kDefault);
+       terminal_filters.emplace_back(
+           registration->name_, registration->filter_, nullptr,
+           std::move(registration->predicates_), registration->version_,
+@@ -308,7 +308,7 @@ ChannelInit::StackConfig ChannelInit::BuildStackConfig(
+   // Right now it forces too many tests to know about channel initialization,
+   // either by supplying a valid configuration or by including an opt-out flag.
+   if (terminal_filters.empty() && type != GRPC_CLIENT_DYNAMIC) {
+-    LOG(ERROR) << "No terminal filters registered for channel stack type "
++    ABSL_LOG(ERROR) << "No terminal filters registered for channel stack type "
+                << grpc_channel_stack_type_string(type)
+                << "; this is common for unit tests messing with "
+                   "CoreConfiguration, but will result in a "
+@@ -333,7 +333,7 @@ void ChannelInit::PrintChannelStackTrace(
+   MutexLock lock(m);
+   // List the channel stack type (since we'll be repeatedly printing graphs in
+   // this loop).
+-  LOG(INFO) << "ORDERED CHANNEL STACK " << grpc_channel_stack_type_string(type)
++  ABSL_LOG(INFO) << "ORDERED CHANNEL STACK " << grpc_channel_stack_type_string(type)
+             << ":";
+   // First build up a map of filter -> file:line: strings, because it helps
+   // the readability of this log to get later fields aligned vertically.
+@@ -392,7 +392,7 @@ void ChannelInit::PrintChannelStackTrace(
+       after_str =
+           std::string(max_filter_name_len - filter.name.name().length(), ' ');
+     }
+-    LOG(INFO) << "  " << loc_strs[filter.name] << filter.name << after_str
++    ABSL_LOG(INFO) << "  " << loc_strs[filter.name] << filter.name << after_str
+               << " [" << filter.ordering << "/" << filter.version << "]";
+   }
+   // Finally list out the terminal filters and where they were registered
+@@ -403,7 +403,7 @@ void ChannelInit::PrintChannelStackTrace(
+         std::string(max_filter_name_len + 1 - terminal.name.name().length(),
+                     ' '),
+         "[terminal]");
+-    LOG(INFO) << filter_str;
++    ABSL_LOG(INFO) << filter_str;
+   }
+ }
+
+@@ -458,7 +458,7 @@ bool ChannelInit::CreateStack(ChannelStackBuilder* builder) const {
+                         "\n");
+       }
+     }
+-    LOG(ERROR) << error;
++    ABSL_LOG(ERROR) << error;
+     return false;
+   }
+   for (const auto& post_processor : stack_config.post_processors) {
+diff --git a/third_party/grpc/source/src/core/lib/surface/channel_init.h b/third_party/grpc/source/src/core/lib/surface/channel_init.h
+index 88ca3d347ddb9..fa4e92c00e65d 100644
+--- a/third_party/grpc/source/src/core/lib/surface/channel_init.h
++++ b/third_party/grpc/source/src/core/lib/surface/channel_init.h
+@@ -29,7 +29,7 @@
+ #include <vector>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/channel/channel_fwd.h"
+ #include "src/core/lib/channel/channel_stack_builder.h"
+@@ -246,26 +246,26 @@ class ChannelInit {
+     // stack.
+     FilterRegistration& ExcludeFromMinimalStack();
+     FilterRegistration& SkipV3() {
+-      CHECK_EQ(version_, Version::kAny);
++      ABSL_CHECK_EQ(version_, Version::kAny);
+       version_ = Version::kV2;
+       return *this;
+     }
+     FilterRegistration& SkipV2() {
+-      CHECK_EQ(version_, Version::kAny);
++      ABSL_CHECK_EQ(version_, Version::kAny);
+       version_ = Version::kV3;
+       return *this;
+     }
+     // Request this filter be placed as high as possible in the stack (given
+     // before/after constraints).
+     FilterRegistration& FloatToTop() {
+-      CHECK_EQ(ordering_, Ordering::kDefault);
++      ABSL_CHECK_EQ(ordering_, Ordering::kDefault);
+       ordering_ = Ordering::kTop;
+       return *this;
+     }
+     // Request this filter be placed as low as possible in the stack (given
+     // before/after constraints).
+     FilterRegistration& SinkToBottom() {
+-      CHECK_EQ(ordering_, Ordering::kDefault);
++      ABSL_CHECK_EQ(ordering_, Ordering::kDefault);
+       ordering_ = Ordering::kBottom;
+       return *this;
+     }
+@@ -301,7 +301,7 @@ class ChannelInit {
+     FilterRegistration& RegisterFilter(
+         grpc_channel_stack_type type, const grpc_channel_filter* filter,
+         SourceLocation registration_source = {}) {
+-      CHECK(filter != nullptr);
++      ABSL_CHECK(filter != nullptr);
+       return RegisterFilter(type, NameFromChannelFilter(filter), filter,
+                             nullptr, registration_source);
+     }
+@@ -331,7 +331,7 @@ class ChannelInit {
+                                PostProcessorSlot slot,
+                                PostProcessor post_processor) {
+       auto& slot_value = post_processors_[type][static_cast<int>(slot)];
+-      CHECK(slot_value == nullptr);
++      ABSL_CHECK(slot_value == nullptr);
+       slot_value = std::move(post_processor);
+     }
+
+diff --git a/third_party/grpc/source/src/core/lib/surface/client_call.cc b/third_party/grpc/source/src/core/lib/surface/client_call.cc
+index 7eca227afd71b..4dfdd8f3aa0e8 100644
+--- a/third_party/grpc/source/src/core/lib/surface/client_call.cc
++++ b/third_party/grpc/source/src/core/lib/surface/client_call.cc
+@@ -39,7 +39,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/event_engine/event_engine_context.h"
+@@ -376,7 +376,7 @@ void ClientCall::CommitBatch(const grpc_op* ops, size_t nops, void* notify_tag,
+             [this, out_status, out_status_details, out_error_string,
+              out_trailing_metadata]() {
+               auto* status = cancel_status_.Get();
+-              CHECK_NE(status, nullptr);
++              ABSL_CHECK_NE(status, nullptr);
+               *out_status = static_cast<grpc_status_code>(status->code());
+               *out_status_details =
+                   Slice::FromCopiedString(status->message()).TakeCSlice();
+@@ -443,8 +443,8 @@ grpc_call* MakeClientCall(grpc_call* parent_call, uint32_t propagation_mask,
+                           grpc_compression_options compression_options,
+                           RefCountedPtr<Arena> arena,
+                           RefCountedPtr<UnstartedCallDestination> destination) {
+-  DCHECK_NE(arena.get(), nullptr);
+-  DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
++  ABSL_DCHECK_NE(arena.get(), nullptr);
++  ABSL_DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
+             nullptr);
+   return arena
+       ->New<ClientCall>(parent_call, propagation_mask, cq, std::move(path),
+diff --git a/third_party/grpc/source/src/core/lib/surface/completion_queue.cc b/third_party/grpc/source/src/core/lib/surface/completion_queue.cc
+index e4996964e8aa7..5ec044cfe3948 100644
+--- a/third_party/grpc/source/src/core/lib/surface/completion_queue.cc
++++ b/third_party/grpc/source/src/core/lib/surface/completion_queue.cc
+@@ -33,8 +33,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/str_join.h"
+@@ -173,7 +173,7 @@ grpc_error_handle non_polling_poller_kick(
+
+ void non_polling_poller_shutdown(grpc_pollset* pollset, grpc_closure* closure) {
+   non_polling_poller* p = reinterpret_cast<non_polling_poller*>(pollset);
+-  CHECK_NE(closure, nullptr);
++  ABSL_CHECK_NE(closure, nullptr);
+   p->shutdown = closure;
+   if (p->root == nullptr) {
+     grpc_core::ExecCtx::Run(DEBUG_LOCATION, closure, absl::OkStatus());
+@@ -251,10 +251,10 @@ class CqEventQueue {
+
+ struct cq_next_data {
+   ~cq_next_data() {
+-    CHECK_EQ(queue.num_items(), 0);
++    ABSL_CHECK_EQ(queue.num_items(), 0);
+ #ifndef NDEBUG
+     if (pending_events.load(std::memory_order_acquire) != 0) {
+-      LOG(ERROR) << "Destroying CQ without draining it fully.";
++      ABSL_LOG(ERROR) << "Destroying CQ without draining it fully.";
+     }
+ #endif
+   }
+@@ -281,10 +281,10 @@ struct cq_pluck_data {
+   }
+
+   ~cq_pluck_data() {
+-    CHECK(completed_head.next == reinterpret_cast<uintptr_t>(&completed_head));
++    ABSL_CHECK(completed_head.next == reinterpret_cast<uintptr_t>(&completed_head));
+ #ifndef NDEBUG
+     if (pending_events.load(std::memory_order_acquire) != 0) {
+-      LOG(ERROR) << "Destroying CQ without draining it fully.";
++      ABSL_LOG(ERROR) << "Destroying CQ without draining it fully.";
+     }
+ #endif
+   }
+@@ -323,7 +323,7 @@ struct cq_callback_data {
+   ~cq_callback_data() {
+ #ifndef NDEBUG
+     if (pending_events.load(std::memory_order_acquire) != 0) {
+-      LOG(ERROR) << "Destroying CQ without draining it fully.";
++      ABSL_LOG(ERROR) << "Destroying CQ without draining it fully.";
+     }
+ #endif
+   }
+@@ -444,7 +444,7 @@ static const cq_vtable g_cq_vtable[] = {
+     if (GRPC_TRACE_FLAG_ENABLED(api) &&               \
+         (GRPC_TRACE_FLAG_ENABLED(queue_pluck) ||      \
+          (event)->type != GRPC_QUEUE_TIMEOUT)) {      \
+-      LOG(INFO) << "RETURN_EVENT[" << (cq)            \
++      ABSL_LOG(INFO) << "RETURN_EVENT[" << (cq)            \
+                 << "]: " << grpc_event_string(event); \
+     }                                                 \
+   } while (0)
+@@ -650,7 +650,7 @@ static void cq_check_tag(grpc_completion_queue* cq, void* tag, bool lock_cq) {
+     gpr_mu_unlock(cq->mu);
+   }
+
+-  CHECK(found);
++  ABSL_CHECK(found);
+ }
+ #else
+ static void cq_check_tag(grpc_completion_queue* /*cq*/, void* /*tag*/,
+@@ -703,7 +703,7 @@ static void cq_end_op_for_next(
+         << ", error=" << errmsg.c_str() << ", done=" << done
+         << ", done_arg=" << done_arg << ", storage=" << storage << ")";
+     if (GRPC_TRACE_FLAG_ENABLED(op_failure) && !error.ok()) {
+-      LOG(INFO) << "Operation failed: tag=" << tag << ", error=" << errmsg;
++      ABSL_LOG(INFO) << "Operation failed: tag=" << tag << ", error=" << errmsg;
+     }
+   }
+   cq_next_data* cqd = static_cast<cq_next_data*> DATA_FROM_CQ(cq);
+@@ -736,7 +736,7 @@ static void cq_end_op_for_next(
+         gpr_mu_unlock(cq->mu);
+
+         if (!kick_error.ok()) {
+-          LOG(ERROR) << "Kick failed: "
++          ABSL_LOG(ERROR) << "Kick failed: "
+                      << grpc_core::StatusToString(kick_error);
+         }
+       }
+@@ -776,7 +776,7 @@ static void cq_end_op_for_pluck(
+         << ", error=" << errmsg.c_str() << ", done=" << done
+         << ", done_arg=" << done_arg << ", storage=" << storage << ")";
+     if (GRPC_TRACE_FLAG_ENABLED(op_failure) && !error.ok()) {
+-      LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
++      ABSL_LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
+     }
+   }
+
+@@ -811,7 +811,7 @@ static void cq_end_op_for_pluck(
+         cq->poller_vtable->kick(POLLSET_FROM_CQ(cq), pluck_worker);
+     gpr_mu_unlock(cq->mu);
+     if (!kick_error.ok()) {
+-      LOG(ERROR) << "Kick failed: " << kick_error;
++      ABSL_LOG(ERROR) << "Kick failed: " << kick_error;
+     }
+   }
+ }
+@@ -836,7 +836,7 @@ static void cq_end_op_for_callback(
+         << ", error=" << errmsg.c_str() << ", done=" << done
+         << ", done_arg=" << done_arg << ", storage=" << storage << ")";
+     if (GRPC_TRACE_FLAG_ENABLED(op_failure) && !error.ok()) {
+-      LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
++      ABSL_LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
+     }
+   }
+
+@@ -906,7 +906,7 @@ class ExecCtxNext : public grpc_core::ExecCtx {
+         static_cast<cq_is_finished_arg*>(check_ready_to_finish_arg_);
+     grpc_completion_queue* cq = a->cq;
+     cq_next_data* cqd = static_cast<cq_next_data*> DATA_FROM_CQ(cq);
+-    CHECK_EQ(a->stolen_completion, nullptr);
++    ABSL_CHECK_EQ(a->stolen_completion, nullptr);
+
+     intptr_t current_last_seen_things_queued_ever =
+         cqd->things_queued_ever.load(std::memory_order_relaxed);
+@@ -943,7 +943,7 @@ static void dump_pending_tags(grpc_completion_queue* cq) {
+     parts.push_back(absl::StrFormat(" %p", cq->outstanding_tags[i]));
+   }
+   gpr_mu_unlock(cq->mu);
+-  VLOG(2) << absl::StrJoin(parts, "");
++  ABSL_VLOG(2) << absl::StrJoin(parts, "");
+ }
+ #else
+ static void dump_pending_tags(grpc_completion_queue* /*cq*/) {}
+@@ -960,7 +960,7 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
+       << ", tv_nsec: " << deadline.tv_nsec
+       << ", clock_type: " << (int)deadline.clock_type
+       << " }, reserved=" << reserved << ")";
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+
+   dump_pending_tags(cq);
+
+@@ -1042,7 +1042,7 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
+     gpr_mu_unlock(cq->mu);
+
+     if (!err.ok()) {
+-      LOG(ERROR) << "Completion queue next failed: "
++      ABSL_LOG(ERROR) << "Completion queue next failed: "
+                  << grpc_core::StatusToString(err);
+       if (err == absl::CancelledError()) {
+         ret.type = GRPC_QUEUE_SHUTDOWN;
+@@ -1066,7 +1066,7 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
+   GRPC_SURFACE_TRACE_RETURNED_EVENT(cq, &ret);
+   GRPC_CQ_INTERNAL_UNREF(cq, "next");
+
+-  CHECK_EQ(is_finished_arg.stolen_completion, nullptr);
++  ABSL_CHECK_EQ(is_finished_arg.stolen_completion, nullptr);
+
+   return ret;
+ }
+@@ -1080,8 +1080,8 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
+ static void cq_finish_shutdown_next(grpc_completion_queue* cq) {
+   cq_next_data* cqd = static_cast<cq_next_data*> DATA_FROM_CQ(cq);
+
+-  CHECK(cqd->shutdown_called);
+-  CHECK_EQ(cqd->pending_events.load(std::memory_order_relaxed), 0);
++  ABSL_CHECK(cqd->shutdown_called);
++  ABSL_CHECK_EQ(cqd->pending_events.load(std::memory_order_relaxed), 0);
+
+   cq->poller_vtable->shutdown(POLLSET_FROM_CQ(cq), &cq->pollset_shutdown_done);
+ }
+@@ -1155,7 +1155,7 @@ class ExecCtxPluck : public grpc_core::ExecCtx {
+     grpc_completion_queue* cq = a->cq;
+     cq_pluck_data* cqd = static_cast<cq_pluck_data*> DATA_FROM_CQ(cq);
+
+-    CHECK_EQ(a->stolen_completion, nullptr);
++    ABSL_CHECK_EQ(a->stolen_completion, nullptr);
+     gpr_atm current_last_seen_things_queued_ever =
+         cqd->things_queued_ever.load(std::memory_order_relaxed);
+     if (current_last_seen_things_queued_ever !=
+@@ -1203,7 +1203,7 @@ static grpc_event cq_pluck(grpc_completion_queue* cq, void* tag,
+         << ", clock_type: " << (int)deadline.clock_type
+         << " }, reserved=" << reserved << ")";
+   }
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+
+   dump_pending_tags(cq);
+
+@@ -1254,7 +1254,7 @@ static grpc_event cq_pluck(grpc_completion_queue* cq, void* tag,
+       break;
+     }
+     if (!add_plucker(cq, tag, &worker)) {
+-      VLOG(2) << "Too many outstanding grpc_completion_queue_pluck calls: "
++      ABSL_VLOG(2) << "Too many outstanding grpc_completion_queue_pluck calls: "
+                  "maximum is "
+               << GRPC_MAX_COMPLETION_QUEUE_PLUCKERS;
+       gpr_mu_unlock(cq->mu);
+@@ -1279,7 +1279,7 @@ static grpc_event cq_pluck(grpc_completion_queue* cq, void* tag,
+     if (!err.ok()) {
+       del_plucker(cq, tag, &worker);
+       gpr_mu_unlock(cq->mu);
+-      LOG(ERROR) << "Completion queue pluck failed: "
++      ABSL_LOG(ERROR) << "Completion queue pluck failed: "
+                  << grpc_core::StatusToString(err);
+       ret.type = GRPC_QUEUE_TIMEOUT;
+       ret.success = 0;
+@@ -1293,7 +1293,7 @@ done:
+   GRPC_SURFACE_TRACE_RETURNED_EVENT(cq, &ret);
+   GRPC_CQ_INTERNAL_UNREF(cq, "pluck");
+
+-  CHECK_EQ(is_finished_arg.stolen_completion, nullptr);
++  ABSL_CHECK_EQ(is_finished_arg.stolen_completion, nullptr);
+
+   return ret;
+ }
+@@ -1306,8 +1306,8 @@ grpc_event grpc_completion_queue_pluck(grpc_completion_queue* cq, void* tag,
+ static void cq_finish_shutdown_pluck(grpc_completion_queue* cq) {
+   cq_pluck_data* cqd = static_cast<cq_pluck_data*> DATA_FROM_CQ(cq);
+
+-  CHECK(cqd->shutdown_called);
+-  CHECK(!cqd->shutdown.load(std::memory_order_relaxed));
++  ABSL_CHECK(cqd->shutdown_called);
++  ABSL_CHECK(!cqd->shutdown.load(std::memory_order_relaxed));
+   cqd->shutdown.store(true, std::memory_order_relaxed);
+
+   cq->poller_vtable->shutdown(POLLSET_FROM_CQ(cq), &cq->pollset_shutdown_done);
+@@ -1343,7 +1343,7 @@ static void cq_finish_shutdown_callback(grpc_completion_queue* cq) {
+   cq_callback_data* cqd = static_cast<cq_callback_data*> DATA_FROM_CQ(cq);
+   auto* callback = cqd->shutdown_callback;
+
+-  CHECK(cqd->shutdown_called);
++  ABSL_CHECK(cqd->shutdown_called);
+
+   cq->poller_vtable->shutdown(POLLSET_FROM_CQ(cq), &cq->pollset_shutdown_done);
+
+diff --git a/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc b/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc
+index c88360772aa76..0fe229ed6e3b3 100644
+--- a/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc
++++ b/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/grpc.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/lib/surface/completion_queue.h"
+
+@@ -47,7 +47,7 @@ static const grpc_completion_queue_factory g_default_cq_factory = {
+
+ const grpc_completion_queue_factory* grpc_completion_queue_factory_lookup(
+     const grpc_completion_queue_attributes* attributes) {
+-  CHECK(attributes->version >= 1 &&
++  ABSL_CHECK(attributes->version >= 1 &&
+         attributes->version <= GRPC_CQ_CURRENT_VERSION);
+
+   // The default factory can handle version 1 of the attributes structure. We
+@@ -61,7 +61,7 @@ const grpc_completion_queue_factory* grpc_completion_queue_factory_lookup(
+
+ grpc_completion_queue* grpc_completion_queue_create_for_next(void* reserved) {
+   grpc_core::ExecCtx exec_ctx;
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+   grpc_completion_queue_attributes attr = {1, GRPC_CQ_NEXT,
+                                            GRPC_CQ_DEFAULT_POLLING, nullptr};
+   return g_default_cq_factory.vtable->create(&g_default_cq_factory, &attr);
+@@ -69,7 +69,7 @@ grpc_completion_queue* grpc_completion_queue_create_for_next(void* reserved) {
+
+ grpc_completion_queue* grpc_completion_queue_create_for_pluck(void* reserved) {
+   grpc_core::ExecCtx exec_ctx;
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+   grpc_completion_queue_attributes attr = {1, GRPC_CQ_PLUCK,
+                                            GRPC_CQ_DEFAULT_POLLING, nullptr};
+   return g_default_cq_factory.vtable->create(&g_default_cq_factory, &attr);
+@@ -78,7 +78,7 @@ grpc_completion_queue* grpc_completion_queue_create_for_pluck(void* reserved) {
+ grpc_completion_queue* grpc_completion_queue_create_for_callback(
+     grpc_completion_queue_functor* shutdown_callback, void* reserved) {
+   grpc_core::ExecCtx exec_ctx;
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+   grpc_completion_queue_attributes attr = {
+       2, GRPC_CQ_CALLBACK, GRPC_CQ_DEFAULT_POLLING, shutdown_callback};
+   return g_default_cq_factory.vtable->create(&g_default_cq_factory, &attr);
+@@ -88,6 +88,6 @@ grpc_completion_queue* grpc_completion_queue_create(
+     const grpc_completion_queue_factory* factory,
+     const grpc_completion_queue_attributes* attr, void* reserved) {
+   grpc_core::ExecCtx exec_ctx;
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+   return factory->vtable->create(factory, attr);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc
+index 12106ad81f762..26893fc096c8f 100644
+--- a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc
++++ b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc
+@@ -37,8 +37,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -109,8 +109,8 @@ grpc_error_handle FilterStackCall::Create(grpc_call_create_args* args,
+   arena->SetContext<grpc_event_engine::experimental::EventEngine>(
+       args->channel->event_engine());
+   call = new (arena->Alloc(call_alloc_size)) FilterStackCall(arena, *args);
+-  DCHECK(FromC(call->c_ptr()) == call);
+-  DCHECK(FromCallStack(call->call_stack()) == call);
++  ABSL_DCHECK(FromC(call->c_ptr()) == call);
++  ABSL_DCHECK(FromCallStack(call->call_stack()) == call);
+   *out_call = call->c_ptr();
+   grpc_slice path = grpc_empty_slice();
+   ScopedContext ctx(call);
+@@ -181,7 +181,7 @@ grpc_error_handle FilterStackCall::Create(grpc_call_create_args* args,
+     call->CancelWithError(error);
+   }
+   if (args->cq != nullptr) {
+-    CHECK(args->pollset_set_alternative == nullptr)
++    ABSL_CHECK(args->pollset_set_alternative == nullptr)
+         << "Only one of 'cq' and 'pollset_set_alternative' should be "
+            "non-nullptr.";
+     GRPC_CQ_INTERNAL_REF(args->cq, "bind");
+@@ -220,7 +220,7 @@ grpc_error_handle FilterStackCall::Create(grpc_call_create_args* args,
+ }
+
+ void FilterStackCall::SetCompletionQueue(grpc_completion_queue* cq) {
+-  CHECK(cq);
++  ABSL_CHECK(cq);
+
+   if (grpc_polling_entity_pollset_set(&pollent_) != nullptr) {
+     Crash("A pollset_set is already registered for this call.");
+@@ -270,7 +270,7 @@ void FilterStackCall::ExternalUnref() {
+
+   MaybeUnpublishFromParent();
+
+-  CHECK(!destroy_called_);
++  ABSL_CHECK(!destroy_called_);
+   destroy_called_ = true;
+   bool cancel = gpr_atm_acq_load(&received_final_op_atm_) == 0;
+   if (cancel) {
+@@ -413,7 +413,7 @@ bool FilterStackCall::PrepareApplicationMetadata(size_t count,
+     }
+     batch->Append(StringViewFromSlice(md->key), Slice(CSliceRef(md->value)),
+                   [md](absl::string_view error, const Slice& value) {
+-                    VLOG(2)
++                    ABSL_VLOG(2)
+                         << "Append error: key=" << StringViewFromSlice(md->key)
+                         << " error=" << error
+                         << " value=" << value.as_string_view();
+@@ -472,7 +472,7 @@ void FilterStackCall::RecvTrailingFilter(grpc_metadata_batch* b,
+     } else if (!is_client()) {
+       SetFinalStatus(absl::OkStatus());
+     } else {
+-      VLOG(2) << "Received trailing metadata with no error and no status";
++      ABSL_VLOG(2) << "Received trailing metadata with no error and no status";
+       SetFinalStatus(grpc_error_set_int(GRPC_ERROR_CREATE("No status received"),
+                                         StatusIntProperty::kRpcStatus,
+                                         GRPC_STATUS_UNKNOWN));
+@@ -672,7 +672,7 @@ void FilterStackCall::BatchControl::ReceivingInitialMetadataReady(
+   while (true) {
+     gpr_atm rsr_bctlp = gpr_atm_acq_load(&call->recv_state_);
+     // Should only receive initial metadata once
+-    CHECK_NE(rsr_bctlp, 1);
++    ABSL_CHECK_NE(rsr_bctlp, 1);
+     if (rsr_bctlp == 0) {
+       // We haven't seen initial metadata and messages before, thus initial
+       // metadata is received first.
+@@ -746,7 +746,7 @@ grpc_call_error FilterStackCall::StartBatch(const grpc_op* ops, size_t nops,
+   if (!is_client() &&
+       (seen_ops & (1u << GRPC_OP_SEND_STATUS_FROM_SERVER)) != 0 &&
+       (seen_ops & (1u << GRPC_OP_RECV_MESSAGE)) != 0) {
+-    LOG(ERROR) << "******************* SEND_STATUS WITH RECV_MESSAGE "
++    ABSL_LOG(ERROR) << "******************* SEND_STATUS WITH RECV_MESSAGE "
+                   "*******************";
+     return GRPC_CALL_ERROR;
+   }
+@@ -1080,7 +1080,7 @@ grpc_call_error FilterStackCall::StartBatch(const grpc_op* ops, size_t nops,
+
+   InternalRef("completion");
+   if (!is_notify_tag_closure) {
+-    CHECK(grpc_cq_begin_op(cq_, notify_tag));
++    ABSL_CHECK(grpc_cq_begin_op(cq_, notify_tag));
+   }
+   bctl->set_pending_ops(pending_ops);
+
+diff --git a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h
+index d6cecb0050250..a5f4570a93055 100644
+--- a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h
++++ b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h
+@@ -38,7 +38,7 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+ #include "absl/strings/string_view.h"
+@@ -110,7 +110,7 @@ class FilterStackCall final : public Call {
+
+   bool is_trailers_only() const override {
+     bool result = is_trailers_only_;
+-    DCHECK(!result || recv_initial_metadata_.TransportSize() == 0);
++    ABSL_DCHECK(!result || recv_initial_metadata_.TransportSize() == 0);
+     return result;
+   }
+
+@@ -219,7 +219,7 @@ class FilterStackCall final : public Call {
+           << "BATCH:" << this << " COMPLETE:" << PendingOpString(mask)
+           << " REMAINING:" << PendingOpString(r & ~mask)
+           << " (tag:" << completion_data_.notify_tag.tag << ")";
+-      CHECK_NE((r & mask), 0);
++      ABSL_CHECK_NE((r & mask), 0);
+       return r == mask;
+     }
+
+diff --git a/third_party/grpc/source/src/core/lib/surface/init.cc b/third_party/grpc/source/src/core/lib/surface/init.cc
+index 9f3bd74786b69..2b85dd92c5417 100644
+--- a/third_party/grpc/source/src/core/lib/surface/init.cc
++++ b/third_party/grpc/source/src/core/lib/surface/init.cc
+@@ -28,7 +28,7 @@
+ #include <grpc/support/time.h>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/time/clock.h"
+ #include "absl/time/time.h"
+ #include "src/core/client_channel/backup_poller.h"
+@@ -128,7 +128,7 @@ void grpc_init(void) {
+       address_sorting_init();
+       auto status = AresInit();
+       if (!status.ok()) {
+-        VLOG(2) << "AresInit failed: " << status.message();
++        ABSL_VLOG(2) << "AresInit failed: " << status.message();
+       } else {
+         // TODO(yijiem): remove this once we remove the iomgr dns system.
+         grpc_resolver_dns_ares_reset_dns_resolver();
+@@ -169,7 +169,7 @@ void grpc_shutdown_from_cleanup_thread(void* /*ignored*/) {
+     return;
+   }
+   grpc_shutdown_internal_locked();
+-  VLOG(2) << "grpc_shutdown from cleanup thread done";
++  ABSL_VLOG(2) << "grpc_shutdown from cleanup thread done";
+ }
+
+ void grpc_shutdown(void) {
+@@ -187,14 +187,14 @@ void grpc_shutdown(void) {
+              0) &&
+         grpc_core::ExecCtx::Get() == nullptr) {
+       // just run clean-up when this is called on non-executor thread.
+-      VLOG(2) << "grpc_shutdown starts clean-up now";
++      ABSL_VLOG(2) << "grpc_shutdown starts clean-up now";
+       g_shutting_down = true;
+       grpc_shutdown_internal_locked();
+-      VLOG(2) << "grpc_shutdown done";
++      ABSL_VLOG(2) << "grpc_shutdown done";
+     } else {
+       // spawn a detached thread to do the actual clean up in case we are
+       // currently in an executor thread.
+-      VLOG(2) << "grpc_shutdown spawns clean-up thread";
++      ABSL_VLOG(2) << "grpc_shutdown spawns clean-up thread";
+       g_initializations++;
+       g_shutting_down = true;
+       grpc_core::Thread cleanup_thread(
+@@ -238,7 +238,7 @@ bool grpc_wait_for_shutdown_with_timeout(absl::Duration timeout) {
+   grpc_core::MutexLock lock(g_init_mu);
+   while (g_initializations != 0) {
+     if (g_shutting_down_cv->WaitWithDeadline(g_init_mu, deadline)) {
+-      LOG(ERROR) << "grpc_wait_for_shutdown_with_timeout() timed out.";
++      ABSL_LOG(ERROR) << "grpc_wait_for_shutdown_with_timeout() timed out.";
+       return false;
+     }
+   }
+diff --git a/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc b/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc
+index 2d915523b4a0b..d4fea97df2893 100644
+--- a/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc
++++ b/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc
+@@ -27,8 +27,8 @@
+ #include <optional>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/channelz/channelz.h"
+ #include "src/core/client_channel/client_channel_filter.h"
+@@ -86,7 +86,7 @@ absl::StatusOr<RefCountedPtr<Channel>> LegacyChannel::Create(
+   absl::StatusOr<RefCountedPtr<grpc_channel_stack>> r = builder.Build();
+   if (!r.ok()) {
+     auto status = r.status();
+-    LOG(ERROR) << "channel stack builder failed: " << status;
++    ABSL_LOG(ERROR) << "channel stack builder failed: " << status;
+     return status;
+   }
+   if (channel_stack_type == GRPC_SERVER_CHANNEL) {
+@@ -186,8 +186,8 @@ grpc_call* LegacyChannel::CreateCall(grpc_call* parent_call,
+                                      Slice path, std::optional<Slice> authority,
+                                      Timestamp deadline,
+                                      bool registered_method) {
+-  CHECK(is_client_);
+-  CHECK(!(cq != nullptr && pollset_set_alternative != nullptr));
++  ABSL_CHECK(is_client_);
++  ABSL_CHECK(!(cq != nullptr && pollset_set_alternative != nullptr));
+   grpc_call_create_args args;
+   args.channel = RefAsSubclass<LegacyChannel>();
+   args.server = nullptr;
+@@ -211,7 +211,7 @@ grpc_connectivity_state LegacyChannel::CheckConnectivityState(
+   ClientChannelFilter* client_channel = GetClientChannelFilter();
+   if (GPR_UNLIKELY(client_channel == nullptr)) {
+     if (IsLame()) return GRPC_CHANNEL_TRANSIENT_FAILURE;
+-    LOG(ERROR) << "grpc_channel_check_connectivity_state called on something "
++    ABSL_LOG(ERROR) << "grpc_channel_check_connectivity_state called on something "
+                   "that is not a client channel";
+     return GRPC_CHANNEL_SHUTDOWN;
+   }
+@@ -232,7 +232,7 @@ class LegacyChannel::StateWatcher final : public DualRefCounted<StateWatcher> {
+         cq_(cq),
+         tag_(tag),
+         state_(last_observed_state) {
+-    CHECK(grpc_cq_begin_op(cq, tag));
++    ABSL_CHECK(grpc_cq_begin_op(cq, tag));
+     GRPC_CLOSURE_INIT(&on_complete_, WatchComplete, this, nullptr);
+     ClientChannelFilter* client_channel = channel_->GetClientChannelFilter();
+     if (client_channel == nullptr) {
+@@ -362,14 +362,14 @@ void LegacyChannel::AddConnectivityWatcher(
+     grpc_connectivity_state initial_state,
+     OrphanablePtr<AsyncConnectivityStateWatcherInterface> watcher) {
+   auto* client_channel = GetClientChannelFilter();
+-  CHECK_NE(client_channel, nullptr);
++  ABSL_CHECK_NE(client_channel, nullptr);
+   client_channel->AddConnectivityWatcher(initial_state, std::move(watcher));
+ }
+
+ void LegacyChannel::RemoveConnectivityWatcher(
+     AsyncConnectivityStateWatcherInterface* watcher) {
+   auto* client_channel = GetClientChannelFilter();
+-  CHECK_NE(client_channel, nullptr);
++  ABSL_CHECK_NE(client_channel, nullptr);
+   client_channel->RemoveConnectivityWatcher(watcher);
+ }
+
+@@ -413,7 +413,7 @@ void LegacyChannel::Ping(grpc_completion_queue* cq, void* tag) {
+   grpc_transport_op* op = grpc_make_transport_op(nullptr);
+   op->send_ping.on_ack = &pr->closure;
+   op->bind_pollset = grpc_cq_pollset(cq);
+-  CHECK(grpc_cq_begin_op(cq, tag));
++  ABSL_CHECK(grpc_cq_begin_op(cq, tag));
+   grpc_channel_element* top_elem =
+       grpc_channel_stack_element(channel_stack_.get(), 0);
+   top_elem->filter->start_transport_op(top_elem, op);
+diff --git a/third_party/grpc/source/src/core/lib/surface/server_call.cc b/third_party/grpc/source/src/core/lib/surface/server_call.cc
+index 73212e84f8f58..b5e71eb9d8d4a 100644
+--- a/third_party/grpc/source/src/core/lib/surface/server_call.cc
++++ b/third_party/grpc/source/src/core/lib/surface/server_call.cc
+@@ -37,7 +37,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/promise/all_ok.h"
+ #include "src/core/lib/promise/map.h"
+@@ -169,12 +169,12 @@ void ServerCall::CommitBatch(const grpc_op* ops, size_t nops, void* notify_tag,
+       // after passing it in, which shouldn't be a supported API.
+       metadata->Set(GrpcMessageMetadata(), Slice(grpc_slice_copy(*details)));
+     }
+-    CHECK(metadata != nullptr);
++    ABSL_CHECK(metadata != nullptr);
+     bool wait_for_initial_metadata_scheduled =
+         sent_server_initial_metadata_batch_.load(std::memory_order_relaxed);
+     return [this, metadata = std::move(metadata),
+             wait_for_initial_metadata_scheduled]() mutable {
+-      CHECK(metadata != nullptr);
++      ABSL_CHECK(metadata != nullptr);
+       // If there was a send initial metadata batch sent prior to this one, then
+       // make sure it's been scheduled first - otherwise we may accidentally
+       // treat this as trailers only.
+@@ -184,7 +184,7 @@ void ServerCall::CommitBatch(const grpc_op* ops, size_t nops, void* notify_tag,
+               [this]() { return server_initial_metadata_scheduled_.Wait(); },
+               []() { return Empty{}; }),
+           [this, metadata = std::move(metadata)]() mutable -> Poll<Success> {
+-            CHECK(metadata != nullptr);
++            ABSL_CHECK(metadata != nullptr);
+             call_handler_.PushServerTrailingMetadata(std::move(metadata));
+             return Success{};
+           });
+diff --git a/third_party/grpc/source/src/core/lib/surface/server_call.h b/third_party/grpc/source/src/core/lib/surface/server_call.h
+index f4bbc1e6a791f..f148bb93485ec 100644
+--- a/third_party/grpc/source/src/core/lib/surface/server_call.h
++++ b/third_party/grpc/source/src/core/lib/surface/server_call.h
+@@ -39,7 +39,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+diff --git a/third_party/grpc/source/src/core/lib/surface/validate_metadata.h b/third_party/grpc/source/src/core/lib/surface/validate_metadata.h
+index f4630ea2d48db..a745a2d5ecf1a 100644
+--- a/third_party/grpc/source/src/core/lib/surface/validate_metadata.h
++++ b/third_party/grpc/source/src/core/lib/surface/validate_metadata.h
+@@ -25,7 +25,7 @@
+
+ #include <cstring>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/iomgr/error.h"
+
+@@ -56,7 +56,7 @@ inline int grpc_key_is_binary_header(const uint8_t* buf, size_t length) {
+   return 0 == memcmp(buf + length - 4, "-bin", 4);
+ }
+ inline int grpc_is_refcounted_slice_binary_header(const grpc_slice& slice) {
+-  DCHECK_NE(slice.refcount, nullptr);
++  ABSL_DCHECK_NE(slice.refcount, nullptr);
+   return grpc_key_is_binary_header(slice.data.refcounted.bytes,
+                                    slice.data.refcounted.length);
+ }
+diff --git a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc
+index 61b779d62c970..9a435971100d8 100644
+--- a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc
++++ b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc
+@@ -24,8 +24,8 @@
+
+ #include <algorithm>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+
+ namespace grpc_core {
+
+@@ -50,7 +50,7 @@ Timestamp BdpEstimator::CompletePing() {
+       << "bdp[" << name_ << "]:complete acc=" << accumulator_
+       << " est=" << estimate_ << " dt=" << dt << " bw=" << bw / 125000.0
+       << "Mbs bw_est=" << bw_est_ / 125000.0 << "Mbs";
+-  CHECK(ping_state_ == PingState::STARTED);
++  ABSL_CHECK(ping_state_ == PingState::STARTED);
+   if (accumulator_ > 2 * estimate_ / 3 && bw > bw_est_) {
+     estimate_ = std::max(accumulator_, estimate_ * 2);
+     bw_est_ = bw;
+diff --git a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h
+index c5879d939c3ef..c63c1c6fe075a 100644
+--- a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h
++++ b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h
+@@ -25,8 +25,8 @@
+
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/util/time.h"
+@@ -50,7 +50,7 @@ class BdpEstimator {
+     GRPC_TRACE_LOG(bdp_estimator, INFO)
+         << "bdp[" << name_ << "]:sched acc=" << accumulator_
+         << " est=" << estimate_;
+-    CHECK(ping_state_ == PingState::UNSCHEDULED);
++    ABSL_CHECK(ping_state_ == PingState::UNSCHEDULED);
+     ping_state_ = PingState::SCHEDULED;
+     accumulator_ = 0;
+   }
+@@ -62,7 +62,7 @@ class BdpEstimator {
+     GRPC_TRACE_LOG(bdp_estimator, INFO)
+         << "bdp[" << name_ << "]:start acc=" << accumulator_
+         << " est=" << estimate_;
+-    CHECK(ping_state_ == PingState::SCHEDULED);
++    ABSL_CHECK(ping_state_ == PingState::SCHEDULED);
+     ping_state_ = PingState::STARTED;
+     ping_start_time_ = gpr_now(GPR_CLOCK_MONOTONIC);
+   }
+diff --git a/third_party/grpc/source/src/core/lib/transport/call_destination.h b/third_party/grpc/source/src/core/lib/transport/call_destination.h
+index 5caf299d3872b..6a1736f281f12 100644
+--- a/third_party/grpc/source/src/core/lib/transport/call_destination.h
++++ b/third_party/grpc/source/src/core/lib/transport/call_destination.h
+@@ -38,7 +38,7 @@ class UnstartedCallDestination
+   // and started.
+   // Must be called from the party owned by the call, eg the following must
+   // hold:
+-  // CHECK(GetContext<Activity>() == unstarted_call_handler.party());
++  // ABSL_CHECK(GetContext<Activity>() == unstarted_call_handler.party());
+   virtual void StartCall(UnstartedCallHandler unstarted_call_handler) = 0;
+ };
+
+diff --git a/third_party/grpc/source/src/core/lib/transport/call_filters.cc b/third_party/grpc/source/src/core/lib/transport/call_filters.cc
+index b023144a60988..1eeceaea5d69e 100644
+--- a/third_party/grpc/source/src/core/lib/transport/call_filters.cc
++++ b/third_party/grpc/source/src/core/lib/transport/call_filters.cc
+@@ -16,8 +16,8 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/transport/metadata.h"
+ #include "src/core/util/crash.h"
+
+@@ -30,7 +30,7 @@ char CallFilters::g_empty_call_data_;
+ // CallFilters
+
+ void CallFilters::Start() {
+-  CHECK_EQ(call_data_, nullptr);
++  ABSL_CHECK_EQ(call_data_, nullptr);
+   size_t call_data_alignment = 1;
+   for (const auto& stack : stacks_) {
+     call_data_alignment =
+@@ -83,11 +83,11 @@ void CallFilters::CancelDueToFailedPipeOperation(SourceLocation but_where) {
+ }
+
+ void CallFilters::PushServerTrailingMetadata(ServerMetadataHandle md) {
+-  CHECK(md != nullptr);
++  ABSL_CHECK(md != nullptr);
+   GRPC_TRACE_LOG(call, INFO)
+       << GetContext<Activity>()->DebugTag() << " PushServerTrailingMetadata["
+       << this << "]: " << md->DebugString() << " into " << DebugString();
+-  CHECK(md != nullptr);
++  ABSL_CHECK(md != nullptr);
+   if (call_state_.PushServerTrailingMetadata(
+           md->get(GrpcCallWasCancelled()).value_or(false))) {
+     push_server_trailing_metadata_ = std::move(md);
+diff --git a/third_party/grpc/source/src/core/lib/transport/call_filters.h b/third_party/grpc/source/src/core/lib/transport/call_filters.h
+index 733382e86e15e..461ede0cd918e 100644
+--- a/third_party/grpc/source/src/core/lib/transport/call_filters.h
++++ b/third_party/grpc/source/src/core/lib/transport/call_filters.h
+@@ -23,7 +23,7 @@
+ #include <ostream>
+ #include <type_traits>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/promise/for_each.h"
+ #include "src/core/lib/promise/if.h"
+ #include "src/core/lib/promise/latch.h"
+@@ -146,9 +146,9 @@ class NextMessage {
+   NextMessage() = default;
+   explicit NextMessage(Failure) : message_(error()), call_state_(nullptr) {}
+   NextMessage(MessageHandle message, CallState* call_state) {
+-    DCHECK_NE(call_state, nullptr);
+-    DCHECK_NE(message.get(), nullptr);
+-    DCHECK(message.get_deleter().has_freelist());
++    ABSL_DCHECK_NE(call_state, nullptr);
++    ABSL_DCHECK_NE(message.get(), nullptr);
++    ABSL_DCHECK(message.get_deleter().has_freelist());
+     message_ = message.release();
+     call_state_ = call_state;
+   }
+@@ -171,31 +171,31 @@ class NextMessage {
+   }
+
+   bool ok() const {
+-    DCHECK_NE(message_, taken());
++    ABSL_DCHECK_NE(message_, taken());
+     return message_ != error();
+   }
+   bool has_value() const {
+-    DCHECK_NE(message_, taken());
+-    DCHECK(ok());
++    ABSL_DCHECK_NE(message_, taken());
++    ABSL_DCHECK(ok());
+     return message_ != end_of_stream();
+   }
+   StatusFlag status() const { return StatusFlag(ok()); }
+   Message& value() {
+-    DCHECK_NE(message_, taken());
+-    DCHECK(ok());
+-    DCHECK(has_value());
++    ABSL_DCHECK_NE(message_, taken());
++    ABSL_DCHECK(ok());
++    ABSL_DCHECK(has_value());
+     return *message_;
+   }
+   MessageHandle TakeValue() {
+-    DCHECK_NE(message_, taken());
+-    DCHECK(ok());
+-    DCHECK(has_value());
++    ABSL_DCHECK_NE(message_, taken());
++    ABSL_DCHECK(ok());
++    ABSL_DCHECK(has_value());
+     return MessageHandle(std::exchange(message_, taken()),
+                          Arena::PooledDeleter());
+   }
+   bool progressed() const { return call_state_ == nullptr; }
+   void Progress() {
+-    DCHECK(!progressed());
++    ABSL_DCHECK(!progressed());
+     (call_state_->*on_progress)();
+     call_state_ = nullptr;
+   }
+@@ -264,7 +264,7 @@ template <typename T>
+ struct ResultOr {
+   ResultOr(T ok, ServerMetadataHandle error)
+       : ok(std::move(ok)), error(std::move(error)) {
+-    CHECK((this->ok == nullptr) ^ (this->error == nullptr));
++    ABSL_CHECK((this->ok == nullptr) ^ (this->error == nullptr));
+   }
+   T ok;
+   ServerMetadataHandle error;
+@@ -1177,13 +1177,13 @@ struct StackData {
+
+   template <typename FilterType>
+   void AddFinalizer(FilterType*, size_t, const NoInterceptor* p) {
+-    DCHECK(p == &FilterType::Call::OnFinalize);
++    ABSL_DCHECK(p == &FilterType::Call::OnFinalize);
+   }
+
+   template <typename FilterType>
+   void AddFinalizer(FilterType* channel_data, size_t call_offset,
+                     void (FilterType::Call::*p)(const grpc_call_final_info*)) {
+-    DCHECK(p == &FilterType::Call::OnFinalize);
++    ABSL_DCHECK(p == &FilterType::Call::OnFinalize);
+     finalizers.push_back(Finalizer{
+         channel_data,
+         call_offset,
+@@ -1198,7 +1198,7 @@ struct StackData {
+   void AddFinalizer(FilterType* channel_data, size_t call_offset,
+                     void (FilterType::Call::*p)(const grpc_call_final_info*,
+                                                 FilterType*)) {
+-    DCHECK(p == &FilterType::Call::OnFinalize);
++    ABSL_DCHECK(p == &FilterType::Call::OnFinalize);
+     finalizers.push_back(Finalizer{
+         channel_data,
+         call_offset,
+@@ -1228,11 +1228,11 @@ class OperationExecutor {
+   OperationExecutor(OperationExecutor&& other) noexcept
+       : ops_(other.ops_), end_ops_(other.end_ops_) {
+     // Movable iff we're not running.
+-    DCHECK_EQ(other.promise_data_, nullptr);
++    ABSL_DCHECK_EQ(other.promise_data_, nullptr);
+   }
+   OperationExecutor& operator=(OperationExecutor&& other) noexcept {
+-    DCHECK_EQ(other.promise_data_, nullptr);
+-    DCHECK_EQ(promise_data_, nullptr);
++    ABSL_DCHECK_EQ(other.promise_data_, nullptr);
++    ABSL_DCHECK_EQ(promise_data_, nullptr);
+     ops_ = other.ops_;
+     end_ops_ = other.end_ops_;
+     return *this;
+@@ -1285,7 +1285,7 @@ OperationExecutor<T>::Start(const Layout<T>* layout, T input, void* call_data) {
+   if (layout->promise_size == 0) {
+     // No call state ==> instantaneously ready
+     auto r = InitStep(std::move(input), call_data);
+-    CHECK(r.ready());
++    ABSL_CHECK(r.ready());
+     return r;
+   }
+   promise_data_ =
+@@ -1296,7 +1296,7 @@ OperationExecutor<T>::Start(const Layout<T>* layout, T input, void* call_data) {
+ template <typename T>
+ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline Poll<ResultOr<T>>
+ OperationExecutor<T>::InitStep(T input, void* call_data) {
+-  CHECK(input != nullptr);
++  ABSL_CHECK(input != nullptr);
+   while (true) {
+     if (ops_ == end_ops_) {
+       return ResultOr<T>{std::move(input), nullptr};
+@@ -1317,7 +1317,7 @@ OperationExecutor<T>::InitStep(T input, void* call_data) {
+ template <typename T>
+ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline Poll<ResultOr<T>>
+ OperationExecutor<T>::Step(void* call_data) {
+-  DCHECK_NE(promise_data_, nullptr);
++  ABSL_DCHECK_NE(promise_data_, nullptr);
+   auto p = ContinueStep(call_data);
+   if (p.ready()) {
+     gpr_free_aligned(promise_data_);
+@@ -1412,7 +1412,7 @@ struct FailureStatusCastImpl<filters_detail::NextMessage<on_progress>,
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static filters_detail::NextMessage<
+       on_progress>
+   Cast(StatusFlag flag) {
+-    DCHECK_EQ(flag, Failure{});
++    ABSL_DCHECK_EQ(flag, Failure{});
+     return filters_detail::NextMessage<on_progress>(Failure{});
+   }
+ };
+@@ -1432,12 +1432,12 @@ struct TrySeqTraitsWithSfinae<filters_detail::NextMessage<on_progress>> {
+     return value.ok();
+   }
+   static const char* ErrorString(const WrappedType& status) {
+-    DCHECK(!status.ok());
++    ABSL_DCHECK(!status.ok());
+     return "failed";
+   }
+   template <typename R>
+   static R ReturnValue(WrappedType&& status) {
+-    DCHECK(!status.ok());
++    ABSL_DCHECK(!status.ok());
+     return WrappedType(Failure{});
+   }
+   template <typename F, typename Elem>
+@@ -1581,13 +1581,13 @@ class CallFilters {
+         : stack_current_(stack_begin),
+           stack_end_(stack_end),
+           filters_(filters) {
+-      DCHECK_NE((filters_->*input_location).get(), nullptr);
++      ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
+     }
+
+     Poll<ValueOrFailure<Output>> operator()() {
+       if ((filters_->*input_location) != nullptr) {
+         if (stack_current_ == stack_end_) {
+-          DCHECK_NE((filters_->*input_location).get(), nullptr);
++          ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
+           (filters_->call_state_.*on_done)();
+           return Output(std::move(filters_->*input_location));
+         }
+@@ -1638,13 +1638,13 @@ class CallFilters {
+         : stack_current_(stack_begin),
+           stack_end_(stack_end),
+           filters_(filters) {
+-      DCHECK_NE((filters_->*input_location).get(), nullptr);
++      ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
+     }
+
+     Poll<NextMsg> operator()() {
+       if ((filters_->*input_location) != nullptr) {
+         if (stack_current_ == stack_end_) {
+-          DCHECK_NE((filters_->*input_location).get(), nullptr);
++          ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
+           return NextMsg(std::move(filters_->*input_location),
+                          &filters_->call_state_);
+         }
+@@ -1732,8 +1732,8 @@ class CallFilters {
+   // Returns a promise that resolves to a StatusFlag indicating success
+   GRPC_MUST_USE_RESULT auto PushClientToServerMessage(MessageHandle message) {
+     call_state_.BeginPushClientToServerMessage();
+-    DCHECK_NE(message.get(), nullptr);
+-    DCHECK_EQ(push_client_to_server_message_.get(), nullptr);
++    ABSL_DCHECK_NE(message.get(), nullptr);
++    ABSL_DCHECK_EQ(push_client_to_server_message_.get(), nullptr);
+     push_client_to_server_message_ = std::move(message);
+     return [this]() { return call_state_.PollPushClientToServerMessage(); };
+   }
+diff --git a/third_party/grpc/source/src/core/lib/transport/call_spine.cc b/third_party/grpc/source/src/core/lib/transport/call_spine.cc
+index 17d4b02c47b91..b726822e25a9c 100644
+--- a/third_party/grpc/source/src/core/lib/transport/call_spine.cc
++++ b/third_party/grpc/source/src/core/lib/transport/call_spine.cc
+@@ -79,8 +79,8 @@ void ForwardCall(CallHandler call_handler, CallInitiator call_initiator,
+
+ CallInitiatorAndHandler MakeCallPair(
+     ClientMetadataHandle client_initial_metadata, RefCountedPtr<Arena> arena) {
+-  DCHECK_NE(arena.get(), nullptr);
+-  DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
++  ABSL_DCHECK_NE(arena.get(), nullptr);
++  ABSL_DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
+             nullptr);
+   auto spine =
+       CallSpine::Create(std::move(client_initial_metadata), std::move(arena));
+diff --git a/third_party/grpc/source/src/core/lib/transport/call_spine.h b/third_party/grpc/source/src/core/lib/transport/call_spine.h
+index 084550a24fcf0..7eb8d050eb679 100644
+--- a/third_party/grpc/source/src/core/lib/transport/call_spine.h
++++ b/third_party/grpc/source/src/core/lib/transport/call_spine.h
+@@ -17,7 +17,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/promise/detail/status.h"
+ #include "src/core/lib/promise/if.h"
+ #include "src/core/lib/promise/latch.h"
+@@ -131,7 +131,7 @@ class CallSpine final : public Party {
+   // The resulting (returned) promise will resolve to Empty.
+   template <typename Promise>
+   auto CancelIfFails(Promise promise) {
+-    DCHECK(GetContext<Activity>() == this);
++    ABSL_DCHECK(GetContext<Activity>() == this);
+     using P = promise_detail::PromiseLike<Promise>;
+     using ResultType = typename P::Result;
+     return Map(std::move(promise), [this](ResultType r) {
+@@ -352,14 +352,14 @@ class CallInitiator {
+   }
+
+   void Cancel(absl::Status error) {
+-    CHECK(!error.ok());
++    ABSL_CHECK(!error.ok());
+     auto status = ServerMetadataFromStatus(error);
+     status->Set(GrpcCallWasCancelled(), true);
+     spine_->PushServerTrailingMetadata(std::move(status));
+   }
+
+   void SpawnCancel(absl::Status error) {
+-    CHECK(!error.ok());
++    ABSL_CHECK(!error.ok());
+     auto status = ServerMetadataFromStatus(error);
+     status->Set(GrpcCallWasCancelled(), true);
+     spine_->SpawnPushServerTrailingMetadata(std::move(status));
+@@ -491,7 +491,7 @@ class CallHandler {
+   }
+
+   void AddChildCall(const CallInitiator& initiator) {
+-    CHECK(initiator.spine_ != nullptr);
++    ABSL_CHECK(initiator.spine_ != nullptr);
+     spine_->AddChildCall(initiator.spine_);
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/transport/call_state.h b/third_party/grpc/source/src/core/lib/transport/call_state.h
+index ba4f5f94d59e3..7f7e30d68ad87 100644
+--- a/third_party/grpc/source/src/core/lib/transport/call_state.h
++++ b/third_party/grpc/source/src/core/lib/transport/call_state.h
+@@ -354,7 +354,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline void CallState::Start() {
+     case ServerToClientPullState::kIdle:
+     case ServerToClientPullState::kReading:
+     case ServerToClientPullState::kProcessingServerToClientMessage:
+-      LOG(FATAL) << "Start called twice; "
++      ABSL_LOG(FATAL) << "Start called twice; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_);
+     case ServerToClientPullState::kTerminated:
+       break;
+@@ -374,11 +374,11 @@ CallState::BeginPushClientToServerMessage() {
+       break;
+     case ClientToServerPushState::kPushedMessage:
+     case ClientToServerPushState::kPushedMessageAndHalfClosed:
+-      LOG(FATAL) << "PushClientToServerMessage called twice concurrently;"
++      ABSL_LOG(FATAL) << "PushClientToServerMessage called twice concurrently;"
+                  << GRPC_DUMP_ARGS(client_to_server_push_state_);
+       break;
+     case ClientToServerPushState::kPushedHalfClose:
+-      LOG(FATAL) << "PushClientToServerMessage called after half-close; "
++      ABSL_LOG(FATAL) << "PushClientToServerMessage called after half-close; "
+                  << GRPC_DUMP_ARGS(client_to_server_push_state_);
+       break;
+     case ClientToServerPushState::kFinished:
+@@ -420,7 +420,7 @@ CallState::ClientToServerHalfClose() {
+       break;
+     case ClientToServerPushState::kPushedHalfClose:
+     case ClientToServerPushState::kPushedMessageAndHalfClosed:
+-      LOG(FATAL) << "ClientToServerHalfClose called twice;"
++      ABSL_LOG(FATAL) << "ClientToServerHalfClose called twice;"
+                  << GRPC_DUMP_ARGS(client_to_server_push_state_);
+       break;
+     case ClientToServerPushState::kFinished:
+@@ -442,7 +442,7 @@ CallState::BeginPullClientInitialMetadata() {
+     case ClientToServerPullState::kIdle:
+     case ClientToServerPullState::kReading:
+     case ClientToServerPullState::kProcessingClientToServerMessage:
+-      LOG(FATAL) << "BeginPullClientInitialMetadata called twice; "
++      ABSL_LOG(FATAL) << "BeginPullClientInitialMetadata called twice; "
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
+       break;
+     case ClientToServerPullState::kTerminated:
+@@ -457,7 +457,7 @@ CallState::FinishPullClientInitialMetadata() {
+       << GRPC_DUMP_ARGS(this, client_to_server_pull_state_);
+   switch (client_to_server_pull_state_) {
+     case ClientToServerPullState::kBegin:
+-      LOG(FATAL) << "FinishPullClientInitialMetadata called before Begin; "
++      ABSL_LOG(FATAL) << "FinishPullClientInitialMetadata called before Begin; "
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
+       break;
+     case ClientToServerPullState::kProcessingClientInitialMetadata:
+@@ -467,7 +467,7 @@ CallState::FinishPullClientInitialMetadata() {
+     case ClientToServerPullState::kIdle:
+     case ClientToServerPullState::kReading:
+     case ClientToServerPullState::kProcessingClientToServerMessage:
+-      LOG(FATAL) << "Out of order FinishPullClientInitialMetadata"
++      ABSL_LOG(FATAL) << "Out of order FinishPullClientInitialMetadata"
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
+       break;
+     case ClientToServerPullState::kTerminated:
+@@ -492,14 +492,14 @@ CallState::PollPullClientToServerMessageAvailable() {
+     case ClientToServerPullState::kReading:
+       break;
+     case ClientToServerPullState::kProcessingClientToServerMessage:
+-      LOG(FATAL) << "PollPullClientToServerMessageAvailable called while "
++      ABSL_LOG(FATAL) << "PollPullClientToServerMessageAvailable called while "
+                     "processing a message; "
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
+       break;
+     case ClientToServerPullState::kTerminated:
+       return Failure{};
+   }
+-  DCHECK_EQ(client_to_server_pull_state_, ClientToServerPullState::kReading);
++  ABSL_DCHECK_EQ(client_to_server_pull_state_, ClientToServerPullState::kReading);
+   switch (client_to_server_push_state_) {
+     case ClientToServerPushState::kIdle:
+       return client_to_server_push_waiter_.pending();
+@@ -545,17 +545,17 @@ CallState::FinishPullClientToServerMessage() {
+   switch (client_to_server_pull_state_) {
+     case ClientToServerPullState::kBegin:
+     case ClientToServerPullState::kProcessingClientInitialMetadata:
+-      LOG(FATAL) << "FinishPullClientToServerMessage called before Begin; "
++      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called before Begin; "
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
+                                    client_to_server_push_state_);
+       break;
+     case ClientToServerPullState::kIdle:
+-      LOG(FATAL) << "FinishPullClientToServerMessage called twice; "
++      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called twice; "
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
+                                    client_to_server_push_state_);
+       break;
+     case ClientToServerPullState::kReading:
+-      LOG(FATAL) << "FinishPullClientToServerMessage called before "
++      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called before "
+                     "PollPullClientToServerMessageAvailable; "
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
+                                    client_to_server_push_state_);
+@@ -574,7 +574,7 @@ CallState::FinishPullClientToServerMessage() {
+       break;
+     case ClientToServerPushState::kIdle:
+     case ClientToServerPushState::kPushedHalfClose:
+-      LOG(FATAL) << "FinishPullClientToServerMessage called without a message; "
++      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called without a message; "
+                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
+                                    client_to_server_push_state_);
+       break;
+@@ -611,7 +611,7 @@ CallState::PushServerInitialMetadata() {
+     case ServerToClientPushState::kTrailersOnly:
+     case ServerToClientPushState::kIdle:
+     case ServerToClientPushState::kPushedMessage:
+-      LOG(FATAL) << "PushServerInitialMetadata called twice; "
++      ABSL_LOG(FATAL) << "PushServerInitialMetadata called twice; "
+                  << GRPC_DUMP_ARGS(server_to_client_push_state_);
+       break;
+     case ServerToClientPushState::kFinished:
+@@ -638,7 +638,7 @@ CallState::BeginPushServerToClientMessage() {
+     case ServerToClientPushState::kPushedServerInitialMetadataAndPushedMessage:
+     case ServerToClientPushState::kPushedMessageWithoutInitialMetadata:
+     case ServerToClientPushState::kPushedMessage:
+-      LOG(FATAL) << "BeginPushServerToClientMessage called twice concurrently; "
++      ABSL_LOG(FATAL) << "BeginPushServerToClientMessage called twice concurrently; "
+                  << GRPC_DUMP_ARGS(server_to_client_push_state_);
+       break;
+     case ServerToClientPushState::kTrailersOnly:
+@@ -661,7 +661,7 @@ CallState::PollPushServerToClientMessage() {
+   switch (server_to_client_push_state_) {
+     case ServerToClientPushState::kStart:
+     case ServerToClientPushState::kPushedServerInitialMetadata:
+-      LOG(FATAL) << "PollPushServerToClientMessage called before "
++      ABSL_LOG(FATAL) << "PollPushServerToClientMessage called before "
+                  << "PushServerInitialMetadata; "
+                  << GRPC_DUMP_ARGS(server_to_client_push_state_);
+     case ServerToClientPushState::kTrailersOnly:
+@@ -763,13 +763,13 @@ CallState::PollPullServerInitialMetadataAvailable() {
+     case ServerToClientPullState::kIdle:
+     case ServerToClientPullState::kReading:
+     case ServerToClientPullState::kProcessingServerToClientMessage:
+-      LOG(FATAL) << "PollPullServerInitialMetadataAvailable called twice; "
++      ABSL_LOG(FATAL) << "PollPullServerInitialMetadataAvailable called twice; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+     case ServerToClientPullState::kTerminated:
+       return false;
+   }
+-  DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kStarted ||
++  ABSL_DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kStarted ||
+          server_to_client_pull_state_ ==
+              ServerToClientPullState::kStartedReading)
+       << server_to_client_pull_state_;
+@@ -787,7 +787,7 @@ CallState::PollPullServerInitialMetadataAvailable() {
+       return true;
+     case ServerToClientPushState::kIdle:
+     case ServerToClientPushState::kPushedMessage:
+-      LOG(FATAL)
++      ABSL_LOG(FATAL)
+           << "PollPullServerInitialMetadataAvailable after metadata processed; "
+           << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                             server_to_client_push_state_);
+@@ -809,10 +809,10 @@ CallState::FinishPullServerInitialMetadata() {
+   switch (server_to_client_pull_state_) {
+     case ServerToClientPullState::kUnstarted:
+     case ServerToClientPullState::kUnstartedReading:
+-      LOG(FATAL) << "FinishPullServerInitialMetadata called before Start";
++      ABSL_LOG(FATAL) << "FinishPullServerInitialMetadata called before Start";
+     case ServerToClientPullState::kStarted:
+     case ServerToClientPullState::kStartedReading:
+-      CHECK_EQ(server_to_client_push_state_,
++      ABSL_CHECK_EQ(server_to_client_push_state_,
+                ServerToClientPushState::kTrailersOnly);
+       return;
+     case ServerToClientPullState::kProcessingServerInitialMetadata:
+@@ -826,19 +826,19 @@ CallState::FinishPullServerInitialMetadata() {
+     case ServerToClientPullState::kIdle:
+     case ServerToClientPullState::kReading:
+     case ServerToClientPullState::kProcessingServerToClientMessage:
+-      LOG(FATAL) << "Out of order FinishPullServerInitialMetadata; "
++      ABSL_LOG(FATAL) << "Out of order FinishPullServerInitialMetadata; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+     case ServerToClientPullState::kTerminated:
+       return;
+   }
+-  DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kIdle ||
++  ABSL_DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kIdle ||
+          server_to_client_pull_state_ == ServerToClientPullState::kReading)
+       << server_to_client_pull_state_;
+   switch (server_to_client_push_state_) {
+     case ServerToClientPushState::kStart:
+     case ServerToClientPushState::kPushedMessageWithoutInitialMetadata:
+-      LOG(FATAL) << "FinishPullServerInitialMetadata called before initial "
++      ABSL_LOG(FATAL) << "FinishPullServerInitialMetadata called before initial "
+                     "metadata consumed; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+@@ -854,7 +854,7 @@ CallState::FinishPullServerInitialMetadata() {
+     case ServerToClientPushState::kPushedMessage:
+     case ServerToClientPushState::kTrailersOnly:
+     case ServerToClientPushState::kFinished:
+-      LOG(FATAL) << "FinishPullServerInitialMetadata called twice; "
++      ABSL_LOG(FATAL) << "FinishPullServerInitialMetadata called twice; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+   }
+@@ -894,14 +894,14 @@ CallState::PollPullServerToClientMessageAvailable() {
+     case ServerToClientPullState::kReading:
+       break;
+     case ServerToClientPullState::kProcessingServerToClientMessage:
+-      LOG(FATAL) << "PollPullServerToClientMessageAvailable called while "
++      ABSL_LOG(FATAL) << "PollPullServerToClientMessageAvailable called while "
+                     "processing a message; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+     case ServerToClientPullState::kTerminated:
+       return Failure{};
+   }
+-  DCHECK_EQ(server_to_client_pull_state_, ServerToClientPullState::kReading);
++  ABSL_DCHECK_EQ(server_to_client_pull_state_, ServerToClientPullState::kReading);
+   switch (server_to_client_push_state_) {
+     case ServerToClientPushState::kStart:
+     case ServerToClientPushState::kPushedMessageWithoutInitialMetadata:
+@@ -916,7 +916,7 @@ CallState::PollPullServerToClientMessageAvailable() {
+       server_trailing_metadata_waiter_.pending();
+       return server_to_client_push_waiter_.pending();
+     case ServerToClientPushState::kTrailersOnly:
+-      DCHECK_NE(server_trailing_metadata_state_,
++      ABSL_DCHECK_NE(server_trailing_metadata_state_,
+                 ServerTrailingMetadataState::kNotPushed);
+       return false;
+     case ServerToClientPushState::kPushedMessage:
+@@ -968,16 +968,16 @@ CallState::FinishPullServerToClientMessage() {
+     case ServerToClientPullState::kStartedReading:
+     case ServerToClientPullState::kProcessingServerInitialMetadata:
+     case ServerToClientPullState::kProcessingServerInitialMetadataReading:
+-      LOG(FATAL) << "FinishPullServerToClientMessage called before metadata "
++      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called before metadata "
+                     "available; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+     case ServerToClientPullState::kIdle:
+-      LOG(FATAL) << "FinishPullServerToClientMessage called twice; "
++      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called twice; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+     case ServerToClientPullState::kReading:
+-      LOG(FATAL) << "FinishPullServerToClientMessage called before "
++      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called before "
+                  << "PollPullServerToClientMessageAvailable; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+@@ -993,12 +993,12 @@ CallState::FinishPullServerToClientMessage() {
+     case ServerToClientPushState::kPushedServerInitialMetadataAndPushedMessage:
+     case ServerToClientPushState::kPushedServerInitialMetadata:
+     case ServerToClientPushState::kStart:
+-      LOG(FATAL) << "FinishPullServerToClientMessage called before initial "
++      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called before initial "
+                     "metadata consumed; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+     case ServerToClientPushState::kTrailersOnly:
+-      LOG(FATAL) << "FinishPullServerToClientMessage called after "
++      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called after "
+                     "PushServerTrailingMetadata; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+@@ -1007,7 +1007,7 @@ CallState::FinishPullServerToClientMessage() {
+       server_to_client_push_waiter_.Wake();
+       break;
+     case ServerToClientPushState::kIdle:
+-      LOG(FATAL) << "FinishPullServerToClientMessage called without a message; "
++      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called without a message; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_to_client_push_state_);
+     case ServerToClientPushState::kFinished:
+@@ -1075,7 +1075,7 @@ CallState::PollServerTrailingMetadataAvailable() {
+     case ServerTrailingMetadataState::kNotPushed:
+     case ServerTrailingMetadataState::kPulled:
+     case ServerTrailingMetadataState::kPulledCancel:
+-      LOG(FATAL) << "PollServerTrailingMetadataAvailable completed twice; "
++      ABSL_LOG(FATAL) << "PollServerTrailingMetadataAvailable completed twice; "
+                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
+                                    server_trailing_metadata_state_);
+   }
+diff --git a/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc b/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc
+index 2a9e86c9e3db9..9425e9b39d1f6 100644
+--- a/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc
++++ b/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc
+@@ -20,7 +20,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/closure.h"
+ #include "src/core/lib/iomgr/error.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+diff --git a/third_party/grpc/source/src/core/lib/transport/interception_chain.h b/third_party/grpc/source/src/core/lib/transport/interception_chain.h
+index fc6ea72e28236..431790987c86c 100644
+--- a/third_party/grpc/source/src/core/lib/transport/interception_chain.h
++++ b/third_party/grpc/source/src/core/lib/transport/interception_chain.h
+@@ -211,7 +211,7 @@ class InterceptionChainBuilder final {
+   }
+
+   void Fail(absl::Status status) {
+-    CHECK(!status.ok()) << status;
++    ABSL_CHECK(!status.ok()) << status;
+     if (status_.ok()) status_ = std::move(status);
+   }
+
+diff --git a/third_party/grpc/source/src/core/lib/transport/metadata_batch.h b/third_party/grpc/source/src/core/lib/transport/metadata_batch.h
+index 2bd5f3d62d851..fd64c1e80c4e4 100644
+--- a/third_party/grpc/source/src/core/lib/transport/metadata_batch.h
++++ b/third_party/grpc/source/src/core/lib/transport/metadata_batch.h
+@@ -32,7 +32,7 @@
+
+ #include "absl/container/inlined_vector.h"
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/strings/numbers.h"
+ #include "absl/strings/string_view.h"
+@@ -107,7 +107,7 @@ struct TeMetadata {
+                                   MetadataParseErrorFn on_error);
+   static ValueType MementoToValue(MementoType te) { return te; }
+   static StaticSlice Encode(ValueType x) {
+-    CHECK(x == kTrailers);
++    ABSL_CHECK(x == kTrailers);
+     return StaticSlice::FromStaticString("trailers");
+   }
+   static const char* DisplayValue(ValueType te);
+@@ -213,7 +213,7 @@ struct CompressionAlgorithmBasedMetadata {
+                                   MetadataParseErrorFn on_error);
+   static ValueType MementoToValue(MementoType x) { return x; }
+   static Slice Encode(ValueType x) {
+-    CHECK(x != GRPC_COMPRESS_ALGORITHMS_COUNT);
++    ABSL_CHECK(x != GRPC_COMPRESS_ALGORITHMS_COUNT);
+     return Slice::FromStaticString(CompressionAlgorithmAsString(x));
+   }
+   static const char* DisplayValue(ValueType x) {
+diff --git a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc
+index 656297624de8f..6cc5e34086f26 100644
+--- a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc
++++ b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc
+@@ -25,7 +25,7 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "src/core/lib/slice/slice_buffer.h"
+ #include "src/core/util/sync.h"
+@@ -37,7 +37,7 @@ PromiseEndpoint::PromiseEndpoint(
+         endpoint,
+     SliceBuffer already_received)
+     : endpoint_(std::move(endpoint)) {
+-  CHECK_NE(endpoint_, nullptr);
++  ABSL_CHECK_NE(endpoint_, nullptr);
+   read_state_->endpoint = endpoint_;
+   // TODO(ladynana): Replace this with `SliceBufferCast<>` when it is
+   // available.
+@@ -71,7 +71,7 @@ void PromiseEndpoint::ReadState::Complete(absl::Status status,
+     // Appends `pending_buffer` to `buffer`.
+     pending_buffer.MoveFirstNBytesIntoSliceBuffer(pending_buffer.Length(),
+                                                   buffer);
+-    DCHECK(pending_buffer.Count() == 0u);
++    ABSL_DCHECK(pending_buffer.Count() == 0u);
+     if (buffer.Length() < num_bytes_requested) {
+       // A further read is needed.
+       // Set read args with number of bytes needed as hint.
+diff --git a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h
+index db96dfdac87c6..ab195347c70f8 100644
+--- a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h
++++ b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h
+@@ -31,7 +31,7 @@
+ #include <utility>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/lib/event_engine/extensions/chaotic_good_extension.h"
+@@ -74,7 +74,7 @@ class PromiseEndpoint {
+     // Start write and assert previous write finishes.
+     auto prev = write_state_->state.exchange(WriteState::kWriting,
+                                              std::memory_order_relaxed);
+-    CHECK(prev == WriteState::kIdle);
++    ABSL_CHECK(prev == WriteState::kIdle);
+     bool completed;
+     if (data.Length() == 0) {
+       completed = true;
+@@ -101,7 +101,7 @@ class PromiseEndpoint {
+           return [write_state = write_state_]() {
+             auto prev = write_state->state.exchange(WriteState::kIdle,
+                                                     std::memory_order_relaxed);
+-            CHECK(prev == WriteState::kWriting);
++            ABSL_CHECK(prev == WriteState::kWriting);
+             return absl::OkStatus();
+           };
+         },
+@@ -120,7 +120,7 @@ class PromiseEndpoint {
+                 }
+                 // State was not Written; since we're polling it must be
+                 // Writing. Assert that and return Pending.
+-                CHECK(expected == WriteState::kWriting);
++                ABSL_CHECK(expected == WriteState::kWriting);
+                 return Pending();
+               };
+             })));
+@@ -135,9 +135,9 @@ class PromiseEndpoint {
+   auto Read(size_t num_bytes) {
+     GRPC_LATENT_SEE_PARENT_SCOPE("GRPC:Read");
+     // Assert previous read finishes.
+-    CHECK(!read_state_->complete.load(std::memory_order_relaxed));
++    ABSL_CHECK(!read_state_->complete.load(std::memory_order_relaxed));
+     // Should not have pending reads.
+-    CHECK(read_state_->pending_buffer.Count() == 0u);
++    ABSL_CHECK(read_state_->pending_buffer.Count() == 0u);
+     bool complete = true;
+     while (read_state_->buffer.Length() < num_bytes) {
+       // Set read args with hinted bytes.
+@@ -157,7 +157,7 @@ class PromiseEndpoint {
+         read_state_->waker = Waker();
+         read_state_->pending_buffer.MoveFirstNBytesIntoSliceBuffer(
+             read_state_->pending_buffer.Length(), read_state_->buffer);
+-        DCHECK(read_state_->pending_buffer.Count() == 0u);
++        ABSL_DCHECK(read_state_->pending_buffer.Count() == 0u);
+       } else {
+         complete = false;
+         break;
+@@ -236,7 +236,7 @@ class PromiseEndpoint {
+       // Copy everything from read_state_->buffer into a single slice and
+       // replace the contents of read_state_->buffer with that slice.
+       grpc_slice slice = grpc_slice_malloc_large(read_state_->buffer.Length());
+-      CHECK(reinterpret_cast<uintptr_t>(GRPC_SLICE_START_PTR(slice)) % 64 == 0);
++      ABSL_CHECK(reinterpret_cast<uintptr_t>(GRPC_SLICE_START_PTR(slice)) % 64 == 0);
+       size_t ofs = 0;
+       for (size_t i = 0; i < read_state_->buffer.Count(); i++) {
+         memcpy(
+@@ -251,7 +251,7 @@ class PromiseEndpoint {
+       read_state_->buffer.Clear();
+       read_state_->buffer.AppendIndexed(
+           grpc_event_engine::experimental::Slice(slice));
+-      DCHECK(read_state_->buffer.Length() == ofs);
++      ABSL_DCHECK(read_state_->buffer.Length() == ofs);
+     }
+   }
+
+@@ -312,7 +312,7 @@ class PromiseEndpoint {
+       auto prev = state.exchange(kWritten, std::memory_order_release);
+       // Previous state should be Writing. If we got anything else we've entered
+       // the callback path twice.
+-      CHECK(prev == kWriting);
++      ABSL_CHECK(prev == kWriting);
+       w.Wakeup();
+     }
+   };
+diff --git a/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc b/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc
+index ec561ce0ab378..8598e81e7458a 100644
+--- a/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc
++++ b/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc
+@@ -24,7 +24,7 @@
+ #include <limits>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -182,7 +182,7 @@ Timeout Timeout::FromMillis(int64_t millis) {
+ }
+
+ Timeout Timeout::FromSeconds(int64_t seconds) {
+-  DCHECK_NE(seconds, 0);
++  ABSL_DCHECK_NE(seconds, 0);
+   if (seconds < 1000) {
+     if (seconds % kSecondsPerMinute != 0) {
+       return Timeout(seconds, Unit::kSeconds);
+@@ -202,7 +202,7 @@ Timeout Timeout::FromSeconds(int64_t seconds) {
+ }
+
+ Timeout Timeout::FromMinutes(int64_t minutes) {
+-  DCHECK_NE(minutes, 0);
++  ABSL_DCHECK_NE(minutes, 0);
+   if (minutes < 1000) {
+     if (minutes % kMinutesPerHour != 0) {
+       return Timeout(minutes, Unit::kMinutes);
+@@ -222,7 +222,7 @@ Timeout Timeout::FromMinutes(int64_t minutes) {
+ }
+
+ Timeout Timeout::FromHours(int64_t hours) {
+-  DCHECK_NE(hours, 0);
++  ABSL_DCHECK_NE(hours, 0);
+   if (hours < kMaxHours) {
+     return Timeout(hours, Unit::kHours);
+   }
+diff --git a/third_party/grpc/source/src/core/lib/transport/transport.h b/third_party/grpc/source/src/core/lib/transport/transport.h
+index 7df662ecfa806..79715d166eb24 100644
+--- a/third_party/grpc/source/src/core/lib/transport/transport.h
++++ b/third_party/grpc/source/src/core/lib/transport/transport.h
+@@ -34,7 +34,7 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -554,7 +554,7 @@ class Transport : public InternallyRefCounted<Transport> {
+   }
+
+   void DisconnectWithError(grpc_error_handle error) {
+-    CHECK(!error.ok()) << error;
++    ABSL_CHECK(!error.ok()) << error;
+     grpc_transport_op* op = grpc_make_transport_op(nullptr);
+     op->disconnect_with_error = error;
+     PerformOp(op);
+diff --git a/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc b/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc
+index 3048508314931..9e693b60dcbc9 100644
+--- a/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc
++++ b/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc
+@@ -22,8 +22,8 @@
+ #include <memory>
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -67,7 +67,7 @@ class ChildPolicyHandler::Helper final
+     // into place.
+     if (CalledByPendingChild()) {
+       if (GRPC_TRACE_FLAG_ENABLED_OBJ(*(parent()->tracer_))) {
+-        LOG(INFO) << "[child_policy_handler " << parent() << "] helper " << this
++        ABSL_LOG(INFO) << "[child_policy_handler " << parent() << "] helper " << this
+                   << ": pending child policy " << child_
+                   << " reports state=" << ConnectivityStateName(state) << " ("
+                   << status << ")";
+@@ -96,7 +96,7 @@ class ChildPolicyHandler::Helper final
+             : parent()->child_policy_.get();
+     if (child_ != latest_child_policy) return;
+     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*(parent()->tracer_))) {
+-      LOG(INFO) << "[child_policy_handler " << parent()
++      ABSL_LOG(INFO) << "[child_policy_handler " << parent()
+                 << "] requesting re-resolution";
+     }
+     parent()->channel_control_helper()->RequestReresolution();
+@@ -113,12 +113,12 @@ class ChildPolicyHandler::Helper final
+
+  private:
+   bool CalledByPendingChild() const {
+-    CHECK_NE(child_, nullptr);
++    ABSL_CHECK_NE(child_, nullptr);
+     return child_ == parent()->pending_child_policy_.get();
+   }
+
+   bool CalledByCurrentChild() const {
+-    CHECK_NE(child_, nullptr);
++    ABSL_CHECK_NE(child_, nullptr);
+     return child_ == parent()->child_policy_.get();
+   };
+
+@@ -131,12 +131,12 @@ class ChildPolicyHandler::Helper final
+
+ void ChildPolicyHandler::ShutdownLocked() {
+   if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
+-    LOG(INFO) << "[child_policy_handler " << this << "] shutting down";
++    ABSL_LOG(INFO) << "[child_policy_handler " << this << "] shutting down";
+   }
+   shutting_down_ = true;
+   if (child_policy_ != nullptr) {
+     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
+-      LOG(INFO) << "[child_policy_handler " << this
++      ABSL_LOG(INFO) << "[child_policy_handler " << this
+                 << "] shutting down lb_policy " << child_policy_.get();
+     }
+     grpc_pollset_set_del_pollset_set(child_policy_->interested_parties(),
+@@ -145,7 +145,7 @@ void ChildPolicyHandler::ShutdownLocked() {
+   }
+   if (pending_child_policy_ != nullptr) {
+     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
+-      LOG(INFO) << "[child_policy_handler " << this
++      ABSL_LOG(INFO) << "[child_policy_handler " << this
+                 << "] shutting down pending lb_policy "
+                 << pending_child_policy_.get();
+     }
+@@ -222,7 +222,7 @@ absl::Status ChildPolicyHandler::UpdateLocked(UpdateArgs args) {
+     // switch to the new policy, even if the new policy stays in
+     // CONNECTING for a very long period of time.
+     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
+-      LOG(INFO) << "[child_policy_handler " << this << "] creating new "
++      ABSL_LOG(INFO) << "[child_policy_handler " << this << "] creating new "
+                 << (child_policy_ == nullptr ? "" : "pending ")
+                 << "child policy " << args.config->name();
+     }
+@@ -238,10 +238,10 @@ absl::Status ChildPolicyHandler::UpdateLocked(UpdateArgs args) {
+                            ? pending_child_policy_.get()
+                            : child_policy_.get();
+   }
+-  CHECK_NE(policy_to_update, nullptr);
++  ABSL_CHECK_NE(policy_to_update, nullptr);
+   // Update the policy.
+   if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
+-    LOG(INFO) << "[child_policy_handler " << this << "] updating "
++    ABSL_LOG(INFO) << "[child_policy_handler " << this << "] updating "
+               << (policy_to_update == pending_child_policy_.get() ? "pending "
+                                                                   : "")
+               << "child policy " << policy_to_update;
+@@ -279,12 +279,12 @@ OrphanablePtr<LoadBalancingPolicy> ChildPolicyHandler::CreateChildPolicy(
+   OrphanablePtr<LoadBalancingPolicy> lb_policy =
+       CreateLoadBalancingPolicy(child_policy_name, std::move(lb_policy_args));
+   if (GPR_UNLIKELY(lb_policy == nullptr)) {
+-    LOG(ERROR) << "could not create LB policy \"" << child_policy_name << "\"";
++    ABSL_LOG(ERROR) << "could not create LB policy \"" << child_policy_name << "\"";
+     return nullptr;
+   }
+   helper->set_child(lb_policy.get());
+   if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
+-    LOG(INFO) << "[child_policy_handler " << this
++    ABSL_LOG(INFO) << "[child_policy_handler " << this
+               << "] created new LB policy \"" << child_policy_name << "\" ("
+               << lb_policy.get() << ")";
+   }
+diff --git a/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc b/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc
+index 8dd402f9cfc5e..44289f4a93e65 100644
+--- a/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc
++++ b/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc
+@@ -26,8 +26,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/config/core_configuration.h"
+@@ -101,7 +101,7 @@ absl::Status EndpointList::Endpoint::Init(
+       CoreConfiguration::Get().lb_policy_registry().CreateLoadBalancingPolicy(
+           "pick_first", std::move(lb_policy_args));
+   if (GPR_UNLIKELY(endpoint_list_->tracer_ != nullptr)) {
+-    LOG(INFO) << "[" << endpoint_list_->tracer_ << " "
++    ABSL_LOG(INFO) << "[" << endpoint_list_->tracer_ << " "
+               << endpoint_list_->policy_.get() << "] endpoint " << this
+               << ": created child policy " << child_policy_.get();
+   }
+@@ -116,7 +116,7 @@ absl::Status EndpointList::Endpoint::Init(
+       CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(
+           Json::FromArray(
+               {Json::FromObject({{"pick_first", Json::FromObject({})}})}));
+-  CHECK(config.ok());
++  ABSL_CHECK(config.ok());
+   // Update child policy.
+   LoadBalancingPolicy::UpdateArgs update_args;
+   update_args.addresses = std::make_shared<SingleEndpointIterator>(addresses);
+diff --git a/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc b/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc
+index 0025bd07ce927..63a240565cda3 100644
+--- a/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc
++++ b/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc
+@@ -82,9 +82,9 @@
+
+ #include "absl/container/inlined_vector.h"
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/log/globals.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -605,14 +605,14 @@ bool IsServerValid(const GrpcLbServer& server, size_t idx, bool log) {
+   if (server.drop) return false;
+   if (GPR_UNLIKELY(server.port >> 16 != 0)) {
+     if (log) {
+-      LOG(ERROR) << "Invalid port '" << server.port << "' at index " << idx
++      ABSL_LOG(ERROR) << "Invalid port '" << server.port << "' at index " << idx
+                  << " of serverlist. Ignoring.";
+     }
+     return false;
+   }
+   if (GPR_UNLIKELY(server.ip_size != 4 && server.ip_size != 16)) {
+     if (log) {
+-      LOG(ERROR) << "Expected IP to be 4 or 16 bytes, got " << server.ip_size
++      ABSL_LOG(ERROR) << "Expected IP to be 4 or 16 bytes, got " << server.ip_size
+                  << " at index " << idx << " of serverlist. Ignoring";
+     }
+     return false;
+@@ -871,8 +871,8 @@ GrpcLb::BalancerCallState::BalancerCallState(
+     : InternallyRefCounted<BalancerCallState>(
+           GRPC_TRACE_FLAG_ENABLED(glb) ? "BalancerCallState" : nullptr),
+       grpclb_policy_(std::move(parent_grpclb_policy)) {
+-  CHECK(grpclb_policy_ != nullptr);
+-  CHECK(!grpclb_policy()->shutting_down_);
++  ABSL_CHECK(grpclb_policy_ != nullptr);
++  ABSL_CHECK(!grpclb_policy()->shutting_down_);
+   // Init the LB call. Note that the LB call will progress every time there's
+   // activity in grpclb_policy_->interested_parties(), which is comprised of
+   // the polling entities from client_channel.
+@@ -909,7 +909,7 @@ GrpcLb::BalancerCallState::BalancerCallState(
+ }
+
+ GrpcLb::BalancerCallState::~BalancerCallState() {
+-  CHECK_NE(lb_call_, nullptr);
++  ABSL_CHECK_NE(lb_call_, nullptr);
+   grpc_call_unref(lb_call_);
+   grpc_metadata_array_destroy(&lb_initial_metadata_recv_);
+   grpc_metadata_array_destroy(&lb_trailing_metadata_recv_);
+@@ -919,7 +919,7 @@ GrpcLb::BalancerCallState::~BalancerCallState() {
+ }
+
+ void GrpcLb::BalancerCallState::Orphan() {
+-  CHECK_NE(lb_call_, nullptr);
++  ABSL_CHECK_NE(lb_call_, nullptr);
+   // If we are here because grpclb_policy wants to cancel the call,
+   // lb_on_balancer_status_received_ will complete the cancellation and clean
+   // up. Otherwise, we are here because grpclb_policy has to orphan a failed
+@@ -936,7 +936,7 @@ void GrpcLb::BalancerCallState::Orphan() {
+ }
+
+ void GrpcLb::BalancerCallState::StartQuery() {
+-  CHECK_NE(lb_call_, nullptr);
++  ABSL_CHECK_NE(lb_call_, nullptr);
+   GRPC_TRACE_LOG(glb, INFO)
+       << "[grpclb " << grpclb_policy_.get() << "] lb_calld=" << this
+       << ": Starting LB call " << lb_call_;
+@@ -953,7 +953,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
+   op->reserved = nullptr;
+   op++;
+   // Op: send request message.
+-  CHECK_NE(send_message_payload_, nullptr);
++  ABSL_CHECK_NE(send_message_payload_, nullptr);
+   op->op = GRPC_OP_SEND_MESSAGE;
+   op->data.send_message.send_message = send_message_payload_;
+   op->flags = 0;
+@@ -967,7 +967,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
+   call_error = grpc_call_start_batch_and_execute(lb_call_, ops,
+                                                  static_cast<size_t>(op - ops),
+                                                  &lb_on_initial_request_sent_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+   // Op: recv initial metadata.
+   op = ops;
+   op->op = GRPC_OP_RECV_INITIAL_METADATA;
+@@ -990,7 +990,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
+   call_error = grpc_call_start_batch_and_execute(
+       lb_call_, ops, static_cast<size_t>(op - ops),
+       &lb_on_balancer_message_received_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+   // Op: recv server status.
+   op = ops;
+   op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;
+@@ -1007,7 +1007,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
+   call_error = grpc_call_start_batch_and_execute(
+       lb_call_, ops, static_cast<size_t>(op - ops),
+       &lb_on_balancer_status_received_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+ }
+
+ void GrpcLb::BalancerCallState::ScheduleNextClientLoadReportLocked() {
+@@ -1039,7 +1039,7 @@ void GrpcLb::BalancerCallState::MaybeSendClientLoadReportLocked() {
+
+ void GrpcLb::BalancerCallState::SendClientLoadReportLocked() {
+   // Construct message payload.
+-  CHECK_EQ(send_message_payload_, nullptr);
++  ABSL_CHECK_EQ(send_message_payload_, nullptr);
+   // Get snapshot of stats.
+   int64_t num_calls_started;
+   int64_t num_calls_finished;
+@@ -1080,9 +1080,9 @@ void GrpcLb::BalancerCallState::SendClientLoadReportLocked() {
+   grpc_call_error call_error = grpc_call_start_batch_and_execute(
+       lb_call_, &op, 1, &client_load_report_done_closure_);
+   if (GPR_UNLIKELY(call_error != GRPC_CALL_OK)) {
+-    LOG(ERROR) << "[grpclb " << grpclb_policy_.get() << "] lb_calld=" << this
++    ABSL_LOG(ERROR) << "[grpclb " << grpclb_policy_.get() << "] lb_calld=" << this
+                << " call_error=" << call_error << " sending client load report";
+-    CHECK_EQ(call_error, GRPC_CALL_OK);
++    ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+   }
+ }
+
+@@ -1150,7 +1150,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
+     if (absl::MinLogLevel() <= absl::LogSeverityAtLeast::kError) {
+       char* response_slice_str =
+           grpc_dump_slice(response_slice, GPR_DUMP_ASCII | GPR_DUMP_HEX);
+-      LOG(ERROR) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
++      ABSL_LOG(ERROR) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
+                  << ": Invalid LB response received: '" << response_slice_str
+                  << "'. Ignoring.";
+       gpr_free(response_slice_str);
+@@ -1176,7 +1176,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
+         break;
+       }
+       case response.SERVERLIST: {
+-        CHECK_NE(lb_call_, nullptr);
++        ABSL_CHECK_NE(lb_call_, nullptr);
+         auto serverlist_wrapper =
+             MakeRefCounted<Serverlist>(std::move(response.serverlist));
+         GRPC_TRACE_LOG(glb, INFO)
+@@ -1222,7 +1222,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
+           // it in favor of the xds policy.  We will implement this the
+           // right way in the xds policy instead.
+           if (grpclb_policy()->fallback_mode_) {
+-            LOG(INFO) << "[grpclb " << grpclb_policy()
++            ABSL_LOG(INFO) << "[grpclb " << grpclb_policy()
+                       << "] Received response from balancer; exiting fallback "
+                          "mode";
+             grpclb_policy()->fallback_mode_ = false;
+@@ -1243,7 +1243,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
+       }
+       case response.FALLBACK: {
+         if (!grpclb_policy()->fallback_mode_) {
+-          LOG(INFO) << "[grpclb " << grpclb_policy()
++          ABSL_LOG(INFO) << "[grpclb " << grpclb_policy()
+                     << "] Entering fallback mode as requested by balancer";
+           if (grpclb_policy()->fallback_at_startup_checks_pending_) {
+             grpclb_policy()->fallback_at_startup_checks_pending_ = false;
+@@ -1274,7 +1274,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
+     // Reuse the "OnBalancerMessageReceivedLocked" ref taken in StartQuery().
+     const grpc_call_error call_error = grpc_call_start_batch_and_execute(
+         lb_call_, &op, 1, &lb_on_balancer_message_received_);
+-    CHECK_EQ(call_error, GRPC_CALL_OK);
++    ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+   } else {
+     Unref(DEBUG_LOCATION, "on_message_received+grpclb_shutdown");
+   }
+@@ -1289,10 +1289,10 @@ void GrpcLb::BalancerCallState::OnBalancerStatusReceived(
+
+ void GrpcLb::BalancerCallState::OnBalancerStatusReceivedLocked(
+     grpc_error_handle error) {
+-  CHECK_NE(lb_call_, nullptr);
++  ABSL_CHECK_NE(lb_call_, nullptr);
+   if (GRPC_TRACE_FLAG_ENABLED(glb)) {
+     char* status_details = grpc_slice_to_c_string(lb_call_status_details_);
+-    LOG(INFO) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
++    ABSL_LOG(INFO) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
+               << ": Status from LB server received. Status = "
+               << lb_call_status_ << ", details = '" << status_details
+               << "', (lb_call: " << lb_call_ << "), error '"
+@@ -1308,8 +1308,8 @@ void GrpcLb::BalancerCallState::OnBalancerStatusReceivedLocked(
+     // case.
+     grpclb_policy()->lb_calld_.reset();
+     if (grpclb_policy()->fallback_at_startup_checks_pending_) {
+-      CHECK(!seen_serverlist_);
+-      LOG(INFO) << "[grpclb " << grpclb_policy()
++      ABSL_CHECK(!seen_serverlist_);
++      ABSL_LOG(INFO) << "[grpclb " << grpclb_policy()
+                 << "] Balancer call finished without receiving serverlist; "
+                    "entering fallback mode";
+       grpclb_policy()->fallback_at_startup_checks_pending_ = false;
+@@ -1322,7 +1322,7 @@ void GrpcLb::BalancerCallState::OnBalancerStatusReceivedLocked(
+       // This handles the fallback-after-startup case.
+       grpclb_policy()->MaybeEnterFallbackModeAfterStartup();
+     }
+-    CHECK(!grpclb_policy()->shutting_down_);
++    ABSL_CHECK(!grpclb_policy()->shutting_down_);
+     grpclb_policy()->channel_control_helper()->RequestReresolution();
+     if (seen_initial_response_) {
+       // If we lose connection to the LB server, reset the backoff and restart
+@@ -1476,7 +1476,7 @@ void GrpcLb::ShutdownLocked() {
+   if (lb_channel_ != nullptr) {
+     if (parent_channelz_node_ != nullptr) {
+       channelz::ChannelNode* child_channelz_node = lb_channel_->channelz_node();
+-      CHECK_NE(child_channelz_node, nullptr);
++      ABSL_CHECK_NE(child_channelz_node, nullptr);
+       parent_channelz_node_->RemoveChildChannel(child_channelz_node->uuid());
+     }
+     lb_channel_.reset();
+@@ -1526,7 +1526,7 @@ absl::Status GrpcLb::UpdateLocked(UpdateArgs args) {
+   GRPC_TRACE_LOG(glb, INFO) << "[grpclb " << this << "] received update";
+   const bool is_initial_update = lb_channel_ == nullptr;
+   config_ = args.config.TakeAsSubclass<GrpcLbConfig>();
+-  CHECK(config_ != nullptr);
++  ABSL_CHECK(config_ != nullptr);
+   args_ = std::move(args.args);
+   // Update fallback address list.
+   if (!args.addresses.ok()) {
+@@ -1580,7 +1580,7 @@ absl::Status GrpcLb::UpdateBalancerChannelLocked() {
+   EndpointAddressesList balancer_addresses = ExtractBalancerAddresses(args_);
+   if (GRPC_TRACE_FLAG_ENABLED(glb)) {
+     for (const auto& endpoint : balancer_addresses) {
+-      LOG(INFO) << "[grpclb " << this
++      ABSL_LOG(INFO) << "[grpclb " << this
+                 << "] balancer address: " << endpoint.ToString();
+     }
+   }
+@@ -1600,7 +1600,7 @@ absl::Status GrpcLb::UpdateBalancerChannelLocked() {
+     lb_channel_.reset(Channel::FromC(
+         grpc_channel_create(uri_str.c_str(), channel_credentials.get(),
+                             lb_channel_args.ToC().get())));
+-    CHECK(lb_channel_ != nullptr);
++    ABSL_CHECK(lb_channel_ != nullptr);
+     // Set up channelz linkage.
+     channelz::ChannelNode* child_channelz_node = lb_channel_->channelz_node();
+     auto parent_channelz_node = args_.GetObjectRef<channelz::ChannelNode>();
+@@ -1630,10 +1630,10 @@ void GrpcLb::CancelBalancerChannelConnectivityWatchLocked() {
+ //
+
+ void GrpcLb::StartBalancerCallLocked() {
+-  CHECK(lb_channel_ != nullptr);
++  ABSL_CHECK(lb_channel_ != nullptr);
+   if (shutting_down_) return;
+   // Init the LB call data.
+-  CHECK(lb_calld_ == nullptr);
++  ABSL_CHECK(lb_calld_ == nullptr);
+   lb_calld_ = MakeOrphanable<BalancerCallState>(Ref());
+   GRPC_TRACE_LOG(glb, INFO)
+       << "[grpclb " << this
+@@ -1645,12 +1645,12 @@ void GrpcLb::StartBalancerCallLocked() {
+ void GrpcLb::StartBalancerCallRetryTimerLocked() {
+   Duration delay = lb_call_backoff_.NextAttemptDelay();
+   if (GRPC_TRACE_FLAG_ENABLED(glb)) {
+-    LOG(INFO) << "[grpclb " << this << "] Connection to LB server lost...";
++    ABSL_LOG(INFO) << "[grpclb " << this << "] Connection to LB server lost...";
+     if (delay > Duration::Zero()) {
+-      LOG(INFO) << "[grpclb " << this << "] ... retry_timer_active in "
++      ABSL_LOG(INFO) << "[grpclb " << this << "] ... retry_timer_active in "
+                 << delay.millis() << "ms.";
+     } else {
+-      LOG(INFO) << "[grpclb " << this
++      ABSL_LOG(INFO) << "[grpclb " << this
+                 << "] ... retry_timer_active immediately.";
+     }
+   }
+@@ -1690,7 +1690,7 @@ void GrpcLb::MaybeEnterFallbackModeAfterStartup() {
+   if (!fallback_mode_ && !fallback_at_startup_checks_pending_ &&
+       (lb_calld_ == nullptr || !lb_calld_->seen_serverlist()) &&
+       !child_policy_ready_) {
+-    LOG(INFO) << "[grpclb " << this
++    ABSL_LOG(INFO) << "[grpclb " << this
+               << "] lost contact with balancer and backends from most recent "
+                  "serverlist; entering fallback mode";
+     fallback_mode_ = true;
+@@ -1702,7 +1702,7 @@ void GrpcLb::OnFallbackTimerLocked() {
+   // If we receive a serverlist after the timer fires but before this callback
+   // actually runs, don't fall back.
+   if (fallback_at_startup_checks_pending_ && !shutting_down_) {
+-    LOG(INFO) << "[grpclb " << this
++    ABSL_LOG(INFO) << "[grpclb " << this
+               << "] No response from balancer after fallback timeout; "
+                  "entering fallback mode";
+     fallback_at_startup_checks_pending_ = false;
+@@ -1784,7 +1784,7 @@ void GrpcLb::CreateOrUpdateChildPolicyLocked() {
+   }
+   update_args.args =
+       CreateChildPolicyArgsLocked(is_backend_from_grpclb_load_balancer);
+-  CHECK(update_args.args != ChannelArgs());
++  ABSL_CHECK(update_args.args != ChannelArgs());
+   update_args.config = config_->child_policy();
+   // Create child policy if needed.
+   if (child_policy_ == nullptr) {
+@@ -1813,7 +1813,7 @@ void GrpcLb::CacheDeletedSubchannelLocked(
+ }
+
+ void GrpcLb::StartSubchannelCacheTimerLocked() {
+-  CHECK(!cached_subchannels_.empty());
++  ABSL_CHECK(!cached_subchannels_.empty());
+   subchannel_cache_timer_handle_ =
+       channel_control_helper()->GetEventEngine()->RunAfter(
+           cached_subchannels_.begin()->first - Timestamp::Now(),
+diff --git a/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc b/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc
+index 6fd1eafd9ff64..93d219873763b 100644
+--- a/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc
++++ b/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc
+@@ -24,7 +24,7 @@
+
+ #include <algorithm>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "google/protobuf/duration.upb.h"
+ #include "google/protobuf/timestamp.upb.h"
+ #include "src/core/util/memory.h"
+@@ -143,7 +143,7 @@ bool ParseServerList(const grpc_lb_v1_LoadBalanceResponse& response,
+       } else if (token.size <= GRPC_GRPCLB_SERVER_LOAD_BALANCE_TOKEN_MAX_SIZE) {
+         memcpy(cur.load_balance_token, token.data, token.size);
+       } else {
+-        LOG(ERROR) << "grpc_lb_v1_LoadBalanceResponse has too long token. len="
++        ABSL_LOG(ERROR) << "grpc_lb_v1_LoadBalanceResponse has too long token. len="
+                    << token.size;
+       }
+       cur.drop = grpc_lb_v1_Server_drop(servers[i]);
+diff --git a/third_party/grpc/source/src/core/load_balancing/health_check_client.cc b/third_party/grpc/source/src/core/load_balancing/health_check_client.cc
+index e1bb7b2fbe348..c78873de3edb2 100644
+--- a/third_party/grpc/source/src/core/load_balancing/health_check_client.cc
++++ b/third_party/grpc/source/src/core/load_balancing/health_check_client.cc
+@@ -30,8 +30,8 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -104,7 +104,7 @@ void HealthProducer::HealthChecker::OnConnectivityStateChangeLocked(
+       state_ = GRPC_CHANNEL_CONNECTING;
+       status_ = absl::OkStatus();
+     } else {
+-      CHECK(state_ == GRPC_CHANNEL_CONNECTING);
++      ABSL_CHECK(state_ == GRPC_CHANNEL_CONNECTING);
+     }
+     // Start the health watch stream.
+     StartHealthStreamLocked();
+@@ -218,7 +218,7 @@ class HealthProducer::HealthChecker::HealthStreamEventHandler final
+       static const char kErrorMessage[] =
+           "health checking Watch method returned UNIMPLEMENTED; "
+           "disabling health checks but assuming server is healthy";
+-      LOG(ERROR) << kErrorMessage;
++      ABSL_LOG(ERROR) << kErrorMessage;
+       auto* channelz_node =
+           health_checker_->producer_->subchannel_->channelz_node();
+       if (channelz_node != nullptr) {
+diff --git a/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc b/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc
+index 20ef3a110117e..a9efe1a4bdf7d 100644
+--- a/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc
++++ b/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc
+@@ -25,8 +25,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -42,8 +42,8 @@ namespace grpc_core {
+
+ void LoadBalancingPolicyRegistry::Builder::RegisterLoadBalancingPolicyFactory(
+     std::unique_ptr<LoadBalancingPolicyFactory> factory) {
+-  VLOG(2) << "registering LB policy factory for \"" << factory->name() << "\"";
+-  CHECK(factories_.find(factory->name()) == factories_.end());
++  ABSL_VLOG(2) << "registering LB policy factory for \"" << factory->name() << "\"";
++  ABSL_CHECK(factories_.find(factory->name()) == factories_.end());
+   factories_.emplace(factory->name(), std::move(factory));
+ }
+
+diff --git a/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc b/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc
+index 4b29bd2584768..32e648e4e3df4 100644
+--- a/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc
++++ b/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc
+@@ -29,8 +29,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "google/protobuf/duration.upb.h"
+@@ -145,7 +145,7 @@ class OrcaProducer::OrcaStreamEventHandler final
+     if (status == GRPC_STATUS_UNIMPLEMENTED) {
+       static const char kErrorMessage[] =
+           "Orca stream returned UNIMPLEMENTED; disabling";
+-      LOG(ERROR) << kErrorMessage;
++      ABSL_LOG(ERROR) << kErrorMessage;
+       auto* channelz_node = producer_->subchannel_->channelz_node();
+       if (channelz_node != nullptr) {
+         channelz_node->AddTraceEvent(
+@@ -221,7 +221,7 @@ void OrcaProducer::Orphaned() {
+     MutexLock lock(&mu_);
+     stream_client_.reset();
+   }
+-  CHECK(subchannel_ != nullptr);  // Should not be called before Start().
++  ABSL_CHECK(subchannel_ != nullptr);  // Should not be called before Start().
+   subchannel_->CancelConnectivityStateWatch(connectivity_watcher_);
+   subchannel_->RemoveDataProducer(this);
+ }
+diff --git a/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc b/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc
+index dd157b373e388..b57ce8cf9611d 100644
+--- a/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc
++++ b/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc
+@@ -35,8 +35,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -328,7 +328,7 @@ class OutlierDetectionLb final : public LoadBalancingPolicy {
+           --multiplier_;
+         }
+       } else {
+-        CHECK(ejection_time_.has_value());
++        ABSL_CHECK(ejection_time_.has_value());
+         auto change_time = ejection_time_.value() +
+                            Duration::Milliseconds(std::min(
+                                base_ejection_time_in_millis * multiplier_,
+@@ -665,7 +665,7 @@ absl::Status OutlierDetectionLb::UpdateLocked(UpdateArgs args) {
+             if (GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
+               std::string address_str = grpc_sockaddr_to_string(&address, false)
+                                             .value_or("<unknown>");
+-              LOG(INFO) << "[outlier_detection_lb " << this
++              ABSL_LOG(INFO) << "[outlier_detection_lb " << this
+                         << "] adding address entry for " << address_str;
+             }
+             it2 = subchannel_state_map_
+@@ -693,7 +693,7 @@ absl::Status OutlierDetectionLb::UpdateLocked(UpdateArgs args) {
+         if (GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
+           std::string address_str =
+               grpc_sockaddr_to_string(&address, false).value_or("<unknown>");
+-          LOG(INFO) << "[outlier_detection_lb " << this
++          ABSL_LOG(INFO) << "[outlier_detection_lb " << this
+                     << "] removing subchannel map entry " << address_str;
+         }
+         // Don't hold a ref to the corresponding EndpointState object,
+@@ -788,7 +788,7 @@ RefCountedPtr<SubchannelInterface> OutlierDetectionLb::Helper::CreateSubchannel(
+   if (GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
+     std::string address_str =
+         grpc_sockaddr_to_string(&address, false).value_or("<unknown>");
+-    LOG(INFO) << "[outlier_detection_lb " << parent()
++    ABSL_LOG(INFO) << "[outlier_detection_lb " << parent()
+               << "] creating subchannel for " << address_str
+               << ", subchannel state " << subchannel_state.get();
+   }
+@@ -1001,7 +1001,7 @@ void OutlierDetectionLb::EjectionTimer::OnTimerLocked() {
+     const bool unejected = endpoint_state->MaybeUneject(
+         config.base_ejection_time.millis(), config.max_ejection_time.millis());
+     if (unejected && GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
+-      LOG(INFO) << "[outlier_detection_lb " << parent_.get()
++      ABSL_LOG(INFO) << "[outlier_detection_lb " << parent_.get()
+                 << "] unejected endpoint " << address_set.ToString() << " ("
+                 << endpoint_state.get() << ")";
+     }
+diff --git a/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc b/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc
+index 8780c4911aed8..7de500482a583 100644
+--- a/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc
++++ b/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc
+@@ -32,8 +32,8 @@
+ #include <vector>
+
+ #include "absl/algorithm/container.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -428,7 +428,7 @@ PickFirst::PickFirst(Args args)
+
+ PickFirst::~PickFirst() {
+   GRPC_TRACE_LOG(pick_first, INFO) << "Destroying Pick First " << this;
+-  CHECK_EQ(subchannel_list_.get(), nullptr);
++  ABSL_CHECK_EQ(subchannel_list_.get(), nullptr);
+ }
+
+ void PickFirst::ShutdownLocked() {
+@@ -459,7 +459,7 @@ void PickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
+   }
+   // Replace subchannel_list_.
+   if (GRPC_TRACE_FLAG_ENABLED(pick_first) && subchannel_list_ != nullptr) {
+-    LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
++    ABSL_LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
+               << subchannel_list_.get();
+   }
+   subchannel_list_ = MakeOrphanable<SubchannelList>(
+@@ -510,9 +510,9 @@ class AddressFamilyIterator final {
+ absl::Status PickFirst::UpdateLocked(UpdateArgs args) {
+   if (GRPC_TRACE_FLAG_ENABLED(pick_first)) {
+     if (args.addresses.ok()) {
+-      LOG(INFO) << "Pick First " << this << " received update";
++      ABSL_LOG(INFO) << "Pick First " << this << " received update";
+     } else {
+-      LOG(INFO) << "Pick First " << this
++      ABSL_LOG(INFO) << "Pick First " << this
+                 << " received update with address error: "
+                 << args.addresses.status();
+     }
+@@ -696,7 +696,7 @@ void PickFirst::SubchannelList::SubchannelData::SubchannelState::Select() {
+   GRPC_TRACE_LOG(pick_first, INFO)
+       << "Pick First " << pick_first_.get() << " selected subchannel "
+       << subchannel_.get();
+-  CHECK_NE(subchannel_data_, nullptr);
++  ABSL_CHECK_NE(subchannel_data_, nullptr);
+   pick_first_->UnsetSelectedSubchannel();  // Cancel health watch, if any.
+   pick_first_->selected_ = std::move(subchannel_data_->subchannel_state_);
+   // If health checking is enabled, start the health watch, but don't
+@@ -752,7 +752,7 @@ void PickFirst::SubchannelList::SubchannelData::SubchannelState::
+   // If we're still part of a subchannel list trying to connect, check
+   // if we're connected.
+   if (subchannel_data_ != nullptr) {
+-    CHECK_EQ(pick_first_->subchannel_list_.get(),
++    ABSL_CHECK_EQ(pick_first_->subchannel_list_.get(),
+              subchannel_data_->subchannel_list_);
+     // If the subchannel is READY, use it.
+     // Otherwise, tell the subchannel list to keep trying.
+@@ -764,7 +764,7 @@ void PickFirst::SubchannelList::SubchannelData::SubchannelState::
+     return;
+   }
+   // We aren't trying to connect, so we must be the selected subchannel.
+-  CHECK_EQ(pick_first_->selected_.get(), this);
++  ABSL_CHECK_EQ(pick_first_->selected_.get(), this);
+   GRPC_TRACE_LOG(pick_first, INFO)
+       << "Pick First " << pick_first_.get()
+       << " selected subchannel connectivity changed to "
+@@ -815,12 +815,12 @@ void PickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(
+       << p->subchannel_list_->shutting_down_;
+   if (subchannel_list_->shutting_down_) return;
+   // The notification must be for a subchannel in the current list.
+-  CHECK_EQ(subchannel_list_, p->subchannel_list_.get());
++  ABSL_CHECK_EQ(subchannel_list_, p->subchannel_list_.get());
+   // SHUTDOWN should never happen.
+-  CHECK_NE(new_state, GRPC_CHANNEL_SHUTDOWN);
++  ABSL_CHECK_NE(new_state, GRPC_CHANNEL_SHUTDOWN);
+   // READY should be caught by SubchannelState, in which case it will
+   // not call us in the first place.
+-  CHECK_NE(new_state, GRPC_CHANNEL_READY);
++  ABSL_CHECK_NE(new_state, GRPC_CHANNEL_READY);
+   // Update state.
+   std::optional<grpc_connectivity_state> old_state = connectivity_state_;
+   connectivity_state_ = new_state;
+@@ -939,11 +939,11 @@ void PickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(
+ }
+
+ void PickFirst::SubchannelList::SubchannelData::RequestConnectionWithTimer() {
+-  CHECK(connectivity_state_.has_value());
++  ABSL_CHECK(connectivity_state_.has_value());
+   if (connectivity_state_ == GRPC_CHANNEL_IDLE) {
+     subchannel_state_->RequestConnection();
+   } else {
+-    CHECK_EQ(connectivity_state_.value(), GRPC_CHANNEL_CONNECTING);
++    ABSL_CHECK_EQ(connectivity_state_.value(), GRPC_CHANNEL_CONNECTING);
+   }
+   // If this is not the last subchannel in the list, start the timer.
+   if (index_ != subchannel_list_->size() - 1) {
+@@ -999,7 +999,7 @@ PickFirst::SubchannelList::SubchannelList(RefCountedPtr<PickFirst> policy,
+   if (addresses == nullptr) return;
+   // Create a subchannel for each address.
+   addresses->ForEach([&](const EndpointAddresses& address) {
+-    CHECK_EQ(address.addresses().size(), 1u);
++    ABSL_CHECK_EQ(address.addresses().size(), 1u);
+     RefCountedPtr<SubchannelInterface> subchannel =
+         policy_->channel_control_helper()->CreateSubchannel(
+             address.address(), address.args(), args_);
+@@ -1028,7 +1028,7 @@ PickFirst::SubchannelList::~SubchannelList() {
+ void PickFirst::SubchannelList::Orphan() {
+   GRPC_TRACE_LOG(pick_first, INFO)
+       << "[PF " << policy_.get() << "] Shutting down subchannel_list " << this;
+-  CHECK(!shutting_down_);
++  ABSL_CHECK(!shutting_down_);
+   shutting_down_ = true;
+   // Shut down subchannels.
+   subchannels_.clear();
+@@ -1060,7 +1060,7 @@ void PickFirst::SubchannelList::StartConnectingNextSubchannel() {
+   // large recursion that could overflow the stack.
+   for (; attempting_index_ < size(); ++attempting_index_) {
+     SubchannelData* sc = subchannels_[attempting_index_].get();
+-    CHECK(sc->connectivity_state().has_value());
++    ABSL_CHECK(sc->connectivity_state().has_value());
+     if (sc->connectivity_state() != GRPC_CHANNEL_TRANSIENT_FAILURE) {
+       // Found a subchannel not in TRANSIENT_FAILURE, so trigger a
+       // connection attempt.
+@@ -1381,8 +1381,8 @@ OldPickFirst::OldPickFirst(Args args)
+
+ OldPickFirst::~OldPickFirst() {
+   GRPC_TRACE_LOG(pick_first, INFO) << "Destroying Pick First " << this;
+-  CHECK(subchannel_list_ == nullptr);
+-  CHECK(latest_pending_subchannel_list_ == nullptr);
++  ABSL_CHECK(subchannel_list_ == nullptr);
++  ABSL_CHECK(latest_pending_subchannel_list_ == nullptr);
+ }
+
+ void OldPickFirst::ShutdownLocked() {
+@@ -1418,7 +1418,7 @@ void OldPickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
+   // Replace latest_pending_subchannel_list_.
+   if (GRPC_TRACE_FLAG_ENABLED(pick_first) &&
+       latest_pending_subchannel_list_ != nullptr) {
+-    LOG(INFO) << "[PF " << this
++    ABSL_LOG(INFO) << "[PF " << this
+               << "] Shutting down previous pending subchannel list "
+               << latest_pending_subchannel_list_.get();
+   }
+@@ -1439,7 +1439,7 @@ void OldPickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
+   if (latest_pending_subchannel_list_->size() == 0 || selected_ == nullptr) {
+     UnsetSelectedSubchannel();
+     if (GRPC_TRACE_FLAG_ENABLED(pick_first) && subchannel_list_ != nullptr) {
+-      LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
++      ABSL_LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
+                 << subchannel_list_.get();
+     }
+     subchannel_list_ = std::move(latest_pending_subchannel_list_);
+@@ -1449,9 +1449,9 @@ void OldPickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
+ absl::Status OldPickFirst::UpdateLocked(UpdateArgs args) {
+   if (GRPC_TRACE_FLAG_ENABLED(pick_first)) {
+     if (args.addresses.ok()) {
+-      LOG(INFO) << "Pick First " << this << " received update";
++      ABSL_LOG(INFO) << "Pick First " << this << " received update";
+     } else {
+-      LOG(INFO) << "Pick First " << this
++      ABSL_LOG(INFO) << "Pick First " << this
+                 << " received update with address error: "
+                 << args.addresses.status();
+     }
+@@ -1643,15 +1643,15 @@ void OldPickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(
+                             ->GetStatsPluginGroup();
+   // The notification must be for a subchannel in either the current or
+   // latest pending subchannel lists.
+-  CHECK(subchannel_list_ == p->subchannel_list_.get() ||
++  ABSL_CHECK(subchannel_list_ == p->subchannel_list_.get() ||
+         subchannel_list_ == p->latest_pending_subchannel_list_.get());
+-  CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
++  ABSL_CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
+   std::optional<grpc_connectivity_state> old_state = connectivity_state_;
+   connectivity_state_ = new_state;
+   connectivity_status_ = std::move(status);
+   // Handle updates for the currently selected subchannel.
+   if (p->selected_ == this) {
+-    CHECK(subchannel_list_ == p->subchannel_list_.get());
++    ABSL_CHECK(subchannel_list_ == p->subchannel_list_.get());
+     GRPC_TRACE_LOG(pick_first, INFO)
+         << "Pick First " << p << " selected subchannel connectivity changed to "
+         << ConnectivityStateName(new_state);
+@@ -1819,11 +1819,11 @@ void OldPickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(
+
+ void OldPickFirst::SubchannelList::SubchannelData::
+     RequestConnectionWithTimer() {
+-  CHECK(connectivity_state_.has_value());
++  ABSL_CHECK(connectivity_state_.has_value());
+   if (connectivity_state_ == GRPC_CHANNEL_IDLE) {
+     subchannel_->RequestConnection();
+   } else {
+-    CHECK(connectivity_state_ == GRPC_CHANNEL_CONNECTING);
++    ABSL_CHECK(connectivity_state_ == GRPC_CHANNEL_CONNECTING);
+   }
+   // If this is not the last subchannel in the list, start the timer.
+   if (index_ != subchannel_list_->size() - 1) {
+@@ -1875,7 +1875,7 @@ void OldPickFirst::SubchannelList::SubchannelData::
+   //    for a subchannel in p->latest_pending_subchannel_list_.  The
+   //    goal here is to find a subchannel from the update that we can
+   //    select in place of the current one.
+-  CHECK(subchannel_list_ == p->subchannel_list_.get() ||
++  ABSL_CHECK(subchannel_list_ == p->subchannel_list_.get() ||
+         subchannel_list_ == p->latest_pending_subchannel_list_.get());
+   // Case 2.  Promote p->latest_pending_subchannel_list_ to p->subchannel_list_.
+   if (subchannel_list_ == p->latest_pending_subchannel_list_.get()) {
+@@ -1937,7 +1937,7 @@ OldPickFirst::SubchannelList::SubchannelList(
+   if (addresses == nullptr) return;
+   // Create a subchannel for each address.
+   addresses->ForEach([&](const EndpointAddresses& address) {
+-    CHECK_EQ(address.addresses().size(), 1u);
++    ABSL_CHECK_EQ(address.addresses().size(), 1u);
+     RefCountedPtr<SubchannelInterface> subchannel =
+         policy_->channel_control_helper()->CreateSubchannel(
+             address.address(), address.args(), args_);
+@@ -1965,7 +1965,7 @@ OldPickFirst::SubchannelList::~SubchannelList() {
+ void OldPickFirst::SubchannelList::Orphan() {
+   GRPC_TRACE_LOG(pick_first, INFO)
+       << "[PF " << policy_.get() << "] Shutting down subchannel_list " << this;
+-  CHECK(!shutting_down_);
++  ABSL_CHECK(!shutting_down_);
+   shutting_down_ = true;
+   for (auto& sd : subchannels_) {
+     sd.ShutdownLocked();
+@@ -1997,7 +1997,7 @@ void OldPickFirst::SubchannelList::StartConnectingNextSubchannel() {
+   // large recursion that could overflow the stack.
+   for (; attempting_index_ < size(); ++attempting_index_) {
+     SubchannelData* sc = &subchannels_[attempting_index_];
+-    CHECK(sc->connectivity_state().has_value());
++    ABSL_CHECK(sc->connectivity_state().has_value());
+     if (sc->connectivity_state() != GRPC_CHANNEL_TRANSIENT_FAILURE) {
+       // Found a subchannel not in TRANSIENT_FAILURE, so trigger a
+       // connection attempt.
+diff --git a/third_party/grpc/source/src/core/load_balancing/priority/priority.cc b/third_party/grpc/source/src/core/load_balancing/priority/priority.cc
+index 0f8a501ff0497..cf1a71d96dcf7 100644
+--- a/third_party/grpc/source/src/core/load_balancing/priority/priority.cc
++++ b/third_party/grpc/source/src/core/load_balancing/priority/priority.cc
+@@ -30,8 +30,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -401,7 +401,7 @@ void PriorityLb::ChoosePriorityLocked() {
+           RefAsSubclass<PriorityLb>(DEBUG_LOCATION, "ChildPriority"),
+           child_name);
+       auto child_config = config_->children().find(child_name);
+-      DCHECK(child_config != config_->children().end());
++      ABSL_DCHECK(child_config != config_->children().end());
+       // If the child policy returns a non-OK status, request re-resolution.
+       // Note that this will initially cause fixed backoff delay in the
+       // resolver instead of exponential delay.  However, once the
+@@ -451,7 +451,7 @@ void PriorityLb::ChoosePriorityLocked() {
+         << "[priority_lb " << this << "] trying priority " << priority
+         << ", child " << child_name;
+     auto& child = children_[child_name];
+-    CHECK(child != nullptr);
++    ABSL_CHECK(child != nullptr);
+     if (child->connectivity_state() == GRPC_CHANNEL_CONNECTING) {
+       SetCurrentPriorityLocked(priority, /*deactivate_lower_priorities=*/false,
+                                "CONNECTING (pass 2)");
+@@ -480,7 +480,7 @@ void PriorityLb::SetCurrentPriorityLocked(int32_t priority,
+     }
+   }
+   auto& child = children_[config_->priorities()[priority]];
+-  CHECK(child != nullptr);
++  ABSL_CHECK(child != nullptr);
+   channel_control_helper()->UpdateState(child->connectivity_state(),
+                                         child->connectivity_status(),
+                                         child->GetPicker());
+diff --git a/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc b/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc
+index fb6691b83e647..37592957c4edd 100644
+--- a/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc
++++ b/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc
+@@ -34,8 +34,8 @@
+
+ #include "absl/base/attributes.h"
+ #include "absl/container/inlined_vector.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -597,7 +597,7 @@ void RingHash::RingHashEndpoint::RequestConnectionLocked() {
+ }
+
+ void RingHash::RingHashEndpoint::CreateChildPolicy() {
+-  CHECK(child_policy_ == nullptr);
++  ABSL_CHECK(child_policy_ == nullptr);
+   LoadBalancingPolicy::Args lb_policy_args;
+   lb_policy_args.work_serializer = ring_hash_->work_serializer();
+   lb_policy_args.args =
+@@ -611,7 +611,7 @@ void RingHash::RingHashEndpoint::CreateChildPolicy() {
+           "pick_first", std::move(lb_policy_args));
+   if (GRPC_TRACE_FLAG_ENABLED(ring_hash_lb)) {
+     const EndpointAddresses& endpoint = ring_hash_->endpoints_[index_];
+-    LOG(INFO) << "[RH " << ring_hash_.get() << "] endpoint " << this
++    ABSL_LOG(INFO) << "[RH " << ring_hash_.get() << "] endpoint " << this
+               << " (index " << index_ << " of " << ring_hash_->endpoints_.size()
+               << ", " << endpoint.ToString() << "): created child policy "
+               << child_policy_.get();
+@@ -639,7 +639,7 @@ absl::Status RingHash::RingHashEndpoint::UpdateChildPolicyLocked() {
+       CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(
+           Json::FromArray(
+               {Json::FromObject({{"pick_first", Json::FromObject({})}})}));
+-  CHECK(config.ok());
++  ABSL_CHECK(config.ok());
+   // Update child policy.
+   LoadBalancingPolicy::UpdateArgs update_args;
+   update_args.addresses =
+@@ -901,7 +901,7 @@ void RingHash::UpdateAggregatedConnectivityStateLocked(
+     for (size_t i = 0; i < endpoints_.size(); ++i) {
+       auto it =
+           endpoint_map_.find(EndpointAddressSet(endpoints_[i].addresses()));
+-      CHECK(it != endpoint_map_.end());
++      ABSL_CHECK(it != endpoint_map_.end());
+       auto& endpoint = it->second;
+       if (endpoint->connectivity_state() == GRPC_CHANNEL_CONNECTING) {
+         first_idle_index = endpoints_.size();
+@@ -915,7 +915,7 @@ void RingHash::UpdateAggregatedConnectivityStateLocked(
+     if (first_idle_index != endpoints_.size()) {
+       auto it = endpoint_map_.find(
+           EndpointAddressSet(endpoints_[first_idle_index].addresses()));
+-      CHECK(it != endpoint_map_.end());
++      ABSL_CHECK(it != endpoint_map_.end());
+       auto& endpoint = it->second;
+       GRPC_TRACE_LOG(ring_hash_lb, INFO)
+           << "[RH " << this
+diff --git a/third_party/grpc/source/src/core/load_balancing/rls/rls.cc b/third_party/grpc/source/src/core/load_balancing/rls/rls.cc
+index 19e976e768d9d..515c9d05f4890 100644
+--- a/third_party/grpc/source/src/core/load_balancing/rls/rls.cc
++++ b/third_party/grpc/source/src/core/load_balancing/rls/rls.cc
+@@ -53,8 +53,8 @@
+
+ #include "absl/base/thread_annotations.h"
+ #include "absl/hash/hash.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -796,7 +796,7 @@ void RlsLb::ChildPolicyWrapper::StartUpdate(
+   auto child_policy_config = InsertOrUpdateChildPolicyField(
+       lb_policy_->config_->child_policy_config_target_field_name(), target_,
+       lb_policy_->config_->child_policy_config(), &errors);
+-  CHECK(child_policy_config.has_value());
++  ABSL_CHECK(child_policy_config.has_value());
+   GRPC_TRACE_LOG(rls_lb, INFO)
+       << "[rlslb " << lb_policy_.get() << "] ChildPolicyWrapper=" << this
+       << " [" << target_
+@@ -873,7 +873,7 @@ void RlsLb::ChildPolicyWrapper::ChildPolicyHelper::UpdateState(
+       return;
+     }
+     wrapper_->connectivity_state_ = state;
+-    DCHECK(picker != nullptr);
++    ABSL_DCHECK(picker != nullptr);
+     if (picker != nullptr) {
+       // We want to unref the picker after we release the lock.
+       wrapper_->picker_.swap(picker);
+@@ -897,7 +897,7 @@ std::map<std::string, std::string> BuildKeyMap(
+   if (it == key_builder_map.end()) {
+     // Didn't find exact match, try method wildcard.
+     last_slash_pos = path.rfind('/');
+-    DCHECK(last_slash_pos != path.npos);
++    ABSL_DCHECK(last_slash_pos != path.npos);
+     if (GPR_UNLIKELY(last_slash_pos == path.npos)) return {};
+     std::string service(path.substr(0, last_slash_pos + 1));
+     it = key_builder_map.find(service);
+@@ -929,7 +929,7 @@ std::map<std::string, std::string> BuildKeyMap(
+   if (!key_builder->service_key.empty()) {
+     if (last_slash_pos == path.npos) {
+       last_slash_pos = path.rfind('/');
+-      DCHECK(last_slash_pos != path.npos);
++      ABSL_DCHECK(last_slash_pos != path.npos);
+       if (GPR_UNLIKELY(last_slash_pos == path.npos)) return {};
+     }
+     key_map[key_builder->service_key] =
+@@ -939,7 +939,7 @@ std::map<std::string, std::string> BuildKeyMap(
+   if (!key_builder->method_key.empty()) {
+     if (last_slash_pos == path.npos) {
+       last_slash_pos = path.rfind('/');
+-      DCHECK(last_slash_pos != path.npos);
++      ABSL_DCHECK(last_slash_pos != path.npos);
+       if (GPR_UNLIKELY(last_slash_pos == path.npos)) return {};
+     }
+     key_map[key_builder->method_key] =
+@@ -1125,7 +1125,7 @@ void RlsLb::Cache::Entry::Orphan() {
+   is_shutdown_ = true;
+   lb_policy_->cache_.lru_list_.erase(lru_iterator_);
+   lru_iterator_ = lb_policy_->cache_.lru_list_.end();  // Just in case.
+-  CHECK(child_policy_wrappers_.empty());
++  ABSL_CHECK(child_policy_wrappers_.empty());
+   backoff_state_.reset();
+   if (backoff_timer_ != nullptr) {
+     backoff_timer_.reset();
+@@ -1136,7 +1136,7 @@ void RlsLb::Cache::Entry::Orphan() {
+
+ size_t RlsLb::Cache::Entry::Size() const {
+   // lru_iterator_ is not valid once we're shut down.
+-  CHECK(!is_shutdown_);
++  ABSL_CHECK(!is_shutdown_);
+   return lb_policy_->cache_.EntrySizeForKey(*lru_iterator_);
+ }
+
+@@ -1428,7 +1428,7 @@ void RlsLb::Cache::MaybeShrinkSize(
+     auto lru_it = lru_list_.begin();
+     if (GPR_UNLIKELY(lru_it == lru_list_.end())) break;
+     auto map_it = map_.find(*lru_it);
+-    CHECK(map_it != map_.end());
++    ABSL_CHECK(map_it != map_.end());
+     auto& entry = map_it->second;
+     if (!entry->CanEvict()) break;
+     GRPC_TRACE_LOG(rls_lb, INFO)
+@@ -1576,7 +1576,7 @@ void RlsLb::RlsChannel::Orphan() {
+     // Remove channelz linkage.
+     if (parent_channelz_node_ != nullptr) {
+       channelz::ChannelNode* child_channelz_node = channel_->channelz_node();
+-      CHECK_NE(child_channelz_node, nullptr);
++      ABSL_CHECK_NE(child_channelz_node, nullptr);
+       parent_channelz_node_->RemoveChildChannel(child_channelz_node->uuid());
+     }
+     // Stop connectivity watch.
+@@ -1612,7 +1612,7 @@ void RlsLb::RlsChannel::ReportResponseLocked(bool response_succeeded) {
+ }
+
+ void RlsLb::RlsChannel::ResetBackoff() {
+-  DCHECK(channel_ != nullptr);
++  ABSL_DCHECK(channel_ != nullptr);
+   channel_->ResetConnectionBackoff();
+ }
+
+@@ -1645,7 +1645,7 @@ RlsLb::RlsRequest::RlsRequest(
+       absl::OkStatus());
+ }
+
+-RlsLb::RlsRequest::~RlsRequest() { CHECK_EQ(call_, nullptr); }
++RlsLb::RlsRequest::~RlsRequest() { ABSL_CHECK_EQ(call_, nullptr); }
+
+ void RlsLb::RlsRequest::Orphan() {
+   if (call_ != nullptr) {
+@@ -1705,7 +1705,7 @@ void RlsLb::RlsRequest::StartCallLocked() {
+   Ref(DEBUG_LOCATION, "OnRlsCallComplete").release();
+   auto call_error = grpc_call_start_batch_and_execute(
+       call_, ops, static_cast<size_t>(op - ops), &call_complete_cb_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+ }
+
+ void RlsLb::RlsRequest::OnRlsCallComplete(void* arg, grpc_error_handle error) {
+@@ -1719,7 +1719,7 @@ void RlsLb::RlsRequest::OnRlsCallComplete(void* arg, grpc_error_handle error) {
+ void RlsLb::RlsRequest::OnRlsCallCompleteLocked(grpc_error_handle error) {
+   if (GRPC_TRACE_FLAG_ENABLED(rls_lb)) {
+     std::string status_message(StringViewFromSlice(status_details_recv_));
+-    LOG(INFO) << "[rlslb " << lb_policy_.get() << "] rls_request=" << this
++    ABSL_LOG(INFO) << "[rlslb " << lb_policy_.get() << "] rls_request=" << this
+               << " " << key_.ToString() << ", error=" << StatusToString(error)
+               << ", status={" << status_recv_ << ", " << status_message << "}"
+               << " RLS call response received";
+@@ -1896,7 +1896,7 @@ absl::Status RlsLb::UpdateLocked(UpdateArgs args) {
+   if (GRPC_TRACE_FLAG_ENABLED(rls_lb) &&
+       (old_config == nullptr ||
+        old_config->child_policy_config() != config_->child_policy_config())) {
+-    LOG(INFO) << "[rlslb " << this << "] updated child policy config: "
++    ABSL_LOG(INFO) << "[rlslb " << this << "] updated child policy config: "
+               << JsonDump(config_->child_policy_config());
+   }
+   // Swap out addresses.
+diff --git a/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc b/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc
+index 2a6577f4934ca..97148b9959dce 100644
+--- a/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc
++++ b/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc
+@@ -27,8 +27,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -209,8 +209,8 @@ RoundRobin::RoundRobin(Args args) : LoadBalancingPolicy(std::move(args)) {
+ RoundRobin::~RoundRobin() {
+   GRPC_TRACE_LOG(round_robin, INFO)
+       << "[RR " << this << "] Destroying Round Robin policy";
+-  CHECK(endpoint_list_ == nullptr);
+-  CHECK(latest_pending_endpoint_list_ == nullptr);
++  ABSL_CHECK(endpoint_list_ == nullptr);
++  ABSL_CHECK(latest_pending_endpoint_list_ == nullptr);
+ }
+
+ void RoundRobin::ShutdownLocked() {
+@@ -243,7 +243,7 @@ absl::Status RoundRobin::UpdateLocked(UpdateArgs args) {
+   // Create new child list, replacing the previous pending list, if any.
+   if (GRPC_TRACE_FLAG_ENABLED(round_robin) &&
+       latest_pending_endpoint_list_ != nullptr) {
+-    LOG(INFO) << "[RR " << this << "] replacing previous pending child list "
++    ABSL_LOG(INFO) << "[RR " << this << "] replacing previous pending child list "
+               << latest_pending_endpoint_list_.get();
+   }
+   std::vector<std::string> errors;
+@@ -254,7 +254,7 @@ absl::Status RoundRobin::UpdateLocked(UpdateArgs args) {
+   // endpoint_list_ and report TRANSIENT_FAILURE.
+   if (latest_pending_endpoint_list_->size() == 0) {
+     if (GRPC_TRACE_FLAG_ENABLED(round_robin) && endpoint_list_ != nullptr) {
+-      LOG(INFO) << "[RR " << this << "] replacing previous child list "
++      ABSL_LOG(INFO) << "[RR " << this << "] replacing previous child list "
+                 << endpoint_list_.get();
+     }
+     endpoint_list_ = std::move(latest_pending_endpoint_list_);
+@@ -316,20 +316,20 @@ void RoundRobin::RoundRobinEndpointList::UpdateStateCountersLocked(
+   // We treat IDLE the same as CONNECTING, since it will immediately
+   // transition into that state anyway.
+   if (old_state.has_value()) {
+-    CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
++    ABSL_CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
+     if (*old_state == GRPC_CHANNEL_READY) {
+-      CHECK_GT(num_ready_, 0u);
++      ABSL_CHECK_GT(num_ready_, 0u);
+       --num_ready_;
+     } else if (*old_state == GRPC_CHANNEL_CONNECTING ||
+                *old_state == GRPC_CHANNEL_IDLE) {
+-      CHECK_GT(num_connecting_, 0u);
++      ABSL_CHECK_GT(num_connecting_, 0u);
+       --num_connecting_;
+     } else if (*old_state == GRPC_CHANNEL_TRANSIENT_FAILURE) {
+-      CHECK_GT(num_transient_failure_, 0u);
++      ABSL_CHECK_GT(num_transient_failure_, 0u);
+       --num_transient_failure_;
+     }
+   }
+-  CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
++  ABSL_CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
+   if (new_state == GRPC_CHANNEL_READY) {
+     ++num_ready_;
+   } else if (new_state == GRPC_CHANNEL_CONNECTING ||
+@@ -356,7 +356,7 @@ void RoundRobin::RoundRobinEndpointList::
+        (num_ready_ > 0 && AllEndpointsSeenInitialState()) ||
+        num_transient_failure_ == size())) {
+     if (GRPC_TRACE_FLAG_ENABLED(round_robin)) {
+-      LOG(INFO) << "[RR " << round_robin << "] swapping out child list "
++      ABSL_LOG(INFO) << "[RR " << round_robin << "] swapping out child list "
+                 << round_robin->endpoint_list_.get() << " ("
+                 << round_robin->endpoint_list_->CountersString()
+                 << ") in favor of " << this << " (" << CountersString() << ")";
+@@ -381,7 +381,7 @@ void RoundRobin::RoundRobinEndpointList::
+         pickers.push_back(endpoint->picker());
+       }
+     }
+-    CHECK(!pickers.empty());
++    ABSL_CHECK(!pickers.empty());
+     round_robin->channel_control_helper()->UpdateState(
+         GRPC_CHANNEL_READY, absl::OkStatus(),
+         MakeRefCounted<Picker>(round_robin, std::move(pickers)));
+diff --git a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc
+index 61240f0fd4d5f..12d166ef041a3 100644
+--- a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc
++++ b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc
+@@ -25,7 +25,7 @@
+ #include <vector>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -146,7 +146,7 @@ std::optional<StaticStrideScheduler> StaticStrideScheduler::Make(
+     }
+   }
+
+-  CHECK(weights.size() == float_weights.size());
++  ABSL_CHECK(weights.size() == float_weights.size());
+   return StaticStrideScheduler{std::move(weights),
+                                std::move(next_sequence_func)};
+ }
+@@ -156,7 +156,7 @@ StaticStrideScheduler::StaticStrideScheduler(
+     absl::AnyInvocable<uint32_t()> next_sequence_func)
+     : next_sequence_func_(std::move(next_sequence_func)),
+       weights_(std::move(weights)) {
+-  CHECK(next_sequence_func_ != nullptr);
++  ABSL_CHECK(next_sequence_func_ != nullptr);
+ }
+
+ size_t StaticStrideScheduler::Pick() const {
+diff --git a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc
+index 2ef90411a6aad..06522256a6556 100644
+--- a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc
++++ b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc
+@@ -33,8 +33,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -574,7 +574,7 @@ void WeightedRoundRobin::Picker::Orphaned() {
+
+ WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick(PickArgs args) {
+   size_t index = PickIndex();
+-  CHECK(index < endpoints_.size());
++  ABSL_CHECK(index < endpoints_.size());
+   auto& endpoint_info = endpoints_[index];
+   GRPC_TRACE_LOG(weighted_round_robin_lb, INFO)
+       << "[WRR " << wrr_.get() << " picker " << this << "] returning index "
+@@ -699,8 +699,8 @@ WeightedRoundRobin::WeightedRoundRobin(Args args)
+ WeightedRoundRobin::~WeightedRoundRobin() {
+   GRPC_TRACE_LOG(weighted_round_robin_lb, INFO)
+       << "[WRR " << this << "] Destroying Round Robin policy";
+-  CHECK(endpoint_list_ == nullptr);
+-  CHECK(latest_pending_endpoint_list_ == nullptr);
++  ABSL_CHECK(endpoint_list_ == nullptr);
++  ABSL_CHECK(latest_pending_endpoint_list_ == nullptr);
+ }
+
+ void WeightedRoundRobin::ShutdownLocked() {
+@@ -760,7 +760,7 @@ absl::Status WeightedRoundRobin::UpdateLocked(UpdateArgs args) {
+   // Create new endpoint list, replacing the previous pending list, if any.
+   if (GRPC_TRACE_FLAG_ENABLED(weighted_round_robin_lb) &&
+       latest_pending_endpoint_list_ != nullptr) {
+-    LOG(INFO) << "[WRR " << this
++    ABSL_LOG(INFO) << "[WRR " << this
+               << "] replacing previous pending endpoint list "
+               << latest_pending_endpoint_list_.get();
+   }
+@@ -773,7 +773,7 @@ absl::Status WeightedRoundRobin::UpdateLocked(UpdateArgs args) {
+   if (latest_pending_endpoint_list_->size() == 0) {
+     if (GRPC_TRACE_FLAG_ENABLED(weighted_round_robin_lb) &&
+         endpoint_list_ != nullptr) {
+-      LOG(INFO) << "[WRR " << this << "] replacing previous endpoint list "
++      ABSL_LOG(INFO) << "[WRR " << this << "] replacing previous endpoint list "
+                 << endpoint_list_.get();
+     }
+     endpoint_list_ = std::move(latest_pending_endpoint_list_);
+@@ -899,20 +899,20 @@ void WeightedRoundRobin::WrrEndpointList::UpdateStateCountersLocked(
+   // We treat IDLE the same as CONNECTING, since it will immediately
+   // transition into that state anyway.
+   if (old_state.has_value()) {
+-    CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
++    ABSL_CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
+     if (*old_state == GRPC_CHANNEL_READY) {
+-      CHECK_GT(num_ready_, 0u);
++      ABSL_CHECK_GT(num_ready_, 0u);
+       --num_ready_;
+     } else if (*old_state == GRPC_CHANNEL_CONNECTING ||
+                *old_state == GRPC_CHANNEL_IDLE) {
+-      CHECK_GT(num_connecting_, 0u);
++      ABSL_CHECK_GT(num_connecting_, 0u);
+       --num_connecting_;
+     } else if (*old_state == GRPC_CHANNEL_TRANSIENT_FAILURE) {
+-      CHECK_GT(num_transient_failure_, 0u);
++      ABSL_CHECK_GT(num_transient_failure_, 0u);
+       --num_transient_failure_;
+     }
+   }
+-  CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
++  ABSL_CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
+   if (new_state == GRPC_CHANNEL_READY) {
+     ++num_ready_;
+   } else if (new_state == GRPC_CHANNEL_CONNECTING ||
+@@ -939,7 +939,7 @@ void WeightedRoundRobin::WrrEndpointList::
+        (num_ready_ > 0 && AllEndpointsSeenInitialState()) ||
+        num_transient_failure_ == size())) {
+     if (GRPC_TRACE_FLAG_ENABLED(weighted_round_robin_lb)) {
+-      LOG(INFO) << "[WRR " << wrr << "] swapping out endpoint list "
++      ABSL_LOG(INFO) << "[WRR " << wrr << "] swapping out endpoint list "
+                 << wrr->endpoint_list_.get() << " ("
+                 << wrr->endpoint_list_->CountersString() << ") in favor of "
+                 << this << " (" << CountersString() << ")";
+diff --git a/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc b/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc
+index bc83cbcd499b8..dbde69ab8fd5d 100644
+--- a/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc
++++ b/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc
+@@ -31,8 +31,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -271,7 +271,7 @@ WeightedTargetLb::PickResult WeightedTargetLb::WeightedPicker::Pick(
+     }
+   }
+   if (index == 0) index = start_index;
+-  CHECK(pickers_[index].first > key);
++  ABSL_CHECK(pickers_[index].first > key);
+   // Delegate to the child picker.
+   return pickers_[index].second->Pick(args);
+ }
+@@ -400,7 +400,7 @@ void WeightedTargetLb::UpdateStateLocked() {
+         << " weight=" << child->weight() << " picker=" << child_picker.get();
+     switch (child->connectivity_state()) {
+       case GRPC_CHANNEL_READY: {
+-        CHECK_GT(child->weight(), 0u);
++        ABSL_CHECK_GT(child->weight(), 0u);
+         ready_end += child->weight();
+         ready_picker_list.emplace_back(ready_end, std::move(child_picker));
+         break;
+@@ -414,7 +414,7 @@ void WeightedTargetLb::UpdateStateLocked() {
+         break;
+       }
+       case GRPC_CHANNEL_TRANSIENT_FAILURE: {
+-        CHECK_GT(child->weight(), 0u);
++        ABSL_CHECK_GT(child->weight(), 0u);
+         tf_end += child->weight();
+         tf_picker_list.emplace_back(tf_end, std::move(child_picker));
+         break;
+@@ -489,7 +489,7 @@ void WeightedTargetLb::WeightedChild::DelayedRemovalTimer::Orphan() {
+ }
+
+ void WeightedTargetLb::WeightedChild::DelayedRemovalTimer::OnTimerLocked() {
+-  CHECK(timer_handle_.has_value());
++  ABSL_CHECK(timer_handle_.has_value());
+   timer_handle_.reset();
+   weighted_child_->weighted_target_policy_->targets_.erase(
+       weighted_child_->name_);
+@@ -565,7 +565,7 @@ absl::Status WeightedTargetLb::WeightedChild::UpdateLocked(
+   if (weighted_target_policy_->shutting_down_) return absl::OkStatus();
+   // Update child weight.
+   if (weight_ != config.weight && GRPC_TRACE_FLAG_ENABLED(weighted_target_lb)) {
+-    LOG(INFO) << "[weighted_target_lb " << weighted_target_policy_.get()
++    ABSL_LOG(INFO) << "[weighted_target_lb " << weighted_target_policy_.get()
+               << "] WeightedChild " << this << " " << name_
+               << ": weight=" << config.weight;
+   }
+diff --git a/third_party/grpc/source/src/core/load_balancing/xds/cds.cc b/third_party/grpc/source/src/core/load_balancing/xds/cds.cc
+index 8a3f2fb2727fb..32e119dc4a4b3 100644
+--- a/third_party/grpc/source/src/core/load_balancing/xds/cds.cc
++++ b/third_party/grpc/source/src/core/load_balancing/xds/cds.cc
+@@ -30,8 +30,8 @@
+ #include <variant>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -277,13 +277,13 @@ absl::Status CdsLb::UpdateLocked(UpdateArgs args) {
+       << "[cdslb " << this
+       << "] received update: cluster=" << new_config->cluster()
+       << " is_dynamic=" << new_config->is_dynamic();
+-  CHECK(new_config != nullptr);
++  ABSL_CHECK(new_config != nullptr);
+   // Cluster name should never change, because we should use a different
+   // child name in xds_cluster_manager in that case.
+   if (cluster_name_.empty()) {
+     cluster_name_ = new_config->cluster();
+   } else {
+-    CHECK(cluster_name_ == new_config->cluster());
++    ABSL_CHECK(cluster_name_ == new_config->cluster());
+   }
+   // Start dynamic subscription if needed.
+   if (new_config->is_dynamic() && subscription_ == nullptr) {
+@@ -335,7 +335,7 @@ absl::Status CdsLb::UpdateLocked(UpdateArgs args) {
+     ReportTransientFailure(new_cluster_config.status());
+     return new_cluster_config.status();
+   }
+-  CHECK_NE(new_cluster_config->cluster, nullptr);
++  ABSL_CHECK_NE(new_cluster_config->cluster, nullptr);
+   // Find old cluster, if any.
+   const XdsConfig::ClusterConfig* old_cluster_config = nullptr;
+   if (xds_config_ != nullptr) {
+@@ -375,7 +375,7 @@ absl::Status CdsLb::UpdateLocked(UpdateArgs args) {
+           ReportTransientFailure(aggregate_cluster_config.status());
+           return aggregate_cluster_config.status();
+         }
+-        CHECK_NE(aggregate_cluster_config->cluster, nullptr);
++        ABSL_CHECK_NE(aggregate_cluster_config->cluster, nullptr);
+         aggregate_cluster_resource = aggregate_cluster_config->cluster.get();
+       }
+     } else {
+@@ -456,7 +456,7 @@ CdsLb::ChildNameState CdsLb::ComputeChildNames(
+     const XdsConfig::ClusterConfig* old_cluster,
+     const XdsConfig::ClusterConfig& new_cluster,
+     const XdsConfig::ClusterConfig::EndpointConfig& endpoint_config) const {
+-  CHECK(!std::holds_alternative<XdsConfig::ClusterConfig::AggregateConfig>(
++  ABSL_CHECK(!std::holds_alternative<XdsConfig::ClusterConfig::AggregateConfig>(
+       new_cluster.children));
+   // First, build some maps from locality to child number and the reverse
+   // from old_cluster and child_name_state_.
+diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc
+index d3bbb0ae10d0c..aad9a914cbb81 100644
+--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc
++++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc
+@@ -29,8 +29,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -333,7 +333,7 @@ class XdsClusterImplLb::Picker::SubchannelCallTracker final
+     locality_stats_.reset(DEBUG_LOCATION, "SubchannelCallTracker");
+     call_counter_.reset(DEBUG_LOCATION, "SubchannelCallTracker");
+ #ifndef NDEBUG
+-    DCHECK(!started_);
++    ABSL_DCHECK(!started_);
+ #endif
+   }
+
+@@ -559,7 +559,7 @@ absl::Status XdsClusterImplLb::UpdateLocked(UpdateArgs args) {
+   // different priority child name if that happens, which means that this
+   // policy instance will get replaced instead of being updated.
+   if (config_ != nullptr) {
+-    CHECK(config_->cluster_name() == new_config->cluster_name());
++    ABSL_CHECK(config_->cluster_name() == new_config->cluster_name());
+   }
+   // Get xDS config.
+   auto new_xds_config = args.args.GetObjectRef<XdsConfig>();
+@@ -622,7 +622,7 @@ absl::Status XdsClusterImplLb::UpdateLocked(UpdateArgs args) {
+         new_cluster_config.cluster->lrs_load_reporting_server,
+         new_config->cluster_name(), new_eds_service_name);
+     if (drop_stats_ == nullptr) {
+-      LOG(ERROR)
++      ABSL_LOG(ERROR)
+           << "[xds_cluster_impl_lb " << this
+           << "] Failed to get cluster drop stats for LRS server "
+           << new_cluster_config.cluster->lrs_load_reporting_server->server_uri()
+@@ -822,7 +822,7 @@ RefCountedPtr<SubchannelInterface> XdsClusterImplLb::Helper::CreateSubchannel(
+             GetEdsResourceName(*parent()->cluster_resource_), locality_name,
+             parent()->cluster_resource_->lrs_backend_metric_propagation);
+     if (locality_stats == nullptr) {
+-      LOG(ERROR)
++      ABSL_LOG(ERROR)
+           << "[xds_cluster_impl_lb " << parent()
+           << "] Failed to get locality stats object for LRS server "
+           << parent()
+@@ -901,7 +901,7 @@ class XdsClusterImplLbFactory final : public LoadBalancingPolicyFactory {
+     auto xds_client = args.args.GetObjectRef<GrpcXdsClient>(DEBUG_LOCATION,
+                                                             "XdsClusterImplLb");
+     if (xds_client == nullptr) {
+-      LOG(ERROR) << "XdsClient not present in channel args -- cannot "
++      ABSL_LOG(ERROR) << "XdsClient not present in channel args -- cannot "
+                     "instantiate xds_cluster_impl LB policy";
+       return nullptr;
+     }
+diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc
+index c9ef2faaf9f33..4b67d3f1a4893 100644
+--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc
++++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc
+@@ -29,7 +29,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc
+index 034899773040d..5868e6124196f 100644
+--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc
++++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc
+@@ -36,8 +36,8 @@
+
+ #include "absl/base/thread_annotations.h"
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -225,7 +225,7 @@ class XdsOverrideHostLb final : public LoadBalancingPolicy {
+     // already has an owned subchannel.
+     void SetOwnedSubchannel(RefCountedPtr<SubchannelWrapper> subchannel)
+         ABSL_EXCLUSIVE_LOCKS_REQUIRED(&XdsOverrideHostLb::mu_) {
+-      DCHECK(!HasOwnedSubchannel());
++      ABSL_DCHECK(!HasOwnedSubchannel());
+       subchannel_ = std::move(subchannel);
+     }
+
+@@ -441,7 +441,7 @@ XdsOverrideHostLb::Picker::Picker(
+ std::optional<LoadBalancingPolicy::PickResult>
+ XdsOverrideHostLb::Picker::PickOverriddenHost(
+     XdsOverrideHostAttribute* override_host_attr) const {
+-  CHECK_NE(override_host_attr, nullptr);
++  ABSL_CHECK_NE(override_host_attr, nullptr);
+   auto cookie_address_list = override_host_attr->cookie_address_list();
+   if (cookie_address_list.empty()) return std::nullopt;
+   // The cookie has an address list, so look through the addresses in order.
+@@ -908,7 +908,7 @@ void XdsOverrideHostLb::CreateSubchannelForAddress(absl::string_view address) {
+       << "[xds_override_host_lb " << this << "] creating owned subchannel for "
+       << address;
+   auto addr = StringToSockaddr(address);
+-  CHECK(addr.ok());
++  ABSL_CHECK(addr.ok());
+   // Note: We don't currently have any cases where per_address_args need to
+   // be passed through.  If we encounter any such cases in the future, we
+   // will need to change this to store those attributes from the resolver
+@@ -973,7 +973,7 @@ RefCountedPtr<SubchannelInterface> XdsOverrideHostLb::Helper::CreateSubchannel(
+     const ChannelArgs& args) {
+   if (GRPC_TRACE_FLAG_ENABLED(xds_override_host_lb)) {
+     auto key = grpc_sockaddr_to_string(&address, /*normalize=*/false);
+-    LOG(INFO) << "[xds_override_host_lb " << this
++    ABSL_LOG(INFO) << "[xds_override_host_lb " << this
+               << "] creating subchannel for " << key.value_or("<unknown>")
+               << ", per_address_args=" << per_address_args << ", args=" << args;
+   }
+diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc
+index 25c4f95fdb55f..a0770cba7569f 100644
+--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc
++++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc
+@@ -25,7 +25,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -171,7 +171,7 @@ absl::Status XdsWrrLocalityLb::UpdateLocked(UpdateArgs args) {
+         auto [it, inserted] = locality_weights.emplace(
+             locality_name->human_readable_string(), weight);
+         if (!inserted && it->second != weight) {
+-          LOG(ERROR) << "INTERNAL ERROR: xds_wrr_locality found different "
++          ABSL_LOG(ERROR) << "INTERNAL ERROR: xds_wrr_locality found different "
+                         "weights for locality "
+                      << it->first.as_string_view() << " (" << it->second
+                      << " vs " << weight << "); using first value";
+@@ -206,7 +206,7 @@ absl::Status XdsWrrLocalityLb::UpdateLocked(UpdateArgs args) {
+   if (!child_config.ok()) {
+     // This should never happen, but if it does, we basically have no
+     // way to fix it, so we put the channel in TRANSIENT_FAILURE.
+-    LOG(ERROR) << "[xds_wrr_locality " << this
++    ABSL_LOG(ERROR) << "[xds_wrr_locality " << this
+                << "] error parsing generated child policy config -- putting "
+                   "channel in TRANSIENT_FAILURE: "
+                << child_config.status();
+diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc
+index 17be5a11c686f..82e7052241941 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc
++++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc
+@@ -28,7 +28,7 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+@@ -352,7 +352,7 @@ class AresClientChannelDNSResolverFactory final : public ResolverFactory {
+
+   bool IsValidUri(const URI& uri) const override {
+     if (absl::StripPrefix(uri.path(), "/").empty()) {
+-      LOG(ERROR) << "no server name supplied in dns URI";
++      ABSL_LOG(ERROR) << "no server name supplied in dns URI";
+       return false;
+     }
+     return true;
+diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc
+index 7341ffba63938..5f128a0432599 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc
++++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc
+@@ -35,7 +35,7 @@
+ #include <utility>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/iomgr/closure.h"
+ #include "src/core/lib/iomgr/error.h"
+@@ -113,7 +113,7 @@ class GrpcPolledFdFactoryPosix final : public GrpcPolledFdFactory {
+   GrpcPolledFd* NewGrpcPolledFdLocked(
+       ares_socket_t as, grpc_pollset_set* driver_pollset_set) override {
+     auto insert_result = owned_fds_.insert(as);
+-    CHECK(insert_result.second);
++    ABSL_CHECK(insert_result.second);
+     return new GrpcPolledFdPosix(as, driver_pollset_set);
+   }
+
+diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc
+index f30826bbb43dc..3c8fd7480cd23 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc
++++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc
+@@ -32,7 +32,7 @@
+ #include <unordered_set>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/address_utils/sockaddr_utils.h"
+ #include "src/core/lib/iomgr/iocp_windows.h"
+@@ -134,8 +134,8 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+         << "| ~GrpcPolledFdWindows shutdown_called_: " << shutdown_called_;
+     CSliceUnref(read_buf_);
+     CSliceUnref(write_buf_);
+-    CHECK_EQ(read_closure_, nullptr);
+-    CHECK_EQ(write_closure_, nullptr);
++    ABSL_CHECK_EQ(read_closure_, nullptr);
++    ABSL_CHECK_EQ(write_closure_, nullptr);
+     if (!shutdown_called_) {
+       // This can happen if the socket was never seen by grpc ares wrapper
+       // code, i.e. if we never started I/O polling on it.
+@@ -155,16 +155,16 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+   }
+
+   void RegisterForOnReadableLocked(grpc_closure* read_closure) override {
+-    CHECK_EQ(read_closure_, nullptr);
++    ABSL_CHECK_EQ(read_closure_, nullptr);
+     read_closure_ = read_closure;
+-    CHECK_EQ(GRPC_SLICE_LENGTH(read_buf_), 0);
++    ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(read_buf_), 0);
+     CSliceUnref(read_buf_);
+-    CHECK(!read_buf_has_data_);
++    ABSL_CHECK(!read_buf_has_data_);
+     read_buf_ = GRPC_SLICE_MALLOC(4192);
+     if (connect_done_) {
+       ContinueRegisterForOnReadableLocked();
+     } else {
+-      CHECK(pending_continue_register_for_on_readable_locked_ == false);
++      ABSL_CHECK(pending_continue_register_for_on_readable_locked_ == false);
+       pending_continue_register_for_on_readable_locked_ = true;
+     }
+   }
+@@ -174,7 +174,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+         << "(c-ares resolver) fd:|" << GetName()
+         << "| ContinueRegisterForOnReadableLocked "
+         << "wsa_connect_error_:" << wsa_connect_error_;
+-    CHECK(connect_done_);
++    ABSL_CHECK(connect_done_);
+     if (wsa_connect_error_ != 0) {
+       ScheduleAndNullReadClosure(GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
+       return;
+@@ -211,16 +211,16 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+           << "(c-ares resolver) fd:|" << GetName()
+           << "| RegisterForOnWriteableLocked called";
+     } else {
+-      CHECK(socket_type_ == SOCK_STREAM);
++      ABSL_CHECK(socket_type_ == SOCK_STREAM);
+       GRPC_TRACE_VLOG(cares_resolver, 2)
+           << "(c-ares resolver) fd:|" << GetName()
+           << "| RegisterForOnWriteableLocked called tcp_write_state_: "
+           << tcp_write_state_ << " connect_done_: " << connect_done_;
+     }
+-    CHECK_EQ(write_closure_, nullptr);
++    ABSL_CHECK_EQ(write_closure_, nullptr);
+     write_closure_ = write_closure;
+     if (!connect_done_) {
+-      CHECK(!pending_continue_register_for_on_writeable_locked_);
++      ABSL_CHECK(!pending_continue_register_for_on_writeable_locked_);
+       pending_continue_register_for_on_writeable_locked_ = true;
+       // Register an async OnTcpConnect callback here rather than when the
+       // connect was initiated, since we are now guaranteed to hold a ref of the
+@@ -236,7 +236,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+         << "(c-ares resolver) fd:|" << GetName()
+         << "| ContinueRegisterForOnWriteableLocked "
+         << "wsa_connect_error_:" << wsa_connect_error_;
+-    CHECK(connect_done_);
++    ABSL_CHECK(connect_done_);
+     if (wsa_connect_error_ != 0) {
+       ScheduleAndNullWriteClosure(
+           GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
+@@ -245,7 +245,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+     if (socket_type_ == SOCK_DGRAM) {
+       ScheduleAndNullWriteClosure(absl::OkStatus());
+     } else {
+-      CHECK(socket_type_ == SOCK_STREAM);
++      ABSL_CHECK(socket_type_ == SOCK_STREAM);
+       int wsa_error_code = 0;
+       switch (tcp_write_state_) {
+         case WRITE_IDLE:
+@@ -271,7 +271,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+   bool IsFdStillReadableLocked() override { return read_buf_has_data_; }
+
+   void ShutdownLocked(grpc_error_handle /* error */) override {
+-    CHECK(!shutdown_called_);
++    ABSL_CHECK(!shutdown_called_);
+     shutdown_called_ = true;
+     on_shutdown_locked_();
+     grpc_winsocket_shutdown(winsocket_);
+@@ -307,7 +307,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+     // c-ares overloads this recv_from virtual socket function to receive
+     // data on both UDP and TCP sockets, and from is nullptr for TCP.
+     if (from != nullptr) {
+-      CHECK(*from_len >= recv_from_source_addr_len_);
++      ABSL_CHECK(*from_len >= recv_from_source_addr_len_);
+       memcpy(from, &recv_from_source_addr_, recv_from_source_addr_len_);
+       *from_len = recv_from_source_addr_len_;
+     }
+@@ -378,7 +378,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+     // to write everything inline.
+     GRPC_TRACE_VLOG(cares_resolver, 2)
+         << "(c-ares resolver) fd:" << GetName() << " SendVUDP called";
+-    CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
++    ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
+     CSliceUnref(write_buf_);
+     write_buf_ = FlattenIovec(iov, iov_count);
+     DWORD bytes_sent = 0;
+@@ -413,7 +413,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+     switch (tcp_write_state_) {
+       case WRITE_IDLE:
+         tcp_write_state_ = WRITE_REQUESTED;
+-        CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
++        ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
+         CSliceUnref(write_buf_);
+         write_buf_ = FlattenIovec(iov, iov_count);
+         wsa_error_ctx->SetWSAError(WSAEWOULDBLOCK);
+@@ -429,11 +429,11 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+         // send again. If c-ares still needs to send even more data, we'll get
+         // to it eventually.
+         grpc_slice currently_attempted = FlattenIovec(iov, iov_count);
+-        CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
++        ABSL_CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
+               GRPC_SLICE_LENGTH(write_buf_));
+         ares_ssize_t total_sent = 0;
+         for (size_t i = 0; i < GRPC_SLICE_LENGTH(write_buf_); i++) {
+-          CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
++          ABSL_CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
+                 GRPC_SLICE_START_PTR(write_buf_)[i]);
+           total_sent++;
+         }
+@@ -459,9 +459,9 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+         << pending_continue_register_for_on_readable_locked_
+         << " pending_register_for_writeable:"
+         << pending_continue_register_for_on_writeable_locked_;
+-    CHECK(!connect_done_);
++    ABSL_CHECK(!connect_done_);
+     connect_done_ = true;
+-    CHECK_EQ(wsa_connect_error_, 0);
++    ABSL_CHECK_EQ(wsa_connect_error_, 0);
+     if (!error.ok() || shutdown_called_) {
+       wsa_connect_error_ = WSA_OPERATION_ABORTED;
+     } else {
+@@ -471,7 +471,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+           WSAGetOverlappedResult(grpc_winsocket_wrapped_socket(winsocket_),
+                                  &winsocket_->write_info.overlapped,
+                                  &transferred_bytes, FALSE, &flags);
+-      CHECK_EQ(transferred_bytes, 0);
++      ABSL_CHECK_EQ(transferred_bytes, 0);
+       if (!wsa_success) {
+         wsa_connect_error_ = WSAGetLastError();
+         char* msg = gpr_format_message(wsa_connect_error_);
+@@ -506,8 +506,8 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+                  ares_socklen_t target_len) {
+     GRPC_TRACE_VLOG(cares_resolver, 2)
+         << "(c-ares resolver) fd:" << GetName() << " ConnectUDP";
+-    CHECK(!connect_done_);
+-    CHECK_EQ(wsa_connect_error_, 0);
++    ABSL_CHECK(!connect_done_);
++    ABSL_CHECK_EQ(wsa_connect_error_, 0);
+     SOCKET s = grpc_winsocket_wrapped_socket(winsocket_);
+     int out =
+         WSAConnect(s, target, target_len, nullptr, nullptr, nullptr, nullptr);
+@@ -651,7 +651,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+   void OnIocpWriteableLocked(grpc_error_handle error) {
+     GRPC_TRACE_VLOG(cares_resolver, 2)
+         << "(c-ares resolver) OnIocpWriteableInner. fd:|" << GetName() << "|";
+-    CHECK(socket_type_ == SOCK_STREAM);
++    ABSL_CHECK(socket_type_ == SOCK_STREAM);
+     if (error.ok()) {
+       if (winsocket_->write_info.wsa_error != 0) {
+         error = GRPC_WSA_ERROR(winsocket_->write_info.wsa_error,
+@@ -664,7 +664,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
+             << StatusToString(error) << "|";
+       }
+     }
+-    CHECK(tcp_write_state_ == WRITE_PENDING);
++    ABSL_CHECK(tcp_write_state_ == WRITE_PENDING);
+     if (error.ok()) {
+       tcp_write_state_ = WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY;
+       write_buf_ = grpc_slice_sub_no_ref(
+@@ -725,7 +725,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
+   GrpcPolledFd* NewGrpcPolledFdLocked(
+       ares_socket_t as, grpc_pollset_set* /* driver_pollset_set */) override {
+     auto it = sockets_.find(as);
+-    CHECK(it != sockets_.end());
++    ABSL_CHECK(it != sockets_.end());
+     return it->second;
+   }
+
+@@ -776,7 +776,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
+         << "(c-ares resolver) fd:" << polled_fd->GetName()
+         << " created with params af:" << af << " type:" << type
+         << " protocol:" << protocol;
+-    CHECK(self->sockets_.insert({s, polled_fd}).second);
++    ABSL_CHECK(self->sockets_.insert({s, polled_fd}).second);
+     return s;
+   }
+
+@@ -786,7 +786,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
+     GrpcPolledFdFactoryWindows* self =
+         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
+     auto it = self->sockets_.find(as);
+-    CHECK(it != self->sockets_.end());
++    ABSL_CHECK(it != self->sockets_.end());
+     return it->second->Connect(&wsa_error_ctx, target, target_len);
+   }
+
+@@ -796,7 +796,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
+     GrpcPolledFdFactoryWindows* self =
+         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
+     auto it = self->sockets_.find(as);
+-    CHECK(it != self->sockets_.end());
++    ABSL_CHECK(it != self->sockets_.end());
+     return it->second->SendV(&wsa_error_ctx, iov, iovec_count);
+   }
+
+@@ -807,7 +807,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
+     GrpcPolledFdFactoryWindows* self =
+         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
+     auto it = self->sockets_.find(as);
+-    CHECK(it != self->sockets_.end());
++    ABSL_CHECK(it != self->sockets_.end());
+     return it->second->RecvFrom(&wsa_error_ctx, data, data_len, flags, from,
+                                 from_len);
+   }
+diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc
+index cad4cfa1918fc..e722e6595e8a2 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc
++++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc
+@@ -47,8 +47,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -215,7 +215,7 @@ static void grpc_ares_ev_driver_unref(grpc_ares_ev_driver* ev_driver)
+     GRPC_TRACE_VLOG(cares_resolver, 2)
+         << "(c-ares resolver) request:" << ev_driver->request
+         << " destroy ev_driver " << ev_driver;
+-    CHECK_EQ(ev_driver->fds, nullptr);
++    ABSL_CHECK_EQ(ev_driver->fds, nullptr);
+     ares_destroy(ev_driver->channel);
+     grpc_ares_complete_request_locked(ev_driver->request);
+     delete ev_driver;
+@@ -227,9 +227,9 @@ static void fd_node_destroy_locked(fd_node* fdn)
+   GRPC_TRACE_VLOG(cares_resolver, 2)
+       << "(c-ares resolver) request:" << fdn->ev_driver->request
+       << " delete fd: " << fdn->grpc_polled_fd->GetName();
+-  CHECK(!fdn->readable_registered);
+-  CHECK(!fdn->writable_registered);
+-  CHECK(fdn->already_shutdown);
++  ABSL_CHECK(!fdn->readable_registered);
++  ABSL_CHECK(!fdn->writable_registered);
++  ABSL_CHECK(fdn->already_shutdown);
+   delete fdn->grpc_polled_fd;
+   delete fdn;
+ }
+@@ -369,7 +369,7 @@ static void on_ares_backup_poll_alarm(void* arg, grpc_error_handle error) {
+ static void on_readable(void* arg, grpc_error_handle error) {
+   fd_node* fdn = static_cast<fd_node*>(arg);
+   grpc_core::MutexLock lock(&fdn->ev_driver->request->mu);
+-  CHECK(fdn->readable_registered);
++  ABSL_CHECK(fdn->readable_registered);
+   grpc_ares_ev_driver* ev_driver = fdn->ev_driver;
+   const ares_socket_t as = fdn->grpc_polled_fd->GetWrappedAresSocketLocked();
+   fdn->readable_registered = false;
+@@ -394,7 +394,7 @@ static void on_readable(void* arg, grpc_error_handle error) {
+ static void on_writable(void* arg, grpc_error_handle error) {
+   fd_node* fdn = static_cast<fd_node*>(arg);
+   grpc_core::MutexLock lock(&fdn->ev_driver->request->mu);
+-  CHECK(fdn->writable_registered);
++  ABSL_CHECK(fdn->writable_registered);
+   grpc_ares_ev_driver* ev_driver = fdn->ev_driver;
+   const ares_socket_t as = fdn->grpc_polled_fd->GetWrappedAresSocketLocked();
+   fdn->writable_registered = false;
+@@ -577,7 +577,7 @@ static void log_address_sorting_list(const grpc_ares_request* r,
+                                      const char* input_output_str) {
+   for (size_t i = 0; i < addresses.size(); i++) {
+     auto addr_str = grpc_sockaddr_to_string(&addresses[i].address(), true);
+-    LOG(INFO) << "(c-ares resolver) request:" << r
++    ABSL_LOG(INFO) << "(c-ares resolver) request:" << r
+               << " c-ares address sorting: " << input_output_str << "[" << i
+               << "]="
+               << (addr_str.ok() ? addr_str->c_str()
+@@ -928,13 +928,13 @@ static bool inner_resolve_as_ip_literal_locked(
+     std::unique_ptr<grpc_core::EndpointAddressesList>* addrs, std::string* host,
+     std::string* port, std::string* hostport) {
+   if (!grpc_core::SplitHostPort(name, host, port)) {
+-    LOG(ERROR) << "Failed to parse " << name
++    ABSL_LOG(ERROR) << "Failed to parse " << name
+                << " to host:port while attempting to resolve as ip literal.";
+     return false;
+   }
+   if (port->empty()) {
+     if (default_port == nullptr || strlen(default_port) == 0) {
+-      LOG(ERROR) << "No port or default port for " << name
++      ABSL_LOG(ERROR) << "No port or default port for " << name
+                  << " while attempting to resolve as ip literal.";
+       return false;
+     }
+@@ -946,7 +946,7 @@ static bool inner_resolve_as_ip_literal_locked(
+                                false /* log errors */) ||
+       grpc_parse_ipv6_hostport(hostport->c_str(), &addr,
+                                false /* log errors */)) {
+-    CHECK(*addrs == nullptr);
++    ABSL_CHECK(*addrs == nullptr);
+     *addrs = std::make_unique<EndpointAddressesList>();
+     (*addrs)->emplace_back(addr, grpc_core::ChannelArgs());
+     return true;
+@@ -968,7 +968,7 @@ static bool resolve_as_ip_literal_locked(
+ static bool target_matches_localhost_inner(const char* name, std::string* host,
+                                            std::string* port) {
+   if (!grpc_core::SplitHostPort(name, host, port)) {
+-    LOG(ERROR) << "Unable to split host and port for name: " << name;
++    ABSL_LOG(ERROR) << "Unable to split host and port for name: " << name;
+     return false;
+   }
+   return gpr_stricmp(host->c_str(), "localhost") == 0;
+@@ -987,20 +987,20 @@ static bool inner_maybe_resolve_localhost_manually_locked(
+     std::string* port) {
+   grpc_core::SplitHostPort(name, host, port);
+   if (host->empty()) {
+-    LOG(ERROR) << "Failed to parse " << name
++    ABSL_LOG(ERROR) << "Failed to parse " << name
+                << " into host:port during manual localhost resolution check.";
+     return false;
+   }
+   if (port->empty()) {
+     if (default_port == nullptr || strlen(default_port) == 0) {
+-      LOG(ERROR) << "No port or default port for " << name
++      ABSL_LOG(ERROR) << "No port or default port for " << name
+                  << " during manual localhost resolution check.";
+       return false;
+     }
+     *port = default_port;
+   }
+   if (gpr_stricmp(host->c_str(), "localhost") == 0) {
+-    CHECK(*addrs == nullptr);
++    ABSL_CHECK(*addrs == nullptr);
+     *addrs = std::make_unique<grpc_core::EndpointAddressesList>();
+     uint16_t numeric_port = grpc_strhtons(port->c_str());
+     grpc_resolved_address address;
+@@ -1199,7 +1199,7 @@ grpc_ares_request* (*grpc_dns_lookup_txt_ares)(
+     int query_timeout_ms) = grpc_dns_lookup_txt_ares_impl;
+
+ static void grpc_cancel_ares_request_impl(grpc_ares_request* r) {
+-  CHECK_NE(r, nullptr);
++  ABSL_CHECK_NE(r, nullptr);
+   grpc_core::MutexLock lock(&r->mu);
+   GRPC_TRACE_VLOG(cares_resolver, 2)
+       << "(c-ares resolver) request:" << r
+diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h
+index 272ef463ac4ab..174579b938dd5 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h
++++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h
+@@ -26,7 +26,7 @@
+ #include <memory>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/iomgr/closure.h"
+ #include "src/core/lib/iomgr/error.h"
+diff --git a/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc b/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc
+index 92fff39943fcc..a40a8fb7d1fd0 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc
++++ b/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc
+@@ -17,7 +17,7 @@
+
+ #include <memory>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "src/core/config/config_vars.h"
+ #include "src/core/lib/experiments/experiments.h"
+@@ -31,14 +31,14 @@ namespace grpc_core {
+
+ void RegisterDnsResolver(CoreConfiguration::Builder* builder) {
+ #if GRPC_IOS_EVENT_ENGINE_CLIENT
+-  VLOG(2) << "Using EventEngine dns resolver";
++  ABSL_VLOG(2) << "Using EventEngine dns resolver";
+   builder->resolver_registry()->RegisterResolverFactory(
+       std::make_unique<EventEngineClientChannelDNSResolverFactory>());
+   return;
+ #endif
+ #ifndef GRPC_DO_NOT_INSTANTIATE_POSIX_POLLER
+   if (IsEventEngineDnsEnabled()) {
+-    VLOG(2) << "Using EventEngine dns resolver";
++    ABSL_VLOG(2) << "Using EventEngine dns resolver";
+     builder->resolver_registry()->RegisterResolverFactory(
+         std::make_unique<EventEngineClientChannelDNSResolverFactory>());
+     return;
+@@ -47,14 +47,14 @@ void RegisterDnsResolver(CoreConfiguration::Builder* builder) {
+   auto resolver = ConfigVars::Get().DnsResolver();
+   // ---- Ares resolver ----
+   if (ShouldUseAresDnsResolver(resolver)) {
+-    VLOG(2) << "Using ares dns resolver";
++    ABSL_VLOG(2) << "Using ares dns resolver";
+     RegisterAresDnsResolver(builder);
+     return;
+   }
+   // ---- Native resolver ----
+   if (absl::EqualsIgnoreCase(resolver, "native") ||
+       !builder->resolver_registry()->HasResolverFactory("dns")) {
+-    VLOG(2) << "Using native dns resolver";
++    ABSL_VLOG(2) << "Using native dns resolver";
+     RegisterNativeDnsResolver(builder);
+     return;
+   }
+diff --git a/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc b/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc
+index 69fc916be9eb8..5772f5ee5303b 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc
++++ b/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc
+@@ -29,8 +29,8 @@
+
+ #include "absl/base/thread_annotations.h"
+ #include "absl/cleanup/cleanup.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+@@ -426,7 +426,7 @@ void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::
+     // Make sure field destroys before cleanup.
+     ValidationErrors::ScopedField field(&errors_, "txt lookup");
+     if (orphaned_) return;
+-    CHECK(is_txt_inflight_);
++    ABSL_CHECK(is_txt_inflight_);
+     is_txt_inflight_ = false;
+     if (!service_config.ok()) {
+       errors_.AddError(service_config.status().message());
+@@ -560,7 +560,7 @@ std::optional<Resolver::Result> EventEngineClientChannelDNSResolver::
+ bool EventEngineClientChannelDNSResolverFactory::IsValidUri(
+     const URI& uri) const {
+   if (absl::StripPrefix(uri.path(), "/").empty()) {
+-    LOG(ERROR) << "no server name supplied in dns URI";
++    ABSL_LOG(ERROR) << "no server name supplied in dns URI";
+     return false;
+   }
+   return true;
+diff --git a/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc b/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc
+index 97012d43401ad..afbbfc3f496fb 100644
+--- a/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc
++++ b/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc
+@@ -24,7 +24,7 @@
+ #include <vector>
+
+ #include "absl/functional/bind_front.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -141,11 +141,11 @@ class NativeClientChannelDNSResolverFactory final : public ResolverFactory {
+
+   bool IsValidUri(const URI& uri) const override {
+     if (GPR_UNLIKELY(!uri.authority().empty())) {
+-      LOG(ERROR) << "authority based dns uri's not supported";
++      ABSL_LOG(ERROR) << "authority based dns uri's not supported";
+       return false;
+     }
+     if (absl::StripPrefix(uri.path(), "/").empty()) {
+-      LOG(ERROR) << "no server name supplied in dns URI";
++      ABSL_LOG(ERROR) << "no server name supplied in dns URI";
+       return false;
+     }
+     return true;
+diff --git a/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc b/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc
+index aa5f46e3abdbc..a71e3b05c79a1 100644
+--- a/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc
++++ b/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc
+@@ -25,7 +25,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -45,7 +45,7 @@ EndpointAddresses::EndpointAddresses(const grpc_resolved_address& address,
+ EndpointAddresses::EndpointAddresses(
+     std::vector<grpc_resolved_address> addresses, const ChannelArgs& args)
+     : addresses_(std::move(addresses)), args_(args) {
+-  CHECK(!addresses_.empty());
++  ABSL_CHECK(!addresses_.empty());
+ }
+
+ EndpointAddresses::EndpointAddresses(const EndpointAddresses& other)
+@@ -108,7 +108,7 @@ bool EndpointAddressSet::operator==(const EndpointAddressSet& other) const {
+   if (addresses_.size() != other.addresses_.size()) return false;
+   auto other_it = other.addresses_.begin();
+   for (auto it = addresses_.begin(); it != addresses_.end(); ++it) {
+-    CHECK(other_it != other.addresses_.end());
++    ABSL_CHECK(other_it != other.addresses_.end());
+     if (it->len != other_it->len ||
+         memcmp(it->addr, other_it->addr, it->len) != 0) {
+       return false;
+diff --git a/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc b/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc
+index 68348d1ce09b7..c3e436ce74cba 100644
+--- a/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc
++++ b/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc
+@@ -25,7 +25,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/lib/channel/channel_args.h"
+@@ -94,7 +94,7 @@ void FakeResolver::StartLocked() {
+
+ void FakeResolver::RequestReresolutionLocked() {
+   // Re-resolution can't happen until after we return an initial result.
+-  CHECK(response_generator_ != nullptr);
++  ABSL_CHECK(response_generator_ != nullptr);
+   response_generator_->ReresolutionRequested();
+ }
+
+diff --git a/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc b/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc
+index 0c86c392c57d8..3b18ce028e56c 100644
+--- a/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc
++++ b/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc
+@@ -25,8 +25,8 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -122,7 +122,7 @@ GoogleCloud2ProdResolver::GoogleCloud2ProdResolver(ResolverArgs args)
+         CoreConfiguration::Get().resolver_registry().CreateResolver(
+             absl::StrCat("dns:", name_to_resolve), args.args, args.pollset_set,
+             work_serializer_, std::move(args.result_handler));
+-    CHECK(child_resolver_ != nullptr);
++    ABSL_CHECK(child_resolver_ != nullptr);
+     return;
+   }
+   // Maybe override metadata server name for testing
+@@ -141,7 +141,7 @@ GoogleCloud2ProdResolver::GoogleCloud2ProdResolver(ResolverArgs args)
+   child_resolver_ = CoreConfiguration::Get().resolver_registry().CreateResolver(
+       xds_uri, args.args, args.pollset_set, work_serializer_,
+       std::move(args.result_handler));
+-  CHECK(child_resolver_ != nullptr);
++  ABSL_CHECK(child_resolver_ != nullptr);
+ }
+
+ void GoogleCloud2ProdResolver::StartLocked() {
+@@ -278,7 +278,7 @@ class GoogleCloud2ProdResolverFactory final : public ResolverFactory {
+
+   bool IsValidUri(const URI& uri) const override {
+     if (GPR_UNLIKELY(!uri.authority().empty())) {
+-      LOG(ERROR) << "google-c2p URI scheme does not support authorities";
++      ABSL_LOG(ERROR) << "google-c2p URI scheme does not support authorities";
+       return false;
+     }
+     return true;
+@@ -301,7 +301,7 @@ class ExperimentalGoogleCloud2ProdResolverFactory final
+
+   bool IsValidUri(const URI& uri) const override {
+     if (GPR_UNLIKELY(!uri.authority().empty())) {
+-      LOG(ERROR) << "google-c2p-experimental URI scheme does not support "
++      ABSL_LOG(ERROR) << "google-c2p-experimental URI scheme does not support "
+                     "authorities";
+       return false;
+     }
+diff --git a/third_party/grpc/source/src/core/resolver/polling_resolver.cc b/third_party/grpc/source/src/core/resolver/polling_resolver.cc
+index 55576591fff93..dc5193f4c7e17 100644
+--- a/third_party/grpc/source/src/core/resolver/polling_resolver.cc
++++ b/third_party/grpc/source/src/core/resolver/polling_resolver.cc
+@@ -24,8 +24,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -58,13 +58,13 @@ PollingResolver::PollingResolver(ResolverArgs args,
+       min_time_between_resolutions_(min_time_between_resolutions),
+       backoff_(backoff_options) {
+   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-    LOG(INFO) << "[polling resolver " << this << "] created";
++    ABSL_LOG(INFO) << "[polling resolver " << this << "] created";
+   }
+ }
+
+ PollingResolver::~PollingResolver() {
+   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-    LOG(INFO) << "[polling resolver " << this << "] destroying";
++    ABSL_LOG(INFO) << "[polling resolver " << this << "] destroying";
+   }
+ }
+
+@@ -95,7 +95,7 @@ void PollingResolver::ResetBackoffLocked() {
+
+ void PollingResolver::ShutdownLocked() {
+   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-    LOG(INFO) << "[polling resolver " << this << "] shutting down";
++    ABSL_LOG(INFO) << "[polling resolver " << this << "] shutting down";
+   }
+   shutdown_ = true;
+   MaybeCancelNextResolutionTimer();
+@@ -116,7 +116,7 @@ void PollingResolver::ScheduleNextResolutionTimer(Duration delay) {
+
+ void PollingResolver::OnNextResolutionLocked() {
+   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-    LOG(INFO) << "[polling resolver " << this
++    ABSL_LOG(INFO) << "[polling resolver " << this
+               << "] re-resolution timer fired: shutdown_=" << shutdown_;
+   }
+   // If we haven't been cancelled nor shutdown, then start resolving.
+@@ -129,7 +129,7 @@ void PollingResolver::OnNextResolutionLocked() {
+ void PollingResolver::MaybeCancelNextResolutionTimer() {
+   if (next_resolution_timer_handle_.has_value()) {
+     if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-      LOG(INFO) << "[polling resolver " << this
++      ABSL_LOG(INFO) << "[polling resolver " << this
+                 << "] cancel re-resolution timer";
+     }
+     channel_args_.GetObject<EventEngine>()->Cancel(
+@@ -146,12 +146,12 @@ void PollingResolver::OnRequestComplete(Result result) {
+
+ void PollingResolver::OnRequestCompleteLocked(Result result) {
+   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-    LOG(INFO) << "[polling resolver " << this << "] request complete";
++    ABSL_LOG(INFO) << "[polling resolver " << this << "] request complete";
+   }
+   request_.reset();
+   if (!shutdown_) {
+     if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-      LOG(INFO)
++      ABSL_LOG(INFO)
+           << "[polling resolver " << this << "] returning result: addresses="
+           << (result.addresses.ok()
+                   ? absl::StrCat("<", result.addresses->size(), " addresses>")
+@@ -165,7 +165,7 @@ void PollingResolver::OnRequestCompleteLocked(Result result) {
+                   : result.service_config.status().ToString())
+           << ", resolution_note=" << result.resolution_note;
+     }
+-    CHECK(result.result_health_callback == nullptr);
++    ABSL_CHECK(result.result_health_callback == nullptr);
+     result.result_health_callback =
+         [self = RefAsSubclass<PollingResolver>(
+              DEBUG_LOCATION, "result_health_callback")](absl::Status status) {
+@@ -179,7 +179,7 @@ void PollingResolver::OnRequestCompleteLocked(Result result) {
+
+ void PollingResolver::GetResultStatus(absl::Status status) {
+   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-    LOG(INFO) << "[polling resolver " << this
++    ABSL_LOG(INFO) << "[polling resolver " << this
+               << "] result status from channel: " << status;
+   }
+   if (status.ok()) {
+@@ -195,9 +195,9 @@ void PollingResolver::GetResultStatus(absl::Status status) {
+   } else {
+     // Set up for retry.
+     const Duration delay = backoff_.NextAttemptDelay();
+-    CHECK(!next_resolution_timer_handle_.has_value());
++    ABSL_CHECK(!next_resolution_timer_handle_.has_value());
+     if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+-      LOG(INFO) << "[polling resolver " << this << "] retrying in "
++      ABSL_LOG(INFO) << "[polling resolver " << this << "] retrying in "
+                 << delay.millis() << " ms";
+     }
+     ScheduleNextResolutionTimer(delay);
+@@ -225,7 +225,7 @@ void PollingResolver::MaybeStartResolvingLocked() {
+       if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+         const Duration last_resolution_ago =
+             Timestamp::Now() - *last_resolution_timestamp_;
+-        LOG(INFO) << "[polling resolver " << this
++        ABSL_LOG(INFO) << "[polling resolver " << this
+                   << "] in cooldown from last resolution (from "
+                   << last_resolution_ago.millis()
+                   << " ms ago); will resolve again in "
+@@ -243,10 +243,10 @@ void PollingResolver::StartResolvingLocked() {
+   last_resolution_timestamp_ = Timestamp::Now();
+   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
+     if (request_ != nullptr) {
+-      LOG(INFO) << "[polling resolver " << this
++      ABSL_LOG(INFO) << "[polling resolver " << this
+                 << "] starting resolution, request_=" << request_.get();
+     } else {
+-      LOG(INFO) << "[polling resolver " << this << "] StartRequest failed";
++      ABSL_LOG(INFO) << "[polling resolver " << this << "] StartRequest failed";
+     }
+   }
+ }
+diff --git a/third_party/grpc/source/src/core/resolver/resolver_registry.cc b/third_party/grpc/source/src/core/resolver/resolver_registry.cc
+index ccc5e8506817c..ae442021f274f 100644
+--- a/third_party/grpc/source/src/core/resolver/resolver_registry.cc
++++ b/third_party/grpc/source/src/core/resolver/resolver_registry.cc
+@@ -18,8 +18,8 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/ascii.h"
+@@ -51,10 +51,10 @@ bool IsLowerCase(absl::string_view str) {
+
+ void ResolverRegistry::Builder::RegisterResolverFactory(
+     std::unique_ptr<ResolverFactory> factory) {
+-  CHECK(IsLowerCase(factory->scheme())) << factory->scheme();
++  ABSL_CHECK(IsLowerCase(factory->scheme())) << factory->scheme();
+   auto [_, inserted] =
+       state_.factories.try_emplace(factory->scheme(), std::move(factory));
+-  CHECK(inserted) << "scheme " << factory->scheme() << " already registered";
++  ABSL_CHECK(inserted) << "scheme " << factory->scheme() << " already registered";
+ }
+
+ bool ResolverRegistry::Builder::HasResolverFactory(
+@@ -132,7 +132,7 @@ ResolverFactory* ResolverRegistry::LookupResolverFactory(
+ // point to the parsed URI.
+ ResolverFactory* ResolverRegistry::FindResolverFactory(
+     absl::string_view target, URI* uri, std::string* canonical_target) const {
+-  CHECK_NE(uri, nullptr);
++  ABSL_CHECK_NE(uri, nullptr);
+   absl::StatusOr<URI> tmp_uri = URI::Parse(target);
+   ResolverFactory* factory =
+       tmp_uri.ok() ? LookupResolverFactory(tmp_uri->scheme()) : nullptr;
+@@ -148,12 +148,12 @@ ResolverFactory* ResolverRegistry::FindResolverFactory(
+     return factory;
+   }
+   if (!tmp_uri.ok() || !tmp_uri2.ok()) {
+-    LOG(ERROR) << "Error parsing URI(s). '" << target
++    ABSL_LOG(ERROR) << "Error parsing URI(s). '" << target
+                << "':" << tmp_uri.status() << "; '" << *canonical_target
+                << "':" << tmp_uri2.status();
+     return nullptr;
+   }
+-  LOG(ERROR) << "Don't know how to resolve '" << target << "' or '"
++  ABSL_LOG(ERROR) << "Don't know how to resolve '" << target << "' or '"
+              << *canonical_target << "'.";
+   return nullptr;
+ }
+diff --git a/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc b/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc
+index 0e433d29ad051..bfae1d88468a0 100644
+--- a/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc
++++ b/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc
+@@ -21,7 +21,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_split.h"
+ #include "absl/strings/string_view.h"
+@@ -75,7 +75,7 @@ bool ParseUri(const URI& uri,
+               bool parse(const URI& uri, grpc_resolved_address* dst),
+               EndpointAddressesList* addresses) {
+   if (!uri.authority().empty()) {
+-    LOG(ERROR) << "authority-based URIs not supported by the " << uri.scheme()
++    ABSL_LOG(ERROR) << "authority-based URIs not supported by the " << uri.scheme()
+                << " scheme";
+     return false;
+   }
+diff --git a/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc b/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc
+index 61b61875f24a4..199ad6d81e327 100644
+--- a/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc
++++ b/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc
+@@ -18,8 +18,8 @@
+
+ #include <set>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_join.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/load_balancing/xds/xds_channel_args.h"
+@@ -652,7 +652,7 @@ bool XdsDependencyManager::PopulateClusterConfigMap(
+     std::set<absl::string_view>* eds_resources_seen,
+     std::set<absl::string_view>* dns_names_seen,
+     absl::StatusOr<std::vector<absl::string_view>>* leaf_clusters) {
+-  if (depth > 0) CHECK_NE(leaf_clusters, nullptr);
++  if (depth > 0) ABSL_CHECK_NE(leaf_clusters, nullptr);
+   if (depth == kMaxXdsAggregateClusterRecursionDepth) {
+     *leaf_clusters =
+         absl::UnavailableError("aggregate cluster graph exceeds max depth");
+diff --git a/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc b/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc
+index 27172e69a704a..3dcb7fb04bd64 100644
+--- a/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc
++++ b/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc
+@@ -32,8 +32,8 @@
+ #include <variant>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/meta/type_traits.h"
+ #include "absl/random/random.h"
+ #include "absl/status/status.h"
+@@ -620,7 +620,7 @@ XdsResolver::XdsConfigSelector::XdsConfigSelector(
+     const XdsHttpFilterImpl* filter_impl =
+         http_filter_registry.GetFilterForType(
+             http_filter.config.config_proto_type_name);
+-    CHECK_NE(filter_impl, nullptr);
++    ABSL_CHECK_NE(filter_impl, nullptr);
+     // Add filter to list.
+     filters_.push_back(filter_impl);
+   }
+@@ -660,7 +660,7 @@ std::optional<uint64_t> HeaderHashHelper(
+ absl::Status XdsResolver::XdsConfigSelector::GetCallConfig(
+     GetCallConfigArgs args) {
+   Slice* path = args.initial_metadata->get_pointer(HttpPathMetadata());
+-  CHECK_NE(path, nullptr);
++  ABSL_CHECK_NE(path, nullptr);
+   auto* entry = route_config_data_->GetRouteForRequest(path->as_string_view(),
+                                                        args.initial_metadata);
+   if (entry == nullptr) {
+@@ -708,7 +708,7 @@ absl::Status XdsResolver::XdsConfigSelector::GetCallConfig(
+           }
+         }
+         if (index == 0) index = start_index;
+-        CHECK(entry->weighted_cluster_state[index].range_end > key);
++        ABSL_CHECK(entry->weighted_cluster_state[index].range_end > key);
+         cluster_name = absl::StrCat(
+             "cluster:", entry->weighted_cluster_state[index].cluster);
+         method_config = entry->weighted_cluster_state[index].method_config;
+@@ -722,7 +722,7 @@ absl::Status XdsResolver::XdsConfigSelector::GetCallConfig(
+         method_config = entry->method_config;
+       });
+   auto cluster = route_config_data_->FindClusterRef(cluster_name);
+-  CHECK(cluster != nullptr);
++  ABSL_CHECK(cluster != nullptr);
+   // Generate a hash.
+   std::optional<uint64_t> hash;
+   for (const auto& hash_policy : route_action->hash_policies) {
+@@ -842,7 +842,7 @@ void XdsResolver::ClusterSelectionFilter::Call::OnClientInitialMetadata(
+     ClientMetadata&) {
+   auto* service_config_call_data =
+       GetContext<ClientChannelServiceConfigCallData>();
+-  CHECK_NE(service_config_call_data, nullptr);
++  ABSL_CHECK_NE(service_config_call_data, nullptr);
+   auto* route_state_attribute = static_cast<XdsRouteStateAttributeImpl*>(
+       service_config_call_data->GetCallAttribute<XdsRouteStateAttribute>());
+   auto* cluster_name_attribute =
+@@ -865,7 +865,7 @@ void XdsResolver::StartLocked() {
+   auto xds_client =
+       GrpcXdsClient::GetOrCreate(uri_.ToString(), args_, "xds resolver");
+   if (!xds_client.ok()) {
+-    LOG(ERROR) << "Failed to create xds client -- channel will remain in "
++    ABSL_LOG(ERROR) << "Failed to create xds client -- channel will remain in "
+                   "TRANSIENT_FAILURE: "
+                << xds_client.status();
+     absl::Status status = absl::UnavailableError(absl::StrCat(
+@@ -949,7 +949,7 @@ void XdsResolver::OnUpdate(
+       << "[xds_resolver " << this << "] received updated xDS config";
+   if (xds_client_ == nullptr) return;
+   if (!config.ok()) {
+-    LOG(ERROR) << "[xds_resolver " << this << "] config error ("
++    ABSL_LOG(ERROR) << "[xds_resolver " << this << "] config error ("
+                << config.status()
+                << ") -- clearing update and returning empty service config";
+     current_config_.reset();
+@@ -1047,7 +1047,7 @@ void XdsResolver::GenerateErrorResult(std::string error) {
+   Result result;
+   result.addresses.emplace();
+   result.service_config = ServiceConfigImpl::Create(args_, "{}");
+-  CHECK(result.service_config.ok());
++  ABSL_CHECK(result.service_config.ok());
+   result.resolution_note = std::move(error);
+   result.args = args_;
+   result_handler_->ReportResult(std::move(result));
+@@ -1077,7 +1077,7 @@ class XdsResolverFactory final : public ResolverFactory {
+
+   bool IsValidUri(const URI& uri) const override {
+     if (uri.path().empty() || uri.path().back() == '/') {
+-      LOG(ERROR) << "URI path does not contain valid data plane authority";
++      ABSL_LOG(ERROR) << "URI path does not contain valid data plane authority";
+       return false;
+     }
+     return true;
+diff --git a/third_party/grpc/source/src/core/server/server.cc b/third_party/grpc/source/src/core/server/server.cc
+index c6691b4edfe47..8495d3190d640 100644
+--- a/third_party/grpc/source/src/core/server/server.cc
++++ b/third_party/grpc/source/src/core/server/server.cc
+@@ -41,8 +41,8 @@
+
+ #include "absl/cleanup/cleanup.h"
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/channelz/channel_trace.h"
+ #include "src/core/channelz/channelz.h"
+@@ -170,7 +170,7 @@ void Server::ListenerState::Stop() {
+       is_serving_ = false;
+     }
+     if (config_fetcher_watcher_ != nullptr) {
+-      CHECK_NE(server_->config_fetcher(), nullptr);
++      ABSL_CHECK_NE(server_->config_fetcher(), nullptr);
+       server_->config_fetcher()->CancelWatch(config_fetcher_watcher_);
+     }
+   }
+@@ -503,7 +503,7 @@ struct Server::RequestedCall {
+         md.get(GrpcTimeoutMetadata()).value_or(Timestamp::InfFuture());
+     switch (type) {
+       case RequestedCall::Type::BATCH_CALL:
+-        CHECK(!payload.has_value());
++        ABSL_CHECK(!payload.has_value());
+         data.batch.details->host =
+             CSliceRef(md.get_pointer(HttpAuthorityMetadata())->c_slice());
+         data.batch.details->method =
+@@ -560,10 +560,10 @@ class Server::RealRequestMatcher : public RequestMatcherInterface {
+
+   ~RealRequestMatcher() override {
+     for (LockedMultiProducerSingleConsumerQueue& queue : requests_per_cq_) {
+-      CHECK_EQ(queue.Pop(), nullptr);
++      ABSL_CHECK_EQ(queue.Pop(), nullptr);
+     }
+-    CHECK(pending_filter_stack_.empty());
+-    CHECK(pending_promises_.empty());
++    ABSL_CHECK(pending_filter_stack_.empty());
++    ABSL_CHECK(pending_promises_.empty());
+   }
+
+   void ZombifyPending() override {
+@@ -787,7 +787,7 @@ class Server::RealRequestMatcher : public RequestMatcherInterface {
+       if (!result.compare_exchange_strong(expected, new_value,
+                                           std::memory_order_acq_rel,
+                                           std::memory_order_acquire)) {
+-        CHECK(new_value->value().TakeCall() == requested_call);
++        ABSL_CHECK(new_value->value().TakeCall() == requested_call);
+         delete new_value;
+         return false;
+       }
+@@ -822,7 +822,7 @@ class Server::AllocatingRequestMatcherBase : public RequestMatcherInterface {
+         break;
+       }
+     }
+-    CHECK(idx < server->cqs_.size());
++    ABSL_CHECK(idx < server->cqs_.size());
+     cq_idx_ = idx;
+   }
+
+@@ -868,7 +868,7 @@ class Server::AllocatingRequestMatcherBatch
+         absl::MakeCleanup([this] { server()->ShutdownUnrefOnRequest(); });
+     if (still_running) {
+       BatchCallAllocation call_info = allocator_();
+-      CHECK(server()->ValidateServerRequest(cq(),
++      ABSL_CHECK(server()->ValidateServerRequest(cq(),
+                                             static_cast<void*>(call_info.tag),
+                                             nullptr, nullptr) == GRPC_CALL_OK);
+       RequestedCall* rc = new RequestedCall(
+@@ -884,7 +884,7 @@ class Server::AllocatingRequestMatcherBatch
+   ArenaPromise<absl::StatusOr<MatchResult>> MatchRequest(
+       size_t /*start_request_queue_index*/) override {
+     BatchCallAllocation call_info = allocator_();
+-    CHECK(server()->ValidateServerRequest(cq(),
++    ABSL_CHECK(server()->ValidateServerRequest(cq(),
+                                           static_cast<void*>(call_info.tag),
+                                           nullptr, nullptr) == GRPC_CALL_OK);
+     RequestedCall* rc = new RequestedCall(
+@@ -914,7 +914,7 @@ class Server::AllocatingRequestMatcherRegistered
+         absl::MakeCleanup([this] { server()->ShutdownUnrefOnRequest(); });
+     if (server()->ShutdownRefOnRequest()) {
+       RegisteredCallAllocation call_info = allocator_();
+-      CHECK(server()->ValidateServerRequest(
++      ABSL_CHECK(server()->ValidateServerRequest(
+                 cq(), call_info.tag, call_info.optional_payload,
+                 registered_method_) == GRPC_CALL_OK);
+       RequestedCall* rc =
+@@ -931,7 +931,7 @@ class Server::AllocatingRequestMatcherRegistered
+   ArenaPromise<absl::StatusOr<MatchResult>> MatchRequest(
+       size_t /*start_request_queue_index*/) override {
+     RegisteredCallAllocation call_info = allocator_();
+-    CHECK(server()->ValidateServerRequest(cq(), call_info.tag,
++    ABSL_CHECK(server()->ValidateServerRequest(cq(), call_info.tag,
+                                           call_info.optional_payload,
+                                           registered_method_) == GRPC_CALL_OK);
+     RequestedCall* rc = new RequestedCall(
+@@ -958,7 +958,7 @@ class ChannelBroadcaster {
+
+   // Copies over the channels from the locked server.
+   void FillChannelsLocked(std::vector<RefCountedPtr<Channel>> channels) {
+-    DCHECK(channels_.empty());
++    ABSL_DCHECK(channels_.empty());
+     channels_ = std::move(channels);
+   }
+
+@@ -1270,15 +1270,15 @@ grpc_error_handle Server::SetupTransport(
+     connections_.emplace(std::move(t));
+     ++connections_open_;
+   } else {
+-    CHECK(transport->filter_stack_transport() != nullptr);
++    ABSL_CHECK(transport->filter_stack_transport() != nullptr);
+     absl::StatusOr<RefCountedPtr<Channel>> channel = LegacyChannel::Create(
+         "", args.SetObject(transport), GRPC_SERVER_CHANNEL);
+     if (!channel.ok()) {
+       return absl_status_to_grpc_error(channel.status());
+     }
+-    CHECK(*channel != nullptr);
++    ABSL_CHECK(*channel != nullptr);
+     auto* channel_stack = (*channel)->channel_stack();
+-    CHECK(channel_stack != nullptr);
++    ABSL_CHECK(channel_stack != nullptr);
+     ChannelData* chand = static_cast<ChannelData*>(
+         grpc_channel_stack_element(channel_stack, 0)->channel_data);
+     // Set up CQs.
+@@ -1317,7 +1317,7 @@ void Server::SetRegisteredMethodAllocator(
+
+ void Server::SetBatchMethodAllocator(
+     grpc_completion_queue* cq, std::function<BatchCallAllocation()> allocator) {
+-  DCHECK(unregistered_request_matcher_ == nullptr);
++  ABSL_DCHECK(unregistered_request_matcher_ == nullptr);
+   unregistered_request_matcher_ =
+       std::make_unique<AllocatingRequestMatcherBatch>(this, cq,
+                                                       std::move(allocator));
+@@ -1340,17 +1340,17 @@ Server::RegisteredMethod* Server::RegisterMethod(
+   }
+
+   if (!method) {
+-    LOG(ERROR) << "grpc_server_register_method method string cannot be NULL";
++    ABSL_LOG(ERROR) << "grpc_server_register_method method string cannot be NULL";
+     return nullptr;
+   }
+   auto key = std::make_pair(host ? host : "", method);
+   if (registered_methods_.find(key) != registered_methods_.end()) {
+-    LOG(ERROR) << "duplicate registration for " << method << "@"
++    ABSL_LOG(ERROR) << "duplicate registration for " << method << "@"
+                << (host ? host : "*");
+     return nullptr;
+   }
+   if (flags != 0) {
+-    LOG(ERROR) << "grpc_server_register_method invalid flags "
++    ABSL_LOG(ERROR) << "grpc_server_register_method invalid flags "
+                << absl::StrFormat("0x%08x", flags);
+     return nullptr;
+   }
+@@ -1368,7 +1368,7 @@ void Server::FailCall(size_t cq_idx, RequestedCall* rc,
+                       grpc_error_handle error) {
+   *rc->call = nullptr;
+   rc->initial_metadata->count = 0;
+-  CHECK(!error.ok());
++  ABSL_CHECK(!error.ok());
+   grpc_cq_end_op(cqs_[cq_idx], rc->tag, error, DoneRequestEvent, rc,
+                  &rc->completion);
+ }
+@@ -1389,7 +1389,7 @@ void Server::MaybeFinishShutdown() {
+                                   last_shutdown_message_time_),
+                      gpr_time_from_seconds(1, GPR_TIMESPAN)) >= 0) {
+       last_shutdown_message_time_ = gpr_now(GPR_CLOCK_REALTIME);
+-      VLOG(2) << "Waiting for " << channels_.size() << " channels "
++      ABSL_VLOG(2) << "Waiting for " << channels_.size() << " channels "
+               << connections_open_ << " connections and "
+               << listener_states_.size() - listeners_destroyed_ << "/"
+               << listener_states_.size()
+@@ -1464,7 +1464,7 @@ void Server::ShutdownAndNotify(grpc_completion_queue* cq, void* tag) {
+       starting_cv_.Wait(&mu_global_);
+     }
+     // Stay locked, and gather up some stuff to do.
+-    CHECK(grpc_cq_begin_op(cq, tag));
++    ABSL_CHECK(grpc_cq_begin_op(cq, tag));
+     if (shutdown_published_) {
+       grpc_cq_end_op(cq, tag, absl::OkStatus(), DonePublishedShutdown, nullptr,
+                      new grpc_cq_completion);
+@@ -1523,8 +1523,8 @@ void Server::SendGoaways() {
+ void Server::Orphan() {
+   {
+     MutexLock lock(&mu_global_);
+-    CHECK(ShutdownCalled() || listener_states_.empty());
+-    CHECK(listeners_destroyed_ == listener_states_.size());
++    ABSL_CHECK(ShutdownCalled() || listener_states_.empty());
++    ABSL_CHECK(listeners_destroyed_ == listener_states_.size());
+   }
+   listener_states_.clear();
+   Unref();
+@@ -1677,7 +1677,7 @@ void Server::ChannelData::InitTransport(RefCountedPtr<Server> server,
+   }
+   // Start accept_stream transport op.
+   grpc_transport_op* op = grpc_make_transport_op(nullptr);
+-  CHECK(transport->filter_stack_transport() != nullptr);
++  ABSL_CHECK(transport->filter_stack_transport() != nullptr);
+   op->set_accept_stream = true;
+   op->set_accept_stream_fn = AcceptStream;
+   op->set_registered_method_matcher_fn = [](void* arg,
+@@ -1745,7 +1745,7 @@ void Server::ChannelData::AcceptStream(void* arg, Transport* /*transport*/,
+   grpc_call* call;
+   grpc_error_handle error = grpc_call_create(&args, &call);
+   grpc_call_stack* call_stack = grpc_call_get_call_stack(call);
+-  CHECK_NE(call_stack, nullptr);
++  ABSL_CHECK_NE(call_stack, nullptr);
+   grpc_call_element* elem = grpc_call_stack_element(call_stack, 0);
+   auto* calld = static_cast<Server::CallData*>(elem->call_data);
+   if (!error.ok()) {
+@@ -1767,7 +1767,7 @@ void Server::ChannelData::FinishDestroy(void* arg,
+
+ void Server::ChannelData::Destroy() {
+   if (!list_position_.has_value()) return;
+-  CHECK(server_ != nullptr);
++  ABSL_CHECK(server_ != nullptr);
+   server_->channels_.erase(*list_position_);
+   list_position_.reset();
+   server_->Ref().release();
+@@ -1787,8 +1787,8 @@ void Server::ChannelData::Destroy() {
+
+ grpc_error_handle Server::ChannelData::InitChannelElement(
+     grpc_channel_element* elem, grpc_channel_element_args* args) {
+-  CHECK(args->is_first);
+-  CHECK(!args->is_last);
++  ABSL_CHECK(args->is_first);
++  ABSL_CHECK(!args->is_last);
+   new (elem->channel_data) ChannelData();
+   return absl::OkStatus();
+ }
+@@ -1815,7 +1815,7 @@ Server::CallData::CallData(grpc_call_element* elem,
+ }
+
+ Server::CallData::~CallData() {
+-  CHECK(state_.load(std::memory_order_relaxed) != CallState::PENDING);
++  ABSL_CHECK(state_.load(std::memory_order_relaxed) != CallState::PENDING);
+   grpc_metadata_array_destroy(&initial_metadata_);
+   grpc_byte_buffer_destroy(payload_);
+ }
+@@ -1866,8 +1866,8 @@ void Server::CallData::Publish(size_t cq_idx, RequestedCall* rc) {
+   std::swap(*rc->initial_metadata, initial_metadata_);
+   switch (rc->type) {
+     case RequestedCall::Type::BATCH_CALL:
+-      CHECK(host_.has_value());
+-      CHECK(path_.has_value());
++      ABSL_CHECK(host_.has_value());
++      ABSL_CHECK(path_.has_value());
+       rc->data.batch.details->host = CSliceRef(host_->c_slice());
+       rc->data.batch.details->method = CSliceRef(path_->c_slice());
+       rc->data.batch.details->deadline =
+@@ -1959,7 +1959,7 @@ void Server::CallData::RecvInitialMetadataBatchComplete(
+   grpc_call_element* elem = static_cast<grpc_call_element*>(arg);
+   auto* calld = static_cast<Server::CallData*>(elem->call_data);
+   if (!error.ok()) {
+-    VLOG(2) << "Failed call creation: " << StatusToString(error);
++    ABSL_VLOG(2) << "Failed call creation: " << StatusToString(error);
+     calld->FailCallCreation();
+     return;
+   }
+@@ -2081,10 +2081,10 @@ void grpc_server_register_completion_queue(grpc_server* server,
+   GRPC_TRACE_LOG(api, INFO)
+       << "grpc_server_register_completion_queue(server=" << server
+       << ", cq=" << cq << ", reserved=" << reserved << ")";
+-  CHECK(!reserved);
++  ABSL_CHECK(!reserved);
+   auto cq_type = grpc_get_cq_completion_type(cq);
+   if (cq_type != GRPC_CQ_NEXT && cq_type != GRPC_CQ_CALLBACK) {
+-    VLOG(2) << "Completion queue of type " << static_cast<int>(cq_type)
++    ABSL_VLOG(2) << "Completion queue of type " << static_cast<int>(cq_type)
+             << " is being registered as a server-completion-queue";
+     // Ideally we should log an error and abort but ruby-wrapped-language API
+     // calls grpc_completion_queue_pluck() on server completion queues
+diff --git a/third_party/grpc/source/src/core/server/server_config_selector_filter.cc b/third_party/grpc/source/src/core/server/server_config_selector_filter.cc
+index 33b4335ead09c..20198942fa233 100644
+--- a/third_party/grpc/source/src/core/server/server_config_selector_filter.cc
++++ b/third_party/grpc/source/src/core/server/server_config_selector_filter.cc
+@@ -22,7 +22,7 @@
+ #include <utility>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/lib/channel/channel_args.h"
+@@ -123,7 +123,7 @@ ServerConfigSelectorFilter::ServerConfigSelectorFilter(
+     RefCountedPtr<ServerConfigSelectorProvider> server_config_selector_provider)
+     : server_config_selector_provider_(
+           std::move(server_config_selector_provider)) {
+-  CHECK(server_config_selector_provider_ != nullptr);
++  ABSL_CHECK(server_config_selector_provider_ != nullptr);
+   auto server_config_selector_watcher =
+       std::make_unique<ServerConfigSelectorWatcher>(Ref());
+   auto config_selector = server_config_selector_provider_->Watch(
+diff --git a/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc b/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc
+index 415d73fc93453..930c78e946efd 100644
+--- a/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc
++++ b/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc
+@@ -35,8 +35,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+@@ -396,7 +396,7 @@ class XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
+   absl::StatusOr<RefCountedPtr<ServerConfigSelector>> Watch(
+       std::unique_ptr<ServerConfigSelectorProvider::ServerConfigSelectorWatcher>
+           watcher) override {
+-    CHECK(watcher_ == nullptr);
++    ABSL_CHECK(watcher_ == nullptr);
+     watcher_ = std::move(watcher);
+     if (!static_resource_.ok()) {
+       return static_resource_.status();
+@@ -504,7 +504,7 @@ XdsServerConfigFetcher::XdsServerConfigFetcher(
+     RefCountedPtr<GrpcXdsClient> xds_client,
+     grpc_server_xds_status_notifier notifier)
+     : xds_client_(std::move(xds_client)), serving_status_notifier_(notifier) {
+-  CHECK(xds_client_ != nullptr);
++  ABSL_CHECK(xds_client_ != nullptr);
+ }
+
+ std::string ListenerResourceName(absl::string_view resource_name_template,
+@@ -614,7 +614,7 @@ void XdsServerConfigFetcher::ListenerWatcher::OnResourceChanged(
+
+ void XdsServerConfigFetcher::ListenerWatcher::OnAmbientError(
+     absl::Status status, RefCountedPtr<ReadDelayHandle> /*read_delay_handle*/) {
+-  LOG(ERROR) << "ListenerWatcher:" << this
++  ABSL_LOG(ERROR) << "ListenerWatcher:" << this
+              << " XdsClient reports ambient error: " << status << " for "
+              << listening_address_
+              << "; ignoring in favor of existing resource";
+@@ -635,7 +635,7 @@ void XdsServerConfigFetcher::ListenerWatcher::OnFatalError(
+         {static_cast<grpc_status_code>(status.raw_code()),
+          std::string(status.message()).c_str()});
+   } else {
+-    LOG(ERROR) << "ListenerWatcher:" << this << " Encountered fatal error "
++    ABSL_LOG(ERROR) << "ListenerWatcher:" << this << " Encountered fatal error "
+                << status << "; not serving on " << listening_address_;
+   }
+ }
+@@ -664,7 +664,7 @@ void XdsServerConfigFetcher::ListenerWatcher::
+           serving_status_notifier_.user_data, listening_address_.c_str(),
+           {GRPC_STATUS_OK, ""});
+     } else {
+-      LOG(INFO) << "xDS Listener resource obtained; will start serving on "
++      ABSL_LOG(INFO) << "xDS Listener resource obtained; will start serving on "
+                 << listening_address_;
+     }
+   }
+@@ -844,7 +844,7 @@ void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
+
+ void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
+     OnAmbientError(const std::string& resource_name, absl::Status status) {
+-  LOG(ERROR) << "RouteConfigWatcher:" << this
++  ABSL_LOG(ERROR) << "RouteConfigWatcher:" << this
+              << " XdsClient reports ambient error: " << status << " for "
+              << resource_name << "; ignoring in favor of existing resource";
+ }
+@@ -928,7 +928,7 @@ const XdsListenerResource::FilterChainData* FindFilterChainDataForSourceType(
+   }
+   auto source_addr = StringToSockaddr(host, 0);  // Port doesn't matter here.
+   if (!source_addr.ok()) {
+-    VLOG(2) << "Could not parse \"" << host
++    ABSL_VLOG(2) << "Could not parse \"" << host
+             << "\" as socket address: " << source_addr.status();
+     return nullptr;
+   }
+@@ -977,7 +977,7 @@ const XdsListenerResource::FilterChainData* FindFilterChainDataForDestinationIp(
+   auto destination_addr =
+       StringToSockaddr(host, 0);  // Port doesn't matter here.
+   if (!destination_addr.ok()) {
+-    VLOG(2) << "Could not parse \"" << host
++    ABSL_VLOG(2) << "Could not parse \"" << host
+             << "\" as socket address: " << destination_addr.status();
+     return nullptr;
+   }
+@@ -1035,7 +1035,7 @@ absl::StatusOr<ChannelArgs> XdsServerConfigFetcher::ListenerWatcher::
+     const XdsHttpFilterImpl* filter_impl =
+         http_filter_registry.GetFilterForType(
+             http_filter.config.config_proto_type_name);
+-    CHECK_NE(filter_impl, nullptr);
++    ABSL_CHECK_NE(filter_impl, nullptr);
+     // Some filters like the router filter are no-op filters and do not have
+     // an implementation.
+     if (filter_impl->channel_filter() != nullptr) {
+@@ -1084,7 +1084,7 @@ absl::StatusOr<ChannelArgs> XdsServerConfigFetcher::ListenerWatcher::
+       return result.status();
+     }
+     xds_certificate_provider = std::move(*result);
+-    CHECK(xds_certificate_provider != nullptr);
++    ABSL_CHECK(xds_certificate_provider != nullptr);
+     args = args.SetObject(xds_certificate_provider);
+   }
+   return args;
+@@ -1202,7 +1202,7 @@ XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
+       resource_name_(std::move(resource_name)),
+       http_filters_(std::move(http_filters)),
+       resource_(std::move(initial_resource)) {
+-  CHECK(!resource_name_.empty());
++  ABSL_CHECK(!resource_name_.empty());
+   // RouteConfigWatcher is being created here instead of in Watch() to avoid
+   // deadlocks from invoking XdsRouteConfigResourceType::StartWatch whilst in a
+   // critical region.
+@@ -1229,7 +1229,7 @@ XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
+   absl::StatusOr<std::shared_ptr<const XdsRouteConfigResource>> resource;
+   {
+     MutexLock lock(&mu_);
+-    CHECK(watcher_ == nullptr);
++    ABSL_CHECK(watcher_ == nullptr);
+     watcher_ = std::move(watcher);
+     resource = resource_;
+   }
+@@ -1278,7 +1278,7 @@ void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
+ void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
+     DynamicXdsServerConfigSelectorProvider::OnAmbientError(
+         absl::Status status) {
+-  LOG(ERROR) << "RouteConfigWatcher:" << this
++  ABSL_LOG(ERROR) << "RouteConfigWatcher:" << this
+              << " XdsClient reports ambient error: " << status << " for "
+              << resource_name_ << "; ignoring in favor of existing resource";
+ }
+@@ -1302,14 +1302,14 @@ grpc_server_config_fetcher* grpc_server_config_fetcher_xds_create(
+       grpc_core::GrpcXdsClient::kServerKey, channel_args,
+       "XdsServerConfigFetcher");
+   if (!xds_client.ok()) {
+-    LOG(ERROR) << "Failed to create xds client: " << xds_client.status();
++    ABSL_LOG(ERROR) << "Failed to create xds client: " << xds_client.status();
+     return nullptr;
+   }
+   if (static_cast<const grpc_core::GrpcXdsBootstrap&>(
+           (*xds_client)->bootstrap())
+           .server_listener_resource_name_template()
+           .empty()) {
+-    LOG(ERROR) << "server_listener_resource_name_template not provided in "
++    ABSL_LOG(ERROR) << "server_listener_resource_name_template not provided in "
+                   "bootstrap file.";
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc b/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc
+index 3278534c49594..c3d064b0900a4 100644
+--- a/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc
++++ b/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc
+@@ -26,7 +26,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/config/core_configuration.h"
+@@ -70,7 +70,7 @@ class ServiceConfigChannelArgFilter final
+       auto service_config =
+           ServiceConfigImpl::Create(args, *service_config_str);
+       if (!service_config.ok()) {
+-        LOG(ERROR) << service_config.status().ToString();
++        ABSL_LOG(ERROR) << service_config.status().ToString();
+       } else {
+         service_config_ = std::move(*service_config);
+       }
+diff --git a/third_party/grpc/source/src/core/service_config/service_config_impl.h b/third_party/grpc/source/src/core/service_config/service_config_impl.h
+index 9d6ae2a46d34c..b23797122e04f 100644
+--- a/third_party/grpc/source/src/core/service_config/service_config_impl.h
++++ b/third_party/grpc/source/src/core/service_config/service_config_impl.h
+@@ -26,7 +26,7 @@
+ #include <unordered_map>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/channel/channel_args.h"
+@@ -87,7 +87,7 @@ class ServiceConfigImpl final : public ServiceConfig {
+   /// ServiceConfig object.
+   ServiceConfigParser::ParsedConfig* GetGlobalParsedConfig(
+       size_t index) override {
+-    DCHECK(index < parsed_global_configs_.size());
++    ABSL_DCHECK(index < parsed_global_configs_.size());
+     return parsed_global_configs_[index].get();
+   }
+
+diff --git a/third_party/grpc/source/src/core/service_config/service_config_parser.cc b/third_party/grpc/source/src/core/service_config/service_config_parser.cc
+index b3ff739251493..2670e76aea816 100644
+--- a/third_party/grpc/source/src/core/service_config/service_config_parser.cc
++++ b/third_party/grpc/source/src/core/service_config/service_config_parser.cc
+@@ -21,7 +21,7 @@
+
+ #include <string>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+
+ namespace grpc_core {
+
+@@ -33,7 +33,7 @@ void ServiceConfigParser::Builder::RegisterParser(
+     std::unique_ptr<Parser> parser) {
+   for (const auto& registered_parser : registered_parsers_) {
+     if (registered_parser->name() == parser->name()) {
+-      LOG(ERROR) << "Parser with name '" << parser->name()
++      ABSL_LOG(ERROR) << "Parser with name '" << parser->name()
+                  << "' already registered";
+       // We'll otherwise crash later.
+       abort();
+diff --git a/third_party/grpc/source/src/core/telemetry/call_tracer.cc b/third_party/grpc/source/src/core/telemetry/call_tracer.cc
+index 49467582cb115..d749b547c58fa 100644
+--- a/third_party/grpc/source/src/core/telemetry/call_tracer.cc
++++ b/third_party/grpc/source/src/core/telemetry/call_tracer.cc
+@@ -24,7 +24,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/promise/context.h"
+ #include "src/core/telemetry/tcp_tracer.h"
+
+@@ -86,7 +86,7 @@ class DelegatingClientCallTracer : public ClientCallTracer {
+     explicit DelegatingClientCallAttemptTracer(
+         std::vector<CallAttemptTracer*> tracers)
+         : tracers_(std::move(tracers)) {
+-      DCHECK(!tracers_.empty());
++      ABSL_DCHECK(!tracers_.empty());
+     }
+     ~DelegatingClientCallAttemptTracer() override {}
+     void RecordSendInitialMetadata(
+@@ -198,7 +198,7 @@ class DelegatingClientCallTracer : public ClientCallTracer {
+     attempt_tracers.reserve(tracers_.size());
+     for (auto* tracer : tracers_) {
+       auto* attempt_tracer = tracer->StartNewAttempt(is_transparent_retry);
+-      DCHECK_NE(attempt_tracer, nullptr);
++      ABSL_DCHECK_NE(attempt_tracer, nullptr);
+       attempt_tracers.push_back(attempt_tracer);
+     }
+     return GetContext<Arena>()->ManagedNew<DelegatingClientCallAttemptTracer>(
+@@ -356,7 +356,7 @@ void AddClientCallTracerToContext(Arena* arena, ClientCallTracer* tracer) {
+ }
+
+ void AddServerCallTracerToContext(Arena* arena, ServerCallTracer* tracer) {
+-  DCHECK_EQ(arena->GetContext<CallTracerInterface>(),
++  ABSL_DCHECK_EQ(arena->GetContext<CallTracerInterface>(),
+             arena->GetContext<CallTracerAnnotationInterface>());
+   if (arena->GetContext<CallTracerAnnotationInterface>() == nullptr) {
+     // This is the first call tracer. Set it directly.
+diff --git a/third_party/grpc/source/src/core/telemetry/metrics.cc b/third_party/grpc/source/src/core/telemetry/metrics.cc
+index 92441a914d4cd..9e38ff4130a4a 100644
+--- a/third_party/grpc/source/src/core/telemetry/metrics.cc
++++ b/third_party/grpc/source/src/core/telemetry/metrics.cc
+@@ -19,7 +19,7 @@
+ #include <memory>
+ #include <optional>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/util/crash.h"
+
+ namespace grpc_core {
+@@ -50,7 +50,7 @@ GlobalInstrumentsRegistry::RegisterInstrument(
+     }
+   }
+   InstrumentID index = instruments.size();
+-  CHECK_LT(index, std::numeric_limits<uint32_t>::max());
++  ABSL_CHECK_LT(index, std::numeric_limits<uint32_t>::max());
+   GlobalInstrumentDescriptor descriptor;
+   descriptor.value_type = value_type;
+   descriptor.instrument_type = instrument_type;
+diff --git a/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc b/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc
+index 534e8555465de..1e5b42590793d 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc
+@@ -26,7 +26,7 @@
+ #include <algorithm>
+ #include <memory>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/types/span.h"
+ #include "src/core/tsi/alts/crypt/gsec.h"
+ #include "src/core/tsi/alts/frame_protector/alts_crypter.h"
+@@ -68,7 +68,7 @@ static tsi_result seal(alts_frame_protector* impl) {
+       &output_size, &error_details);
+   impl->in_place_protect_bytes_buffered = output_size;
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << error_details;
++    ABSL_LOG(ERROR) << error_details;
+     gpr_free(error_details);
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -86,7 +86,7 @@ static tsi_result alts_protect_flush(tsi_frame_protector* self,
+   if (self == nullptr || protected_output_frames == nullptr ||
+       protected_output_frames_size == nullptr ||
+       still_pending_size == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to alts_protect_flush().";
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_protect_flush().";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_frame_protector* impl = reinterpret_cast<alts_frame_protector*>(self);
+@@ -111,7 +111,7 @@ static tsi_result alts_protect_flush(tsi_frame_protector* self,
+     }
+     if (!alts_reset_frame_writer(impl->writer, impl->in_place_protect_buffer,
+                                  impl->in_place_protect_bytes_buffered)) {
+-      LOG(ERROR) << "Couldn't reset frame writer.";
++      ABSL_LOG(ERROR) << "Couldn't reset frame writer.";
+       return TSI_INTERNAL_ERROR;
+     }
+   }
+@@ -124,7 +124,7 @@ static tsi_result alts_protect_flush(tsi_frame_protector* self,
+   size_t written_frame_bytes = *protected_output_frames_size;
+   if (!alts_write_frame_bytes(impl->writer, protected_output_frames,
+                               &written_frame_bytes)) {
+-    LOG(ERROR) << "Couldn't write frame bytes.";
++    ABSL_LOG(ERROR) << "Couldn't write frame bytes.";
+     return TSI_INTERNAL_ERROR;
+   }
+   *protected_output_frames_size = written_frame_bytes;
+@@ -147,7 +147,7 @@ static tsi_result alts_protect(tsi_frame_protector* self,
+   if (self == nullptr || unprotected_bytes == nullptr ||
+       unprotected_bytes_size == nullptr || protected_output_frames == nullptr ||
+       protected_output_frames_size == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to alts_protect().";
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_protect().";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_frame_protector* impl = reinterpret_cast<alts_frame_protector*>(self);
+@@ -200,7 +200,7 @@ static tsi_result unseal(alts_frame_protector* impl) {
+       impl->max_unprotected_frame_size,
+       alts_get_output_bytes_read(impl->reader), &output_size, &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << error_details;
++    ABSL_LOG(ERROR) << error_details;
+     gpr_free(error_details);
+     return TSI_DATA_CORRUPTED;
+   }
+@@ -239,7 +239,7 @@ static tsi_result alts_unprotect(tsi_frame_protector* self,
+   if (self == nullptr || protected_frames_bytes == nullptr ||
+       protected_frames_bytes_size == nullptr || unprotected_bytes == nullptr ||
+       unprotected_bytes_size == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to alts_unprotect().";
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_unprotect().";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_frame_protector* impl = reinterpret_cast<alts_frame_protector*>(self);
+@@ -254,7 +254,7 @@ static tsi_result alts_unprotect(tsi_frame_protector* self,
+         impl->in_place_unprotect_bytes_processed + impl->overhead_length))) {
+     if (!alts_reset_frame_reader(impl->reader,
+                                  impl->in_place_unprotect_buffer)) {
+-      LOG(ERROR) << "Couldn't reset frame reader.";
++      ABSL_LOG(ERROR) << "Couldn't reset frame reader.";
+       return TSI_INTERNAL_ERROR;
+     }
+     impl->in_place_unprotect_bytes_processed = 0;
+@@ -274,7 +274,7 @@ static tsi_result alts_unprotect(tsi_frame_protector* self,
+     size_t read_frames_bytes_size = *protected_frames_bytes_size;
+     if (!alts_read_frame_bytes(impl->reader, protected_frames_bytes,
+                                &read_frames_bytes_size)) {
+-      LOG(ERROR) << "Failed to process frame.";
++      ABSL_LOG(ERROR) << "Failed to process frame.";
+       return TSI_INTERNAL_ERROR;
+     }
+     *protected_frames_bytes_size = read_frames_bytes_size;
+@@ -368,7 +368,7 @@ tsi_result alts_create_frame_protector(const uint8_t* key, size_t key_size,
+                                        size_t* max_protected_frame_size,
+                                        tsi_frame_protector** self) {
+   if (key == nullptr || self == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to alts_create_frame_protector().";
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_create_frame_protector().";
+     return TSI_INTERNAL_ERROR;
+   }
+   char* error_details = nullptr;
+@@ -376,7 +376,7 @@ tsi_result alts_create_frame_protector(const uint8_t* key, size_t key_size,
+   grpc_status_code status = create_alts_crypters(
+       key, key_size, is_client, is_rekey, impl, &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to create ALTS crypters, " << error_details;
++    ABSL_LOG(ERROR) << "Failed to create ALTS crypters, " << error_details;
+     gpr_free(error_details);
+     gpr_free(impl);
+     return TSI_INTERNAL_ERROR;
+diff --git a/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc b/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc
+index 7fcbcce34bb90..452dbc6428986 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc
+@@ -26,7 +26,7 @@
+
+ #include <algorithm>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/memory.h"
+
+@@ -56,7 +56,7 @@ bool alts_reset_frame_writer(alts_frame_writer* writer,
+   if (buffer == nullptr) return false;
+   size_t max_input_size = SIZE_MAX - kFrameLengthFieldSize;
+   if (length > max_input_size) {
+-    LOG(ERROR) << "length must be at most " << max_input_size;
++    ABSL_LOG(ERROR) << "length must be at most " << max_input_size;
+     return false;
+   }
+   writer->input_buffer = buffer;
+@@ -180,7 +180,7 @@ bool alts_read_frame_bytes(alts_frame_reader* reader,
+     size_t frame_length = load_32_le(reader->header_buffer);
+     if (frame_length < kFrameMessageTypeFieldSize ||
+         frame_length > kFrameMaxSize) {
+-      LOG(ERROR) << "Bad frame length (should be at least "
++      ABSL_LOG(ERROR) << "Bad frame length (should be at least "
+                  << kFrameMessageTypeFieldSize << ", and at most "
+                  << kFrameMaxSize << ")";
+       *bytes_size = 0;
+@@ -189,7 +189,7 @@ bool alts_read_frame_bytes(alts_frame_reader* reader,
+     size_t message_type =
+         load_32_le(reader->header_buffer + kFrameLengthFieldSize);
+     if (message_type != kFrameMessageType) {
+-      LOG(ERROR) << "Unsupported message type " << message_type
++      ABSL_LOG(ERROR) << "Unsupported message type " << message_type
+                  << " (should be " << kFrameMessageType << ")";
+       *bytes_size = 0;
+       return false;
+diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc
+index bf74e0d297d86..bd4b953a430a5 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc
+@@ -24,8 +24,8 @@
+
+ #include <list>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/numbers.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/lib/surface/call.h"
+@@ -117,13 +117,13 @@ typedef struct alts_grpc_handshaker_client {
+
+ static void handshaker_client_send_buffer_destroy(
+     alts_grpc_handshaker_client* client) {
+-  CHECK_NE(client, nullptr);
++  ABSL_CHECK_NE(client, nullptr);
+   grpc_byte_buffer_destroy(client->send_buffer);
+   client->send_buffer = nullptr;
+ }
+
+ static bool is_handshake_finished_properly(grpc_gcp_HandshakerResp* resp) {
+-  CHECK_NE(resp, nullptr);
++  ABSL_CHECK_NE(resp, nullptr);
+   return grpc_gcp_HandshakerResp_result(resp) != nullptr;
+ }
+
+@@ -156,7 +156,7 @@ static void maybe_complete_tsi_next(
+     grpc_core::MutexLock lock(&client->mu);
+     client->receive_status_finished |= receive_status_finished;
+     if (pending_recv_message_result != nullptr) {
+-      CHECK_EQ(client->pending_recv_message_result, nullptr);
++      ABSL_CHECK_EQ(client->pending_recv_message_result, nullptr);
+       client->pending_recv_message_result = pending_recv_message_result;
+     }
+     if (client->pending_recv_message_result == nullptr) {
+@@ -197,19 +197,19 @@ static void handle_response_done(alts_grpc_handshaker_client* client,
+
+ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
+                                             bool is_ok) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   grpc_byte_buffer* recv_buffer = client->recv_buffer;
+   alts_tsi_handshaker* handshaker = client->handshaker;
+   // Invalid input check.
+   if (client->cb == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "client->cb is nullptr in alts_tsi_handshaker_handle_response()";
+     return;
+   }
+   if (handshaker == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "handshaker is nullptr in alts_tsi_handshaker_handle_response()";
+     handle_response_done(
+         client, TSI_INTERNAL_ERROR,
+@@ -219,21 +219,21 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
+   }
+   // TSI handshake has been shutdown.
+   if (alts_tsi_handshaker_has_shutdown(handshaker)) {
+-    VLOG(2) << "TSI handshake shutdown";
++    ABSL_VLOG(2) << "TSI handshake shutdown";
+     handle_response_done(client, TSI_HANDSHAKE_SHUTDOWN,
+                          "TSI handshake shutdown", nullptr, 0, nullptr);
+     return;
+   }
+   // Check for failed grpc read.
+   if (!is_ok || client->inject_read_failure) {
+-    VLOG(2) << "read failed on grpc call to handshaker service";
++    ABSL_VLOG(2) << "read failed on grpc call to handshaker service";
+     handle_response_done(client, TSI_INTERNAL_ERROR,
+                          "read failed on grpc call to handshaker service",
+                          nullptr, 0, nullptr);
+     return;
+   }
+   if (recv_buffer == nullptr) {
+-    VLOG(2)
++    ABSL_VLOG(2)
+         << "recv_buffer is nullptr in alts_tsi_handshaker_handle_response()";
+     handle_response_done(
+         client, TSI_INTERNAL_ERROR,
+@@ -248,7 +248,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
+   client->recv_buffer = nullptr;
+   // Invalid handshaker response check.
+   if (resp == nullptr) {
+-    LOG(ERROR) << "alts_tsi_utils_deserialize_response() failed";
++    ABSL_LOG(ERROR) << "alts_tsi_utils_deserialize_response() failed";
+     handle_response_done(client, TSI_DATA_CORRUPTED,
+                          "alts_tsi_utils_deserialize_response() failed",
+                          nullptr, 0, nullptr);
+@@ -257,7 +257,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
+   const grpc_gcp_HandshakerStatus* resp_status =
+       grpc_gcp_HandshakerResp_status(resp);
+   if (resp_status == nullptr) {
+-    LOG(ERROR) << "No status in HandshakerResp";
++    ABSL_LOG(ERROR) << "No status in HandshakerResp";
+     handle_response_done(client, TSI_DATA_CORRUPTED,
+                          "No status in HandshakerResp", nullptr, 0, nullptr);
+     return;
+@@ -280,7 +280,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
+     tsi_result status =
+         alts_tsi_handshaker_result_create(resp, client->is_client, &result);
+     if (status != TSI_OK) {
+-      LOG(ERROR) << "alts_tsi_handshaker_result_create() failed";
++      ABSL_LOG(ERROR) << "alts_tsi_handshaker_result_create() failed";
+       handle_response_done(client, status,
+                            "alts_tsi_handshaker_result_create() failed",
+                            nullptr, 0, nullptr);
+@@ -298,7 +298,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
+     if (details.size > 0) {
+       error = absl::StrCat("Status ", code, " from handshaker service: ",
+                            absl::string_view(details.data, details.size));
+-      LOG_EVERY_N_SEC(INFO, 1) << error;
++      ABSL_LOG_EVERY_N_SEC(INFO, 1) << error;
+     }
+   }
+   // TODO(apolcyn): consider short ciruiting handle_response_done and
+@@ -312,7 +312,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
+
+ static tsi_result continue_make_grpc_call(alts_grpc_handshaker_client* client,
+                                           bool is_start) {
+-  CHECK_NE(client, nullptr);
++  ABSL_CHECK_NE(client, nullptr);
+   grpc_op ops[kHandshakerClientOpNum];
+   memset(ops, 0, sizeof(ops));
+   grpc_op* op = ops;
+@@ -325,38 +325,38 @@ static tsi_result continue_make_grpc_call(alts_grpc_handshaker_client* client,
+     op->flags = 0;
+     op->reserved = nullptr;
+     op++;
+-    CHECK(op - ops <= kHandshakerClientOpNum);
++    ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
+     gpr_ref(&client->refs);
+     grpc_call_error call_error =
+         client->grpc_caller(client->call, ops, static_cast<size_t>(op - ops),
+                             &client->on_status_received);
+     // TODO(apolcyn): return the error here instead, as done for other ops?
+-    CHECK_EQ(call_error, GRPC_CALL_OK);
++    ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+     memset(ops, 0, sizeof(ops));
+     op = ops;
+     op->op = GRPC_OP_SEND_INITIAL_METADATA;
+     op->data.send_initial_metadata.count = 0;
+     op++;
+-    CHECK(op - ops <= kHandshakerClientOpNum);
++    ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
+     op->op = GRPC_OP_RECV_INITIAL_METADATA;
+     op->data.recv_initial_metadata.recv_initial_metadata =
+         &client->recv_initial_metadata;
+     op++;
+-    CHECK(op - ops <= kHandshakerClientOpNum);
++    ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
+   }
+   op->op = GRPC_OP_SEND_MESSAGE;
+   op->data.send_message.send_message = client->send_buffer;
+   op++;
+-  CHECK(op - ops <= kHandshakerClientOpNum);
++  ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
+   op->op = GRPC_OP_RECV_MESSAGE;
+   op->data.recv_message.recv_message = &client->recv_buffer;
+   op++;
+-  CHECK(op - ops <= kHandshakerClientOpNum);
+-  CHECK_NE(client->grpc_caller, nullptr);
++  ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
++  ABSL_CHECK_NE(client->grpc_caller, nullptr);
+   if (client->grpc_caller(client->call, ops, static_cast<size_t>(op - ops),
+                           &client->on_handshaker_service_resp_recv) !=
+       GRPC_CALL_OK) {
+-    LOG(ERROR) << "Start batch operation failed";
++    ABSL_LOG(ERROR) << "Start batch operation failed";
+     return TSI_INTERNAL_ERROR;
+   }
+   return TSI_OK;
+@@ -450,7 +450,7 @@ void HandshakeDone(bool is_client) {
+ /// make a grpc call.
+ ///
+ static tsi_result make_grpc_call(alts_handshaker_client* c, bool is_start) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   if (is_start) {
+@@ -469,7 +469,7 @@ static void on_status_received(void* arg, grpc_error_handle error) {
+     // status from the final ALTS message with the status here.
+     char* status_details =
+         grpc_slice_to_c_string(client->handshake_status_details);
+-    VLOG(2) << "alts_grpc_handshaker_client:" << client
++    ABSL_VLOG(2) << "alts_grpc_handshaker_client:" << client
+             << " on_status_received status:" << client->handshake_status_code
+             << " details:|" << status_details << "| error:|"
+             << grpc_core::StatusToString(error) << "|";
+@@ -499,7 +499,7 @@ static grpc_byte_buffer* get_serialized_handshaker_req(
+ // Create and populate a client_start handshaker request, then serialize it.
+ static grpc_byte_buffer* get_serialized_start_client(
+     alts_handshaker_client* c) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   upb::Arena arena;
+@@ -542,21 +542,21 @@ static grpc_byte_buffer* get_serialized_start_client(
+
+ static tsi_result handshaker_client_start_client(alts_handshaker_client* c) {
+   if (c == nullptr) {
+-    LOG(ERROR) << "client is nullptr in handshaker_client_start_client()";
++    ABSL_LOG(ERROR) << "client is nullptr in handshaker_client_start_client()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   grpc_byte_buffer* buffer = get_serialized_start_client(c);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   if (buffer == nullptr) {
+-    LOG(ERROR) << "get_serialized_start_client() failed";
++    ABSL_LOG(ERROR) << "get_serialized_start_client() failed";
+     return TSI_INTERNAL_ERROR;
+   }
+   handshaker_client_send_buffer_destroy(client);
+   client->send_buffer = buffer;
+   tsi_result result = make_grpc_call(&client->base, true /* is_start */);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "make_grpc_call() failed";
++    ABSL_LOG(ERROR) << "make_grpc_call() failed";
+   }
+   return result;
+ }
+@@ -564,8 +564,8 @@ static tsi_result handshaker_client_start_client(alts_handshaker_client* c) {
+ // Create and populate a start_server handshaker request, then serialize it.
+ static grpc_byte_buffer* get_serialized_start_server(
+     alts_handshaker_client* c, grpc_slice* bytes_received) {
+-  CHECK_NE(c, nullptr);
+-  CHECK_NE(bytes_received, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(bytes_received, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+
+@@ -601,28 +601,28 @@ static grpc_byte_buffer* get_serialized_start_server(
+ static tsi_result handshaker_client_start_server(alts_handshaker_client* c,
+                                                  grpc_slice* bytes_received) {
+   if (c == nullptr || bytes_received == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to handshaker_client_start_server()";
++    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_client_start_server()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   grpc_byte_buffer* buffer = get_serialized_start_server(c, bytes_received);
+   if (buffer == nullptr) {
+-    LOG(ERROR) << "get_serialized_start_server() failed";
++    ABSL_LOG(ERROR) << "get_serialized_start_server() failed";
+     return TSI_INTERNAL_ERROR;
+   }
+   handshaker_client_send_buffer_destroy(client);
+   client->send_buffer = buffer;
+   tsi_result result = make_grpc_call(&client->base, true /* is_start */);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "make_grpc_call() failed";
++    ABSL_LOG(ERROR) << "make_grpc_call() failed";
+   }
+   return result;
+ }
+
+ // Create and populate a next handshaker request, then serialize it.
+ static grpc_byte_buffer* get_serialized_next(grpc_slice* bytes_received) {
+-  CHECK_NE(bytes_received, nullptr);
++  ABSL_CHECK_NE(bytes_received, nullptr);
+   upb::Arena arena;
+   grpc_gcp_HandshakerReq* req = grpc_gcp_HandshakerReq_new(arena.ptr());
+   grpc_gcp_NextHandshakeMessageReq* next =
+@@ -638,7 +638,7 @@ static grpc_byte_buffer* get_serialized_next(grpc_slice* bytes_received) {
+ static tsi_result handshaker_client_next(alts_handshaker_client* c,
+                                          grpc_slice* bytes_received) {
+   if (c == nullptr || bytes_received == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to handshaker_client_next()";
++    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_client_next()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_grpc_handshaker_client* client =
+@@ -647,20 +647,20 @@ static tsi_result handshaker_client_next(alts_handshaker_client* c,
+   client->recv_bytes = grpc_core::CSliceRef(*bytes_received);
+   grpc_byte_buffer* buffer = get_serialized_next(bytes_received);
+   if (buffer == nullptr) {
+-    LOG(ERROR) << "get_serialized_next() failed";
++    ABSL_LOG(ERROR) << "get_serialized_next() failed";
+     return TSI_INTERNAL_ERROR;
+   }
+   handshaker_client_send_buffer_destroy(client);
+   client->send_buffer = buffer;
+   tsi_result result = make_grpc_call(&client->base, false /* is_start */);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "make_grpc_call() failed";
++    ABSL_LOG(ERROR) << "make_grpc_call() failed";
+   }
+   return result;
+ }
+
+ static void handshaker_client_shutdown(alts_handshaker_client* c) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   if (client->call != nullptr) {
+@@ -714,7 +714,7 @@ alts_handshaker_client* alts_grpc_handshaker_client_create(
+     void* user_data, alts_handshaker_client_vtable* vtable_for_testing,
+     bool is_client, size_t max_frame_size, std::string* error) {
+   if (channel == nullptr || handshaker_service_url == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to alts_handshaker_client_create()";
++    ABSL_LOG(ERROR) << "Invalid arguments to alts_handshaker_client_create()";
+     return nullptr;
+   }
+   alts_grpc_handshaker_client* client = new alts_grpc_handshaker_client();
+@@ -758,8 +758,8 @@ namespace internal {
+
+ void alts_handshaker_client_set_grpc_caller_for_testing(
+     alts_handshaker_client* c, alts_grpc_caller caller) {
+-  CHECK(c != nullptr);
+-  CHECK_NE(caller, nullptr);
++  ABSL_CHECK(c != nullptr);
++  ABSL_CHECK_NE(caller, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   client->grpc_caller = caller;
+@@ -767,7 +767,7 @@ void alts_handshaker_client_set_grpc_caller_for_testing(
+
+ grpc_byte_buffer* alts_handshaker_client_get_send_buffer_for_testing(
+     alts_handshaker_client* c) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   return client->send_buffer;
+@@ -775,7 +775,7 @@ grpc_byte_buffer* alts_handshaker_client_get_send_buffer_for_testing(
+
+ grpc_byte_buffer** alts_handshaker_client_get_recv_buffer_addr_for_testing(
+     alts_handshaker_client* c) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   return &client->recv_buffer;
+@@ -783,7 +783,7 @@ grpc_byte_buffer** alts_handshaker_client_get_recv_buffer_addr_for_testing(
+
+ grpc_metadata_array* alts_handshaker_client_get_initial_metadata_for_testing(
+     alts_handshaker_client* c) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   return &client->recv_initial_metadata;
+@@ -791,7 +791,7 @@ grpc_metadata_array* alts_handshaker_client_get_initial_metadata_for_testing(
+
+ void alts_handshaker_client_set_recv_bytes_for_testing(
+     alts_handshaker_client* c, grpc_slice* recv_bytes) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   client->recv_bytes = CSliceRef(*recv_bytes);
+@@ -801,7 +801,7 @@ void alts_handshaker_client_set_fields_for_testing(
+     alts_handshaker_client* c, alts_tsi_handshaker* handshaker,
+     tsi_handshaker_on_next_done_cb cb, void* user_data,
+     grpc_byte_buffer* recv_buffer, bool inject_read_failure) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   client->handshaker = handshaker;
+@@ -814,22 +814,22 @@ void alts_handshaker_client_set_fields_for_testing(
+ void alts_handshaker_client_check_fields_for_testing(
+     alts_handshaker_client* c, tsi_handshaker_on_next_done_cb cb,
+     void* user_data, bool has_sent_start_message, grpc_slice* recv_bytes) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+-  CHECK(client->cb == cb);
+-  CHECK(client->user_data == user_data);
++  ABSL_CHECK(client->cb == cb);
++  ABSL_CHECK(client->user_data == user_data);
+   if (recv_bytes != nullptr) {
+-    CHECK_EQ(grpc_slice_cmp(client->recv_bytes, *recv_bytes), 0);
++    ABSL_CHECK_EQ(grpc_slice_cmp(client->recv_bytes, *recv_bytes), 0);
+   }
+-  CHECK(alts_tsi_handshaker_get_has_sent_start_message_for_testing(
++  ABSL_CHECK(alts_tsi_handshaker_get_has_sent_start_message_for_testing(
+             client->handshaker) == has_sent_start_message);
+ }
+
+ void alts_handshaker_client_set_vtable_for_testing(
+     alts_handshaker_client* c, alts_handshaker_client_vtable* vtable) {
+-  CHECK_NE(c, nullptr);
+-  CHECK_NE(vtable, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(vtable, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   client->base.vtable = vtable;
+@@ -837,7 +837,7 @@ void alts_handshaker_client_set_vtable_for_testing(
+
+ alts_tsi_handshaker* alts_handshaker_client_get_handshaker_for_testing(
+     alts_handshaker_client* c) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   return client->handshaker;
+@@ -845,7 +845,7 @@ alts_tsi_handshaker* alts_handshaker_client_get_handshaker_for_testing(
+
+ void alts_handshaker_client_set_cb_for_testing(
+     alts_handshaker_client* c, tsi_handshaker_on_next_done_cb cb) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   client->cb = cb;
+@@ -853,7 +853,7 @@ void alts_handshaker_client_set_cb_for_testing(
+
+ grpc_closure* alts_handshaker_client_get_closure_for_testing(
+     alts_handshaker_client* c) {
+-  CHECK_NE(c, nullptr);
++  ABSL_CHECK_NE(c, nullptr);
+   alts_grpc_handshaker_client* client =
+       reinterpret_cast<alts_grpc_handshaker_client*>(c);
+   return &client->on_handshaker_service_resp_recv;
+@@ -889,7 +889,7 @@ tsi_result alts_handshaker_client_start_client(alts_handshaker_client* client) {
+       client->vtable->client_start != nullptr) {
+     return client->vtable->client_start(client);
+   }
+-  LOG(ERROR) << "client or client->vtable has not been initialized properly";
++  ABSL_LOG(ERROR) << "client or client->vtable has not been initialized properly";
+   return TSI_INVALID_ARGUMENT;
+ }
+
+@@ -899,7 +899,7 @@ tsi_result alts_handshaker_client_start_server(alts_handshaker_client* client,
+       client->vtable->server_start != nullptr) {
+     return client->vtable->server_start(client, bytes_received);
+   }
+-  LOG(ERROR) << "client or client->vtable has not been initialized properly";
++  ABSL_LOG(ERROR) << "client or client->vtable has not been initialized properly";
+   return TSI_INVALID_ARGUMENT;
+ }
+
+@@ -909,7 +909,7 @@ tsi_result alts_handshaker_client_next(alts_handshaker_client* client,
+       client->vtable->next != nullptr) {
+     return client->vtable->next(client, bytes_received);
+   }
+-  LOG(ERROR) << "client or client->vtable has not been initialized properly";
++  ABSL_LOG(ERROR) << "client or client->vtable has not been initialized properly";
+   return TSI_INVALID_ARGUMENT;
+ }
+
+diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc
+index ec1fe8129632f..cd84083c3ca94 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc
+@@ -20,7 +20,7 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/tsi/alts/handshaker/alts_handshaker_client.h"
+ #include "src/core/util/crash.h"
+@@ -36,11 +36,11 @@ static void thread_worker(void* /*arg*/) {
+     grpc_event event =
+         grpc_completion_queue_next(g_alts_resource_dedicated.cq,
+                                    gpr_inf_future(GPR_CLOCK_REALTIME), nullptr);
+-    CHECK(event.type != GRPC_QUEUE_TIMEOUT);
++    ABSL_CHECK(event.type != GRPC_QUEUE_TIMEOUT);
+     if (event.type == GRPC_QUEUE_SHUTDOWN) {
+       break;
+     }
+-    CHECK(event.type == GRPC_OP_COMPLETE);
++    ABSL_CHECK(event.type == GRPC_OP_COMPLETE);
+     alts_handshaker_client* client =
+         static_cast<alts_handshaker_client*>(event.tag);
+     alts_handshaker_client_handle_response(client, event.success);
+diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc
+index b42f9994e72e5..e930b4dac9e44 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc
+@@ -29,8 +29,8 @@
+ #include <stdlib.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/closure.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/lib/surface/channel.h"
+@@ -85,68 +85,68 @@ typedef struct alts_tsi_handshaker_result {
+ static tsi_result handshaker_result_extract_peer(
+     const tsi_handshaker_result* self, tsi_peer* peer) {
+   if (self == nullptr || peer == nullptr) {
+-    LOG(ERROR) << "Invalid argument to handshaker_result_extract_peer()";
++    ABSL_LOG(ERROR) << "Invalid argument to handshaker_result_extract_peer()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_tsi_handshaker_result* result =
+       reinterpret_cast<alts_tsi_handshaker_result*>(
+           const_cast<tsi_handshaker_result*>(self));
+-  CHECK_EQ(kTsiAltsNumOfPeerProperties, 5u);
++  ABSL_CHECK_EQ(kTsiAltsNumOfPeerProperties, 5u);
+   tsi_result ok = tsi_construct_peer(kTsiAltsNumOfPeerProperties, peer);
+   int index = 0;
+   if (ok != TSI_OK) {
+-    LOG(ERROR) << "Failed to construct tsi peer";
++    ABSL_LOG(ERROR) << "Failed to construct tsi peer";
+     return ok;
+   }
+-  CHECK_NE(&peer->properties[index], nullptr);
++  ABSL_CHECK_NE(&peer->properties[index], nullptr);
+   ok = tsi_construct_string_peer_property_from_cstring(
+       TSI_CERTIFICATE_TYPE_PEER_PROPERTY, TSI_ALTS_CERTIFICATE_TYPE,
+       &peer->properties[index]);
+   if (ok != TSI_OK) {
+     tsi_peer_destruct(peer);
+-    LOG(ERROR) << "Failed to set tsi peer property";
++    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
+     return ok;
+   }
+   index++;
+-  CHECK_NE(&peer->properties[index], nullptr);
++  ABSL_CHECK_NE(&peer->properties[index], nullptr);
+   ok = tsi_construct_string_peer_property_from_cstring(
+       TSI_ALTS_SERVICE_ACCOUNT_PEER_PROPERTY, result->peer_identity,
+       &peer->properties[index]);
+   if (ok != TSI_OK) {
+     tsi_peer_destruct(peer);
+-    LOG(ERROR) << "Failed to set tsi peer property";
++    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
+   }
+   index++;
+-  CHECK_NE(&peer->properties[index], nullptr);
++  ABSL_CHECK_NE(&peer->properties[index], nullptr);
+   ok = tsi_construct_string_peer_property(
+       TSI_ALTS_RPC_VERSIONS,
+       reinterpret_cast<char*>(GRPC_SLICE_START_PTR(result->rpc_versions)),
+       GRPC_SLICE_LENGTH(result->rpc_versions), &peer->properties[index]);
+   if (ok != TSI_OK) {
+     tsi_peer_destruct(peer);
+-    LOG(ERROR) << "Failed to set tsi peer property";
++    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
+   }
+   index++;
+-  CHECK_NE(&peer->properties[index], nullptr);
++  ABSL_CHECK_NE(&peer->properties[index], nullptr);
+   ok = tsi_construct_string_peer_property(
+       TSI_ALTS_CONTEXT,
+       reinterpret_cast<char*>(GRPC_SLICE_START_PTR(result->serialized_context)),
+       GRPC_SLICE_LENGTH(result->serialized_context), &peer->properties[index]);
+   if (ok != TSI_OK) {
+     tsi_peer_destruct(peer);
+-    LOG(ERROR) << "Failed to set tsi peer property";
++    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
+   }
+   index++;
+-  CHECK_NE(&peer->properties[index], nullptr);
++  ABSL_CHECK_NE(&peer->properties[index], nullptr);
+   ok = tsi_construct_string_peer_property_from_cstring(
+       TSI_SECURITY_LEVEL_PEER_PROPERTY,
+       tsi_security_level_to_string(TSI_PRIVACY_AND_INTEGRITY),
+       &peer->properties[index]);
+   if (ok != TSI_OK) {
+     tsi_peer_destruct(peer);
+-    LOG(ERROR) << "Failed to set tsi peer property";
++    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
+   }
+-  CHECK(++index == kTsiAltsNumOfPeerProperties);
++  ABSL_CHECK(++index == kTsiAltsNumOfPeerProperties);
+   return ok;
+ }
+
+@@ -161,7 +161,7 @@ static tsi_result handshaker_result_create_zero_copy_grpc_protector(
+     const tsi_handshaker_result* self, size_t* max_output_protected_frame_size,
+     tsi_zero_copy_grpc_protector** protector) {
+   if (self == nullptr || protector == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to create_zero_copy_grpc_protector()";
++    ABSL_LOG(ERROR) << "Invalid arguments to create_zero_copy_grpc_protector()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_tsi_handshaker_result* result =
+@@ -183,7 +183,7 @@ static tsi_result handshaker_result_create_zero_copy_grpc_protector(
+     max_frame_size = std::max<size_t>(max_frame_size, kTsiAltsMinFrameSize);
+   }
+   max_output_protected_frame_size = &max_frame_size;
+-  VLOG(2) << "After Frame Size Negotiation, maximum frame size used by frame "
++  ABSL_VLOG(2) << "After Frame Size Negotiation, maximum frame size used by frame "
+              "protector equals "
+           << *max_output_protected_frame_size;
+   tsi_result ok = alts_zero_copy_grpc_protector_create(
+@@ -194,7 +194,7 @@ static tsi_result handshaker_result_create_zero_copy_grpc_protector(
+       /*is_integrity_only=*/false, /*enable_extra_copy=*/false,
+       max_output_protected_frame_size, protector);
+   if (ok != TSI_OK) {
+-    LOG(ERROR) << "Failed to create zero-copy grpc protector";
++    ABSL_LOG(ERROR) << "Failed to create zero-copy grpc protector";
+   }
+   return ok;
+ }
+@@ -203,7 +203,7 @@ static tsi_result handshaker_result_create_frame_protector(
+     const tsi_handshaker_result* self, size_t* max_output_protected_frame_size,
+     tsi_frame_protector** protector) {
+   if (self == nullptr || protector == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid arguments to handshaker_result_create_frame_protector()";
+     return TSI_INVALID_ARGUMENT;
+   }
+@@ -215,7 +215,7 @@ static tsi_result handshaker_result_create_frame_protector(
+       kAltsAes128GcmRekeyKeyLength, result->is_client, /*is_rekey=*/true,
+       max_output_protected_frame_size, protector);
+   if (ok != TSI_OK) {
+-    LOG(ERROR) << "Failed to create frame protector";
++    ABSL_LOG(ERROR) << "Failed to create frame protector";
+   }
+   return ok;
+ }
+@@ -224,7 +224,7 @@ static tsi_result handshaker_result_get_unused_bytes(
+     const tsi_handshaker_result* self, const unsigned char** bytes,
+     size_t* bytes_size) {
+   if (self == nullptr || bytes == nullptr || bytes_size == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to handshaker_result_get_unused_bytes()";
++    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_result_get_unused_bytes()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_tsi_handshaker_result* result =
+@@ -262,7 +262,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
+                                              bool is_client,
+                                              tsi_handshaker_result** result) {
+   if (result == nullptr || resp == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
++    ABSL_LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   const grpc_gcp_HandshakerResult* hresult =
+@@ -270,42 +270,42 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
+   const grpc_gcp_Identity* identity =
+       grpc_gcp_HandshakerResult_peer_identity(hresult);
+   if (identity == nullptr) {
+-    LOG(ERROR) << "Invalid identity";
++    ABSL_LOG(ERROR) << "Invalid identity";
+     return TSI_FAILED_PRECONDITION;
+   }
+   upb_StringView peer_service_account =
+       grpc_gcp_Identity_service_account(identity);
+   if (peer_service_account.size == 0) {
+-    LOG(ERROR) << "Invalid peer service account";
++    ABSL_LOG(ERROR) << "Invalid peer service account";
+     return TSI_FAILED_PRECONDITION;
+   }
+   upb_StringView key_data = grpc_gcp_HandshakerResult_key_data(hresult);
+   if (key_data.size < kAltsAes128GcmRekeyKeyLength) {
+-    LOG(ERROR) << "Bad key length";
++    ABSL_LOG(ERROR) << "Bad key length";
+     return TSI_FAILED_PRECONDITION;
+   }
+   const grpc_gcp_RpcProtocolVersions* peer_rpc_version =
+       grpc_gcp_HandshakerResult_peer_rpc_versions(hresult);
+   if (peer_rpc_version == nullptr) {
+-    LOG(ERROR) << "Peer does not set RPC protocol versions.";
++    ABSL_LOG(ERROR) << "Peer does not set RPC protocol versions.";
+     return TSI_FAILED_PRECONDITION;
+   }
+   upb_StringView application_protocol =
+       grpc_gcp_HandshakerResult_application_protocol(hresult);
+   if (application_protocol.size == 0) {
+-    LOG(ERROR) << "Invalid application protocol";
++    ABSL_LOG(ERROR) << "Invalid application protocol";
+     return TSI_FAILED_PRECONDITION;
+   }
+   upb_StringView record_protocol =
+       grpc_gcp_HandshakerResult_record_protocol(hresult);
+   if (record_protocol.size == 0) {
+-    LOG(ERROR) << "Invalid record protocol";
++    ABSL_LOG(ERROR) << "Invalid record protocol";
+     return TSI_FAILED_PRECONDITION;
+   }
+   const grpc_gcp_Identity* local_identity =
+       grpc_gcp_HandshakerResult_local_identity(hresult);
+   if (local_identity == nullptr) {
+-    LOG(ERROR) << "Invalid local identity";
++    ABSL_LOG(ERROR) << "Invalid local identity";
+     return TSI_FAILED_PRECONDITION;
+   }
+   upb_StringView local_service_account =
+@@ -326,7 +326,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
+   bool serialized = grpc_gcp_rpc_protocol_versions_encode(
+       peer_rpc_version, rpc_versions_arena.ptr(), &sresult->rpc_versions);
+   if (!serialized) {
+-    LOG(ERROR) << "Failed to serialize peer's RPC protocol versions.";
++    ABSL_LOG(ERROR) << "Failed to serialize peer's RPC protocol versions.";
+     return TSI_FAILED_PRECONDITION;
+   }
+   upb::Arena context_arena;
+@@ -343,7 +343,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
+       context, const_cast<grpc_gcp_RpcProtocolVersions*>(peer_rpc_version));
+   grpc_gcp_Identity* peer_identity = const_cast<grpc_gcp_Identity*>(identity);
+   if (peer_identity == nullptr) {
+-    LOG(ERROR) << "Null peer identity in ALTS context.";
++    ABSL_LOG(ERROR) << "Null peer identity in ALTS context.";
+     return TSI_FAILED_PRECONDITION;
+   }
+   if (grpc_gcp_Identity_attributes_size(identity) != 0) {
+@@ -367,7 +367,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
+   char* serialized_ctx = grpc_gcp_AltsContext_serialize(
+       context, context_arena.ptr(), &serialized_ctx_length);
+   if (serialized_ctx == nullptr) {
+-    LOG(ERROR) << "Failed to serialize peer's ALTS context.";
++    ABSL_LOG(ERROR) << "Failed to serialize peer's ALTS context.";
+     return TSI_FAILED_PRECONDITION;
+   }
+   sresult->serialized_context =
+@@ -383,12 +383,12 @@ static void on_handshaker_service_resp_recv(void* arg,
+                                             grpc_error_handle error) {
+   alts_handshaker_client* client = static_cast<alts_handshaker_client*>(arg);
+   if (client == nullptr) {
+-    LOG(ERROR) << "ALTS handshaker client is nullptr";
++    ABSL_LOG(ERROR) << "ALTS handshaker client is nullptr";
+     return;
+   }
+   bool success = true;
+   if (!error.ok()) {
+-    VLOG(2) << "ALTS handshaker on_handshaker_service_resp_recv error: "
++    ABSL_VLOG(2) << "ALTS handshaker on_handshaker_service_resp_recv error: "
+             << grpc_core::StatusToString(error);
+     success = false;
+   }
+@@ -418,7 +418,7 @@ static tsi_result alts_tsi_handshaker_continue_handshaker_next(
+           handshaker->handshaker_service_url);
+       handshaker->interested_parties =
+           grpc_alts_get_shared_resource_dedicated()->interested_parties;
+-      CHECK_NE(handshaker->interested_parties, nullptr);
++      ABSL_CHECK_NE(handshaker->interested_parties, nullptr);
+     }
+     grpc_iomgr_cb_func grpc_cb = handshaker->channel == nullptr
+                                      ? on_handshaker_service_resp_recv_dedicated
+@@ -434,16 +434,16 @@ static tsi_result alts_tsi_handshaker_continue_handshaker_next(
+         handshaker->client_vtable_for_testing, handshaker->is_client,
+         handshaker->max_frame_size, error);
+     if (client == nullptr) {
+-      LOG(ERROR) << "Failed to create ALTS handshaker client";
++      ABSL_LOG(ERROR) << "Failed to create ALTS handshaker client";
+       if (error != nullptr) *error = "Failed to create ALTS handshaker client";
+       return TSI_FAILED_PRECONDITION;
+     }
+     {
+       grpc_core::MutexLock lock(&handshaker->mu);
+-      CHECK_EQ(handshaker->client, nullptr);
++      ABSL_CHECK_EQ(handshaker->client, nullptr);
+       handshaker->client = client;
+       if (handshaker->shutdown) {
+-        VLOG(2) << "TSI handshake shutdown";
++        ABSL_VLOG(2) << "TSI handshake shutdown";
+         if (error != nullptr) *error = "TSI handshaker shutdown";
+         return TSI_HANDSHAKE_SHUTDOWN;
+       }
+@@ -452,7 +452,7 @@ static tsi_result alts_tsi_handshaker_continue_handshaker_next(
+   }
+   if (handshaker->channel == nullptr &&
+       handshaker->client_vtable_for_testing == nullptr) {
+-    CHECK(grpc_cq_begin_op(grpc_alts_get_shared_resource_dedicated()->cq,
++    ABSL_CHECK(grpc_cq_begin_op(grpc_alts_get_shared_resource_dedicated()->cq,
+                            handshaker->client));
+   }
+   grpc_slice slice = (received_bytes == nullptr || received_bytes_size == 0)
+@@ -495,7 +495,7 @@ static void alts_tsi_handshaker_create_channel(
+   alts_tsi_handshaker_continue_handshaker_next_args* next_args =
+       static_cast<alts_tsi_handshaker_continue_handshaker_next_args*>(arg);
+   alts_tsi_handshaker* handshaker = next_args->handshaker;
+-  CHECK_EQ(handshaker->channel, nullptr);
++  ABSL_CHECK_EQ(handshaker->channel, nullptr);
+   grpc_channel_credentials* creds = grpc_insecure_credentials_create();
+   // Disable retries so that we quickly get a signal when the
+   // handshake server is not reachable.
+@@ -523,7 +523,7 @@ static tsi_result handshaker_next(
+     size_t* /*bytes_to_send_size*/, tsi_handshaker_result** /*result*/,
+     tsi_handshaker_on_next_done_cb cb, void* user_data, std::string* error) {
+   if (self == nullptr || cb == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to handshaker_next()";
++    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_next()";
+     if (error != nullptr) *error = "invalid argument";
+     return TSI_INVALID_ARGUMENT;
+   }
+@@ -532,7 +532,7 @@ static tsi_result handshaker_next(
+   {
+     grpc_core::MutexLock lock(&handshaker->mu);
+     if (handshaker->shutdown) {
+-      LOG(INFO) << "TSI handshake shutdown";
++      ABSL_LOG(INFO) << "TSI handshake shutdown";
+       if (error != nullptr) *error = "handshake shutdown";
+       return TSI_HANDSHAKE_SHUTDOWN;
+     }
+@@ -567,7 +567,7 @@ static tsi_result handshaker_next(
+     tsi_result ok = alts_tsi_handshaker_continue_handshaker_next(
+         handshaker, received_bytes, received_bytes_size, cb, user_data, error);
+     if (ok != TSI_OK) {
+-      LOG(ERROR) << "Failed to schedule ALTS handshaker requests";
++      ABSL_LOG(ERROR) << "Failed to schedule ALTS handshaker requests";
+       return ok;
+     }
+   }
+@@ -591,7 +591,7 @@ static tsi_result handshaker_next_dedicated(
+ }
+
+ static void handshaker_shutdown(tsi_handshaker* self) {
+-  CHECK_NE(self, nullptr);
++  ABSL_CHECK_NE(self, nullptr);
+   alts_tsi_handshaker* handshaker =
+       reinterpret_cast<alts_tsi_handshaker*>(self);
+   grpc_core::MutexLock lock(&handshaker->mu);
+@@ -637,7 +637,7 @@ static const tsi_handshaker_vtable handshaker_vtable_dedicated = {
+     handshaker_shutdown};
+
+ bool alts_tsi_handshaker_has_shutdown(alts_tsi_handshaker* handshaker) {
+-  CHECK_NE(handshaker, nullptr);
++  ABSL_CHECK_NE(handshaker, nullptr);
+   grpc_core::MutexLock lock(&handshaker->mu);
+   return handshaker->shutdown;
+ }
+@@ -649,7 +649,7 @@ tsi_result alts_tsi_handshaker_create(
+     size_t user_specified_max_frame_size) {
+   if (handshaker_service_url == nullptr || self == nullptr ||
+       options == nullptr || (is_client && target_name == nullptr)) {
+-    LOG(ERROR) << "Invalid arguments to alts_tsi_handshaker_create()";
++    ABSL_LOG(ERROR) << "Invalid arguments to alts_tsi_handshaker_create()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   bool use_dedicated_cq = interested_parties == nullptr;
+@@ -675,8 +675,8 @@ tsi_result alts_tsi_handshaker_create(
+ void alts_tsi_handshaker_result_set_unused_bytes(tsi_handshaker_result* result,
+                                                  grpc_slice* recv_bytes,
+                                                  size_t bytes_consumed) {
+-  CHECK(recv_bytes != nullptr);
+-  CHECK_NE(result, nullptr);
++  ABSL_CHECK(recv_bytes != nullptr);
++  ABSL_CHECK_NE(result, nullptr);
+   if (GRPC_SLICE_LENGTH(*recv_bytes) == bytes_consumed) {
+     return;
+   }
+@@ -695,19 +695,19 @@ namespace internal {
+
+ bool alts_tsi_handshaker_get_has_sent_start_message_for_testing(
+     alts_tsi_handshaker* handshaker) {
+-  CHECK_NE(handshaker, nullptr);
++  ABSL_CHECK_NE(handshaker, nullptr);
+   return handshaker->has_sent_start_message;
+ }
+
+ void alts_tsi_handshaker_set_client_vtable_for_testing(
+     alts_tsi_handshaker* handshaker, alts_handshaker_client_vtable* vtable) {
+-  CHECK_NE(handshaker, nullptr);
++  ABSL_CHECK_NE(handshaker, nullptr);
+   handshaker->client_vtable_for_testing = vtable;
+ }
+
+ bool alts_tsi_handshaker_get_is_client_for_testing(
+     alts_tsi_handshaker* handshaker) {
+-  CHECK_NE(handshaker, nullptr);
++  ABSL_CHECK_NE(handshaker, nullptr);
+   return handshaker->is_client;
+ }
+
+diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc
+index cc8f6dc78bd59..907987be79410 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc
+@@ -21,8 +21,8 @@
+ #include <grpc/byte_buffer_reader.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/slice/slice.h"
+ #include "src/core/lib/slice/slice_internal.h"
+
+@@ -45,8 +45,8 @@ tsi_result alts_tsi_utils_convert_to_tsi_result(grpc_status_code code) {
+
+ grpc_gcp_HandshakerResp* alts_tsi_utils_deserialize_response(
+     grpc_byte_buffer* resp_buffer, upb_Arena* arena) {
+-  CHECK_NE(resp_buffer, nullptr);
+-  CHECK_NE(arena, nullptr);
++  ABSL_CHECK_NE(resp_buffer, nullptr);
++  ABSL_CHECK_NE(arena, nullptr);
+   grpc_byte_buffer_reader bbr;
+   grpc_byte_buffer_reader_init(&bbr, resp_buffer);
+   grpc_slice slice = grpc_byte_buffer_reader_readall(&bbr);
+@@ -59,7 +59,7 @@ grpc_gcp_HandshakerResp* alts_tsi_utils_deserialize_response(
+   grpc_core::CSliceUnref(slice);
+   grpc_byte_buffer_reader_destroy(&bbr);
+   if (resp == nullptr) {
+-    LOG(ERROR) << "grpc_gcp_handshaker_resp_decode() failed";
++    ABSL_LOG(ERROR) << "grpc_gcp_handshaker_resp_decode() failed";
+     return nullptr;
+   }
+   return resp;
+diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc
+index a7881e0d71f78..77ca832cd234a 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc
+@@ -20,14 +20,14 @@
+
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "upb/mem/arena.hpp"
+
+ bool grpc_gcp_rpc_protocol_versions_set_max(
+     grpc_gcp_rpc_protocol_versions* versions, uint32_t max_major,
+     uint32_t max_minor) {
+   if (versions == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "versions is nullptr in grpc_gcp_rpc_protocol_versions_set_max().";
+     return false;
+   }
+@@ -40,7 +40,7 @@ bool grpc_gcp_rpc_protocol_versions_set_min(
+     grpc_gcp_rpc_protocol_versions* versions, uint32_t min_major,
+     uint32_t min_minor) {
+   if (versions == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "versions is nullptr in grpc_gcp_rpc_protocol_versions_set_min().";
+     return false;
+   }
+@@ -52,7 +52,7 @@ bool grpc_gcp_rpc_protocol_versions_set_min(
+ bool grpc_gcp_rpc_protocol_versions_encode(
+     const grpc_gcp_rpc_protocol_versions* versions, grpc_slice* slice) {
+   if (versions == nullptr || slice == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to "
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to "
+                   "grpc_gcp_rpc_protocol_versions_encode().";
+     return false;
+   }
+@@ -69,7 +69,7 @@ bool grpc_gcp_rpc_protocol_versions_encode(
+     const grpc_gcp_RpcProtocolVersions* versions, upb_Arena* arena,
+     grpc_slice* slice) {
+   if (versions == nullptr || arena == nullptr || slice == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to "
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to "
+                   "grpc_gcp_rpc_protocol_versions_encode().";
+     return false;
+   }
+@@ -86,7 +86,7 @@ bool grpc_gcp_rpc_protocol_versions_encode(
+ bool grpc_gcp_rpc_protocol_versions_decode(
+     const grpc_slice& slice, grpc_gcp_rpc_protocol_versions* versions) {
+   if (versions == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "version is nullptr in grpc_gcp_rpc_protocol_versions_decode().";
+     return false;
+   }
+@@ -96,7 +96,7 @@ bool grpc_gcp_rpc_protocol_versions_decode(
+           reinterpret_cast<const char*>(GRPC_SLICE_START_PTR(slice)),
+           GRPC_SLICE_LENGTH(slice), arena.ptr());
+   if (versions_msg == nullptr) {
+-    LOG(ERROR) << "cannot deserialize RpcProtocolVersions message";
++    ABSL_LOG(ERROR) << "cannot deserialize RpcProtocolVersions message";
+     return false;
+   }
+   grpc_gcp_rpc_protocol_versions_assign_from_upb(versions, versions_msg);
+@@ -152,7 +152,7 @@ bool grpc_gcp_rpc_protocol_versions_copy(
+     grpc_gcp_rpc_protocol_versions* dst) {
+   if ((src == nullptr && dst != nullptr) ||
+       (src != nullptr && dst == nullptr)) {
+-    LOG(ERROR) << "Invalid arguments to grpc_gcp_rpc_protocol_versions_copy().";
++    ABSL_LOG(ERROR) << "Invalid arguments to grpc_gcp_rpc_protocol_versions_copy().";
+     return false;
+   }
+   if (src == nullptr) {
+@@ -190,7 +190,7 @@ bool grpc_gcp_rpc_protocol_versions_check(
+     const grpc_gcp_rpc_protocol_versions* peer_versions,
+     grpc_gcp_rpc_protocol_versions_version* highest_common_version) {
+   if (local_versions == nullptr || peer_versions == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid arguments to grpc_gcp_rpc_protocol_versions_check().";
+     return false;
+   }
+diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc
+index 5bde0334f503b..1d9946877fafe 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc
+@@ -22,8 +22,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/slice/slice.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.h"
+@@ -67,7 +67,7 @@ static tsi_result alts_grpc_integrity_only_extra_copy_protect(
+   grpc_status_code status = alts_iovec_record_protocol_integrity_only_protect(
+       rp->iovec_rp, rp->iovec_buf, 1, header_iovec, tag_iovec, &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to protect, " << error_details;
++    ABSL_LOG(ERROR) << "Failed to protect, " << error_details;
+     gpr_free(error_details);
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -82,7 +82,7 @@ static tsi_result alts_grpc_integrity_only_protect(
+   // Input sanity check.
+   if (rp == nullptr || unprotected_slices == nullptr ||
+       protected_slices == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_grpc_record_protocol protect.";
+     return TSI_INVALID_ARGUMENT;
+   }
+@@ -107,7 +107,7 @@ static tsi_result alts_grpc_integrity_only_protect(
+       rp->iovec_rp, rp->iovec_buf, unprotected_slices->count, header_iovec,
+       tag_iovec, &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to protect, " << error_details;
++    ABSL_LOG(ERROR) << "Failed to protect, " << error_details;
+     gpr_free(error_details);
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -124,12 +124,12 @@ static tsi_result alts_grpc_integrity_only_unprotect(
+   // Input sanity check.
+   if (rp == nullptr || protected_slices == nullptr ||
+       unprotected_slices == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_grpc_record_protocol unprotect.";
+     return TSI_INVALID_ARGUMENT;
+   }
+   if (protected_slices->length < rp->header_length + rp->tag_length) {
+-    LOG(ERROR) << "Protected slices do not have sufficient data.";
++    ABSL_LOG(ERROR) << "Protected slices do not have sufficient data.";
+     return TSI_INVALID_ARGUMENT;
+   }
+   // In this method, rp points to alts_grpc_record_protocol struct
+@@ -141,14 +141,14 @@ static tsi_result alts_grpc_integrity_only_unprotect(
+   grpc_slice_buffer_reset_and_unref(&rp->header_sb);
+   grpc_slice_buffer_move_first(protected_slices, rp->header_length,
+                                &rp->header_sb);
+-  CHECK(rp->header_sb.length == rp->header_length);
++  ABSL_CHECK(rp->header_sb.length == rp->header_length);
+   iovec_t header_iovec = alts_grpc_record_protocol_get_header_iovec(rp);
+   // Moves protected slices data to data_sb and leaves the remaining tag.
+   grpc_slice_buffer_reset_and_unref(&integrity_only_record_protocol->data_sb);
+   grpc_slice_buffer_move_first(protected_slices,
+                                protected_slices->length - rp->tag_length,
+                                &integrity_only_record_protocol->data_sb);
+-  CHECK(protected_slices->length == rp->tag_length);
++  ABSL_CHECK(protected_slices->length == rp->tag_length);
+   iovec_t tag_iovec = {nullptr, rp->tag_length};
+   if (protected_slices->count == 1) {
+     tag_iovec.iov_base = GRPC_SLICE_START_PTR(protected_slices->slices[0]);
+@@ -168,7 +168,7 @@ static tsi_result alts_grpc_integrity_only_unprotect(
+       integrity_only_record_protocol->data_sb.count, header_iovec, tag_iovec,
+       &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to unprotect, " << error_details;
++    ABSL_LOG(ERROR) << "Failed to unprotect, " << error_details;
+     gpr_free(error_details);
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -198,7 +198,7 @@ tsi_result alts_grpc_integrity_only_record_protocol_create(
+     gsec_aead_crypter* crypter, size_t overflow_size, bool is_client,
+     bool is_protect, bool enable_extra_copy, alts_grpc_record_protocol** rp) {
+   if (crypter == nullptr || rp == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_grpc_record_protocol create.";
+     return TSI_INVALID_ARGUMENT;
+   }
+diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc
+index cc10ddb8eb487..06218824ee609 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/slice/slice.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.h"
+@@ -39,7 +39,7 @@ static tsi_result alts_grpc_privacy_integrity_protect(
+   // Input sanity check.
+   if (rp == nullptr || unprotected_slices == nullptr ||
+       protected_slices == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_grpc_record_protocol protect.";
+     return TSI_INVALID_ARGUMENT;
+   }
+@@ -60,7 +60,7 @@ static tsi_result alts_grpc_privacy_integrity_protect(
+           rp->iovec_rp, rp->iovec_buf, unprotected_slices->count,
+           protected_iovec, &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to protect, " << error_details;
++    ABSL_LOG(ERROR) << "Failed to protect, " << error_details;
+     gpr_free(error_details);
+     grpc_core::CSliceUnref(protected_slice);
+     return TSI_INTERNAL_ERROR;
+@@ -76,14 +76,14 @@ static tsi_result alts_grpc_privacy_integrity_unprotect(
+   // Input sanity check.
+   if (rp == nullptr || protected_slices == nullptr ||
+       unprotected_slices == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_grpc_record_protocol unprotect.";
+     return TSI_INVALID_ARGUMENT;
+   }
+   // Allocates memory for output frame. In privacy-integrity unprotect, the
+   // unprotected data are stored in a newly allocated buffer.
+   if (protected_slices->length < rp->header_length + rp->tag_length) {
+-    LOG(ERROR) << "Protected slices do not have sufficient data.";
++    ABSL_LOG(ERROR) << "Protected slices do not have sufficient data.";
+     return TSI_INVALID_ARGUMENT;
+   }
+   size_t unprotected_frame_size =
+@@ -104,7 +104,7 @@ static tsi_result alts_grpc_privacy_integrity_unprotect(
+           rp->iovec_rp, header_iovec, rp->iovec_buf, protected_slices->count,
+           unprotected_iovec, &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to unprotect, " << error_details;
++    ABSL_LOG(ERROR) << "Failed to unprotect, " << error_details;
+     gpr_free(error_details);
+     grpc_core::CSliceUnref(unprotected_slice);
+     return TSI_INTERNAL_ERROR;
+@@ -124,7 +124,7 @@ tsi_result alts_grpc_privacy_integrity_record_protocol_create(
+     gsec_aead_crypter* crypter, size_t overflow_size, bool is_client,
+     bool is_protect, alts_grpc_record_protocol** rp) {
+   if (crypter == nullptr || rp == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_grpc_record_protocol create.";
+     return TSI_INVALID_ARGUMENT;
+   }
+diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc
+index 76cf72290cc99..c51aca05288be 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc
+@@ -22,8 +22,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/util/crash.h"
+@@ -34,8 +34,8 @@ const size_t kInitialIovecBufferSize = 8;
+ // Makes sure iovec_buf in alts_grpc_record_protocol is large enough.
+ static void ensure_iovec_buf_size(alts_grpc_record_protocol* rp,
+                                   const grpc_slice_buffer* sb) {
+-  CHECK(rp != nullptr);
+-  CHECK_NE(sb, nullptr);
++  ABSL_CHECK(rp != nullptr);
++  ABSL_CHECK_NE(sb, nullptr);
+   if (sb->count <= rp->iovec_buf_length) {
+     return;
+   }
+@@ -50,8 +50,8 @@ static void ensure_iovec_buf_size(alts_grpc_record_protocol* rp,
+
+ void alts_grpc_record_protocol_convert_slice_buffer_to_iovec(
+     alts_grpc_record_protocol* rp, const grpc_slice_buffer* sb) {
+-  CHECK(rp != nullptr);
+-  CHECK_NE(sb, nullptr);
++  ABSL_CHECK(rp != nullptr);
++  ABSL_CHECK_NE(sb, nullptr);
+   ensure_iovec_buf_size(rp, sb);
+   for (size_t i = 0; i < sb->count; i++) {
+     rp->iovec_buf[i].iov_base = GRPC_SLICE_START_PTR(sb->slices[i]);
+@@ -61,8 +61,8 @@ void alts_grpc_record_protocol_convert_slice_buffer_to_iovec(
+
+ void alts_grpc_record_protocol_copy_slice_buffer(const grpc_slice_buffer* src,
+                                                  unsigned char* dst) {
+-  CHECK(src != nullptr);
+-  CHECK_NE(dst, nullptr);
++  ABSL_CHECK(src != nullptr);
++  ABSL_CHECK_NE(dst, nullptr);
+   for (size_t i = 0; i < src->count; i++) {
+     size_t slice_length = GRPC_SLICE_LENGTH(src->slices[i]);
+     memcpy(dst, GRPC_SLICE_START_PTR(src->slices[i]), slice_length);
+@@ -94,7 +94,7 @@ tsi_result alts_grpc_record_protocol_init(alts_grpc_record_protocol* rp,
+                                           bool is_integrity_only,
+                                           bool is_protect) {
+   if (rp == nullptr || crypter == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_grpc_record_protocol init.";
+     return TSI_INVALID_ARGUMENT;
+   }
+@@ -104,7 +104,7 @@ tsi_result alts_grpc_record_protocol_init(alts_grpc_record_protocol* rp,
+       crypter, overflow_size, is_client, is_integrity_only, is_protect,
+       &rp->iovec_rp, &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to create alts_iovec_record_protocol, "
++    ABSL_LOG(ERROR) << "Failed to create alts_iovec_record_protocol, "
+                << error_details;
+     gpr_free(error_details);
+     return TSI_INTERNAL_ERROR;
+diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc
+index 65c3e21a801ab..689593c9b6fd4 100644
+--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc
++++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc
+@@ -25,8 +25,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/tsi/alts/crypt/gsec.h"
+ #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.h"
+ #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.h"
+@@ -84,14 +84,14 @@ static bool read_frame_size(const grpc_slice_buffer* sb,
+       remaining -= slice_length;
+     }
+   }
+-  CHECK_EQ(remaining, 0u);
++  ABSL_CHECK_EQ(remaining, 0u);
+   // Gets little-endian frame size.
+   uint32_t frame_size = (static_cast<uint32_t>(frame_size_buffer[3]) << 24) |
+                         (static_cast<uint32_t>(frame_size_buffer[2]) << 16) |
+                         (static_cast<uint32_t>(frame_size_buffer[1]) << 8) |
+                         static_cast<uint32_t>(frame_size_buffer[0]);
+   if (frame_size > kMaxFrameLength) {
+-    LOG(ERROR) << "Frame size is larger than maximum frame size";
++    ABSL_LOG(ERROR) << "Frame size is larger than maximum frame size";
+     return false;
+   }
+   // Returns frame size including frame length field.
+@@ -122,7 +122,7 @@ static tsi_result create_alts_grpc_record_protocol(
+                                             kAesGcmTagLength, &crypter,
+                                             &error_details);
+   if (status != GRPC_STATUS_OK) {
+-    LOG(ERROR) << "Failed to create AEAD crypter, " << error_details;
++    ABSL_LOG(ERROR) << "Failed to create AEAD crypter, " << error_details;
+     gpr_free(error_details);
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -151,7 +151,7 @@ static tsi_result alts_zero_copy_grpc_protector_protect(
+     grpc_slice_buffer* protected_slices) {
+   if (self == nullptr || unprotected_slices == nullptr ||
+       protected_slices == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc protect.";
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc protect.";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_zero_copy_grpc_protector* protector =
+@@ -177,7 +177,7 @@ static tsi_result alts_zero_copy_grpc_protector_unprotect(
+     grpc_slice_buffer* unprotected_slices, int* min_progress_size) {
+   if (self == nullptr || unprotected_slices == nullptr ||
+       protected_slices == nullptr) {
+-    LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc unprotect.";
++    ABSL_LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc unprotect.";
+     return TSI_INVALID_ARGUMENT;
+   }
+   alts_zero_copy_grpc_protector* protector =
+@@ -262,7 +262,7 @@ tsi_result alts_zero_copy_grpc_protector_create(
+     size_t* max_protected_frame_size,
+     tsi_zero_copy_grpc_protector** protector) {
+   if (protector == nullptr) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Invalid nullptr arguments to alts_zero_copy_grpc_protector create.";
+     return TSI_INVALID_ARGUMENT;
+   }
+@@ -292,7 +292,7 @@ tsi_result alts_zero_copy_grpc_protector_create(
+       impl->max_unprotected_data_size =
+           alts_grpc_record_protocol_max_unprotected_data_size(
+               impl->record_protocol, max_protected_frame_size_to_set);
+-      CHECK_GT(impl->max_unprotected_data_size, 0u);
++      ABSL_CHECK_GT(impl->max_unprotected_data_size, 0u);
+       // Allocates internal slice buffers.
+       grpc_slice_buffer_init(&impl->unprotected_staging_sb);
+       grpc_slice_buffer_init(&impl->protected_sb);
+diff --git a/third_party/grpc/source/src/core/tsi/fake_transport_security.cc b/third_party/grpc/source/src/core/tsi/fake_transport_security.cc
+index 595a239051bf3..8e9f17b0854c3 100644
+--- a/third_party/grpc/source/src/core/tsi/fake_transport_security.cc
++++ b/third_party/grpc/source/src/core/tsi/fake_transport_security.cc
+@@ -23,8 +23,8 @@
+ #include <stdlib.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/tsi/transport_security_grpc.h"
+ #include "src/core/tsi/transport_security_interface.h"
+@@ -89,7 +89,7 @@ static const char* tsi_fake_handshake_message_strings[] = {
+
+ static const char* tsi_fake_handshake_message_to_string(int msg) {
+   if (msg < 0 || msg >= TSI_FAKE_HANDSHAKE_MESSAGE_MAX) {
+-    LOG(ERROR) << "Invalid message " << msg;
++    ABSL_LOG(ERROR) << "Invalid message " << msg;
+     return "UNKNOWN";
+   }
+   return tsi_fake_handshake_message_strings[msg];
+@@ -105,7 +105,7 @@ static tsi_result tsi_fake_handshake_message_from_string(
+       return TSI_OK;
+     }
+   }
+-  LOG(ERROR) << "Invalid handshake message.";
++  ABSL_LOG(ERROR) << "Invalid handshake message.";
+   if (error != nullptr) *error = "invalid handshake message";
+   return TSI_DATA_CORRUPTED;
+ }
+@@ -124,8 +124,8 @@ static void store32_little_endian(uint32_t value, unsigned char* buf) {
+ }
+
+ static uint32_t read_frame_size(const grpc_slice_buffer* sb) {
+-  CHECK(sb != nullptr);
+-  CHECK(sb->length >= TSI_FAKE_FRAME_HEADER_SIZE);
++  ABSL_CHECK(sb != nullptr);
++  ABSL_CHECK(sb->length >= TSI_FAKE_FRAME_HEADER_SIZE);
+   uint8_t frame_size_buffer[TSI_FAKE_FRAME_HEADER_SIZE];
+   uint8_t* buf = frame_size_buffer;
+   // Copies the first 4 bytes to a temporary buffer.
+@@ -142,7 +142,7 @@ static uint32_t read_frame_size(const grpc_slice_buffer* sb) {
+       remaining -= slice_length;
+     }
+   }
+-  CHECK_EQ(remaining, 0u);
++  ABSL_CHECK_EQ(remaining, 0u);
+   return load32_little_endian(frame_size_buffer);
+ }
+
+@@ -317,7 +317,7 @@ static tsi_result fake_protector_protect(tsi_frame_protector* self,
+     result = tsi_fake_frame_decode(frame_header, &written_in_frame_size, frame,
+                                    /*error=*/nullptr);
+     if (result != TSI_INCOMPLETE_DATA) {
+-      LOG(ERROR) << "tsi_fake_frame_decode returned "
++      ABSL_LOG(ERROR) << "tsi_fake_frame_decode returned "
+                  << tsi_result_to_string(result);
+       return result;
+     }
+@@ -474,7 +474,7 @@ static tsi_result fake_zero_copy_grpc_protector_unprotect(
+     if (impl->parsed_frame_size == 0) {
+       impl->parsed_frame_size = read_frame_size(&impl->protected_sb);
+       if (impl->parsed_frame_size <= 4) {
+-        LOG(ERROR) << "Invalid frame size.";
++        ABSL_LOG(ERROR) << "Invalid frame size.";
+         return TSI_DATA_CORRUPTED;
+       }
+     }
+@@ -690,7 +690,7 @@ static tsi_result fake_handshaker_process_bytes_from_peer(
+     return result;
+   }
+   if (received_msg != expected_msg) {
+-    LOG(ERROR) << "Invalid received message ("
++    ABSL_LOG(ERROR) << "Invalid received message ("
+                << tsi_fake_handshake_message_to_string(received_msg)
+                << " instead of "
+                << tsi_fake_handshake_message_to_string(expected_msg) << ")";
+diff --git a/third_party/grpc/source/src/core/tsi/local_transport_security.cc b/third_party/grpc/source/src/core/tsi/local_transport_security.cc
+index ced2ef2baa16f..f104b120d5f61 100644
+--- a/third_party/grpc/source/src/core/tsi/local_transport_security.cc
++++ b/third_party/grpc/source/src/core/tsi/local_transport_security.cc
+@@ -25,7 +25,7 @@
+ #include <stdlib.h>
+ #include <string.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/tsi/transport_security_grpc.h"
+ #include "src/core/util/crash.h"
+@@ -67,7 +67,7 @@ tsi_result handshaker_result_get_unused_bytes(const tsi_handshaker_result* self,
+                                               const unsigned char** bytes,
+                                               size_t* bytes_size) {
+   if (self == nullptr || bytes == nullptr || bytes_size == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to get_unused_bytes()";
++    ABSL_LOG(ERROR) << "Invalid arguments to get_unused_bytes()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   auto* result = reinterpret_cast<local_tsi_handshaker_result*>(
+@@ -100,7 +100,7 @@ tsi_result create_handshaker_result(const unsigned char* received_bytes,
+                                     size_t received_bytes_size,
+                                     tsi_handshaker_result** self) {
+   if (self == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
++    ABSL_LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   local_tsi_handshaker_result* result =
+@@ -127,7 +127,7 @@ tsi_result handshaker_next(tsi_handshaker* self,
+                            tsi_handshaker_on_next_done_cb /*cb*/,
+                            void* /*user_data*/, std::string* error) {
+   if (self == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to handshaker_next()";
++    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_next()";
+     if (error != nullptr) *error = "invalid argument";
+     return TSI_INVALID_ARGUMENT;
+   }
+@@ -163,7 +163,7 @@ const tsi_handshaker_vtable handshaker_vtable = {
+
+ tsi_result tsi_local_handshaker_create(tsi_handshaker** self) {
+   if (self == nullptr) {
+-    LOG(ERROR) << "Invalid arguments to local_tsi_handshaker_create()";
++    ABSL_LOG(ERROR) << "Invalid arguments to local_tsi_handshaker_create()";
+     return TSI_INVALID_ARGUMENT;
+   }
+   local_tsi_handshaker* handshaker = grpc_core::Zalloc<local_tsi_handshaker>();
+diff --git a/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc b/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc
+index b0f961a41c827..98d94259fed8c 100644
+--- a/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc
++++ b/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc
+@@ -18,8 +18,8 @@
+
+ #include <map>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/error.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/util/crash.h"
+@@ -48,12 +48,12 @@ TlsSessionKeyLoggerCache::TlsSessionKeyLogger::TlsSessionKeyLogger(
+     grpc_core::RefCountedPtr<TlsSessionKeyLoggerCache> cache)
+     : tls_session_key_log_file_path_(std::move(tls_session_key_log_file_path)),
+       cache_(std::move(cache)) {
+-  CHECK(!tls_session_key_log_file_path_.empty());
+-  CHECK(cache_ != nullptr);
++  ABSL_CHECK(!tls_session_key_log_file_path_.empty());
++  ABSL_CHECK(cache_ != nullptr);
+   fd_ = fopen(tls_session_key_log_file_path_.c_str(), "a");
+   if (fd_ == nullptr) {
+     grpc_error_handle error = GRPC_OS_ERROR(errno, "fopen");
+-    LOG(ERROR) << "Ignoring TLS Key logging. ERROR Opening TLS Keylog file: "
++    ABSL_LOG(ERROR) << "Ignoring TLS Key logging. ERROR Opening TLS Keylog file: "
+                << grpc_core::StatusToString(error);
+   }
+   cache_->tls_session_key_logger_map_.emplace(tls_session_key_log_file_path_,
+@@ -86,7 +86,7 @@ void TlsSessionKeyLoggerCache::TlsSessionKeyLogger::LogSessionKeys(
+
+   if (err) {
+     grpc_error_handle error = GRPC_OS_ERROR(errno, "fwrite");
+-    LOG(ERROR) << "Error Appending to TLS session key log file: "
++    ABSL_LOG(ERROR) << "Error Appending to TLS session key log file: "
+                << grpc_core::StatusToString(error);
+     fclose(fd_);
+     fd_ = nullptr;  // disable future attempts to write to this file
+@@ -108,7 +108,7 @@ TlsSessionKeyLoggerCache::~TlsSessionKeyLoggerCache() {
+ grpc_core::RefCountedPtr<TlsSessionKeyLogger> TlsSessionKeyLoggerCache::Get(
+     std::string tls_session_key_log_file_path) {
+   gpr_once_init(&g_cache_mutex_init, do_cache_mutex_init);
+-  DCHECK_NE(g_tls_session_key_log_cache_mu, nullptr);
++  ABSL_DCHECK_NE(g_tls_session_key_log_cache_mu, nullptr);
+   if (tls_session_key_log_file_path.empty()) {
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc
+index 6e107c066c51e..eec3eefe9f1ba 100644
+--- a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc
++++ b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc
+@@ -21,8 +21,8 @@
+ #include <grpc/support/port_platform.h>
+ #include <grpc/support/string_util.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/slice/slice_internal.h"
+ #include "src/core/tsi/ssl/session_cache/ssl_session.h"
+ #include "src/core/util/crash.h"
+@@ -63,7 +63,7 @@ class SslSessionLRUCache::Node {
+
+ SslSessionLRUCache::SslSessionLRUCache(size_t capacity) : capacity_(capacity) {
+   if (capacity == 0) {
+-    LOG(ERROR) << "SslSessionLRUCache capacity is zero. SSL sessions cannot be "
++    ABSL_LOG(ERROR) << "SslSessionLRUCache capacity is zero. SSL sessions cannot be "
+                   "resumed.";
+   }
+ }
+@@ -98,7 +98,7 @@ SslSessionLRUCache::Node* SslSessionLRUCache::FindLocked(
+
+ void SslSessionLRUCache::Put(const char* key, SslSessionPtr session) {
+   if (session == nullptr) {
+-    LOG(ERROR) << "Attempted to put null SSL session in session cache.";
++    ABSL_LOG(ERROR) << "Attempted to put null SSL session in session cache.";
+     return;
+   }
+   grpc_core::MutexLock lock(&lock_);
+@@ -112,7 +112,7 @@ void SslSessionLRUCache::Put(const char* key, SslSessionPtr session) {
+   entry_by_key_.emplace(key, node);
+   AssertInvariants();
+   if (use_order_list_size_ > capacity_) {
+-    CHECK(use_order_list_tail_);
++    ABSL_CHECK(use_order_list_tail_);
+     node = use_order_list_tail_;
+     Remove(node);
+     // Order matters, key is destroyed after deleting node.
+@@ -143,7 +143,7 @@ void SslSessionLRUCache::Remove(SslSessionLRUCache::Node* node) {
+   } else {
+     node->next_->prev_ = node->prev_;
+   }
+-  CHECK_GE(use_order_list_size_, 1u);
++  ABSL_CHECK_GE(use_order_list_size_, 1u);
+   use_order_list_size_--;
+ }
+
+@@ -169,16 +169,16 @@ void SslSessionLRUCache::AssertInvariants() {
+   Node* current = use_order_list_head_;
+   while (current != nullptr) {
+     size++;
+-    CHECK(current->prev_ == prev);
++    ABSL_CHECK(current->prev_ == prev);
+     auto it = entry_by_key_.find(current->key());
+-    CHECK(it != entry_by_key_.end());
+-    CHECK(it->second == current);
++    ABSL_CHECK(it != entry_by_key_.end());
++    ABSL_CHECK(it->second == current);
+     prev = current;
+     current = current->next_;
+   }
+-  CHECK(prev == use_order_list_tail_);
+-  CHECK(size == use_order_list_size_);
+-  CHECK(entry_by_key_.size() == use_order_list_size_);
++  ABSL_CHECK(prev == use_order_list_tail_);
++  ABSL_CHECK(size == use_order_list_size_);
++  ABSL_CHECK(entry_by_key_.size() == use_order_list_size_);
+ }
+ #else
+ void SslSessionLRUCache::AssertInvariants() {}
+diff --git a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc
+index f44b4cb7335ef..6628fc91ebbb1 100644
+--- a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc
++++ b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc
+@@ -17,7 +17,7 @@
+ //
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/tsi/ssl/session_cache/ssl_session.h"
+ #include "src/core/util/crash.h"
+
+@@ -41,11 +41,11 @@ class OpenSslCachedSession : public SslCachedSession {
+  public:
+   OpenSslCachedSession(SslSessionPtr session) {
+     int size = i2d_SSL_SESSION(session.get(), nullptr);
+-    CHECK_GT(size, 0);
++    ABSL_CHECK_GT(size, 0);
+     grpc_slice slice = grpc_slice_malloc(size_t(size));
+     unsigned char* start = GRPC_SLICE_START_PTR(slice);
+     int second_size = i2d_SSL_SESSION(session.get(), &start);
+-    CHECK(size == second_size);
++    ABSL_CHECK(size == second_size);
+     serialized_session_ = slice;
+   }
+
+diff --git a/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc b/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc
+index 9310314e00855..edd099773c392 100644
+--- a/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc
++++ b/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc
+@@ -55,8 +55,8 @@
+ #include <memory>
+ #include <string>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -202,7 +202,7 @@ static void init_openssl(void) {
+ #if OPENSSL_VERSION_NUMBER < 0x10100000
+   if (!CRYPTO_get_locking_callback()) {
+     int num_locks = CRYPTO_num_locks();
+-    CHECK_GT(num_locks, 0);
++    ABSL_CHECK_GT(num_locks, 0);
+     g_openssl_mutexes = static_cast<gpr_mu*>(
+         gpr_malloc(static_cast<size_t>(num_locks) * sizeof(gpr_mu)));
+     for (int i = 0; i < num_locks; i++) {
+@@ -216,15 +216,15 @@ static void init_openssl(void) {
+ #endif
+   g_ssl_ctx_ex_factory_index =
+       SSL_CTX_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
+-  CHECK_NE(g_ssl_ctx_ex_factory_index, -1);
++  ABSL_CHECK_NE(g_ssl_ctx_ex_factory_index, -1);
+
+   g_ssl_ctx_ex_crl_provider_index =
+       SSL_CTX_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
+-  CHECK_NE(g_ssl_ctx_ex_crl_provider_index, -1);
++  ABSL_CHECK_NE(g_ssl_ctx_ex_crl_provider_index, -1);
+
+   g_ssl_ex_verified_root_cert_index = SSL_get_ex_new_index(
+       0, nullptr, nullptr, nullptr, verified_root_cert_free);
+-  CHECK_NE(g_ssl_ex_verified_root_cert_index, -1);
++  ABSL_CHECK_NE(g_ssl_ex_verified_root_cert_index, -1);
+ }
+
+ // --- Ssl utils. ---
+@@ -233,7 +233,7 @@ static void init_openssl(void) {
+ static void ssl_log_where_info(const SSL* ssl, int where, int flag,
+                                const char* msg) {
+   if ((where & flag) && GRPC_TRACE_FLAG_ENABLED(tsi)) {
+-    LOG(INFO) << absl::StrFormat("%20.20s - %s  - %s", msg,
++    ABSL_LOG(INFO) << absl::StrFormat("%20.20s - %s  - %s", msg,
+                                  SSL_state_string_long(ssl),
+                                  SSL_state_string(ssl));
+   }
+@@ -242,7 +242,7 @@ static void ssl_log_where_info(const SSL* ssl, int where, int flag,
+ // Used for debugging. TODO(jboeuf): Remove when code is mature enough.
+ static void ssl_info_callback(const SSL* ssl, int where, int ret) {
+   if (ret == 0) {
+-    LOG(ERROR) << "ssl_info_callback: error occurred.\n";
++    ABSL_LOG(ERROR) << "ssl_info_callback: error occurred.\n";
+     return;
+   }
+
+@@ -285,28 +285,28 @@ static tsi_result ssl_get_x509_common_name(X509* cert, unsigned char** utf8,
+   X509_NAME* subject_name = X509_get_subject_name(cert);
+   int utf8_returned_size = 0;
+   if (subject_name == nullptr) {
+-    VLOG(2) << "Could not get subject name from certificate.";
++    ABSL_VLOG(2) << "Could not get subject name from certificate.";
+     return TSI_NOT_FOUND;
+   }
+   common_name_index =
+       X509_NAME_get_index_by_NID(subject_name, NID_commonName, -1);
+   if (common_name_index == -1) {
+-    VLOG(2) << "Could not get common name of subject from certificate.";
++    ABSL_VLOG(2) << "Could not get common name of subject from certificate.";
+     return TSI_NOT_FOUND;
+   }
+   common_name_entry = X509_NAME_get_entry(subject_name, common_name_index);
+   if (common_name_entry == nullptr) {
+-    LOG(ERROR) << "Could not get common name entry from certificate.";
++    ABSL_LOG(ERROR) << "Could not get common name entry from certificate.";
+     return TSI_INTERNAL_ERROR;
+   }
+   common_name_asn1 = X509_NAME_ENTRY_get_data(common_name_entry);
+   if (common_name_asn1 == nullptr) {
+-    LOG(ERROR) << "Could not get common name entry asn1 from certificate.";
++    ABSL_LOG(ERROR) << "Could not get common name entry asn1 from certificate.";
+     return TSI_INTERNAL_ERROR;
+   }
+   utf8_returned_size = ASN1_STRING_to_UTF8(utf8, common_name_asn1);
+   if (utf8_returned_size < 0) {
+-    LOG(ERROR) << "Could not extract utf8 from asn1 string.";
++    ABSL_LOG(ERROR) << "Could not extract utf8 from asn1 string.";
+     return TSI_OUT_OF_RESOURCES;
+   }
+   *utf8_size = static_cast<size_t>(utf8_returned_size);
+@@ -350,7 +350,7 @@ static tsi_result peer_property_from_x509_subject(X509* cert,
+   char* contents;
+   long len = BIO_get_mem_data(bio, &contents);
+   if (len < 0) {
+-    LOG(ERROR) << "Could not get subject entry from certificate.";
++    ABSL_LOG(ERROR) << "Could not get subject entry from certificate.";
+     BIO_free(bio);
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -415,7 +415,7 @@ static tsi_result add_subject_alt_names_properties_to_peer(
+         property_name = TSI_X509_URI_PEER_PROPERTY;
+       }
+       if (name_size < 0) {
+-        LOG(ERROR) << "Could not get utf8 from asn1 string.";
++        ABSL_LOG(ERROR) << "Could not get utf8 from asn1 string.";
+         result = TSI_INTERNAL_ERROR;
+         break;
+       }
+@@ -441,14 +441,14 @@ static tsi_result add_subject_alt_names_properties_to_peer(
+       } else if (subject_alt_name->d.iPAddress->length == 16) {
+         af = AF_INET6;
+       } else {
+-        LOG(ERROR) << "SAN IP Address contained invalid IP";
++        ABSL_LOG(ERROR) << "SAN IP Address contained invalid IP";
+         result = TSI_INTERNAL_ERROR;
+         break;
+       }
+       const char* name = inet_ntop(af, subject_alt_name->d.iPAddress->data,
+                                    ntop_buf, INET6_ADDRSTRLEN);
+       if (name == nullptr) {
+-        LOG(ERROR) << "Could not get IP string from asn1 octet.";
++        ABSL_LOG(ERROR) << "Could not get IP string from asn1 octet.";
+         result = TSI_INTERNAL_ERROR;
+         break;
+       }
+@@ -482,7 +482,7 @@ static tsi_result peer_from_x509(X509* cert, int include_certificate_type,
+           : 0;
+   size_t property_count;
+   tsi_result result;
+-  CHECK_GE(subject_alt_name_count, 0);
++  ABSL_CHECK_GE(subject_alt_name_count, 0);
+   property_count = (include_certificate_type ? size_t{1} : 0) +
+                    3 /* subject, common name, certificate */ +
+                    static_cast<size_t>(subject_alt_name_count);
+@@ -537,7 +537,7 @@ static tsi_result peer_from_x509(X509* cert, int include_certificate_type,
+   }
+   if (result != TSI_OK) tsi_peer_destruct(peer);
+
+-  CHECK((int)peer->property_count == current_insert_index);
++  ABSL_CHECK((int)peer->property_count == current_insert_index);
+   return result;
+ }
+
+@@ -548,7 +548,7 @@ static tsi_result ssl_ctx_use_certificate_chain(SSL_CTX* context,
+   tsi_result result = TSI_OK;
+   X509* certificate = nullptr;
+   BIO* pem;
+-  CHECK_LE(pem_cert_chain_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(pem_cert_chain_size, static_cast<size_t>(INT_MAX));
+   pem = BIO_new_mem_buf(pem_cert_chain, static_cast<int>(pem_cert_chain_size));
+   if (pem == nullptr) return TSI_OUT_OF_RESOURCES;
+
+@@ -611,7 +611,7 @@ static tsi_result ssl_ctx_use_engine_private_key(SSL_CTX* context,
+     }
+     engine_name = static_cast<char*>(gpr_zalloc(engine_name_length + 1));
+     memcpy(engine_name, engine_start, engine_name_length);
+-    VLOG(2) << "ENGINE key: " << engine_name;
++    ABSL_VLOG(2) << "ENGINE key: " << engine_name;
+     ENGINE_load_dynamic();
+     engine = ENGINE_by_id(engine_name);
+     if (engine == nullptr) {
+@@ -619,7 +619,7 @@ static tsi_result ssl_ctx_use_engine_private_key(SSL_CTX* context,
+       // current working directory.
+       engine = ENGINE_by_id("dynamic");
+       if (engine == nullptr) {
+-        LOG(ERROR) << "Cannot load dynamic engine";
++        ABSL_LOG(ERROR) << "Cannot load dynamic engine";
+         result = TSI_INVALID_ARGUMENT;
+         break;
+       }
+@@ -628,29 +628,29 @@ static tsi_result ssl_ctx_use_engine_private_key(SSL_CTX* context,
+           !ENGINE_ctrl_cmd_string(engine, "DIR_ADD", ".", 0) ||
+           !ENGINE_ctrl_cmd_string(engine, "LIST_ADD", "1", 0) ||
+           !ENGINE_ctrl_cmd_string(engine, "LOAD", NULL, 0)) {
+-        LOG(ERROR) << "Cannot find engine";
++        ABSL_LOG(ERROR) << "Cannot find engine";
+         result = TSI_INVALID_ARGUMENT;
+         break;
+       }
+     }
+     if (!ENGINE_set_default(engine, ENGINE_METHOD_ALL)) {
+-      LOG(ERROR) << "ENGINE_set_default with ENGINE_METHOD_ALL failed";
++      ABSL_LOG(ERROR) << "ENGINE_set_default with ENGINE_METHOD_ALL failed";
+       result = TSI_INVALID_ARGUMENT;
+       break;
+     }
+     if (!ENGINE_init(engine)) {
+-      LOG(ERROR) << "ENGINE_init failed";
++      ABSL_LOG(ERROR) << "ENGINE_init failed";
+       result = TSI_INVALID_ARGUMENT;
+       break;
+     }
+     private_key = ENGINE_load_private_key(engine, key_id, 0, 0);
+     if (private_key == nullptr) {
+-      LOG(ERROR) << "ENGINE_load_private_key failed";
++      ABSL_LOG(ERROR) << "ENGINE_load_private_key failed";
+       result = TSI_INVALID_ARGUMENT;
+       break;
+     }
+     if (!SSL_CTX_use_PrivateKey(context, private_key)) {
+-      LOG(ERROR) << "SSL_CTX_use_PrivateKey failed";
++      ABSL_LOG(ERROR) << "SSL_CTX_use_PrivateKey failed";
+       result = TSI_INVALID_ARGUMENT;
+       break;
+     }
+@@ -668,7 +668,7 @@ static tsi_result ssl_ctx_use_pem_private_key(SSL_CTX* context,
+   tsi_result result = TSI_OK;
+   EVP_PKEY* private_key = nullptr;
+   BIO* pem;
+-  CHECK_LE(pem_key_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(pem_key_size, static_cast<size_t>(INT_MAX));
+   pem = BIO_new_mem_buf(pem_key, static_cast<int>(pem_key_size));
+   if (pem == nullptr) return TSI_OUT_OF_RESOURCES;
+   do {
+@@ -713,7 +713,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
+   X509* root = nullptr;
+   X509_NAME* root_name = nullptr;
+   BIO* pem;
+-  CHECK_LE(pem_roots_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(pem_roots_size, static_cast<size_t>(INT_MAX));
+   pem = BIO_new_mem_buf(pem_roots, static_cast<int>(pem_roots_size));
+   if (cert_store == nullptr) return TSI_INVALID_ARGUMENT;
+   if (pem == nullptr) return TSI_OUT_OF_RESOURCES;
+@@ -731,7 +731,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
+     if (root_names != nullptr) {
+       root_name = X509_get_subject_name(root);
+       if (root_name == nullptr) {
+-        LOG(ERROR) << "Could not get name from root certificate.";
++        ABSL_LOG(ERROR) << "Could not get name from root certificate.";
+         result = TSI_INVALID_ARGUMENT;
+         break;
+       }
+@@ -748,7 +748,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
+       unsigned long error = ERR_get_error();
+       if (ERR_GET_LIB(error) != ERR_LIB_X509 ||
+           ERR_GET_REASON(error) != X509_R_CERT_ALREADY_IN_HASH_TABLE) {
+-        LOG(ERROR) << "Could not add root certificate to ssl context.";
++        ABSL_LOG(ERROR) << "Could not add root certificate to ssl context.";
+         result = TSI_INTERNAL_ERROR;
+         break;
+       }
+@@ -757,7 +757,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
+     num_roots++;
+   }
+   if (num_roots == 0) {
+-    LOG(ERROR) << "Could not load any root certificate.";
++    ABSL_LOG(ERROR) << "Could not load any root certificate.";
+     result = TSI_INVALID_ARGUMENT;
+   }
+
+@@ -796,7 +796,7 @@ static tsi_result populate_ssl_context(
+       result = ssl_ctx_use_certificate_chain(context, key_cert_pair->cert_chain,
+                                              strlen(key_cert_pair->cert_chain));
+       if (result != TSI_OK) {
+-        LOG(ERROR) << "Invalid cert chain file.";
++        ABSL_LOG(ERROR) << "Invalid cert chain file.";
+         return result;
+       }
+     }
+@@ -804,21 +804,21 @@ static tsi_result populate_ssl_context(
+       result = ssl_ctx_use_private_key(context, key_cert_pair->private_key,
+                                        strlen(key_cert_pair->private_key));
+       if (result != TSI_OK || !SSL_CTX_check_private_key(context)) {
+-        LOG(ERROR) << "Invalid private key.";
++        ABSL_LOG(ERROR) << "Invalid private key.";
+         return result != TSI_OK ? result : TSI_INVALID_ARGUMENT;
+       }
+     }
+   }
+   if ((cipher_list != nullptr) &&
+       !SSL_CTX_set_cipher_list(context, cipher_list)) {
+-    LOG(ERROR) << "Invalid cipher list: " << cipher_list;
++    ABSL_LOG(ERROR) << "Invalid cipher list: " << cipher_list;
+     return TSI_INVALID_ARGUMENT;
+   }
+   {
+ #if OPENSSL_VERSION_NUMBER < 0x30000000L
+     EC_KEY* ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
+     if (!SSL_CTX_set_tmp_ecdh(context, ecdh)) {
+-      LOG(ERROR) << "Could not set ephemeral ECDH key.";
++      ABSL_LOG(ERROR) << "Could not set ephemeral ECDH key.";
+       EC_KEY_free(ecdh);
+       return TSI_INTERNAL_ERROR;
+     }
+@@ -826,7 +826,7 @@ static tsi_result populate_ssl_context(
+     EC_KEY_free(ecdh);
+ #else
+     if (!SSL_CTX_set1_groups(context, kSslEcCurveNames, 1)) {
+-      LOG(ERROR) << "Could not set ephemeral ECDH key.";
++      ABSL_LOG(ERROR) << "Could not set ephemeral ECDH key.";
+       return TSI_INTERNAL_ERROR;
+     }
+     SSL_CTX_set_options(context, SSL_OP_SINGLE_ECDH_USE);
+@@ -846,7 +846,7 @@ tsi_result tsi_ssl_extract_x509_subject_names_from_pem_cert(
+
+   cert = PEM_read_bio_X509(pem, nullptr, nullptr, const_cast<char*>(""));
+   if (cert == nullptr) {
+-    LOG(ERROR) << "Invalid certificate";
++    ABSL_LOG(ERROR) << "Invalid certificate";
+     result = TSI_INVALID_ARGUMENT;
+   } else {
+     result = peer_from_x509(cert, 0, peer);
+@@ -869,7 +869,7 @@ static tsi_result build_alpn_protocol_name_list(
+     size_t length =
+         alpn_protocols[i] == nullptr ? 0 : strlen(alpn_protocols[i]);
+     if (length == 0 || length > 255) {
+-      LOG(ERROR) << "Invalid protocol name length: " << length;
++      ABSL_LOG(ERROR) << "Invalid protocol name length: " << length;
+       return TSI_INVALID_ARGUMENT;
+     }
+     *protocol_name_list_length += length + 1;
+@@ -904,7 +904,7 @@ static int verify_cb(int ok, X509_STORE_CTX* ctx) {
+     return 1;
+   }
+   if (cert_error != 0) {
+-    LOG(ERROR) << "Certificate verify failed with code " << cert_error;
++    ABSL_LOG(ERROR) << "Certificate verify failed with code " << cert_error;
+   }
+   return ok;
+ }
+@@ -948,7 +948,7 @@ static int RootCertExtractCallback(X509_STORE_CTX* ctx, void* /*arg*/) {
+   if (ssl_index < 0) {
+     char err_str[256];
+     ERR_error_string_n(ERR_get_error(), err_str, sizeof(err_str));
+-    LOG(ERROR) << "error getting the SSL index from the X509_STORE_CTX: "
++    ABSL_LOG(ERROR) << "error getting the SSL index from the X509_STORE_CTX: "
+                << err_str;
+     return ret;
+   }
+@@ -1053,12 +1053,12 @@ static bool ValidateCrl(X509* cert, X509* issuer, X509_CRL* crl) {
+   // 6.3.3b verify issuer and scope
+   valid = grpc_core::VerifyCrlCertIssuerNamesMatch(crl, cert);
+   if (!valid) {
+-    VLOG(2) << "CRL and cert issuer names mismatched.";
++    ABSL_VLOG(2) << "CRL and cert issuer names mismatched.";
+     return valid;
+   }
+   valid = grpc_core::HasCrlSignBit(issuer);
+   if (!valid) {
+-    VLOG(2) << "CRL issuer not allowed to sign CRLs.";
++    ABSL_VLOG(2) << "CRL issuer not allowed to sign CRLs.";
+     return valid;
+   }
+   // 6.3.3c Not supporting deltas
+@@ -1069,7 +1069,7 @@ static bool ValidateCrl(X509* cert, X509* issuer, X509_CRL* crl) {
+   // 6.3.3g Verify CRL Signature
+   valid = grpc_core::VerifyCrlSignature(crl, issuer);
+   if (!valid) {
+-    VLOG(2) << "Crl signature check failed.";
++    ABSL_VLOG(2) << "Crl signature check failed.";
+   }
+   return valid;
+ }
+@@ -1159,7 +1159,7 @@ static int CheckChainRevocation(
+ static int CustomVerificationFunction(X509_STORE_CTX* ctx, void* arg) {
+   int ret = X509_verify_cert(ctx);
+   if (ret <= 0) {
+-    VLOG(2) << "Failed to verify cert chain.";
++    ABSL_VLOG(2) << "Failed to verify cert chain.";
+     // Verification failed. We shouldn't expect to have a verified chain, so
+     // there is no need to attempt to extract the root cert from it, check for
+     // revocation, or check anything else.
+@@ -1169,7 +1169,7 @@ static int CustomVerificationFunction(X509_STORE_CTX* ctx, void* arg) {
+   if (provider != nullptr) {
+     ret = CheckChainRevocation(ctx, provider);
+     if (ret <= 0) {
+-      VLOG(2) << "The chain failed revocation checks.";
++      ABSL_VLOG(2) << "The chain failed revocation checks.";
+       return ret;
+     }
+   }
+@@ -1236,25 +1236,25 @@ static tsi_result tsi_set_min_and_max_tls_versions(
+ tsi_ssl_root_certs_store* tsi_ssl_root_certs_store_create(
+     const char* pem_roots) {
+   if (pem_roots == nullptr) {
+-    LOG(ERROR) << "The root certificates are empty.";
++    ABSL_LOG(ERROR) << "The root certificates are empty.";
+     return nullptr;
+   }
+   tsi_ssl_root_certs_store* root_store = static_cast<tsi_ssl_root_certs_store*>(
+       gpr_zalloc(sizeof(tsi_ssl_root_certs_store)));
+   if (root_store == nullptr) {
+-    LOG(ERROR) << "Could not allocate buffer for ssl_root_certs_store.";
++    ABSL_LOG(ERROR) << "Could not allocate buffer for ssl_root_certs_store.";
+     return nullptr;
+   }
+   root_store->store = X509_STORE_new();
+   if (root_store->store == nullptr) {
+-    LOG(ERROR) << "Could not allocate buffer for X509_STORE.";
++    ABSL_LOG(ERROR) << "Could not allocate buffer for X509_STORE.";
+     gpr_free(root_store);
+     return nullptr;
+   }
+   tsi_result result = x509_store_load_certs(root_store->store, pem_roots,
+                                             strlen(pem_roots), nullptr);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "Could not load root certificates.";
++    ABSL_LOG(ERROR) << "Could not load root certificates.";
+     X509_STORE_free(root_store->store);
+     gpr_free(root_store);
+     return nullptr;
+@@ -1380,7 +1380,7 @@ static tsi_ssl_handshaker_factory_vtable handshaker_factory_vtable = {nullptr};
+ // allocating memory for the factory.
+ static void tsi_ssl_handshaker_factory_init(
+     tsi_ssl_handshaker_factory* factory) {
+-  CHECK_NE(factory, nullptr);
++  ABSL_CHECK_NE(factory, nullptr);
+
+   factory->vtable = &handshaker_factory_vtable;
+   gpr_ref_init(&factory->refcount, 1);
+@@ -1484,7 +1484,7 @@ static tsi_result ssl_handshaker_result_extract_peer(
+     result = peer_property_from_x509_subject(
+         verified_root_cert, &peer->properties[peer->property_count], true);
+     if (result != TSI_OK) {
+-      VLOG(2) << "Problem extracting subject from verified_root_cert. result: "
++      ABSL_VLOG(2) << "Problem extracting subject from verified_root_cert. result: "
+               << result;
+     }
+     peer->property_count++;
+@@ -1529,7 +1529,7 @@ static tsi_result ssl_handshaker_result_create_frame_protector(
+   protector_impl->buffer =
+       static_cast<unsigned char*>(gpr_malloc(protector_impl->buffer_size));
+   if (protector_impl->buffer == nullptr) {
+-    LOG(ERROR) << "Could not allocate buffer for tsi_ssl_frame_protector.";
++    ABSL_LOG(ERROR) << "Could not allocate buffer for tsi_ssl_frame_protector.";
+     gpr_free(protector_impl);
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -1606,7 +1606,7 @@ static tsi_result ssl_handshaker_get_bytes_to_send_to_peer(
+     if (error != nullptr) *error = "invalid argument";
+     return TSI_INVALID_ARGUMENT;
+   }
+-  CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
+   bytes_read_from_ssl =
+       BIO_read(impl->network_io, bytes, static_cast<int>(*bytes_size));
+   if (bytes_read_from_ssl < 0) {
+@@ -1662,7 +1662,7 @@ static tsi_result ssl_handshaker_do_handshake(tsi_ssl_handshaker* impl,
+           const char* verify_err = X509_verify_cert_error_string(verify_result);
+           verify_result_str = absl::StrCat(": ", verify_err);
+         }
+-        LOG(INFO) << "Handshake failed with error "
++        ABSL_LOG(INFO) << "Handshake failed with error "
+                   << grpc_core::SslErrorString(ssl_result) << ": " << err_str
+                   << verify_result_str;
+         if (error != nullptr) {
+@@ -1684,11 +1684,11 @@ static tsi_result ssl_handshaker_process_bytes_from_peer(
+     if (error != nullptr) *error = "invalid argument";
+     return TSI_INVALID_ARGUMENT;
+   }
+-  CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
+   bytes_written_into_ssl_size =
+       BIO_write(impl->network_io, bytes, static_cast<int>(*bytes_size));
+   if (bytes_written_into_ssl_size < 0) {
+-    LOG(ERROR) << "Could not write to memory BIO.";
++    ABSL_LOG(ERROR) << "Could not write to memory BIO.";
+     if (error != nullptr) *error = "could not write to memory BIO";
+     impl->result = TSI_INTERNAL_ERROR;
+     return impl->result;
+@@ -1728,7 +1728,7 @@ static tsi_result ssl_bytes_remaining(tsi_ssl_handshaker* impl,
+   // If an unexpected number of bytes were read, return an error status and
+   // free all of the bytes that were read.
+   if (bytes_read < 0 || static_cast<size_t>(bytes_read) != bytes_in_ssl) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "Failed to read the expected number of bytes from SSL object.";
+     gpr_free(*bytes_remaining);
+     *bytes_remaining = nullptr;
+@@ -1835,7 +1835,7 @@ static tsi_result ssl_handshaker_next(tsi_handshaker* self,
+         ssl_bytes_remaining(impl, &unused_bytes, &unused_bytes_size, error);
+     if (status != TSI_OK) return status;
+     if (unused_bytes_size > received_bytes_size) {
+-      LOG(ERROR) << "More unused bytes than received bytes.";
++      ABSL_LOG(ERROR) << "More unused bytes than received bytes.";
+       gpr_free(unused_bytes);
+       if (error != nullptr) *error = "More unused bytes than received bytes.";
+       return TSI_INTERNAL_ERROR;
+@@ -1900,7 +1900,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,
+   tsi_ssl_handshaker* impl = nullptr;
+   *handshaker = nullptr;
+   if (ctx == nullptr) {
+-    LOG(ERROR) << "SSL Context is null. Should never happen.";
++    ABSL_LOG(ERROR) << "SSL Context is null. Should never happen.";
+     return TSI_INTERNAL_ERROR;
+   }
+   if (ssl == nullptr) {
+@@ -1910,7 +1910,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,
+
+   if (!BIO_new_bio_pair(&network_io, network_bio_buf_size, &ssl_io,
+                         ssl_bio_buf_size)) {
+-    LOG(ERROR) << "BIO_new_bio_pair failed.";
++    ABSL_LOG(ERROR) << "BIO_new_bio_pair failed.";
+     SSL_free(ssl);
+     return TSI_OUT_OF_RESOURCES;
+   }
+@@ -1923,7 +1923,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,
+     if (server_name_indication != nullptr &&
+         !looks_like_ip_address(server_name_indication)) {
+       if (!SSL_set_tlsext_host_name(ssl, server_name_indication)) {
+-        LOG(ERROR) << "Invalid server name indication "
++        ABSL_LOG(ERROR) << "Invalid server name indication "
+                    << server_name_indication;
+         SSL_free(ssl);
+         BIO_free(network_io);
+@@ -1940,7 +1940,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,
+     ssl_result = SSL_do_handshake(ssl);
+     ssl_result = SSL_get_error(ssl, ssl_result);
+     if (ssl_result != SSL_ERROR_WANT_READ) {
+-      LOG(ERROR)
++      ABSL_LOG(ERROR)
+           << "Unexpected error received from first SSL_do_handshake call: "
+           << grpc_core::SslErrorString(ssl_result);
+       SSL_free(ssl);
+@@ -2099,7 +2099,7 @@ static int does_entry_match_name(absl::string_view entry,
+
+   // Wildchar subdomain matching.
+   if (entry.size() < 3 || entry[1] != '.') {  // At least *.x
+-    LOG(ERROR) << "Invalid wildchar entry.";
++    ABSL_LOG(ERROR) << "Invalid wildchar entry.";
+     return 0;
+   }
+   size_t name_subdomain_pos = name.find('.');
+@@ -2110,7 +2110,7 @@ static int does_entry_match_name(absl::string_view entry,
+   entry.remove_prefix(2);                   // Remove *.
+   size_t dot = name_subdomain.find('.');
+   if (dot == absl::string_view::npos || dot == name_subdomain.size() - 1) {
+-    LOG(ERROR) << "Invalid toplevel subdomain: " << name_subdomain;
++    ABSL_LOG(ERROR) << "Invalid toplevel subdomain: " << name_subdomain;
+     return 0;
+   }
+   if (name_subdomain.back() == '.') {
+@@ -2137,7 +2137,7 @@ static int ssl_server_handshaker_factory_servername_callback(SSL* ssl,
+       return SSL_TLSEXT_ERR_OK;
+     }
+   }
+-  LOG(ERROR) << "No match found for server name: " << servername;
++  ABSL_LOG(ERROR) << "No match found for server name: " << servername;
+   return SSL_TLSEXT_ERR_NOACK;
+ }
+
+@@ -2158,7 +2158,7 @@ static int server_handshaker_factory_npn_advertised_callback(
+   tsi_ssl_server_handshaker_factory* factory =
+       static_cast<tsi_ssl_server_handshaker_factory*>(arg);
+   *out = factory->alpn_protocol_list;
+-  CHECK(factory->alpn_protocol_list_length <= UINT_MAX);
++  ABSL_CHECK(factory->alpn_protocol_list_length <= UINT_MAX);
+   *outlen = static_cast<unsigned int>(factory->alpn_protocol_list_length);
+   return SSL_TLSEXT_ERR_OK;
+ }
+@@ -2192,7 +2192,7 @@ static int server_handshaker_factory_new_session_callback(
+ template <typename T>
+ static void ssl_keylogging_callback(const SSL* ssl, const char* info) {
+   SSL_CTX* ssl_context = SSL_get_SSL_CTX(ssl);
+-  CHECK_NE(ssl_context, nullptr);
++  ABSL_CHECK_NE(ssl_context, nullptr);
+   void* arg = SSL_CTX_get_ex_data(ssl_context, g_ssl_ctx_ex_factory_index);
+   T* factory = static_cast<T*>(arg);
+   factory->key_logger->LogSessionKeys(ssl_context, info);
+@@ -2244,7 +2244,7 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
+ #endif
+   if (ssl_context == nullptr) {
+     grpc_core::LogSslErrorStack();
+-    LOG(ERROR) << "Could not create ssl context.";
++    ABSL_LOG(ERROR) << "Could not create ssl context.";
+     return TSI_INVALID_ARGUMENT;
+   }
+
+@@ -2311,7 +2311,7 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
+
+       X509_VERIFY_PARAM_set_depth(param, kMaxChainLength);
+       if (result != TSI_OK) {
+-        LOG(ERROR) << "Cannot load server root certificates.";
++        ABSL_LOG(ERROR) << "Cannot load server root certificates.";
+         break;
+       }
+     }
+@@ -2321,16 +2321,16 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
+           options->alpn_protocols, options->num_alpn_protocols,
+           &impl->alpn_protocol_list, &impl->alpn_protocol_list_length);
+       if (result != TSI_OK) {
+-        LOG(ERROR) << "Building alpn list failed with error "
++        ABSL_LOG(ERROR) << "Building alpn list failed with error "
+                    << tsi_result_to_string(result);
+         break;
+       }
+ #if TSI_OPENSSL_ALPN_SUPPORT
+-      CHECK(impl->alpn_protocol_list_length < UINT_MAX);
++      ABSL_CHECK(impl->alpn_protocol_list_length < UINT_MAX);
+       if (SSL_CTX_set_alpn_protos(
+               ssl_context, impl->alpn_protocol_list,
+               static_cast<unsigned int>(impl->alpn_protocol_list_length))) {
+-        LOG(ERROR) << "Could not set alpn protocol list to context.";
++        ABSL_LOG(ERROR) << "Could not set alpn protocol list to context.";
+         result = TSI_INVALID_ARGUMENT;
+         break;
+       }
+@@ -2360,7 +2360,7 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
+     X509_STORE_set_verify_cb(cert_store, verify_cb);
+     if (!X509_STORE_load_locations(cert_store, nullptr,
+                                    options->crl_directory)) {
+-      LOG(ERROR) << "Failed to load CRL File from directory.";
++      ABSL_LOG(ERROR) << "Failed to load CRL File from directory.";
+     } else {
+       X509_VERIFY_PARAM* param = X509_STORE_get0_param(cert_store);
+       X509_VERIFY_PARAM_set_flags(
+@@ -2465,7 +2465,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
+ #endif
+       if (impl->ssl_contexts[i] == nullptr) {
+         grpc_core::LogSslErrorStack();
+-        LOG(ERROR) << "Could not create ssl context.";
++        ABSL_LOG(ERROR) << "Could not create ssl context.";
+         result = TSI_OUT_OF_RESOURCES;
+         break;
+       }
+@@ -2487,7 +2487,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
+           impl->ssl_contexts[i], kSslSessionIdContext,
+           GPR_ARRAY_SIZE(kSslSessionIdContext));
+       if (set_sid_ctx_result == 0) {
+-        LOG(ERROR) << "Failed to set session id context.";
++        ABSL_LOG(ERROR) << "Failed to set session id context.";
+         result = TSI_INTERNAL_ERROR;
+         break;
+       }
+@@ -2497,7 +2497,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
+                 impl->ssl_contexts[i],
+                 const_cast<char*>(options->session_ticket_key),
+                 options->session_ticket_key_size) == 0) {
+-          LOG(ERROR) << "Invalid STEK size.";
++          ABSL_LOG(ERROR) << "Invalid STEK size.";
+           result = TSI_INVALID_ARGUMENT;
+           break;
+         }
+@@ -2510,7 +2510,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
+             strlen(options->pem_client_root_certs),
+             options->send_client_ca_list ? &root_names : nullptr);
+         if (result != TSI_OK) {
+-          LOG(ERROR) << "Invalid verification certs.";
++          ABSL_LOG(ERROR) << "Invalid verification certs.";
+           break;
+         }
+         if (options->send_client_ca_list) {
+@@ -2558,7 +2558,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
+         X509_STORE_set_verify_cb(cert_store, verify_cb);
+         if (!X509_STORE_load_locations(cert_store, nullptr,
+                                        options->crl_directory)) {
+-          LOG(ERROR) << "Failed to load CRL File from directory.";
++          ABSL_LOG(ERROR) << "Failed to load CRL File from directory.";
+         } else {
+           X509_VERIFY_PARAM* param = X509_STORE_get0_param(cert_store);
+           X509_VERIFY_PARAM_set_flags(
+@@ -2654,8 +2654,8 @@ int tsi_ssl_peer_matches_name(const tsi_peer* peer, absl::string_view name) {
+ const tsi_ssl_handshaker_factory_vtable* tsi_ssl_handshaker_factory_swap_vtable(
+     tsi_ssl_handshaker_factory* factory,
+     tsi_ssl_handshaker_factory_vtable* new_vtable) {
+-  CHECK_NE(factory, nullptr);
+-  CHECK_NE(factory->vtable, nullptr);
++  ABSL_CHECK_NE(factory, nullptr);
++  ABSL_CHECK_NE(factory->vtable, nullptr);
+
+   const tsi_ssl_handshaker_factory_vtable* orig_vtable = factory->vtable;
+   factory->vtable = new_vtable;
+diff --git a/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc b/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc
+index 5c3b828751ebc..0dbfbd9615b1b 100644
+--- a/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc
++++ b/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc
+@@ -30,8 +30,8 @@
+ #include <openssl/x509.h>
+ #include <openssl/x509v3.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/tsi/transport_security_interface.h"
+@@ -68,24 +68,24 @@ void LogSslErrorStack(void) {
+   while ((err = ERR_get_error()) != 0) {
+     char details[256];
+     ERR_error_string_n(static_cast<uint32_t>(err), details, sizeof(details));
+-    LOG(ERROR) << details;
++    ABSL_LOG(ERROR) << details;
+   }
+ }
+
+ tsi_result DoSslWrite(SSL* ssl, unsigned char* unprotected_bytes,
+                       size_t unprotected_bytes_size) {
+-  CHECK_LE(unprotected_bytes_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(unprotected_bytes_size, static_cast<size_t>(INT_MAX));
+   ERR_clear_error();
+   int ssl_write_result = SSL_write(ssl, unprotected_bytes,
+                                    static_cast<int>(unprotected_bytes_size));
+   if (ssl_write_result < 0) {
+     ssl_write_result = SSL_get_error(ssl, ssl_write_result);
+     if (ssl_write_result == SSL_ERROR_WANT_READ) {
+-      LOG(ERROR)
++      ABSL_LOG(ERROR)
+           << "Peer tried to renegotiate SSL connection. This is unsupported.";
+       return TSI_UNIMPLEMENTED;
+     } else {
+-      LOG(ERROR) << "SSL_write failed with error "
++      ABSL_LOG(ERROR) << "SSL_write failed with error "
+                  << SslErrorString(ssl_write_result);
+       return TSI_INTERNAL_ERROR;
+     }
+@@ -95,7 +95,7 @@ tsi_result DoSslWrite(SSL* ssl, unsigned char* unprotected_bytes,
+
+ tsi_result DoSslRead(SSL* ssl, unsigned char* unprotected_bytes,
+                      size_t* unprotected_bytes_size) {
+-  CHECK_LE(*unprotected_bytes_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(*unprotected_bytes_size, static_cast<size_t>(INT_MAX));
+   ERR_clear_error();
+   int read_from_ssl = SSL_read(ssl, unprotected_bytes,
+                                static_cast<int>(*unprotected_bytes_size));
+@@ -107,15 +107,15 @@ tsi_result DoSslRead(SSL* ssl, unsigned char* unprotected_bytes,
+         *unprotected_bytes_size = 0;
+         return TSI_OK;
+       case SSL_ERROR_WANT_WRITE:
+-        LOG(ERROR)
++        ABSL_LOG(ERROR)
+             << "Peer tried to renegotiate SSL connection. This is unsupported.";
+         return TSI_UNIMPLEMENTED;
+       case SSL_ERROR_SSL:
+-        LOG(ERROR) << "Corruption detected.";
++        ABSL_LOG(ERROR) << "Corruption detected.";
+         LogSslErrorStack();
+         return TSI_DATA_CORRUPTED;
+       default:
+-        LOG(ERROR) << "SSL_read failed with error "
++        ABSL_LOG(ERROR) << "SSL_read failed with error "
+                    << SslErrorString(read_from_ssl);
+         return TSI_PROTOCOL_FAILURE;
+     }
+@@ -139,11 +139,11 @@ tsi_result SslProtectorProtect(const unsigned char* unprotected_bytes,
+   int pending_in_ssl = static_cast<int>(BIO_pending(network_io));
+   if (pending_in_ssl > 0) {
+     *unprotected_bytes_size = 0;
+-    CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
++    ABSL_CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
+     read_from_ssl = BIO_read(network_io, protected_output_frames,
+                              static_cast<int>(*protected_output_frames_size));
+     if (read_from_ssl < 0) {
+-      LOG(ERROR) << "Could not read from BIO even though some data is pending";
++      ABSL_LOG(ERROR) << "Could not read from BIO even though some data is pending";
+       return TSI_INTERNAL_ERROR;
+     }
+     *protected_output_frames_size = static_cast<size_t>(read_from_ssl);
+@@ -165,11 +165,11 @@ tsi_result SslProtectorProtect(const unsigned char* unprotected_bytes,
+   result = DoSslWrite(ssl, buffer, buffer_size);
+   if (result != TSI_OK) return result;
+
+-  CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
+   read_from_ssl = BIO_read(network_io, protected_output_frames,
+                            static_cast<int>(*protected_output_frames_size));
+   if (read_from_ssl < 0) {
+-    LOG(ERROR) << "Could not read from BIO after SSL_write.";
++    ABSL_LOG(ERROR) << "Could not read from BIO after SSL_write.";
+     return TSI_INTERNAL_ERROR;
+   }
+   *protected_output_frames_size = static_cast<size_t>(read_from_ssl);
+@@ -195,20 +195,20 @@ tsi_result SslProtectorProtectFlush(size_t& buffer_offset,
+   }
+
+   pending = static_cast<int>(BIO_pending(network_io));
+-  CHECK_GE(pending, 0);
++  ABSL_CHECK_GE(pending, 0);
+   *still_pending_size = static_cast<size_t>(pending);
+   if (*still_pending_size == 0) return TSI_OK;
+
+-  CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
+   read_from_ssl = BIO_read(network_io, protected_output_frames,
+                            static_cast<int>(*protected_output_frames_size));
+   if (read_from_ssl <= 0) {
+-    LOG(ERROR) << "Could not read from BIO after SSL_write.";
++    ABSL_LOG(ERROR) << "Could not read from BIO after SSL_write.";
+     return TSI_INTERNAL_ERROR;
+   }
+   *protected_output_frames_size = static_cast<size_t>(read_from_ssl);
+   pending = static_cast<int>(BIO_pending(network_io));
+-  CHECK_GE(pending, 0);
++  ABSL_CHECK_GE(pending, 0);
+   *still_pending_size = static_cast<size_t>(pending);
+   return TSI_OK;
+ }
+@@ -236,11 +236,11 @@ tsi_result SslProtectorUnprotect(const unsigned char* protected_frames_bytes,
+   *unprotected_bytes_size = output_bytes_size - output_bytes_offset;
+
+   // Then, try to write some data to ssl.
+-  CHECK_LE(*protected_frames_bytes_size, static_cast<size_t>(INT_MAX));
++  ABSL_CHECK_LE(*protected_frames_bytes_size, static_cast<size_t>(INT_MAX));
+   written_into_ssl = BIO_write(network_io, protected_frames_bytes,
+                                static_cast<int>(*protected_frames_bytes_size));
+   if (written_into_ssl < 0) {
+-    LOG(ERROR) << "Sending protected frame to ssl failed with "
++    ABSL_LOG(ERROR) << "Sending protected frame to ssl failed with "
+                << written_into_ssl;
+     return TSI_INTERNAL_ERROR;
+   }
+@@ -263,15 +263,15 @@ bool VerifyCrlSignature(X509_CRL* crl, X509* issuer) {
+   if (ikey == nullptr) {
+     // Can't verify signature because we couldn't get the pubkey, fail the
+     // check.
+-    VLOG(2) << "Could not get public key from certificate.";
++    ABSL_VLOG(2) << "Could not get public key from certificate.";
+     EVP_PKEY_free(ikey);
+     return false;
+   }
+   int ret = X509_CRL_verify(crl, ikey);
+   if (ret < 0) {
+-    VLOG(2) << "There was an unexpected problem checking the CRL signature.";
++    ABSL_VLOG(2) << "There was an unexpected problem checking the CRL signature.";
+   } else if (ret == 0) {
+-    VLOG(2) << "CRL failed verification.";
++    ABSL_VLOG(2) << "CRL failed verification.";
+   }
+   EVP_PKEY_free(ikey);
+   return ret == 1;
+diff --git a/third_party/grpc/source/src/core/util/alloc.cc b/third_party/grpc/source/src/core/util/alloc.cc
+index 2ce94f9db7834..1cb9700b7088c 100644
+--- a/third_party/grpc/source/src/core/util/alloc.cc
++++ b/third_party/grpc/source/src/core/util/alloc.cc
+@@ -21,7 +21,7 @@
+ #include <stdlib.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/util/crash.h"
+
+ void* gpr_malloc(size_t size) {
+@@ -57,7 +57,7 @@ void* gpr_realloc(void* p, size_t size) {
+ }
+
+ void* gpr_malloc_aligned(size_t size, size_t alignment) {
+-  CHECK_EQ(((alignment - 1) & alignment), 0u);  // Must be power of 2.
++  ABSL_CHECK_EQ(((alignment - 1) & alignment), 0u);  // Must be power of 2.
+   size_t extra = alignment - 1 + sizeof(void*);
+   void* p = gpr_malloc(size + extra);
+   void** ret = reinterpret_cast<void**>(
+diff --git a/third_party/grpc/source/src/core/util/chunked_vector.h b/third_party/grpc/source/src/core/util/chunked_vector.h
+index d3a1d6ba93002..927839a24ab71 100644
+--- a/third_party/grpc/source/src/core/util/chunked_vector.h
++++ b/third_party/grpc/source/src/core/util/chunked_vector.h
+@@ -21,7 +21,7 @@
+ #include <iterator>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/resource_quota/arena.h"
+ #include "src/core/util/manual_constructor.h"
+
+@@ -86,9 +86,9 @@ class ChunkedVector {
+
+   // Remove the last element and return it.
+   T PopBack() {
+-    CHECK_NE(append_, nullptr);
++    ABSL_CHECK_NE(append_, nullptr);
+     if (append_->count == 0) {
+-      CHECK(first_ != append_);
++      ABSL_CHECK(first_ != append_);
+       Chunk* chunk = first_;
+       while (chunk->next != append_) {
+         chunk = chunk->next;
+@@ -234,7 +234,7 @@ class ChunkedVector {
+  private:
+   ManualConstructor<T>* AppendSlot() {
+     if (append_ == nullptr) {
+-      CHECK_EQ(first_, nullptr);
++      ABSL_CHECK_EQ(first_, nullptr);
+       first_ = arena_->New<Chunk>();
+       append_ = first_;
+     } else if (append_->count == kChunkSize) {
+diff --git a/third_party/grpc/source/src/core/util/crash.cc b/third_party/grpc/source/src/core/util/crash.cc
+index c77412e2b96ac..66d1e21dab824 100644
+--- a/third_party/grpc/source/src/core/util/crash.cc
++++ b/third_party/grpc/source/src/core/util/crash.cc
+@@ -20,13 +20,13 @@
+
+ #include <string>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+
+ namespace grpc_core {
+
+ void Crash(absl::string_view message, SourceLocation location) {
+-  LOG(ERROR).AtLocation(location.file(), location.line()) << message;
++  ABSL_LOG(ERROR).AtLocation(location.file(), location.line()) << message;
+   abort();
+ }
+
+diff --git a/third_party/grpc/source/src/core/util/down_cast.h b/third_party/grpc/source/src/core/util/down_cast.h
+index b658f5bab38e8..e46a2f90916eb 100644
+--- a/third_party/grpc/source/src/core/util/down_cast.h
++++ b/third_party/grpc/source/src/core/util/down_cast.h
+@@ -20,7 +20,7 @@
+ #include <type_traits>
+
+ #include "absl/base/config.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -32,7 +32,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline To DownCast(From* f) {
+ // If we have RTTI & we're in debug, assert that the cast is legal.
+ #if ABSL_INTERNAL_HAS_RTTI
+ #ifndef NDEBUG
+-  if (f != nullptr) CHECK_NE(dynamic_cast<To>(f), nullptr);
++  if (f != nullptr) ABSL_CHECK_NE(dynamic_cast<To>(f), nullptr);
+ #endif
+ #endif
+   return static_cast<To>(f);
+diff --git a/third_party/grpc/source/src/core/util/dual_ref_counted.h b/third_party/grpc/source/src/core/util/dual_ref_counted.h
+index 4742c62bc2c6c..953035b18220f 100644
+--- a/third_party/grpc/source/src/core/util/dual_ref_counted.h
++++ b/third_party/grpc/source/src/core/util/dual_ref_counted.h
+@@ -22,8 +22,8 @@
+ #include <atomic>
+ #include <cstdint>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/debug_location.h"
+ #include "src/core/util/down_cast.h"
+ #include "src/core/util/orphanable.h"
+@@ -92,11 +92,11 @@ class DualRefCounted : public Impl {
+ #ifndef NDEBUG
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+     if (trace_ != nullptr) {
+-      VLOG(2) << trace_ << ":" << this << " unref " << strong_refs << " -> "
++      ABSL_VLOG(2) << trace_ << ":" << this << " unref " << strong_refs << " -> "
+               << strong_refs - 1 << ", weak_ref " << weak_refs << " -> "
+               << weak_refs + 1;
+     }
+-    CHECK_GT(strong_refs, 0u);
++    ABSL_CHECK_GT(strong_refs, 0u);
+ #endif
+     if (GPR_UNLIKELY(strong_refs == 1)) {
+       Orphaned();
+@@ -111,12 +111,12 @@ class DualRefCounted : public Impl {
+ #ifndef NDEBUG
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+     if (trace_ != nullptr) {
+-      VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
++      ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+               << location.line() << " unref " << strong_refs << " -> "
+               << strong_refs - 1 << ", weak_ref " << weak_refs << " -> "
+               << weak_refs + 1 << ") " << reason;
+     }
+-    CHECK_GT(strong_refs, 0u);
++    ABSL_CHECK_GT(strong_refs, 0u);
+ #else
+     // Avoid unused-parameter warnings for debug-only parameters
+     (void)location;
+@@ -136,7 +136,7 @@ class DualRefCounted : public Impl {
+ #ifndef NDEBUG
+       const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+       if (trace_ != nullptr) {
+-        VLOG(2) << trace_ << ":" << this << " ref_if_non_zero " << strong_refs
++        ABSL_VLOG(2) << trace_ << ":" << this << " ref_if_non_zero " << strong_refs
+                 << " -> " << strong_refs + 1 << " (weak_refs=" << weak_refs
+                 << ")";
+       }
+@@ -155,7 +155,7 @@ class DualRefCounted : public Impl {
+ #ifndef NDEBUG
+       const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+       if (trace_ != nullptr) {
+-        VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
++        ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+                 << location.line() << " ref_if_non_zero " << strong_refs
+                 << " -> " << strong_refs + 1 << " (weak_refs=" << weak_refs
+                 << ") " << reason;
+@@ -213,10 +213,10 @@ class DualRefCounted : public Impl {
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
+     if (trace != nullptr) {
+-      VLOG(2) << trace << ":" << this << " weak_unref " << weak_refs << " -> "
++      ABSL_VLOG(2) << trace << ":" << this << " weak_unref " << weak_refs << " -> "
+               << weak_refs - 1 << " (refs=" << strong_refs << ")";
+     }
+-    CHECK_GT(weak_refs, 0u);
++    ABSL_CHECK_GT(weak_refs, 0u);
+ #endif
+     if (GPR_UNLIKELY(prev_ref_pair == MakeRefPair(0, 1))) {
+       unref_behavior_(static_cast<Child*>(this));
+@@ -235,11 +235,11 @@ class DualRefCounted : public Impl {
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
+     if (trace != nullptr) {
+-      VLOG(2) << trace << ":" << this << " " << location.file() << ":"
++      ABSL_VLOG(2) << trace << ":" << this << " " << location.file() << ":"
+               << location.line() << " weak_unref " << weak_refs << " -> "
+               << weak_refs - 1 << " (refs=" << strong_refs << ") " << reason;
+     }
+-    CHECK_GT(weak_refs, 0u);
++    ABSL_CHECK_GT(weak_refs, 0u);
+ #else
+     // Avoid unused-parameter warnings for debug-only parameters
+     (void)location;
+@@ -298,9 +298,9 @@ class DualRefCounted : public Impl {
+         refs_.fetch_add(MakeRefPair(1, 0), std::memory_order_relaxed);
+     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+-    CHECK_NE(strong_refs, 0u);
++    ABSL_CHECK_NE(strong_refs, 0u);
+     if (trace_ != nullptr) {
+-      VLOG(2) << trace_ << ":" << this << " ref " << strong_refs << " -> "
++      ABSL_VLOG(2) << trace_ << ":" << this << " ref " << strong_refs << " -> "
+               << strong_refs + 1 << "; (weak_refs=" << weak_refs << ")";
+     }
+ #else
+@@ -313,9 +313,9 @@ class DualRefCounted : public Impl {
+         refs_.fetch_add(MakeRefPair(1, 0), std::memory_order_relaxed);
+     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+-    CHECK_NE(strong_refs, 0u);
++    ABSL_CHECK_NE(strong_refs, 0u);
+     if (trace_ != nullptr) {
+-      VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
++      ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+               << location.line() << " ref " << strong_refs << " -> "
+               << strong_refs + 1 << " (weak_refs=" << weak_refs << ") "
+               << reason;
+@@ -335,10 +335,10 @@ class DualRefCounted : public Impl {
+     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+     if (trace_ != nullptr) {
+-      VLOG(2) << trace_ << ":" << this << " weak_ref " << weak_refs << " -> "
++      ABSL_VLOG(2) << trace_ << ":" << this << " weak_ref " << weak_refs << " -> "
+               << weak_refs + 1 << "; (refs=" << strong_refs << ")";
+     }
+-    if (strong_refs == 0) CHECK_NE(weak_refs, 0u);
++    if (strong_refs == 0) ABSL_CHECK_NE(weak_refs, 0u);
+ #else
+     refs_.fetch_add(MakeRefPair(0, 1), std::memory_order_relaxed);
+ #endif
+@@ -351,11 +351,11 @@ class DualRefCounted : public Impl {
+     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
+     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
+     if (trace_ != nullptr) {
+-      VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
++      ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+               << location.line() << " weak_ref " << weak_refs << " -> "
+               << weak_refs + 1 << " (refs=" << strong_refs << ") " << reason;
+     }
+-    if (strong_refs == 0) CHECK_NE(weak_refs, 0u);
++    if (strong_refs == 0) ABSL_CHECK_NE(weak_refs, 0u);
+ #else
+     // Use conditionally-important parameters
+     (void)location;
+diff --git a/third_party/grpc/source/src/core/util/dump_args.cc b/third_party/grpc/source/src/core/util/dump_args.cc
+index bd82483bfcd95..515536a500ef9 100644
+--- a/third_party/grpc/source/src/core/util/dump_args.cc
++++ b/third_party/grpc/source/src/core/util/dump_args.cc
+@@ -14,7 +14,7 @@
+
+ #include "src/core/util/dump_args.h"
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/ascii.h"
+ #include "absl/strings/string_view.h"
+
+@@ -41,7 +41,7 @@ void DumpArgs::Stringify(CustomSink& sink) const {
+     }
+   }
+   keys.push_back(start);
+-  CHECK_EQ(keys.size(), arg_dumpers_.size());
++  ABSL_CHECK_EQ(keys.size(), arg_dumpers_.size());
+   for (size_t i = 0; i < keys.size(); i++) {
+     if (i != 0) sink.Append(", ");
+     sink.Append(absl::StripAsciiWhitespace(keys[i]));
+diff --git a/third_party/grpc/source/src/core/util/dump_args.h b/third_party/grpc/source/src/core/util/dump_args.h
+index 8e1d44335cb86..dbc6eae34dc6f 100644
+--- a/third_party/grpc/source/src/core/util/dump_args.h
++++ b/third_party/grpc/source/src/core/util/dump_args.h
+@@ -105,7 +105,7 @@ class DumpArgs {
+ // Usage:
+ //   int a = 1;
+ //   int b = 2;
+-//   LOG(INFO) << GRPC_DUMP_ARGS(a, b)
++//   ABSL_LOG(INFO) << GRPC_DUMP_ARGS(a, b)
+ // Output:
+ //   a = 1, b = 2
+ #define GRPC_DUMP_ARGS(...) \
+diff --git a/third_party/grpc/source/src/core/util/event_log.cc b/third_party/grpc/source/src/core/util/event_log.cc
+index 66611150e6fa0..c2edb636e8632 100644
+--- a/third_party/grpc/source/src/core/util/event_log.cc
++++ b/third_party/grpc/source/src/core/util/event_log.cc
+@@ -19,7 +19,7 @@
+ #include <algorithm>
+ #include <atomic>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+
+@@ -28,7 +28,7 @@ namespace grpc_core {
+ std::atomic<EventLog*> EventLog::g_instance_{nullptr};
+
+ EventLog::~EventLog() {
+-  CHECK(g_instance_.load(std::memory_order_acquire) != this);
++  ABSL_CHECK(g_instance_.load(std::memory_order_acquire) != this);
+ }
+
+ void EventLog::BeginCollection() {
+diff --git a/third_party/grpc/source/src/core/util/gcp_metadata_query.cc b/third_party/grpc/source/src/core/util/gcp_metadata_query.cc
+index cc9fd80cd1b45..770c88aa1586a 100644
+--- a/third_party/grpc/source/src/core/util/gcp_metadata_query.cc
++++ b/third_party/grpc/source/src/core/util/gcp_metadata_query.cc
+@@ -27,8 +27,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+@@ -70,7 +70,7 @@ GcpMetadataQuery::GcpMetadataQuery(
+   GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);
+   auto uri = URI::Create("http", std::move(metadata_server_name), attribute_,
+                          {} /* query params */, "" /* fragment */);
+-  CHECK(uri.ok());  // params are hardcoded
++  ABSL_CHECK(uri.ok());  // params are hardcoded
+   grpc_http_request request;
+   memset(&request, 0, sizeof(grpc_http_request));
+   grpc_http_header header = {const_cast<char*>("Metadata-Flavor"),
+diff --git a/third_party/grpc/source/src/core/util/gpr_time.cc b/third_party/grpc/source/src/core/util/gpr_time.cc
+index 657da132f5eb1..115f2d467d0f8 100644
+--- a/third_party/grpc/source/src/core/util/gpr_time.cc
++++ b/third_party/grpc/source/src/core/util/gpr_time.cc
+@@ -24,11 +24,11 @@
+ #include <stdio.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ int gpr_time_cmp(gpr_timespec a, gpr_timespec b) {
+   int cmp = (a.tv_sec > b.tv_sec) - (a.tv_sec < b.tv_sec);
+-  CHECK(a.clock_type == b.clock_type);
++  ABSL_CHECK(a.clock_type == b.clock_type);
+   if (cmp == 0 && a.tv_sec != INT64_MAX && a.tv_sec != INT64_MIN) {
+     cmp = (a.tv_nsec > b.tv_nsec) - (a.tv_nsec < b.tv_nsec);
+   }
+@@ -76,7 +76,7 @@ static gpr_timespec to_seconds_from_sub_second_time(int64_t time_in_units,
+   } else if (time_in_units == INT64_MIN) {
+     out = gpr_inf_past(type);
+   } else {
+-    DCHECK_EQ(GPR_NS_PER_SEC % units_per_sec, 0);
++    ABSL_DCHECK_EQ(GPR_NS_PER_SEC % units_per_sec, 0);
+
+     out.tv_sec = time_in_units / units_per_sec;
+     out.tv_nsec =
+@@ -136,11 +136,11 @@ gpr_timespec gpr_time_from_hours(int64_t h, gpr_clock_type clock_type) {
+ gpr_timespec gpr_time_add(gpr_timespec a, gpr_timespec b) {
+   gpr_timespec sum;
+   int64_t inc = 0;
+-  CHECK(b.clock_type == GPR_TIMESPAN);
++  ABSL_CHECK(b.clock_type == GPR_TIMESPAN);
+   // tv_nsec in a timespan is always +ve. -ve timespan is represented as (-ve
+   // tv_sec, +ve tv_nsec). For example, timespan = -2.5 seconds is represented
+   // as {-3, 5e8, GPR_TIMESPAN}
+-  CHECK_GE(b.tv_nsec, 0);
++  ABSL_CHECK_GE(b.tv_nsec, 0);
+   sum.clock_type = a.clock_type;
+   sum.tv_nsec = a.tv_nsec + b.tv_nsec;
+   if (sum.tv_nsec >= GPR_NS_PER_SEC) {
+@@ -174,9 +174,9 @@ gpr_timespec gpr_time_sub(gpr_timespec a, gpr_timespec b) {
+     // tv_nsec in a timespan is always +ve. -ve timespan is represented as (-ve
+     // tv_sec, +ve tv_nsec). For example, timespan = -2.5 seconds is represented
+     // as {-3, 5e8, GPR_TIMESPAN}
+-    CHECK_GE(b.tv_nsec, 0);
++    ABSL_CHECK_GE(b.tv_nsec, 0);
+   } else {
+-    CHECK(a.clock_type == b.clock_type);
++    ABSL_CHECK(a.clock_type == b.clock_type);
+     diff.clock_type = GPR_TIMESPAN;
+   }
+   diff.tv_nsec = a.tv_nsec - b.tv_nsec;
+@@ -207,8 +207,8 @@ gpr_timespec gpr_time_sub(gpr_timespec a, gpr_timespec b) {
+ int gpr_time_similar(gpr_timespec a, gpr_timespec b, gpr_timespec threshold) {
+   int cmp_ab;
+
+-  CHECK(a.clock_type == b.clock_type);
+-  CHECK(threshold.clock_type == GPR_TIMESPAN);
++  ABSL_CHECK(a.clock_type == b.clock_type);
++  ABSL_CHECK(threshold.clock_type == GPR_TIMESPAN);
+
+   cmp_ab = gpr_time_cmp(a, b);
+   if (cmp_ab == 0) return 1;
+diff --git a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc
+index 1d5b866e5e044..f77fcddef3a24 100644
+--- a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc
++++ b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc
+@@ -25,14 +25,14 @@
+ #include <errno.h>
+ #include <net/if.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/grpc_if_nametoindex.h"
+
+ uint32_t grpc_if_nametoindex(char* name) {
+   uint32_t out = if_nametoindex(name);
+   if (out == 0) {
+-    VLOG(2) << "if_nametoindex failed for name " << name << ". errno " << errno;
++    ABSL_VLOG(2) << "if_nametoindex failed for name " << name << ". errno " << errno;
+   }
+   return out;
+ }
+diff --git a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc
+index cabca947c60c7..7db85c8187fd8 100644
+--- a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc
++++ b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc
+@@ -22,12 +22,12 @@
+
+ #if GRPC_IF_NAMETOINDEX == 0 || !defined(GRPC_POSIX_SOCKET_IF_NAMETOINDEX)
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/grpc_if_nametoindex.h"
+
+ uint32_t grpc_if_nametoindex(char* name) {
+-  VLOG(2) << "Not attempting to convert interface name " << name
++  ABSL_VLOG(2) << "Not attempting to convert interface name " << name
+           << " to index for current platform.";
+   return 0;
+ }
+diff --git a/third_party/grpc/source/src/core/util/host_port.cc b/third_party/grpc/source/src/core/util/host_port.cc
+index 3f2608951e361..980a57be773bc 100644
+--- a/third_party/grpc/source/src/core/util/host_port.cc
++++ b/third_party/grpc/source/src/core/util/host_port.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <stddef.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+
+@@ -91,10 +91,10 @@ bool SplitHostPort(absl::string_view name, absl::string_view* host,
+
+ bool SplitHostPort(absl::string_view name, std::string* host,
+                    std::string* port) {
+-  DCHECK(host != nullptr);
+-  DCHECK(host->empty());
+-  DCHECK(port != nullptr);
+-  DCHECK(port->empty());
++  ABSL_DCHECK(host != nullptr);
++  ABSL_DCHECK(host->empty());
++  ABSL_DCHECK(port != nullptr);
++  ABSL_DCHECK(port->empty());
+   absl::string_view host_view;
+   absl::string_view port_view;
+   bool has_port;
+diff --git a/third_party/grpc/source/src/core/util/http_client/httpcli.cc b/third_party/grpc/source/src/core/util/http_client/httpcli.cc
+index 2a92a2553b5fc..601911c65efd0 100644
+--- a/third_party/grpc/source/src/core/util/http_client/httpcli.cc
++++ b/third_party/grpc/source/src/core/util/http_client/httpcli.cc
+@@ -28,7 +28,7 @@
+ #include <utility>
+
+ #include "absl/functional/bind_front.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/config/core_configuration.h"
+@@ -196,7 +196,7 @@ HttpRequest::HttpRequest(
+   GRPC_CLOSURE_INIT(&continue_done_write_after_schedule_on_exec_ctx_,
+                     ContinueDoneWriteAfterScheduleOnExecCtx, this,
+                     grpc_schedule_on_exec_ctx);
+-  CHECK(pollent);
++  ABSL_CHECK(pollent);
+   grpc_polling_entity_add_to_pollset_set(pollent, pollset_set_);
+ }
+
+@@ -254,7 +254,7 @@ void HttpRequest::Start() {
+ void HttpRequest::Orphan() {
+   {
+     MutexLock lock(&mu_);
+-    CHECK(!cancelled_);
++    ABSL_CHECK(!cancelled_);
+     cancelled_ = true;
+     // cancel potentially pending DNS resolution.
+     if (use_event_engine_dns_resolver_) {
+diff --git a/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc b/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc
+index 4fba0765c8707..10b69ecd24840 100644
+--- a/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc
++++ b/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc
+@@ -28,7 +28,7 @@
+ #include <optional>
+ #include <string>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+@@ -92,7 +92,7 @@ class grpc_httpcli_ssl_channel_security_connector final
+           handshaker_factory_, secure_peer_name_, /*network_bio_buf_size=*/0,
+           /*ssl_bio_buf_size=*/0, &handshaker);
+       if (result != TSI_OK) {
+-        LOG(ERROR) << "Handshaker creation failed with error "
++        ABSL_LOG(ERROR) << "Handshaker creation failed with error "
+                    << tsi_result_to_string(result);
+       }
+     }
+@@ -146,7 +146,7 @@ httpcli_ssl_channel_security_connector_create(
+     const char* pem_root_certs, const tsi_ssl_root_certs_store* root_store,
+     const char* secure_peer_name) {
+   if (secure_peer_name != nullptr && pem_root_certs == nullptr) {
+-    LOG(ERROR) << "Cannot assert a secure peer name without a trust root.";
++    ABSL_LOG(ERROR) << "Cannot assert a secure peer name without a trust root.";
+     return nullptr;
+   }
+   RefCountedPtr<grpc_httpcli_ssl_channel_security_connector> c =
+@@ -154,7 +154,7 @@ httpcli_ssl_channel_security_connector_create(
+           secure_peer_name == nullptr ? nullptr : gpr_strdup(secure_peer_name));
+   tsi_result result = c->InitHandshakerFactory(pem_root_certs, root_store);
+   if (result != TSI_OK) {
+-    LOG(ERROR) << "Handshaker factory creation failed with "
++    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
+                << tsi_result_to_string(result);
+     return nullptr;
+   }
+@@ -170,7 +170,7 @@ class HttpRequestSSLCredentials : public grpc_channel_credentials {
+     const tsi_ssl_root_certs_store* root_store =
+         DefaultSslRootStore::GetRootStore();
+     if (root_store == nullptr) {
+-      LOG(ERROR) << "Could not get default pem root certs.";
++      ABSL_LOG(ERROR) << "Could not get default pem root certs.";
+       return nullptr;
+     }
+     std::optional<std::string> target_string =
+diff --git a/third_party/grpc/source/src/core/util/http_client/parser.cc b/third_party/grpc/source/src/core/util/http_client/parser.cc
+index a490f212ee91c..64e2b477e8358 100644
+--- a/third_party/grpc/source/src/core/util/http_client/parser.cc
++++ b/third_party/grpc/source/src/core/util/http_client/parser.cc
+@@ -24,8 +24,8 @@
+
+ #include <algorithm>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+
+ static char* buf2str(void* buffer, size_t length) {
+@@ -175,7 +175,7 @@ static grpc_error_handle add_header(grpc_http_parser* parser) {
+   grpc_http_header hdr = {nullptr, nullptr};
+   grpc_error_handle error;
+
+-  CHECK(cur != end);
++  ABSL_CHECK(cur != end);
+
+   if (*cur == ' ' || *cur == '\t') {
+     error = GRPC_ERROR_CREATE("Continued header lines not supported yet");
+@@ -189,14 +189,14 @@ static grpc_error_handle add_header(grpc_http_parser* parser) {
+     error = GRPC_ERROR_CREATE("Didn't find ':' in header string");
+     goto done;
+   }
+-  CHECK(cur >= beg);
++  ABSL_CHECK(cur >= beg);
+   hdr.key = buf2str(beg, static_cast<size_t>(cur - beg));
+   cur++;  // skip :
+
+   while (cur != end && (*cur == ' ' || *cur == '\t')) {
+     cur++;
+   }
+-  CHECK((size_t)(end - cur) >= parser->cur_line_end_length);
++  ABSL_CHECK((size_t)(end - cur) >= parser->cur_line_end_length);
+   size = static_cast<size_t>(end - cur) - parser->cur_line_end_length;
+   if ((size != 0) && (cur[size - 1] == '\r')) {
+     size--;
+diff --git a/third_party/grpc/source/src/core/util/json/json_reader.cc b/third_party/grpc/source/src/core/util/json/json_reader.cc
+index 5b437af925ef2..50091e23443e1 100644
+--- a/third_party/grpc/source/src/core/util/json/json_reader.cc
++++ b/third_party/grpc/source/src/core/util/json/json_reader.cc
+@@ -27,7 +27,7 @@
+ #include <vector>
+
+ #include "absl/base/attributes.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -277,14 +277,14 @@ bool JsonReader::StartContainer(Json::Type type) {
+   if (type == Json::Type::kObject) {
+     scope.data = Json::Object();
+   } else {
+-    CHECK(type == Json::Type::kArray);
++    ABSL_CHECK(type == Json::Type::kArray);
+     scope.data = Json::Array();
+   }
+   return true;
+ }
+
+ void JsonReader::EndContainer() {
+-  CHECK(!stack_.empty());
++  ABSL_CHECK(!stack_.empty());
+   Scope scope = std::move(stack_.back());
+   stack_.pop_back();
+   key_ = std::move(scope.parent_object_key);
+diff --git a/third_party/grpc/source/src/core/util/latent_see.cc b/third_party/grpc/source/src/core/util/latent_see.cc
+index 97d483cf7faa8..9ab12d0c63c67 100644
+--- a/third_party/grpc/source/src/core/util/latent_see.cc
++++ b/third_party/grpc/source/src/core/util/latent_see.cc
+@@ -54,7 +54,7 @@ void Log::TryPullEventsAndFlush(
+   // This is relatively quick and ensures that we don't stall capture for
+   // long.
+   for (auto& fragment : fragments_) {
+-    CHECK_EQ(fragment.flushing.size(), 0);
++    ABSL_CHECK_EQ(fragment.flushing.size(), 0);
+     MutexLock lock(&fragment.mu_active);
+     fragment.flushing.swap(fragment.active);
+   }
+diff --git a/third_party/grpc/source/src/core/util/latent_see.h b/third_party/grpc/source/src/core/util/latent_see.h
+index c0b5831eb7900..95525dea6565f 100644
+--- a/third_party/grpc/source/src/core/util/latent_see.h
++++ b/third_party/grpc/source/src/core/util/latent_see.h
+@@ -34,7 +34,7 @@
+ #include "absl/base/thread_annotations.h"
+ #include "absl/functional/any_invocable.h"
+ #include "absl/functional/function_ref.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/util/per_cpu.h"
+ #include "src/core/util/sync.h"
+@@ -123,7 +123,7 @@ class Log {
+       atexit([] {
+         auto json = log->TryGenerateJson();
+         if (!json.has_value()) {
+-          LOG(INFO) << "Failed to generate latent_see.json (contention with "
++          ABSL_LOG(INFO) << "Failed to generate latent_see.json (contention with "
+                        "another writer)";
+           return;
+         }
+@@ -131,7 +131,7 @@ class Log {
+           log->stats_flusher_(*json);
+           return;
+         }
+-        LOG(INFO) << "Writing latent_see.json in " << get_current_dir_name();
++        ABSL_LOG(INFO) << "Writing latent_see.json in " << get_current_dir_name();
+         FILE* f = fopen("latent_see.json", "w");
+         if (f == nullptr) return;
+         fprintf(f, "%s", json->c_str());
+@@ -182,7 +182,7 @@ class Scope {
+       bin_descriptor_ = Log::StartBin(this);
+       bin_ = Log::ToBin(bin_descriptor_);
+     }
+-    CHECK_NE(bin_, nullptr);
++    ABSL_CHECK_NE(bin_, nullptr);
+     bin_->Append(metadata_, EventType::kBegin, 0);
+   }
+   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~Scope() {
+diff --git a/third_party/grpc/source/src/core/util/linux/cpu.cc b/third_party/grpc/source/src/core/util/linux/cpu.cc
+index 41730292e89fe..b32e43f99ea70 100644
+--- a/third_party/grpc/source/src/core/util/linux/cpu.cc
++++ b/third_party/grpc/source/src/core/util/linux/cpu.cc
+@@ -31,7 +31,7 @@
+ #include <string.h>
+ #include <unistd.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/strerror.h"
+
+@@ -40,7 +40,7 @@ static int ncpus = 0;
+ static void init_num_cpus() {
+ #ifndef GPR_MUSL_LIBC_COMPAT
+   if (sched_getcpu() < 0) {
+-    LOG(ERROR) << "Error determining current CPU: "
++    ABSL_LOG(ERROR) << "Error determining current CPU: "
+                << grpc_core::StrError(errno) << "\n";
+     ncpus = 1;
+     return;
+@@ -50,7 +50,7 @@ static void init_num_cpus() {
+   // determined
+   ncpus = static_cast<int>(sysconf(_SC_NPROCESSORS_CONF));
+   if (ncpus < 1) {
+-    LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
++    ABSL_LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
+     ncpus = 1;
+   }
+ }
+@@ -71,12 +71,12 @@ unsigned gpr_cpu_current_cpu(void) {
+   }
+   int cpu = sched_getcpu();
+   if (cpu < 0) {
+-    LOG(ERROR) << "Error determining current CPU: "
++    ABSL_LOG(ERROR) << "Error determining current CPU: "
+                << grpc_core::StrError(errno) << "\n";
+     return 0;
+   }
+   if (static_cast<unsigned>(cpu) >= gpr_cpu_num_cores()) {
+-    VLOG(2) << "Cannot handle hot-plugged CPUs";
++    ABSL_VLOG(2) << "Cannot handle hot-plugged CPUs";
+     return 0;
+   }
+   return static_cast<unsigned>(cpu);
+diff --git a/third_party/grpc/source/src/core/util/log.cc b/third_party/grpc/source/src/core/util/log.cc
+index f627f7622a304..39c265de31c5d 100644
+--- a/third_party/grpc/source/src/core/util/log.cc
++++ b/third_party/grpc/source/src/core/util/log.cc
+@@ -16,7 +16,7 @@
+ //
+ //
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+
+ #include <grpc/support/alloc.h>
+ #include <grpc/support/atm.h>
+@@ -25,7 +25,7 @@
+ #include <stdio.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/log/globals.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+@@ -42,16 +42,16 @@ GPRAPI void grpc_absl_log(const char* file, int line, gpr_log_severity severity,
+                           const char* message_str) {
+   switch (severity) {
+     case GPR_LOG_SEVERITY_DEBUG:
+-      VLOG(2).AtLocation(file, line) << message_str;
++      ABSL_VLOG(2).AtLocation(file, line) << message_str;
+       return;
+     case GPR_LOG_SEVERITY_INFO:
+-      LOG(INFO).AtLocation(file, line) << message_str;
++      ABSL_LOG(INFO).AtLocation(file, line) << message_str;
+       return;
+     case GPR_LOG_SEVERITY_ERROR:
+-      LOG(ERROR).AtLocation(file, line) << message_str;
++      ABSL_LOG(ERROR).AtLocation(file, line) << message_str;
+       return;
+     default:
+-      DCHECK(false) << "Invalid severity";
++      ABSL_DCHECK(false) << "Invalid severity";
+   }
+ }
+
+@@ -60,16 +60,16 @@ GPRAPI void grpc_absl_log_int(const char* file, int line,
+                               const char* message_str, intptr_t num) {
+   switch (severity) {
+     case GPR_LOG_SEVERITY_DEBUG:
+-      VLOG(2).AtLocation(file, line) << message_str << num;
++      ABSL_VLOG(2).AtLocation(file, line) << message_str << num;
+       return;
+     case GPR_LOG_SEVERITY_INFO:
+-      LOG(INFO).AtLocation(file, line) << message_str << num;
++      ABSL_LOG(INFO).AtLocation(file, line) << message_str << num;
+       return;
+     case GPR_LOG_SEVERITY_ERROR:
+-      LOG(ERROR).AtLocation(file, line) << message_str << num;
++      ABSL_LOG(ERROR).AtLocation(file, line) << message_str << num;
+       return;
+     default:
+-      DCHECK(false) << "Invalid severity";
++      ABSL_DCHECK(false) << "Invalid severity";
+   }
+ }
+
+@@ -79,16 +79,16 @@ GPRAPI void grpc_absl_log_str(const char* file, int line,
+                               const char* message_str2) {
+   switch (severity) {
+     case GPR_LOG_SEVERITY_DEBUG:
+-      VLOG(2).AtLocation(file, line) << message_str1 << message_str2;
++      ABSL_VLOG(2).AtLocation(file, line) << message_str1 << message_str2;
+       return;
+     case GPR_LOG_SEVERITY_INFO:
+-      LOG(INFO).AtLocation(file, line) << message_str1 << message_str2;
++      ABSL_LOG(INFO).AtLocation(file, line) << message_str1 << message_str2;
+       return;
+     case GPR_LOG_SEVERITY_ERROR:
+-      LOG(ERROR).AtLocation(file, line) << message_str1 << message_str2;
++      ABSL_LOG(ERROR).AtLocation(file, line) << message_str1 << message_str2;
+       return;
+     default:
+-      DCHECK(false) << "Invalid severity";
++      ABSL_DCHECK(false) << "Invalid severity";
+   }
+ }
+
+@@ -99,14 +99,14 @@ void gpr_log_verbosity_init(void) {
+   // to grpc.
+   absl::string_view verbosity = grpc_core::ConfigVars::Get().Verbosity();
+   if (absl::EqualsIgnoreCase(verbosity, "INFO")) {
+-    LOG_FIRST_N(WARNING, 1)
++    ABSL_LOG_FIRST_N(WARNING, 1)
+         << "Log level INFO is not suitable for production. Prefer WARNING or "
+            "ERROR. However if you see this message in a debug environment or "
+            "test environment it is safe to ignore this message.";
+     absl::SetVLogLevel("*grpc*/*", -1);
+     absl::SetMinLogLevel(absl::LogSeverityAtLeast::kInfo);
+   } else if (absl::EqualsIgnoreCase(verbosity, "DEBUG")) {
+-    LOG_FIRST_N(WARNING, 1)
++    ABSL_LOG_FIRST_N(WARNING, 1)
+         << "Log level DEBUG is not suitable for production. Prefer WARNING or "
+            "ERROR. However if you see this message in a debug environment or "
+            "test environment it is safe to ignore this message.";
+@@ -121,7 +121,7 @@ void gpr_log_verbosity_init(void) {
+   } else if (verbosity.empty()) {
+     // Do not alter absl settings if GRPC_VERBOSITY flag is not set.
+   } else {
+-    LOG(ERROR) << "Unknown log verbosity: " << verbosity;
++    ABSL_LOG(ERROR) << "Unknown log verbosity: " << verbosity;
+   }
+ #endif  // GRPC_VERBOSITY_MACRO
+ }
+diff --git a/third_party/grpc/source/src/core/util/lru_cache.h b/third_party/grpc/source/src/core/util/lru_cache.h
+index cfacc595d88d9..cbcf48e4e44cc 100644
+--- a/third_party/grpc/source/src/core/util/lru_cache.h
++++ b/third_party/grpc/source/src/core/util/lru_cache.h
+@@ -24,7 +24,7 @@
+
+ #include "absl/container/flat_hash_map.h"
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -35,7 +35,7 @@ template <typename Key, typename Value>
+ class LruCache {
+  public:
+   explicit LruCache(size_t max_size) : max_size_(max_size) {
+-    CHECK_GT(max_size, 0UL);
++    ABSL_CHECK_GT(max_size, 0UL);
+   }
+
+   // Returns the value for key, or nullopt if not present.
+@@ -110,9 +110,9 @@ void LruCache<Key, Value>::SetMaxSize(size_t max_size) {
+ template <typename Key, typename Value>
+ void LruCache<Key, Value>::RemoveOldestEntry() {
+   auto lru_it = lru_list_.begin();
+-  CHECK(lru_it != lru_list_.end());
++  ABSL_CHECK(lru_it != lru_list_.end());
+   auto cache_it = cache_.find(*lru_it);
+-  CHECK(cache_it != cache_.end());
++  ABSL_CHECK(cache_it != cache_.end());
+   cache_.erase(cache_it);
+   lru_list_.pop_front();
+ }
+diff --git a/third_party/grpc/source/src/core/util/mpscq.h b/third_party/grpc/source/src/core/util/mpscq.h
+index 44502a0b352e9..d581458cbeeff 100644
+--- a/third_party/grpc/source/src/core/util/mpscq.h
++++ b/third_party/grpc/source/src/core/util/mpscq.h
+@@ -23,7 +23,7 @@
+
+ #include <atomic>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/util/sync.h"
+
+ namespace grpc_core {
+@@ -40,8 +40,8 @@ class MultiProducerSingleConsumerQueue {
+
+   MultiProducerSingleConsumerQueue() : head_{&stub_}, tail_(&stub_) {}
+   ~MultiProducerSingleConsumerQueue() {
+-    CHECK(head_.load(std::memory_order_relaxed) == &stub_);
+-    CHECK(tail_ == &stub_);
++    ABSL_CHECK(head_.load(std::memory_order_relaxed) == &stub_);
++    ABSL_CHECK(tail_ == &stub_);
+   }
+
+   // Push a node
+diff --git a/third_party/grpc/source/src/core/util/posix/cpu.cc b/third_party/grpc/source/src/core/util/posix/cpu.cc
+index 92a9e45635e51..d85e95e0d6352 100644
+--- a/third_party/grpc/source/src/core/util/posix/cpu.cc
++++ b/third_party/grpc/source/src/core/util/posix/cpu.cc
+@@ -27,7 +27,7 @@
+ #include <string.h>
+ #include <unistd.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/useful.h"
+
+@@ -38,7 +38,7 @@ static pthread_key_t thread_id_key;
+ static void init_ncpus() {
+   ncpus = sysconf(_SC_NPROCESSORS_CONF);
+   if (ncpus < 1 || ncpus > INT32_MAX) {
+-    LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
++    ABSL_LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
+     ncpus = 1;
+   }
+ }
+diff --git a/third_party/grpc/source/src/core/util/posix/stat.cc b/third_party/grpc/source/src/core/util/posix/stat.cc
+index 5de6f456321e5..3c08fb19f4d63 100644
+--- a/third_party/grpc/source/src/core/util/posix/stat.cc
++++ b/third_party/grpc/source/src/core/util/posix/stat.cc
+@@ -27,20 +27,20 @@
+ #include <errno.h>
+ #include <sys/stat.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/stat.h"
+ #include "src/core/util/strerror.h"
+
+ namespace grpc_core {
+
+ absl::Status GetFileModificationTime(const char* filename, time_t* timestamp) {
+-  CHECK_NE(filename, nullptr);
+-  CHECK_NE(timestamp, nullptr);
++  ABSL_CHECK_NE(filename, nullptr);
++  ABSL_CHECK_NE(timestamp, nullptr);
+   struct stat buf;
+   if (stat(filename, &buf) != 0) {
+     std::string error_msg = StrError(errno);
+-    LOG(ERROR) << "stat failed for filename " << filename << " with error "
++    ABSL_LOG(ERROR) << "stat failed for filename " << filename << " with error "
+                << error_msg;
+     return absl::Status(absl::StatusCode::kInternal, error_msg);
+   }
+diff --git a/third_party/grpc/source/src/core/util/posix/sync.cc b/third_party/grpc/source/src/core/util/posix/sync.cc
+index ad6431bbeb227..09425a88c68a5 100644
+--- a/third_party/grpc/source/src/core/util/posix/sync.cc
++++ b/third_party/grpc/source/src/core/util/posix/sync.cc
+@@ -27,40 +27,40 @@
+ #include <grpc/support/time.h>
+ #include <time.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ void gpr_mu_init(gpr_mu* mu) {
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_mutex_init(&mu->mutex, nullptr), 0);
++  ABSL_CHECK_EQ(pthread_mutex_init(&mu->mutex, nullptr), 0);
+   mu->leak_checker = static_cast<int*>(malloc(sizeof(*mu->leak_checker)));
+-  CHECK_NE(mu->leak_checker, nullptr);
++  ABSL_CHECK_NE(mu->leak_checker, nullptr);
+ #else
+-  CHECK_EQ(pthread_mutex_init(mu, nullptr), 0);
++  ABSL_CHECK_EQ(pthread_mutex_init(mu, nullptr), 0);
+ #endif
+ }
+
+ void gpr_mu_destroy(gpr_mu* mu) {
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_mutex_destroy(&mu->mutex), 0);
++  ABSL_CHECK_EQ(pthread_mutex_destroy(&mu->mutex), 0);
+   free(mu->leak_checker);
+ #else
+-  CHECK_EQ(pthread_mutex_destroy(mu), 0);
++  ABSL_CHECK_EQ(pthread_mutex_destroy(mu), 0);
+ #endif
+ }
+
+ void gpr_mu_lock(gpr_mu* mu) {
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_mutex_lock(&mu->mutex), 0);
++  ABSL_CHECK_EQ(pthread_mutex_lock(&mu->mutex), 0);
+ #else
+-  CHECK_EQ(pthread_mutex_lock(mu), 0);
++  ABSL_CHECK_EQ(pthread_mutex_lock(mu), 0);
+ #endif
+ }
+
+ void gpr_mu_unlock(gpr_mu* mu) {
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_mutex_unlock(&mu->mutex), 0);
++  ABSL_CHECK_EQ(pthread_mutex_unlock(&mu->mutex), 0);
+ #else
+-  CHECK_EQ(pthread_mutex_unlock(mu), 0);
++  ABSL_CHECK_EQ(pthread_mutex_unlock(mu), 0);
+ #endif
+ }
+
+@@ -71,7 +71,7 @@ int gpr_mu_trylock(gpr_mu* mu) {
+ #else
+   err = pthread_mutex_trylock(mu);
+ #endif
+-  CHECK(err == 0 || err == EBUSY);
++  ABSL_CHECK(err == 0 || err == EBUSY);
+   return err == 0;
+ }
+
+@@ -79,26 +79,26 @@ int gpr_mu_trylock(gpr_mu* mu) {
+
+ void gpr_cv_init(gpr_cv* cv) {
+   pthread_condattr_t attr;
+-  CHECK_EQ(pthread_condattr_init(&attr), 0);
++  ABSL_CHECK_EQ(pthread_condattr_init(&attr), 0);
+ #if GPR_LINUX
+-  CHECK_EQ(pthread_condattr_setclock(&attr, CLOCK_MONOTONIC), 0);
++  ABSL_CHECK_EQ(pthread_condattr_setclock(&attr, CLOCK_MONOTONIC), 0);
+ #endif  // GPR_LINUX
+
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_cond_init(&cv->cond_var, &attr), 0);
++  ABSL_CHECK_EQ(pthread_cond_init(&cv->cond_var, &attr), 0);
+   cv->leak_checker = static_cast<int*>(malloc(sizeof(*cv->leak_checker)));
+-  CHECK_NE(cv->leak_checker, nullptr);
++  ABSL_CHECK_NE(cv->leak_checker, nullptr);
+ #else
+-  CHECK_EQ(pthread_cond_init(cv, &attr), 0);
++  ABSL_CHECK_EQ(pthread_cond_init(cv, &attr), 0);
+ #endif
+ }
+
+ void gpr_cv_destroy(gpr_cv* cv) {
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_cond_destroy(&cv->cond_var), 0);
++  ABSL_CHECK_EQ(pthread_cond_destroy(&cv->cond_var), 0);
+   free(cv->leak_checker);
+ #else
+-  CHECK_EQ(pthread_cond_destroy(cv), 0);
++  ABSL_CHECK_EQ(pthread_cond_destroy(cv), 0);
+ #endif
+ }
+
+@@ -127,30 +127,30 @@ int gpr_cv_wait(gpr_cv* cv, gpr_mu* mu, gpr_timespec abs_deadline) {
+     err = pthread_cond_timedwait(cv, mu, &abs_deadline_ts);
+ #endif
+   }
+-  CHECK(err == 0 || err == ETIMEDOUT || err == EAGAIN);
++  ABSL_CHECK(err == 0 || err == ETIMEDOUT || err == EAGAIN);
+   return err == ETIMEDOUT;
+ }
+
+ void gpr_cv_signal(gpr_cv* cv) {
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_cond_signal(&cv->cond_var), 0);
++  ABSL_CHECK_EQ(pthread_cond_signal(&cv->cond_var), 0);
+ #else
+-  CHECK_EQ(pthread_cond_signal(cv), 0);
++  ABSL_CHECK_EQ(pthread_cond_signal(cv), 0);
+ #endif
+ }
+
+ void gpr_cv_broadcast(gpr_cv* cv) {
+ #ifdef GRPC_ASAN_ENABLED
+-  CHECK_EQ(pthread_cond_broadcast(&cv->cond_var), 0);
++  ABSL_CHECK_EQ(pthread_cond_broadcast(&cv->cond_var), 0);
+ #else
+-  CHECK_EQ(pthread_cond_broadcast(cv), 0);
++  ABSL_CHECK_EQ(pthread_cond_broadcast(cv), 0);
+ #endif
+ }
+
+ //----------------------------------------
+
+ void gpr_once_init(gpr_once* once, void (*init_function)(void)) {
+-  CHECK_EQ(pthread_once(once, init_function), 0);
++  ABSL_CHECK_EQ(pthread_once(once, init_function), 0);
+ }
+
+ #endif  // defined(GPR_POSIX_SYNC) && !defined(GPR_ABSEIL_SYNC) &&
+diff --git a/third_party/grpc/source/src/core/util/posix/thd.cc b/third_party/grpc/source/src/core/util/posix/thd.cc
+index 764882dd676d5..759eacbbd206d 100644
+--- a/third_party/grpc/source/src/core/util/posix/thd.cc
++++ b/third_party/grpc/source/src/core/util/posix/thd.cc
+@@ -34,8 +34,8 @@
+ #include <string.h>
+ #include <unistd.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/fork.h"
+ #include "src/core/util/strerror.h"
+@@ -87,7 +87,7 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
+     // don't use gpr_malloc as we may cause an infinite recursion with
+     // the profiling code
+     thd_arg* info = static_cast<thd_arg*>(malloc(sizeof(*info)));
+-    CHECK_NE(info, nullptr);
++    ABSL_CHECK_NE(info, nullptr);
+     info->thread = this;
+     info->body = thd_body;
+     info->arg = arg;
+@@ -98,16 +98,16 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
+       Fork::IncThreadCount();
+     }
+
+-    CHECK_EQ(pthread_attr_init(&attr), 0);
++    ABSL_CHECK_EQ(pthread_attr_init(&attr), 0);
+     if (options.joinable()) {
+-      CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE) == 0);
++      ABSL_CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE) == 0);
+     } else {
+-      CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) == 0);
++      ABSL_CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) == 0);
+     }
+
+     if (options.stack_size() != 0) {
+       size_t stack_size = MinValidStackSize(options.stack_size());
+-      CHECK_EQ(pthread_attr_setstacksize(&attr, stack_size), 0);
++      ABSL_CHECK_EQ(pthread_attr_setstacksize(&attr, stack_size), 0);
+     }
+
+     int pthread_create_err = pthread_create(
+@@ -151,10 +151,10 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
+         info);
+     *success = (pthread_create_err == 0);
+
+-    CHECK_EQ(pthread_attr_destroy(&attr), 0);
++    ABSL_CHECK_EQ(pthread_attr_destroy(&attr), 0);
+
+     if (!(*success)) {
+-      LOG(ERROR) << "pthread_create failed: " << StrError(pthread_create_err);
++      ABSL_LOG(ERROR) << "pthread_create failed: " << StrError(pthread_create_err);
+       // don't use gpr_free, as this was allocated using malloc (see above)
+       free(info);
+       if (options.tracked()) {
+@@ -194,7 +194,7 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
+ void Thread::Signal(gpr_thd_id tid, int sig) {
+   auto kill_err = pthread_kill((pthread_t)tid, sig);
+   if (kill_err != 0) {
+-    LOG(ERROR) << "pthread_kill for tid " << tid
++    ABSL_LOG(ERROR) << "pthread_kill for tid " << tid
+                << " failed: " << StrError(kill_err);
+   }
+ }
+@@ -203,13 +203,13 @@ void Thread::Signal(gpr_thd_id tid, int sig) {
+ void Thread::Kill(gpr_thd_id tid) {
+   auto cancel_err = pthread_cancel((pthread_t)tid);
+   if (cancel_err != 0) {
+-    LOG(ERROR) << "pthread_cancel for tid " << tid
++    ABSL_LOG(ERROR) << "pthread_cancel for tid " << tid
+                << " failed: " << StrError(cancel_err);
+   }
+ }
+ #else  // GPR_ANDROID
+ void Thread::Kill(gpr_thd_id /* tid */) {
+-  VLOG(2) << "Thread::Kill is not supported on Android.";
++  ABSL_VLOG(2) << "Thread::Kill is not supported on Android.";
+ }
+ #endif
+
+diff --git a/third_party/grpc/source/src/core/util/posix/time.cc b/third_party/grpc/source/src/core/util/posix/time.cc
+index 8231cc588c745..553b737193dee 100644
+--- a/third_party/grpc/source/src/core/util/posix/time.cc
++++ b/third_party/grpc/source/src/core/util/posix/time.cc
+@@ -31,14 +31,14 @@
+ #include <grpc/support/atm.h>
+ #include <grpc/support/time.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ static struct timespec timespec_from_gpr(gpr_timespec gts) {
+   struct timespec rv;
+   if (sizeof(time_t) < sizeof(int64_t)) {
+     // fine to assert, as this is only used in gpr_sleep_until
+-    CHECK(gts.tv_sec <= INT32_MAX);
+-    CHECK(gts.tv_sec >= INT32_MIN);
++    ABSL_CHECK(gts.tv_sec <= INT32_MAX);
++    ABSL_CHECK(gts.tv_sec >= INT32_MIN);
+   }
+   rv.tv_sec = static_cast<time_t>(gts.tv_sec);
+   rv.tv_nsec = gts.tv_nsec;
+@@ -67,7 +67,7 @@ void gpr_time_init(void) { gpr_precise_clock_init(); }
+
+ static gpr_timespec now_impl(gpr_clock_type clock_type) {
+   struct timespec now;
+-  CHECK(clock_type != GPR_TIMESPAN);
++  ABSL_CHECK(clock_type != GPR_TIMESPAN);
+   if (clock_type == GPR_CLOCK_PRECISE) {
+     gpr_timespec ret;
+     gpr_precise_clock_now(&ret);
+@@ -87,12 +87,12 @@ gpr_timespec (*gpr_now_impl)(gpr_clock_type clock_type) = now_impl;
+
+ gpr_timespec gpr_now(gpr_clock_type clock_type) {
+   // validate clock type
+-  CHECK(clock_type == GPR_CLOCK_MONOTONIC || clock_type == GPR_CLOCK_REALTIME ||
++  ABSL_CHECK(clock_type == GPR_CLOCK_MONOTONIC || clock_type == GPR_CLOCK_REALTIME ||
+         clock_type == GPR_CLOCK_PRECISE);
+   gpr_timespec ts = gpr_now_impl(clock_type);
+   // tv_nsecs must be in the range [0, 1e9).
+-  CHECK(ts.tv_nsec >= 0);
+-  CHECK(ts.tv_nsec < 1e9);
++  ABSL_CHECK(ts.tv_nsec >= 0);
++  ABSL_CHECK(ts.tv_nsec < 1e9);
+   return ts;
+ }
+
+diff --git a/third_party/grpc/source/src/core/util/posix/tmpfile.cc b/third_party/grpc/source/src/core/util/posix/tmpfile.cc
+index 832391f1599e7..a2031cac4d2f4 100644
+--- a/third_party/grpc/source/src/core/util/posix/tmpfile.cc
++++ b/third_party/grpc/source/src/core/util/posix/tmpfile.cc
+@@ -27,8 +27,8 @@
+ #include <string.h>
+ #include <unistd.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/strerror.h"
+ #include "src/core/util/string.h"
+@@ -42,17 +42,17 @@ FILE* gpr_tmpfile(const char* prefix, char** tmp_filename) {
+   if (tmp_filename != nullptr) *tmp_filename = nullptr;
+
+   gpr_asprintf(&filename_template, "/tmp/%s_XXXXXX", prefix);
+-  CHECK_NE(filename_template, nullptr);
++  ABSL_CHECK_NE(filename_template, nullptr);
+
+   fd = mkstemp(filename_template);
+   if (fd == -1) {
+-    LOG(ERROR) << "mkstemp failed for filename_template " << filename_template
++    ABSL_LOG(ERROR) << "mkstemp failed for filename_template " << filename_template
+                << " with error " << grpc_core::StrError(errno);
+     goto end;
+   }
+   result = fdopen(fd, "w+");
+   if (result == nullptr) {
+-    LOG(ERROR) << "Could not open file " << filename_template << " from fd "
++    ABSL_LOG(ERROR) << "Could not open file " << filename_template << " from fd "
+                << fd << " (error = " << grpc_core::StrError(errno) << ").";
+     unlink(filename_template);
+     close(fd);
+diff --git a/third_party/grpc/source/src/core/util/ref_counted.h b/third_party/grpc/source/src/core/util/ref_counted.h
+index b82a99b83f717..57503b97b331e 100644
+--- a/third_party/grpc/source/src/core/util/ref_counted.h
++++ b/third_party/grpc/source/src/core/util/ref_counted.h
+@@ -25,8 +25,8 @@
+ #include <cassert>
+ #include <cinttypes>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/atomic_utils.h"
+ #include "src/core/util/debug_location.h"
+ #include "src/core/util/down_cast.h"
+@@ -72,7 +72,7 @@ class RefCount {
+ #ifndef NDEBUG
+     const Value prior = value_.fetch_add(n, std::memory_order_relaxed);
+     if (trace_ != nullptr) {
+-      LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
++      ABSL_LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
+                 << prior + n;
+     }
+ #else
+@@ -83,7 +83,7 @@ class RefCount {
+ #ifndef NDEBUG
+     const Value prior = value_.fetch_add(n, std::memory_order_relaxed);
+     if (trace_ != nullptr) {
+-      LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
++      ABSL_LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
+                 << location.line() << " ref " << prior << " -> " << prior + n
+                 << " " << reason;
+     }
+@@ -100,7 +100,7 @@ class RefCount {
+ #ifndef NDEBUG
+     const Value prior = value_.fetch_add(1, std::memory_order_relaxed);
+     if (trace_ != nullptr) {
+-      LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
++      ABSL_LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
+                 << prior + 1;
+     }
+     assert(prior > 0);
+@@ -112,7 +112,7 @@ class RefCount {
+ #ifndef NDEBUG
+     const Value prior = value_.fetch_add(1, std::memory_order_relaxed);
+     if (trace_ != nullptr) {
+-      LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
++      ABSL_LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
+                 << location.line() << " ref " << prior << " -> " << prior + 1
+                 << " " << reason;
+     }
+@@ -129,7 +129,7 @@ class RefCount {
+ #ifndef NDEBUG
+     if (trace_ != nullptr) {
+       const Value prior = get();
+-      LOG(INFO) << trace_ << ":" << this << " ref_if_non_zero " << prior
++      ABSL_LOG(INFO) << trace_ << ":" << this << " ref_if_non_zero " << prior
+                 << " -> " << prior + 1;
+     }
+ #endif
+@@ -139,7 +139,7 @@ class RefCount {
+ #ifndef NDEBUG
+     if (trace_ != nullptr) {
+       const Value prior = get();
+-      LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
++      ABSL_LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
+                 << location.line() << " ref_if_non_zero " << prior << " -> "
+                 << prior + 1 << " " << reason;
+     }
+@@ -161,10 +161,10 @@ class RefCount {
+     const Value prior = value_.fetch_sub(1, std::memory_order_acq_rel);
+ #ifndef NDEBUG
+     if (trace != nullptr) {
+-      LOG(INFO) << trace << ":" << this << " unref " << prior << " -> "
++      ABSL_LOG(INFO) << trace << ":" << this << " unref " << prior << " -> "
+                 << prior - 1;
+     }
+-    DCHECK_GT(prior, 0);
++    ABSL_DCHECK_GT(prior, 0);
+ #endif
+     return prior == 1;
+   }
+@@ -178,11 +178,11 @@ class RefCount {
+     const Value prior = value_.fetch_sub(1, std::memory_order_acq_rel);
+ #ifndef NDEBUG
+     if (trace != nullptr) {
+-      LOG(INFO) << trace << ":" << this << " " << location.file() << ":"
++      ABSL_LOG(INFO) << trace << ":" << this << " " << location.file() << ":"
+                 << location.line() << " unref " << prior << " -> " << prior - 1
+                 << " " << reason;
+     }
+-    DCHECK_GT(prior, 0);
++    ABSL_DCHECK_GT(prior, 0);
+ #else
+     // Avoid unused-parameter warnings for debug-only parameters
+     (void)location;
+diff --git a/third_party/grpc/source/src/core/util/single_set_ptr.h b/third_party/grpc/source/src/core/util/single_set_ptr.h
+index 9508e53eb6db6..b4167093ec7b8 100644
+--- a/third_party/grpc/source/src/core/util/single_set_ptr.h
++++ b/third_party/grpc/source/src/core/util/single_set_ptr.h
+@@ -20,7 +20,7 @@
+ #include <atomic>
+ #include <memory>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -70,7 +70,7 @@ class SingleSetPtr {
+
+   T* operator->() const {
+     T* p = Get();
+-    DCHECK_NE(p, nullptr);
++    ABSL_DCHECK_NE(p, nullptr);
+     return p;
+   }
+
+diff --git a/third_party/grpc/source/src/core/util/status_helper.cc b/third_party/grpc/source/src/core/util/status_helper.cc
+index f4b8e8a1c5b23..b5591c31dd984 100644
+--- a/third_party/grpc/source/src/core/util/status_helper.cc
++++ b/third_party/grpc/source/src/core/util/status_helper.cc
+@@ -23,7 +23,7 @@
+
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/cord.h"
+ #include "absl/strings/escaping.h"
+ #include "absl/strings/match.h"
+@@ -121,7 +121,7 @@ std::vector<absl::Status> ParseChildren(absl::Cord children) {
+   while (buf.size() - cur >= sizeof(uint32_t)) {
+     size_t msg_size = DecodeUInt32FromBytes(buf.data() + cur);
+     cur += sizeof(uint32_t);
+-    CHECK(buf.size() - cur >= msg_size);
++    ABSL_CHECK(buf.size() - cur >= msg_size);
+     google_rpc_Status* msg =
+         google_rpc_Status_parse(buf.data() + cur, msg_size, arena.ptr());
+     cur += msg_size;
+diff --git a/third_party/grpc/source/src/core/util/subprocess_posix.cc b/third_party/grpc/source/src/core/util/subprocess_posix.cc
+index ef4512b3734f7..e7c319d1e653f 100644
+--- a/third_party/grpc/source/src/core/util/subprocess_posix.cc
++++ b/third_party/grpc/source/src/core/util/subprocess_posix.cc
+@@ -29,8 +29,8 @@
+
+ #include <iostream>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/substitute.h"
+ #include "src/core/util/memory.h"
+ #include "src/core/util/strerror.h"
+@@ -59,7 +59,7 @@ gpr_subprocess* gpr_subprocess_create(int argc, const char** argv) {
+     exec_args[argc] = nullptr;
+     execv(exec_args[0], exec_args);
+     // if we reach here, an error has occurred
+-    LOG(ERROR) << "execv '" << exec_args[0]
++    ABSL_LOG(ERROR) << "execv '" << exec_args[0]
+                << "' failed: " << grpc_core::StrError(errno);
+     _exit(1);
+   } else {
+@@ -80,8 +80,8 @@ gpr_subprocess* gpr_subprocess_create_with_envp(int argc, const char** argv,
+   int stdout_pipe[2];
+   int p0 = pipe(stdin_pipe);
+   int p1 = pipe(stdout_pipe);
+-  CHECK_NE(p0, -1);
+-  CHECK_NE(p1, -1);
++  ABSL_CHECK_NE(p0, -1);
++  ABSL_CHECK_NE(p1, -1);
+   pid = fork();
+   if (pid == -1) {
+     return nullptr;
+@@ -102,7 +102,7 @@ gpr_subprocess* gpr_subprocess_create_with_envp(int argc, const char** argv,
+     envp_args[envc] = nullptr;
+     execve(exec_args[0], exec_args, envp_args);
+     // if we reach here, an error has occurred
+-    LOG(ERROR) << "execvpe '" << exec_args[0]
++    ABSL_LOG(ERROR) << "execvpe '" << exec_args[0]
+                << "' failed: " << grpc_core::StrError(errno);
+     _exit(1);
+   } else {
+@@ -144,7 +144,7 @@ bool gpr_subprocess_communicate(gpr_subprocess* p, std::string& input_data,
+         continue;
+       } else {
+         std::cerr << "select: " << strerror(errno) << std::endl;
+-        CHECK(0);
++        ABSL_CHECK(0);
+       }
+     }
+
+@@ -191,7 +191,7 @@ bool gpr_subprocess_communicate(gpr_subprocess* p, std::string& input_data,
+   while (waitpid(p->pid, &status, 0) == -1) {
+     if (errno != EINTR) {
+       std::cerr << "waitpid: " << strerror(errno) << std::endl;
+-      CHECK(0);
++      ABSL_CHECK(0);
+     }
+   }
+
+@@ -232,7 +232,7 @@ retry:
+     if (errno == EINTR) {
+       goto retry;
+     }
+-    LOG(ERROR) << "waitpid failed for pid " << p->pid << ": "
++    ABSL_LOG(ERROR) << "waitpid failed for pid " << p->pid << ": "
+                << grpc_core::StrError(errno);
+     return -1;
+   }
+diff --git a/third_party/grpc/source/src/core/util/subprocess_windows.cc b/third_party/grpc/source/src/core/util/subprocess_windows.cc
+index 71fd6497e785a..1585de0fe9009 100644
+--- a/third_party/grpc/source/src/core/util/subprocess_windows.cc
++++ b/third_party/grpc/source/src/core/util/subprocess_windows.cc
+@@ -25,7 +25,7 @@
+ #include <tchar.h>
+ #include <windows.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_join.h"
+ #include "absl/types/span.h"
+ #include "src/core/util/crash.h"
+@@ -112,7 +112,7 @@ void gpr_subprocess_interrupt(gpr_subprocess* p) {
+   DWORD dwExitCode;
+   if (GetExitCodeProcess(p->pi.hProcess, &dwExitCode)) {
+     if (dwExitCode == STILL_ACTIVE) {
+-      VLOG(2) << "sending ctrl-break";
++      ABSL_VLOG(2) << "sending ctrl-break";
+       GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, p->pi.dwProcessId);
+       p->joined = 1;
+       p->interrupted = 1;
+diff --git a/third_party/grpc/source/src/core/util/sync.cc b/third_party/grpc/source/src/core/util/sync.cc
+index 7a5f24409eeb8..ffff953718e16 100644
+--- a/third_party/grpc/source/src/core/util/sync.cc
++++ b/third_party/grpc/source/src/core/util/sync.cc
+@@ -23,7 +23,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <grpc/support/sync.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ // Number of mutexes to allocate for events, to avoid lock contention.
+ // Should be a prime.
+@@ -58,11 +58,11 @@ void gpr_event_init(gpr_event* ev) {
+ void gpr_event_set(gpr_event* ev, void* value) {
+   struct sync_array_s* s = hash(ev);
+   gpr_mu_lock(&s->mu);
+-  CHECK_EQ(gpr_atm_acq_load(&ev->state), 0);
++  ABSL_CHECK_EQ(gpr_atm_acq_load(&ev->state), 0);
+   gpr_atm_rel_store(&ev->state, (gpr_atm)value);
+   gpr_cv_broadcast(&s->cv);
+   gpr_mu_unlock(&s->mu);
+-  CHECK_NE(value, nullptr);
++  ABSL_CHECK_NE(value, nullptr);
+ }
+
+ void* gpr_event_get(gpr_event* ev) {
+@@ -101,7 +101,7 @@ void gpr_refn(gpr_refcount* r, int n) {
+
+ int gpr_unref(gpr_refcount* r) {
+   gpr_atm prior = gpr_atm_full_fetch_add(&r->count, -1);
+-  CHECK_GT(prior, 0);
++  ABSL_CHECK_GT(prior, 0);
+   return prior == 1;
+ }
+
+diff --git a/third_party/grpc/source/src/core/util/sync.h b/third_party/grpc/source/src/core/util/sync.h
+index 77d1a54206ffe..1a6ee75cb97a8 100644
+--- a/third_party/grpc/source/src/core/util/sync.h
++++ b/third_party/grpc/source/src/core/util/sync.h
+@@ -23,7 +23,7 @@
+ #include <grpc/support/sync.h>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/synchronization/mutex.h"
+
+ #ifndef GPR_ABSEIL_SYNC
+@@ -112,7 +112,7 @@ class ABSL_SCOPED_LOCKABLE ReleasableMutexLock {
+   ReleasableMutexLock& operator=(const ReleasableMutexLock&) = delete;
+
+   void Release() ABSL_UNLOCK_FUNCTION() {
+-    DCHECK(!released_);
++    ABSL_DCHECK(!released_);
+     released_ = true;
+     mu_->Unlock();
+   }
+@@ -178,13 +178,13 @@ class ABSL_SCOPED_LOCKABLE LockableAndReleasableMutexLock {
+       const LockableAndReleasableMutexLock&) = delete;
+
+   void Lock() ABSL_EXCLUSIVE_LOCK_FUNCTION() {
+-    DCHECK(released_);
++    ABSL_DCHECK(released_);
+     mu_->Lock();
+     released_ = false;
+   }
+
+   void Release() ABSL_UNLOCK_FUNCTION() {
+-    DCHECK(!released_);
++    ABSL_DCHECK(!released_);
+     released_ = true;
+     mu_->Unlock();
+   }
+diff --git a/third_party/grpc/source/src/core/util/tdigest.cc b/third_party/grpc/source/src/core/util/tdigest.cc
+index 90d63bb3c0be6..5f6b7e65b4016 100644
+--- a/third_party/grpc/source/src/core/util/tdigest.cc
++++ b/third_party/grpc/source/src/core/util/tdigest.cc
+@@ -14,8 +14,8 @@
+
+ #include "src/core/util/tdigest.h"
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_split.h"
+
+@@ -42,9 +42,9 @@ size_t MaxCentroids(double compression) {
+
+ double LinearInterpolate(double val1, double val2, double weight1,
+                          double weight2) {
+-  DCHECK_GE(weight1, 0);
+-  DCHECK_GE(weight2, 0);
+-  DCHECK_GT(weight1 + weight2, 0);
++  ABSL_DCHECK_GE(weight1, 0);
++  ABSL_DCHECK_GE(weight2, 0);
++  ABSL_DCHECK_GT(weight1 + weight2, 0);
+   return (val1 * weight1 + val2 * weight2) / (weight1 + weight2);
+ }
+
+@@ -56,7 +56,7 @@ void TDigest::Reset(double compression) {
+   compression_ = BoundedCompression(compression);
+   // Set the default batch_size to 4 times the number of centroids.
+   batch_size_ = static_cast<int64_t>(4 * MaxCentroids(compression_));
+-  DCHECK(compression_ == 0.0 || batch_size_ > 0);
++  ABSL_DCHECK(compression_ == 0.0 || batch_size_ > 0);
+   centroids_.reserve(MaxCentroids(compression_) + batch_size_);
+   centroids_.clear();
+   merged_ = 0;
+@@ -77,7 +77,7 @@ void TDigest::Add(double val, int64_t count) {
+ }
+
+ void TDigest::AddUnmergedCentroid(const CentroidPod& centroid) {
+-  DCHECK_LT(unmerged_, batch_size_);
++  ABSL_DCHECK_LT(unmerged_, batch_size_);
+
+   centroids_.push_back(centroid);
+   ++unmerged_;
+@@ -117,7 +117,7 @@ void TDigest::DoMerge() {
+
+   // We first sort the centroids, and assume the first centroid is merged,
+   // and the rest are unmerged.
+-  DCHECK(!centroids_.empty());
++  ABSL_DCHECK(!centroids_.empty());
+   std::sort(centroids_.begin(), centroids_.end());
+   unmerged_ += merged_ - 1;
+   merged_ = 1;
+@@ -170,7 +170,7 @@ void TDigest::DoMerge() {
+     min_ = std::min(min_, centroids_.front().mean);
+     max_ = std::max(max_, centroids_.back().mean);
+   }
+-  DCHECK_LE(centroids_.size(), MaxCentroids(compression_));
++  ABSL_DCHECK_LE(centroids_.size(), MaxCentroids(compression_));
+ }
+
+ // We use linear interpolation between mid points of centroids when calculating
+@@ -213,7 +213,7 @@ double TDigest::Cdf(double val) {
+   if (val >= max_) {
+     return 1;
+   }
+-  DCHECK_NE(min_, max_);
++  ABSL_DCHECK_NE(min_, max_);
+
+   if (merged_ == 1) {
+     return (val - min_) / (min_ - max_);
+@@ -259,13 +259,13 @@ double TDigest::Cdf(double val) {
+     accum_count += (centroids_[i].count + centroids_[i + 1].count) / 2.0;
+   }
+
+-  LOG(DFATAL) << "Cannot measure CDF for: " << val;
++  ABSL_LOG(DFATAL) << "Cannot measure CDF for: " << val;
+   return kNan;
+ }
+
+ double TDigest::Quantile(double quantile) {
+-  DCHECK_LE(quantile, 1);
+-  DCHECK_GE(quantile, 0);
++  ABSL_DCHECK_LE(quantile, 1);
++  ABSL_DCHECK_GE(quantile, 0);
+
+   DoMerge();
+
+@@ -407,7 +407,7 @@ absl::Status TDigest::FromString(absl::string_view string) {
+   }
+
+   // Validate min/max/sum/count.
+-  DCHECK_LT(std::abs(sum - sum_), 1e-10) << "Invalid sum value.";
++  ABSL_DCHECK_LT(std::abs(sum - sum_), 1e-10) << "Invalid sum value.";
+
+   if (count != count_) {
+     return absl::InvalidArgumentError("Invalid count value.");
+diff --git a/third_party/grpc/source/src/core/util/thd.h b/third_party/grpc/source/src/core/util/thd.h
+index 61f229af97ef0..93ca30c8afddf 100644
+--- a/third_party/grpc/source/src/core/util/thd.h
++++ b/third_party/grpc/source/src/core/util/thd.h
+@@ -29,7 +29,7 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+ namespace internal {
+@@ -123,7 +123,7 @@ class Thread {
+   Thread& operator=(Thread&& other) noexcept {
+     if (this != &other) {
+       // TODO(vjpai): if we can be sure that all Thread's are actually
+-      // constructed, then we should assert CHECK(impl_ == nullptr) here.
++      // constructed, then we should assert ABSL_CHECK(impl_ == nullptr) here.
+       // However, as long as threads come in structures that are
+       // allocated via gpr_malloc, this will not be the case, so we cannot
+       // assert it for the time being.
+@@ -142,11 +142,11 @@ class Thread {
+   /// the Join function kills it, or it was detached (non-joinable) and it has
+   /// run to completion and is now killing itself. The destructor shouldn't have
+   /// to do anything.
+-  ~Thread() { CHECK(!options_.joinable() || impl_ == nullptr); }
++  ~Thread() { ABSL_CHECK(!options_.joinable() || impl_ == nullptr); }
+
+   void Start() {
+     if (impl_ != nullptr) {
+-      CHECK(state_ == ALIVE);
++      ABSL_CHECK(state_ == ALIVE);
+       state_ = STARTED;
+       impl_->Start();
+       // If the Thread is not joinable, then the impl_ will cause the deletion
+@@ -155,7 +155,7 @@ class Thread {
+       // no need to change the value of the impl_ or state_ . The next operation
+       // on this object will be the deletion, which will trigger the destructor.
+     } else {
+-      CHECK(state_ == FAILED);
++      ABSL_CHECK(state_ == FAILED);
+     }
+   }
+
+@@ -167,7 +167,7 @@ class Thread {
+       state_ = DONE;
+       impl_ = nullptr;
+     } else {
+-      CHECK(state_ == FAILED);
++      ABSL_CHECK(state_ == FAILED);
+     }
+   }
+
+diff --git a/third_party/grpc/source/src/core/util/time.cc b/third_party/grpc/source/src/core/util/time.cc
+index 2d7c6873c1084..8c42b2b350aaf 100644
+--- a/third_party/grpc/source/src/core/util/time.cc
++++ b/third_party/grpc/source/src/core/util/time.cc
+@@ -23,8 +23,8 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/util/no_destruct.h"
+
+@@ -59,19 +59,19 @@ GPR_ATTRIBUTE_NOINLINE std::pair<int64_t, gpr_cycle_counter> InitTime() {
+     if (process_epoch_seconds > 1) {
+       break;
+     }
+-    LOG(INFO) << "gpr_now(GPR_CLOCK_MONOTONIC) returns a very small number: "
++    ABSL_LOG(INFO) << "gpr_now(GPR_CLOCK_MONOTONIC) returns a very small number: "
+                  "sleeping for 100ms";
+     gpr_sleep_until(gpr_time_add(now, gpr_time_from_millis(100, GPR_TIMESPAN)));
+   }
+
+   // Check time has increased past 1 second.
+-  CHECK_GT(process_epoch_seconds, 1);
++  ABSL_CHECK_GT(process_epoch_seconds, 1);
+   // Fake the epoch to always return >=1 second from our monotonic clock (to
+   // avoid bugs elsewhere)
+   process_epoch_seconds -= 1;
+   int64_t expected = 0;
+   gpr_cycle_counter process_epoch_cycles = (cycles_start + cycles_end) / 2;
+-  CHECK_NE(process_epoch_cycles, 0);
++  ABSL_CHECK_NE(process_epoch_cycles, 0);
+   if (!g_process_epoch_seconds.compare_exchange_strong(
+           expected, process_epoch_seconds, std::memory_order_relaxed,
+           std::memory_order_relaxed)) {
+@@ -118,7 +118,7 @@ gpr_timespec MillisecondsAsTimespec(int64_t millis, gpr_clock_type clock_type) {
+ }
+
+ int64_t TimespanToMillisRoundUp(gpr_timespec ts) {
+-  CHECK(ts.clock_type == GPR_TIMESPAN);
++  ABSL_CHECK(ts.clock_type == GPR_TIMESPAN);
+   double x = GPR_MS_PER_SEC * static_cast<double>(ts.tv_sec) +
+              (static_cast<double>(ts.tv_nsec) / GPR_NS_PER_MS) +
+              (static_cast<double>(GPR_NS_PER_SEC - 1) /
+@@ -133,7 +133,7 @@ int64_t TimespanToMillisRoundUp(gpr_timespec ts) {
+ }
+
+ int64_t TimespanToMillisRoundDown(gpr_timespec ts) {
+-  CHECK(ts.clock_type == GPR_TIMESPAN);
++  ABSL_CHECK(ts.clock_type == GPR_TIMESPAN);
+   double x = GPR_MS_PER_SEC * static_cast<double>(ts.tv_sec) +
+              (static_cast<double>(ts.tv_nsec) / GPR_NS_PER_MS);
+   if (x <= static_cast<double>(std::numeric_limits<int64_t>::min())) {
+diff --git a/third_party/grpc/source/src/core/util/time.h b/third_party/grpc/source/src/core/util/time.h
+index 1de2b4ff99768..20a5ce4ad9f36 100644
+--- a/third_party/grpc/source/src/core/util/time.h
++++ b/third_party/grpc/source/src/core/util/time.h
+@@ -37,7 +37,7 @@
+     if (prev == 0) prev = now;                                  \
+     if (now - prev > (n) * 1000) {                              \
+       prev = now;                                               \
+-      VLOG(2) << absl::StrFormat(format, __VA_ARGS__);          \
++      ABSL_VLOG(2) << absl::StrFormat(format, __VA_ARGS__);          \
+     }                                                           \
+   } while (0)
+
+diff --git a/third_party/grpc/source/src/core/util/time_precise.cc b/third_party/grpc/source/src/core/util/time_precise.cc
+index 76dce6d57dfba..ccbf039b3b6f0 100644
+--- a/third_party/grpc/source/src/core/util/time_precise.cc
++++ b/third_party/grpc/source/src/core/util/time_precise.cc
+@@ -27,7 +27,7 @@
+
+ #include <algorithm>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/time_precise.h"
+
+ #ifndef GPR_CYCLE_COUNTER_CUSTOM
+@@ -71,7 +71,7 @@ static bool is_fake_clock() {
+ }
+
+ void gpr_precise_clock_init(void) {
+-  VLOG(2) << "Calibrating timers";
++  ABSL_VLOG(2) << "Calibrating timers";
+
+ #if GPR_LINUX
+   if (read_freq_from_kernel(&cycles_per_second)) {
+@@ -109,7 +109,7 @@ void gpr_precise_clock_init(void) {
+     last_freq = freq;
+   }
+   cycles_per_second = last_freq;
+-  VLOG(2) << "... cycles_per_second = " << cycles_per_second << "\n";
++  ABSL_VLOG(2) << "... cycles_per_second = " << cycles_per_second << "\n";
+ }
+
+ gpr_timespec gpr_cycle_counter_to_time(gpr_cycle_counter cycles) {
+diff --git a/third_party/grpc/source/src/core/util/time_util.cc b/third_party/grpc/source/src/core/util/time_util.cc
+index d20dca30e52aa..3ef5322bbf30e 100644
+--- a/third_party/grpc/source/src/core/util/time_util.cc
++++ b/third_party/grpc/source/src/core/util/time_util.cc
+@@ -21,7 +21,7 @@
+ #include <stdint.h>
+ #include <time.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc_core {
+
+@@ -54,7 +54,7 @@ gpr_timespec ToGprTimeSpec(absl::Time time) {
+ }
+
+ absl::Duration ToAbslDuration(gpr_timespec ts) {
+-  CHECK(ts.clock_type == GPR_TIMESPAN);
++  ABSL_CHECK(ts.clock_type == GPR_TIMESPAN);
+   if (gpr_time_cmp(ts, gpr_inf_future(GPR_TIMESPAN)) == 0) {
+     return absl::InfiniteDuration();
+   } else if (gpr_time_cmp(ts, gpr_inf_past(GPR_TIMESPAN)) == 0) {
+@@ -65,7 +65,7 @@ absl::Duration ToAbslDuration(gpr_timespec ts) {
+ }
+
+ absl::Time ToAbslTime(gpr_timespec ts) {
+-  CHECK(ts.clock_type != GPR_TIMESPAN);
++  ABSL_CHECK(ts.clock_type != GPR_TIMESPAN);
+   gpr_timespec rts = gpr_convert_clock_type(ts, GPR_CLOCK_REALTIME);
+   if (gpr_time_cmp(rts, gpr_inf_future(GPR_CLOCK_REALTIME)) == 0) {
+     return absl::InfiniteFuture();
+diff --git a/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h b/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h
+index 112c3ea49ec6c..4569c700c700c 100644
+--- a/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h
++++ b/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h
+@@ -18,7 +18,7 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/numeric/bits.h"
+
+ namespace grpc_core {
+@@ -36,7 +36,7 @@ class UniquePtrWithBitset {
+   UniquePtrWithBitset(std::unique_ptr<T>&& p)
+       : UniquePtrWithBitset(p.release()) {}
+   ~UniquePtrWithBitset() {
+-    DCHECK_LE(kBits, static_cast<size_t>(absl::countr_zero(alignof(T))));
++    ABSL_DCHECK_LE(kBits, static_cast<size_t>(absl::countr_zero(alignof(T))));
+     delete get();
+   }
+   UniquePtrWithBitset(const UniquePtrWithBitset&) = delete;
+@@ -59,15 +59,15 @@ class UniquePtrWithBitset {
+   }
+
+   void SetBit(size_t bit) {
+-    DCHECK_LT(bit, kBits);
++    ABSL_DCHECK_LT(bit, kBits);
+     p_ |= 1 << bit;
+   }
+   void ClearBit(size_t bit) {
+-    DCHECK_LT(bit, kBits);
++    ABSL_DCHECK_LT(bit, kBits);
+     p_ &= ~(1 << bit);
+   }
+   bool TestBit(size_t bit) const {
+-    DCHECK_LT(bit, kBits);
++    ABSL_DCHECK_LT(bit, kBits);
+     return p_ & (1 << bit);
+   }
+
+diff --git a/third_party/grpc/source/src/core/util/uri.cc b/third_party/grpc/source/src/core/util/uri.cc
+index 0469c640d703d..66dbac898d4d7 100644
+--- a/third_party/grpc/source/src/core/util/uri.cc
++++ b/third_party/grpc/source/src/core/util/uri.cc
+@@ -26,7 +26,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/ascii.h"
+ #include "absl/strings/escaping.h"
+@@ -140,7 +140,7 @@ std::string PercentEncode(absl::string_view str,
+   for (char c : str) {
+     if (!is_allowed_char(c)) {
+       std::string hex = absl::BytesToHexString(absl::string_view(&c, 1));
+-      CHECK_EQ(hex.size(), 2u);
++      ABSL_CHECK_EQ(hex.size(), 2u);
+       // BytesToHexString() returns lower case, but
+       // https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1 says
+       // to prefer upper-case.
+diff --git a/third_party/grpc/source/src/core/util/useful.h b/third_party/grpc/source/src/core/util/useful.h
+index 834e3b32b9b0a..749856554a275 100644
+--- a/third_party/grpc/source/src/core/util/useful.h
++++ b/third_party/grpc/source/src/core/util/useful.h
+@@ -21,7 +21,7 @@
+ #include <limits>
+ #include <variant>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/numeric/bits.h"
+ #include "absl/strings/string_view.h"
+
+diff --git a/third_party/grpc/source/src/core/util/validation_errors.cc b/third_party/grpc/source/src/core/util/validation_errors.cc
+index 850ea674a5fae..0ebf5e1e4d72d 100644
+--- a/third_party/grpc/source/src/core/util/validation_errors.cc
++++ b/third_party/grpc/source/src/core/util/validation_errors.cc
+@@ -19,7 +19,7 @@
+
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+@@ -38,7 +38,7 @@ void ValidationErrors::PopField() { fields_.pop_back(); }
+ void ValidationErrors::AddError(absl::string_view error) {
+   auto key = absl::StrJoin(fields_, "");
+   if (field_errors_[key].size() >= max_error_count_) {
+-    VLOG(2) << "Ignoring validation error: too many errors found ("
++    ABSL_VLOG(2) << "Ignoring validation error: too many errors found ("
+             << max_error_count_ << ")";
+     return;
+   }
+diff --git a/third_party/grpc/source/src/core/util/wait_for_single_owner.h b/third_party/grpc/source/src/core/util/wait_for_single_owner.h
+index 2b201a94f6996..2efc7f1b9b753 100644
+--- a/third_party/grpc/source/src/core/util/wait_for_single_owner.h
++++ b/third_party/grpc/source/src/core/util/wait_for_single_owner.h
+@@ -17,7 +17,7 @@
+
+ #include <memory>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/time.h"
+
+@@ -49,7 +49,7 @@ void WaitForSingleOwnerWithTimeout(std::shared_ptr<T> obj, Duration timeout) {
+     }
+     // To avoid log spam, wait a few seconds to begin logging the wait time.
+     if (elapsed >= Duration::Seconds(2)) {
+-      LOG_EVERY_N_SEC(INFO, 2)
++      ABSL_LOG_EVERY_N_SEC(INFO, 2)
+           << "obj.use_count() = " << obj.use_count() << " timeout_remaining = "
+           << absl::FormatDuration(absl::Milliseconds(remaining.millis()));
+     }
+diff --git a/third_party/grpc/source/src/core/util/windows/stat.cc b/third_party/grpc/source/src/core/util/windows/stat.cc
+index 5ac15a407cfd8..1380bde94b4c6 100644
+--- a/third_party/grpc/source/src/core/util/windows/stat.cc
++++ b/third_party/grpc/source/src/core/util/windows/stat.cc
+@@ -22,8 +22,8 @@
+ #include <sys/stat.h>
+ #include <sys/types.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/stat.h"
+ #include "src/core/util/strerror.h"
+@@ -31,12 +31,12 @@
+ namespace grpc_core {
+
+ absl::Status GetFileModificationTime(const char* filename, time_t* timestamp) {
+-  CHECK_NE(filename, nullptr);
+-  CHECK_NE(timestamp, nullptr);
++  ABSL_CHECK_NE(filename, nullptr);
++  ABSL_CHECK_NE(timestamp, nullptr);
+   struct _stat buf;
+   if (_stat(filename, &buf) != 0) {
+     std::string error_msg = StrError(errno);
+-    LOG(ERROR) << "_stat failed for filename " << filename << " with error "
++    ABSL_LOG(ERROR) << "_stat failed for filename " << filename << " with error "
+                << error_msg;
+     return absl::Status(absl::StatusCode::kInternal, error_msg);
+   }
+diff --git a/third_party/grpc/source/src/core/util/windows/sync.cc b/third_party/grpc/source/src/core/util/windows/sync.cc
+index 3bde6dad729d6..d14d87094e3ec 100644
+--- a/third_party/grpc/source/src/core/util/windows/sync.cc
++++ b/third_party/grpc/source/src/core/util/windows/sync.cc
+@@ -26,7 +26,7 @@
+ #include <grpc/support/sync.h>
+ #include <grpc/support/time.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ void gpr_mu_init(gpr_mu* mu) {
+   InitializeCriticalSection(&mu->cs);
+@@ -37,7 +37,7 @@ void gpr_mu_destroy(gpr_mu* mu) { DeleteCriticalSection(&mu->cs); }
+
+ void gpr_mu_lock(gpr_mu* mu) {
+   EnterCriticalSection(&mu->cs);
+-  CHECK(!mu->locked);
++  ABSL_CHECK(!mu->locked);
+   mu->locked = 1;
+ }
+
+diff --git a/third_party/grpc/source/src/core/util/windows/thd.cc b/third_party/grpc/source/src/core/util/windows/thd.cc
+index 464d8a6d06ccd..be3ca122cd181 100644
+--- a/third_party/grpc/source/src/core/util/windows/thd.cc
++++ b/third_party/grpc/source/src/core/util/windows/thd.cc
+@@ -27,8 +27,8 @@
+ #include <grpc/support/time.h>
+ #include <string.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/memory.h"
+ #include "src/core/util/thd.h"
+@@ -101,7 +101,7 @@ class ThreadInternalsWindows
+
+   void Join() override {
+     DWORD ret = WaitForSingleObject(info_->join_event, INFINITE);
+-    CHECK(ret == WAIT_OBJECT_0);
++    ABSL_CHECK(ret == WAIT_OBJECT_0);
+     destroy_thread();
+   }
+
+@@ -121,7 +121,7 @@ class ThreadInternalsWindows
+     g_thd_info->body(g_thd_info->arg);
+     if (g_thd_info->joinable) {
+       BOOL ret = SetEvent(g_thd_info->join_event);
+-      CHECK(ret);
++      ABSL_CHECK(ret);
+     } else {
+       gpr_free(g_thd_info);
+     }
+@@ -147,12 +147,12 @@ namespace grpc_core {
+
+ void Thread::Signal(gpr_thd_id /* tid */, int /* sig */) {
+   // TODO(hork): Implement
+-  VLOG(2) << "Thread signals are not supported on Windows.";
++  ABSL_VLOG(2) << "Thread signals are not supported on Windows.";
+ }
+
+ void Thread::Kill(gpr_thd_id /* tid */) {
+   // TODO(hork): Implement
+-  VLOG(2) << "Thread::Kill is not supported on Windows.";
++  ABSL_VLOG(2) << "Thread::Kill is not supported on Windows.";
+ }
+
+ Thread::Thread(const char* /* thd_name */, void (*thd_body)(void* arg),
+diff --git a/third_party/grpc/source/src/core/util/windows/time.cc b/third_party/grpc/source/src/core/util/windows/time.cc
+index 1e8bb4b068712..1de729dafc003 100644
+--- a/third_party/grpc/source/src/core/util/windows/time.cc
++++ b/third_party/grpc/source/src/core/util/windows/time.cc
+@@ -27,7 +27,7 @@
+ #include <process.h>
+ #include <sys/timeb.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/util/time_precise.h"
+
+ static LARGE_INTEGER g_start_time = []() {
+@@ -95,8 +95,8 @@ void gpr_sleep_until(gpr_timespec until) {
+     delta = gpr_time_sub(until, now);
+     sleep_millis =
+         delta.tv_sec * GPR_MS_PER_SEC + delta.tv_nsec / GPR_NS_PER_MS;
+-    CHECK_GE(sleep_millis, 0);
+-    CHECK_LE(sleep_millis, INT_MAX);
++    ABSL_CHECK_GE(sleep_millis, 0);
++    ABSL_CHECK_LE(sleep_millis, INT_MAX);
+     Sleep((DWORD)sleep_millis);
+   }
+ }
+diff --git a/third_party/grpc/source/src/core/util/work_serializer.cc b/third_party/grpc/source/src/core/util/work_serializer.cc
+index 4aa6154e33c0a..b83658f86deb8 100644
+--- a/third_party/grpc/source/src/core/util/work_serializer.cc
++++ b/third_party/grpc/source/src/core/util/work_serializer.cc
+@@ -29,8 +29,8 @@
+ #include <utility>
+
+ #include "absl/container/inlined_vector.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/lib/experiments/experiments.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -175,7 +175,7 @@ void WorkSerializer::WorkSerializerImpl::Run(
+     running_start_time_ = std::chrono::steady_clock::now();
+     items_processed_during_run_ = 0;
+     time_running_items_ = std::chrono::steady_clock::duration();
+-    CHECK(processing_.empty());
++    ABSL_CHECK(processing_.empty());
+     processing_.emplace_back(std::move(callback), location);
+     event_engine_->Run(this);
+   } else {
+diff --git a/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc b/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc
+index a68a8a7974bc3..b65890627eef8 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc
+@@ -21,7 +21,7 @@
+ #include <grpc/support/json.h>
+ #include <grpc/support/port_platform.h>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/config/core_configuration.h"
+ #include "src/core/lib/security/certificate_provider/certificate_provider_registry.h"
+@@ -126,7 +126,7 @@ CertificateProviderStore::CreateCertificateProviderLocked(
+     // This should never happen since an entry is only inserted in the
+     // plugin_config_map_ if the corresponding factory was found when parsing
+     // the xDS bootstrap file.
+-    LOG(ERROR) << "Certificate provider factory " << definition.plugin_name
++    ABSL_LOG(ERROR) << "Certificate provider factory " << definition.plugin_name
+                << " not found";
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc b/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc
+index f668d3f381226..8de1f5510c335 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc
+@@ -26,7 +26,7 @@
+ #include <memory>
+ #include <vector>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/str_join.h"
+ #include "src/core/config/core_configuration.h"
+@@ -114,7 +114,7 @@ RefCountedPtr<grpc_tls_certificate_provider>
+ FileWatcherCertificateProviderFactory::CreateCertificateProvider(
+     RefCountedPtr<CertificateProviderFactory::Config> config) {
+   if (config->name() != name()) {
+-    LOG(ERROR) << "Wrong config type Actual:" << config->name()
++    ABSL_LOG(ERROR) << "Wrong config type Actual:" << config->name()
+                << " vs Expected:" << name();
+     return nullptr;
+   }
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc b/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc
+index 17ab5aac4d9b1..c8f2f36c533c7 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc
+@@ -24,7 +24,7 @@
+ #include <utility>
+
+ #include "absl/functional/bind_front.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/channel/channel_args.h"
+ #include "src/core/lib/iomgr/error.h"
+ #include "src/core/lib/security/security_connector/ssl_utils.h"
+@@ -186,7 +186,7 @@ void XdsCertificateProvider::WatchStatusCallback(std::string cert_name,
+     }
+   } else if (!root_being_watched && root_cert_watcher_ != nullptr) {
+     // Cancel root cert watch.
+-    CHECK(root_cert_provider_ != nullptr);
++    ABSL_CHECK(root_cert_provider_ != nullptr);
+     root_cert_provider_->distributor()->CancelTlsCertificatesWatch(
+         root_cert_watcher_);
+     root_cert_watcher_ = nullptr;
+@@ -206,7 +206,7 @@ void XdsCertificateProvider::WatchStatusCallback(std::string cert_name,
+           std::move(watcher), std::nullopt, identity_cert_name_);
+     }
+   } else if (!identity_being_watched && identity_cert_watcher_ != nullptr) {
+-    CHECK(identity_cert_provider_ != nullptr);
++    ABSL_CHECK(identity_cert_provider_ != nullptr);
+     identity_cert_provider_->distributor()->CancelTlsCertificatesWatch(
+         identity_cert_watcher_);
+     identity_cert_watcher_ = nullptr;
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc b/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc
+index 5171a6d454c13..aa537475fff52 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc
+@@ -32,7 +32,7 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc
+index 42f9f65287c4a..441954620a3e7 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc
+@@ -19,8 +19,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -446,7 +446,7 @@ absl::StatusOr<std::shared_ptr<const XdsClusterResource>> CdsResourceParse(
+     ValidationErrors::ScopedField field(&errors, ".cluster_type");
+     const auto* custom_cluster_type =
+         envoy_config_cluster_v3_Cluster_cluster_type(cluster);
+-    CHECK_NE(custom_cluster_type, nullptr);
++    ABSL_CHECK_NE(custom_cluster_type, nullptr);
+     ValidationErrors::ScopedField field2(&errors, ".typed_config");
+     const auto* typed_config =
+         envoy_config_cluster_v3_Cluster_CustomClusterType_typed_config(
+@@ -729,7 +729,7 @@ void MaybeLogCluster(const XdsResourceType::DecodeContext& context,
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(cluster), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << context.client << "] Cluster: " << buf;
++    ABSL_VLOG(2) << "[xds_client " << context.client << "] Cluster: " << buf;
+   }
+ }
+
+@@ -754,13 +754,13 @@ XdsResourceType::DecodeResult XdsClusterResourceType::Decode(
+   auto cds_resource = CdsResourceParse(context, resource);
+   if (!cds_resource.ok()) {
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(ERROR) << "[xds_client " << context.client << "] invalid Cluster "
++      ABSL_LOG(ERROR) << "[xds_client " << context.client << "] invalid Cluster "
+                  << *result.name << ": " << cds_resource.status();
+     }
+     result.resource = cds_resource.status();
+   } else {
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(INFO) << "[xds_client " << context.client << "] parsed Cluster "
++      ABSL_LOG(INFO) << "[xds_client " << context.client << "] parsed Cluster "
+                 << *result.name << ": " << (*cds_resource)->ToString();
+     }
+     result.resource = std::move(*cds_resource);
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc
+index 12d56543813f5..a21214ca4e241 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc
+@@ -24,7 +24,7 @@
+ #include <utility>
+ #include <variant>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/util/json/json.h"
+@@ -89,7 +89,7 @@ Json XdsRouteLookupClusterSpecifierPlugin::GenerateLoadBalancingPolicyConfig(
+   upb_JsonEncode(plugin_config, msg_type, symtab, 0,
+                  reinterpret_cast<char*>(buf), json_size + 1, status.ptr());
+   auto json = JsonParse(reinterpret_cast<char*>(buf));
+-  CHECK(json.ok());
++  ABSL_CHECK(json.ok());
+   return Json::FromArray({Json::FromObject(
+       {{"rls_experimental",
+         Json::FromObject({
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc
+index 0980eb51149b4..282176adb047b 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc
+@@ -27,8 +27,8 @@
+ #include <set>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -95,7 +95,7 @@ void MaybeLogClusterLoadAssignment(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(cla), msg_type, nullptr,
+                    0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << context.client
++    ABSL_VLOG(2) << "[xds_client " << context.client
+             << "] ClusterLoadAssignment: " << buf;
+   }
+ }
+@@ -366,7 +366,7 @@ absl::StatusOr<std::shared_ptr<const XdsEndpointResource>> EdsResourceParse(
+       auto parsed_locality =
+           LocalityParse(context, endpoints[i], &address_set, &errors);
+       if (parsed_locality.has_value()) {
+-        CHECK_NE(parsed_locality->locality.lb_weight, 0u);
++        ABSL_CHECK_NE(parsed_locality->locality.lb_weight, 0u);
+         // Make sure prorities is big enough. Note that they might not
+         // arrive in priority order.
+         if (eds_resource->priorities.size() < parsed_locality->priority + 1) {
+@@ -456,14 +456,14 @@ XdsResourceType::DecodeResult XdsEndpointResourceType::Decode(
+   auto eds_resource = EdsResourceParse(context, resource);
+   if (!eds_resource.ok()) {
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(ERROR) << "[xds_client " << context.client
++      ABSL_LOG(ERROR) << "[xds_client " << context.client
+                  << "] invalid ClusterLoadAssignment " << *result.name << ": "
+                  << eds_resource.status();
+     }
+     result.resource = eds_resource.status();
+   } else {
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(INFO) << "[xds_client " << context.client
++      ABSL_LOG(INFO) << "[xds_client " << context.client
+                 << "] parsed ClusterLoadAssignment " << *result.name << ": "
+                 << (*eds_resource)->ToString();
+     }
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc b/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc
+index ec64f365599e5..9bf71bb4c3a77 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc
+@@ -23,7 +23,7 @@
+ #include <variant>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "envoy/extensions/filters/http/router/v3/router.upb.h"
+ #include "envoy/extensions/filters/http/router/v3/router.upbdefs.h"
+ #include "src/core/util/json/json.h"
+@@ -98,10 +98,10 @@ XdsHttpFilterRegistry::XdsHttpFilterRegistry(bool register_builtins) {
+
+ void XdsHttpFilterRegistry::RegisterFilter(
+     std::unique_ptr<XdsHttpFilterImpl> filter) {
+-  CHECK(registry_map_.emplace(filter->ConfigProtoName(), filter.get()).second);
++  ABSL_CHECK(registry_map_.emplace(filter->ConfigProtoName(), filter.get()).second);
+   auto override_proto_name = filter->OverrideConfigProtoName();
+   if (!override_proto_name.empty()) {
+-    CHECK(registry_map_.emplace(override_proto_name, filter.get()).second);
++    ABSL_CHECK(registry_map_.emplace(override_proto_name, filter.get()).second);
+   }
+   owning_list_.push_back(std::move(filter));
+ }
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc
+index 9360f1db025ba..e6ecbd9962e5f 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc
+@@ -22,8 +22,8 @@
+ #include <set>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -143,7 +143,7 @@ void MaybeLogHttpConnectionManager(
+     upb_TextEncode(
+         reinterpret_cast<const upb_Message*>(http_connection_manager_config),
+         msg_type, nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << context.client
++    ABSL_VLOG(2) << "[xds_client " << context.client
+             << "] HttpConnectionManager: " << buf;
+   }
+ }
+@@ -739,7 +739,7 @@ void AddFilterChainDataForSourceType(
+     const FilterChain& filter_chain,
+     InternalFilterChainMap::DestinationIp* destination_ip,
+     ValidationErrors* errors) {
+-  CHECK(static_cast<unsigned int>(filter_chain.filter_chain_match.source_type) <
++  ABSL_CHECK(static_cast<unsigned int>(filter_chain.filter_chain_match.source_type) <
+         3u);
+   AddFilterChainDataForSourceIpRange(
+       filter_chain,
+@@ -958,7 +958,7 @@ void MaybeLogListener(const XdsResourceType::DecodeContext& context,
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(listener), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << context.client << "] Listener: " << buf;
++    ABSL_VLOG(2) << "[xds_client " << context.client << "] Listener: " << buf;
+   }
+ }
+
+@@ -983,13 +983,13 @@ XdsResourceType::DecodeResult XdsListenerResourceType::Decode(
+   auto listener = LdsResourceParse(context, resource);
+   if (!listener.ok()) {
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(ERROR) << "[xds_client " << context.client << "] invalid Listener "
++      ABSL_LOG(ERROR) << "[xds_client " << context.client << "] invalid Listener "
+                  << *result.name << ": " << listener.status();
+     }
+     result.resource = listener.status();
+   } else {
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(INFO) << "[xds_client " << context.client << "] parsed Listener "
++      ABSL_LOG(INFO) << "[xds_client " << context.client << "] parsed Listener "
+                 << *result.name << ": " << (*listener)->ToString();
+     }
+     result.resource = std::move(*listener);
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc b/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc
+index 4e2d5b2ca2cef..654a5f85bdaa4 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc
+@@ -21,7 +21,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+ #include "absl/strings/string_view.h"
+@@ -30,8 +30,8 @@ namespace grpc_core {
+
+ void XdsMetadataMap::Insert(absl::string_view key,
+                             std::unique_ptr<XdsMetadataValue> value) {
+-  CHECK(value != nullptr);
+-  CHECK(map_.emplace(key, std::move(value)).second) << "duplicate key: " << key;
++  ABSL_CHECK(value != nullptr);
++  ABSL_CHECK(map_.emplace(key, std::move(value)).second) << "duplicate key: " << key;
+ }
+
+ const XdsMetadataValue* XdsMetadataMap::Find(absl::string_view key) const {
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc
+index d6660248356aa..f9abfdbf546ce 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc
+@@ -71,7 +71,7 @@ std::unique_ptr<XdsMetadataValue> ParseGcpAuthnAudience(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(proto), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << context.client
++    ABSL_VLOG(2) << "[xds_client " << context.client
+             << "] cluster metadata Audience: " << buf;
+   }
+   absl::string_view url = UpbStringToAbsl(
+@@ -105,7 +105,7 @@ std::unique_ptr<XdsMetadataValue> ParseAddress(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(proto), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << context.client
++    ABSL_VLOG(2) << "[xds_client " << context.client
+             << "] cluster metadata Address: " << buf;
+   }
+   auto addr = ParseXdsAddress(proto, errors);
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc
+index 7b14d16492cd0..37bd458756ad4 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc
+@@ -31,8 +31,8 @@
+ #include <variant>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_cat.h"
+@@ -228,7 +228,7 @@ std::optional<StringMatcher> RoutePathMatchParse(
+   } else if (envoy_config_route_v3_RouteMatch_has_safe_regex(match)) {
+     const envoy_type_matcher_v3_RegexMatcher* regex_matcher =
+         envoy_config_route_v3_RouteMatch_safe_regex(match);
+-    CHECK_NE(regex_matcher, nullptr);
++    ABSL_CHECK_NE(regex_matcher, nullptr);
+     type = StringMatcher::Type::kSafeRegex;
+     match_string = UpbStringToStdString(
+         envoy_type_matcher_v3_RegexMatcher_regex(regex_matcher));
+@@ -256,7 +256,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
+     ValidationErrors::ScopedField field(errors,
+                                         absl::StrCat(".headers[", i, "]"));
+     const envoy_config_route_v3_HeaderMatcher* header = headers[i];
+-    CHECK_NE(header, nullptr);
++    ABSL_CHECK_NE(header, nullptr);
+     const std::string name =
+         UpbStringToStdString(envoy_config_route_v3_HeaderMatcher_name(header));
+     HeaderMatcher::Type type;
+@@ -285,7 +285,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
+                    header)) {
+       const envoy_type_matcher_v3_RegexMatcher* regex_matcher =
+           envoy_config_route_v3_HeaderMatcher_safe_regex_match(header);
+-      CHECK_NE(regex_matcher, nullptr);
++      ABSL_CHECK_NE(regex_matcher, nullptr);
+       type = HeaderMatcher::Type::kSafeRegex;
+       match_string = UpbStringToStdString(
+           envoy_type_matcher_v3_RegexMatcher_regex(regex_matcher));
+@@ -293,7 +293,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
+       type = HeaderMatcher::Type::kRange;
+       const envoy_type_v3_Int64Range* range_matcher =
+           envoy_config_route_v3_HeaderMatcher_range_match(header);
+-      CHECK_NE(range_matcher, nullptr);
++      ABSL_CHECK_NE(range_matcher, nullptr);
+       range_start = envoy_type_v3_Int64Range_start(range_matcher);
+       range_end = envoy_type_v3_Int64Range_end(range_matcher);
+     } else if (envoy_config_route_v3_HeaderMatcher_has_present_match(header)) {
+@@ -303,7 +303,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
+       ValidationErrors::ScopedField field(errors, ".string_match");
+       const auto* matcher =
+           envoy_config_route_v3_HeaderMatcher_string_match(header);
+-      CHECK_NE(matcher, nullptr);
++      ABSL_CHECK_NE(matcher, nullptr);
+       if (envoy_type_matcher_v3_StringMatcher_has_exact(matcher)) {
+         type = HeaderMatcher::Type::kExact;
+         match_string = UpbStringToStdString(
+@@ -324,7 +324,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
+         type = HeaderMatcher::Type::kSafeRegex;
+         const auto* regex_matcher =
+             envoy_type_matcher_v3_StringMatcher_safe_regex(matcher);
+-        CHECK_NE(regex_matcher, nullptr);
++        ABSL_CHECK_NE(regex_matcher, nullptr);
+         match_string = UpbStringToStdString(
+             envoy_type_matcher_v3_RegexMatcher_regex(regex_matcher));
+       } else {
+@@ -467,7 +467,7 @@ XdsRouteConfigResource::RetryPolicy RetryPolicyParse(
+       retry_policy.retry_on.Add(GRPC_STATUS_UNAVAILABLE);
+     } else {
+       if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-        LOG(INFO) << "Unsupported retry_on policy " << code;
++        ABSL_LOG(INFO) << "Unsupported retry_on policy " << code;
+       }
+     }
+   }
+@@ -649,7 +649,7 @@ std::optional<XdsRouteConfigResource::Route::RouteAction> RouteActionParse(
+     ValidationErrors::ScopedField field(errors, ".weighted_clusters");
+     const envoy_config_route_v3_WeightedCluster* weighted_clusters_proto =
+         envoy_config_route_v3_RouteAction_weighted_clusters(route_action_proto);
+-    CHECK_NE(weighted_clusters_proto, nullptr);
++    ABSL_CHECK_NE(weighted_clusters_proto, nullptr);
+     std::vector<XdsRouteConfigResource::Route::RouteAction::ClusterWeight>
+         action_weighted_clusters;
+     uint64_t total_weight = 0;
+@@ -910,7 +910,7 @@ void MaybeLogRouteConfiguration(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(route_config), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << context.client
++    ABSL_VLOG(2) << "[xds_client " << context.client
+             << "] RouteConfiguration: " << buf;
+   }
+ }
+@@ -940,14 +940,14 @@ XdsResourceType::DecodeResult XdsRouteConfigResourceType::Decode(
+         errors.status(absl::StatusCode::kInvalidArgument,
+                       "errors validating RouteConfiguration resource");
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(ERROR) << "[xds_client " << context.client
++      ABSL_LOG(ERROR) << "[xds_client " << context.client
+                  << "] invalid RouteConfiguration " << *result.name << ": "
+                  << status;
+     }
+     result.resource = std::move(status);
+   } else {
+     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-      LOG(INFO) << "[xds_client " << context.client
++      ABSL_LOG(INFO) << "[xds_client " << context.client
+                 << "] parsed RouteConfiguration " << *result.name << ": "
+                 << rds_update->ToString();
+     }
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc b/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc
+index ca45f10f825c3..7359eac65ab1c 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc
+@@ -26,7 +26,7 @@
+ #include <cctype>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/match.h"
+@@ -115,7 +115,7 @@ std::optional<size_t> XdsRouting::FindVirtualHostForDomain(
+       // than current match.
+       const MatchType match_type = DomainPatternMatchType(domain_pattern);
+       // This should be caught by RouteConfigParse().
+-      CHECK(match_type != INVALID_MATCH);
++      ABSL_CHECK(match_type != INVALID_MATCH);
+       if (match_type > best_match_type) continue;
+       if (match_type == best_match_type &&
+           domain_pattern.size() <= longest_match) {
+@@ -231,7 +231,7 @@ GeneratePerHTTPFilterConfigs(
+     const XdsHttpFilterImpl* filter_impl =
+         http_filter_registry.GetFilterForType(
+             http_filter.config.config_proto_type_name);
+-    CHECK_NE(filter_impl, nullptr);
++    ABSL_CHECK_NE(filter_impl, nullptr);
+     // If there is not actually any C-core filter associated with this
+     // xDS filter, then it won't need any config, so skip it.
+     if (filter_impl->channel_filter() == nullptr) continue;
+diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc b/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc
+index f3e0acd033ecc..f2eb3b69de02a 100644
+--- a/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc
++++ b/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc
+@@ -32,7 +32,7 @@
+ #include <string_view>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/client_channel/client_channel_filter.h"
+ #include "src/core/config/core_configuration.h"
+@@ -77,7 +77,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::GrpcStreamingCall(
+       factory_->interested_parties(), Slice::FromStaticString(method),
+       /*authority=*/std::nullopt, Timestamp::InfFuture(),
+       /*registered_method=*/true);
+-  CHECK_NE(call_, nullptr);
++  ABSL_CHECK_NE(call_, nullptr);
+   // Init data associated with the call.
+   grpc_metadata_array_init(&initial_metadata_recv_);
+   grpc_metadata_array_init(&trailing_metadata_recv_);
+@@ -107,7 +107,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::GrpcStreamingCall(
+       this->Ref(DEBUG_LOCATION, "OnRecvInitialMetadata").release(), nullptr);
+   call_error = grpc_call_start_batch_and_execute(
+       call_, ops, static_cast<size_t>(op - ops), &on_recv_initial_metadata_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+   // Start a batch for recv_trailing_metadata.
+   memset(ops, 0, sizeof(ops));
+   op = ops;
+@@ -124,7 +124,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::GrpcStreamingCall(
+   GRPC_CLOSURE_INIT(&on_status_received_, OnStatusReceived, this, nullptr);
+   call_error = grpc_call_start_batch_and_execute(
+       call_, ops, static_cast<size_t>(op - ops), &on_status_received_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+   GRPC_CLOSURE_INIT(&on_response_received_, OnResponseReceived, this, nullptr);
+ }
+
+@@ -134,12 +134,12 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
+   grpc_byte_buffer_destroy(send_message_payload_);
+   grpc_byte_buffer_destroy(recv_message_payload_);
+   CSliceUnref(status_details_);
+-  CHECK_NE(call_, nullptr);
++  ABSL_CHECK_NE(call_, nullptr);
+   grpc_call_unref(call_);
+ }
+
+ void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::Orphan() {
+-  CHECK_NE(call_, nullptr);
++  ABSL_CHECK_NE(call_, nullptr);
+   // If we are here because xds_client wants to cancel the call,
+   // OnStatusReceived() will complete the cancellation and clean up.
+   // Otherwise, we are here because xds_client has to orphan a failed call,
+@@ -163,7 +163,7 @@ void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::SendMessage(
+   Ref(DEBUG_LOCATION, "OnRequestSent").release();
+   grpc_call_error call_error =
+       grpc_call_start_batch_and_execute(call_, &op, 1, &on_request_sent_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+ }
+
+ void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
+@@ -173,10 +173,10 @@ void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
+   memset(&op, 0, sizeof(op));
+   op.op = GRPC_OP_RECV_MESSAGE;
+   op.data.recv_message.recv_message = &recv_message_payload_;
+-  CHECK_NE(call_, nullptr);
++  ABSL_CHECK_NE(call_, nullptr);
+   const grpc_call_error call_error =
+       grpc_call_start_batch_and_execute(call_, &op, 1, &on_response_received_);
+-  CHECK_EQ(call_error, GRPC_CALL_OK);
++  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
+ }
+
+ void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
+@@ -273,7 +273,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcXdsTransport(
+       << "[GrpcXdsTransport " << this << "] created";
+   channel_ = CreateXdsChannel(factory_->args_,
+                               static_cast<const GrpcXdsServer&>(server));
+-  CHECK(channel_ != nullptr);
++  ABSL_CHECK(channel_ != nullptr);
+   if (channel_->IsLame()) {
+     *status = absl::UnavailableError("xds client has a lame channel");
+   }
+diff --git a/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc b/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc
+index 7fbb86c9b1ebe..09f3b58b025b5 100644
+--- a/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc
++++ b/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc
+@@ -25,8 +25,8 @@
+ #include <vector>
+
+ #include "absl/cleanup/cleanup.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "envoy/config/core/v3/base.upb.h"
+ #include "envoy/config/endpoint/v3/load_report.upb.h"
+@@ -400,9 +400,9 @@ LrsClient::LrsChannel::LrsChannel(
+       << " for server " << server_->server_uri();
+   absl::Status status;
+   transport_ = lrs_client_->transport_factory_->GetTransport(*server_, &status);
+-  CHECK(transport_ != nullptr);
++  ABSL_CHECK(transport_ != nullptr);
+   if (!status.ok()) {
+-    LOG(ERROR) << "Error creating LRS channel to " << server_->server_uri()
++    ABSL_LOG(ERROR) << "Error creating LRS channel to " << server_->server_uri()
+                << ": " << status;
+   }
+ }
+@@ -484,8 +484,8 @@ void LrsClient::LrsChannel::RetryableCall<T>::OnCallFinishedLocked() {
+ template <typename T>
+ void LrsClient::LrsChannel::RetryableCall<T>::StartNewCallLocked() {
+   if (shutting_down_) return;
+-  CHECK(lrs_channel_->transport_ != nullptr);
+-  CHECK(call_ == nullptr);
++  ABSL_CHECK(lrs_channel_->transport_ != nullptr);
++  ABSL_CHECK(call_ == nullptr);
+   GRPC_TRACE_LOG(xds_client, INFO)
+       << "[lrs_client " << lrs_channel()->lrs_client() << "] lrs server "
+       << lrs_channel()->server_->server_uri()
+@@ -571,7 +571,7 @@ LrsClient::LrsChannel::LrsCall::LrsCall(
+   // Init the LRS call. Note that the call will progress every time there's
+   // activity in lrs_client()->interested_parties_, which is comprised of
+   // the polling entities from client_channel.
+-  CHECK_NE(lrs_client(), nullptr);
++  ABSL_CHECK_NE(lrs_client(), nullptr);
+   const char* method =
+       "/envoy.service.load_stats.v3.LoadReportingService/StreamLoadStats";
+   streaming_call_ = lrs_channel()->transport_->CreateStreamingCall(
+@@ -579,7 +579,7 @@ LrsClient::LrsChannel::LrsCall::LrsCall(
+                   // Passing the initial ref here.  This ref will go away when
+                   // the StreamEventHandler is destroyed.
+                   RefCountedPtr<LrsCall>(this)));
+-  CHECK(streaming_call_ != nullptr);
++  ABSL_CHECK(streaming_call_ != nullptr);
+   // Start the call.
+   GRPC_TRACE_LOG(xds_client, INFO)
+       << "[lrs_client " << lrs_client() << "] lrs server "
+@@ -679,14 +679,14 @@ void LrsClient::LrsChannel::LrsCall::OnRecvMessage(absl::string_view payload) {
+       payload, &send_all_clusters, &new_cluster_names,
+       &new_load_reporting_interval);
+   if (!status.ok()) {
+-    LOG(ERROR) << "[lrs_client " << lrs_client() << "] lrs server "
++    ABSL_LOG(ERROR) << "[lrs_client " << lrs_client() << "] lrs server "
+                << lrs_channel()->server_->server_uri()
+                << ": LRS response parsing failed: " << status;
+     return;
+   }
+   seen_response_ = true;
+   if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
+-    LOG(INFO) << "[lrs_client " << lrs_client() << "] lrs server "
++    ABSL_LOG(INFO) << "[lrs_client " << lrs_client() << "] lrs server "
+               << lrs_channel()->server_->server_uri()
+               << ": LRS response received, " << new_cluster_names.size()
+               << " cluster names, send_all_clusters=" << send_all_clusters
+@@ -694,7 +694,7 @@ void LrsClient::LrsChannel::LrsCall::OnRecvMessage(absl::string_view payload) {
+               << new_load_reporting_interval.millis() << "ms";
+     size_t i = 0;
+     for (const auto& name : new_cluster_names) {
+-      LOG(INFO) << "[lrs_client " << lrs_client() << "] cluster_name " << i++
++      ABSL_LOG(INFO) << "[lrs_client " << lrs_client() << "] cluster_name " << i++
+                 << ": " << name;
+     }
+   }
+@@ -1054,7 +1054,7 @@ void MaybeLogLrsRequest(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(request), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[lrs_client " << context.client
++    ABSL_VLOG(2) << "[lrs_client " << context.client
+             << "] constructed LRS request: " << buf;
+   }
+ }
+@@ -1233,7 +1233,7 @@ void MaybeLogLrsResponse(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(response), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[lrs_client " << context.client
++    ABSL_VLOG(2) << "[lrs_client " << context.client
+             << "] received LRS response: " << buf;
+   }
+ }
+diff --git a/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc b/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc
+index da09d1db1be55..608f4cf8ab28d 100644
+--- a/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc
++++ b/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc
+@@ -30,8 +30,8 @@
+ #include <vector>
+
+ #include "absl/cleanup/cleanup.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/match.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+@@ -401,7 +401,7 @@ XdsClient::XdsChannel::XdsChannel(WeakRefCountedPtr<XdsClient> xds_client,
+       << " for server " << server.server_uri();
+   absl::Status status;
+   transport_ = xds_client_->transport_factory_->GetTransport(server, &status);
+-  CHECK(transport_ != nullptr);
++  ABSL_CHECK(transport_ != nullptr);
+   if (!status.ok()) {
+     SetChannelStatusLocked(std::move(status));
+   } else {
+@@ -542,7 +542,7 @@ void XdsClient::XdsChannel::SetChannelStatusLocked(absl::Status status) {
+   status = absl::Status(status.code(), absl::StrCat("xDS channel for server ",
+                                                     server_.server_uri(), ": ",
+                                                     status.message()));
+-  LOG(INFO) << "[xds_client " << xds_client() << "] " << status;
++  ABSL_LOG(INFO) << "[xds_client " << xds_client() << "] " << status;
+   // If status was previously OK, report that the channel has gone unhealthy.
+   if (status_.ok() && xds_client_->metrics_reporter_ != nullptr) {
+     xds_client_->metrics_reporter_->ReportServerFailure(server_.server_uri());
+@@ -621,8 +621,8 @@ void XdsClient::XdsChannel::RetryableCall<T>::OnCallFinishedLocked() {
+ template <typename T>
+ void XdsClient::XdsChannel::RetryableCall<T>::StartNewCallLocked() {
+   if (shutting_down_) return;
+-  CHECK(xds_channel_->transport_ != nullptr);
+-  CHECK(call_ == nullptr);
++  ABSL_CHECK(xds_channel_->transport_ != nullptr);
++  ABSL_CHECK(call_ == nullptr);
+   GRPC_TRACE_LOG(xds_client, INFO)
+       << "[xds_client " << xds_channel()->xds_client() << "] xds server "
+       << xds_channel()->server_.server_uri()
+@@ -692,7 +692,7 @@ XdsClient::XdsChannel::AdsCall::AdsCall(
+     : InternallyRefCounted<AdsCall>(
+           GRPC_TRACE_FLAG_ENABLED(xds_client_refcount) ? "AdsCall" : nullptr),
+       retryable_call_(std::move(retryable_call)) {
+-  CHECK_NE(xds_client(), nullptr);
++  ABSL_CHECK_NE(xds_client(), nullptr);
+   // Init the ADS call.
+   const char* method =
+       "/envoy.service.discovery.v3.AggregatedDiscoveryService/"
+@@ -702,7 +702,7 @@ XdsClient::XdsChannel::AdsCall::AdsCall(
+                   // Passing the initial ref here.  This ref will go away when
+                   // the StreamEventHandler is destroyed.
+                   RefCountedPtr<AdsCall>(this)));
+-  CHECK(streaming_call_ != nullptr);
++  ABSL_CHECK(streaming_call_ != nullptr);
+   // Start the call.
+   GRPC_TRACE_LOG(xds_client, INFO)
+       << "[xds_client " << xds_client() << "] xds server "
+@@ -788,7 +788,7 @@ void MaybeLogDiscoveryRequest(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(request), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << client << "] constructed ADS request: " << buf;
++    ABSL_VLOG(2) << "[xds_client " << client << "] constructed ADS request: " << buf;
+   }
+ }
+
+@@ -1067,7 +1067,7 @@ void MaybeLogDiscoveryResponse(
+     char buf[10240];
+     upb_TextEncode(reinterpret_cast<const upb_Message*>(response), msg_type,
+                    nullptr, 0, buf, sizeof(buf));
+-    VLOG(2) << "[xds_client " << client << "] received response: " << buf;
++    ABSL_VLOG(2) << "[xds_client " << client << "] received response: " << buf;
+   }
+ }
+
+@@ -1162,7 +1162,7 @@ void XdsClient::XdsChannel::AdsCall::OnRecvMessage(absl::string_view payload) {
+   absl::Status status = DecodeAdsResponse(payload, &context);
+   if (!status.ok()) {
+     // Ignore unparsable response.
+-    LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
++    ABSL_LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
+                << xds_channel()->server_.server_uri()
+                << ": error parsing ADS response (" << status << ") -- ignoring";
+   } else {
+@@ -1176,7 +1176,7 @@ void XdsClient::XdsChannel::AdsCall::OnRecvMessage(absl::string_view payload) {
+       state.status = absl::UnavailableError(
+           absl::StrCat("xDS response validation errors: [",
+                        absl::StrJoin(context.errors, "; "), "]"));
+-      LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
++      ABSL_LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
+                  << xds_channel()->server_.server_uri()
+                  << ": ADS response invalid for resource type "
+                  << context.type_url << " version " << context.version
+@@ -1439,7 +1439,7 @@ XdsClient::XdsClient(
+       metrics_reporter_(std::move(metrics_reporter)) {
+   GRPC_TRACE_LOG(xds_client, INFO)
+       << "[xds_client " << this << "] creating xds client";
+-  CHECK(bootstrap_ != nullptr);
++  ABSL_CHECK(bootstrap_ != nullptr);
+   if (bootstrap_->node() != nullptr) {
+     GRPC_TRACE_LOG(xds_client, INFO)
+         << "[xds_client " << this
+@@ -1629,7 +1629,7 @@ void XdsClient::MaybeRegisterResourceTypeLocked(
+     const XdsResourceType* resource_type) {
+   auto it = resource_types_.find(resource_type->type_url());
+   if (it != resource_types_.end()) {
+-    CHECK(it->second == resource_type);
++    ABSL_CHECK(it->second == resource_type);
+     return;
+   }
+   resource_types_.emplace(resource_type->type_url(), resource_type);
+@@ -1680,7 +1680,7 @@ std::string XdsClient::ConstructFullXdsResourceName(
+     auto uri = URI::Create("xdstp", std::string(authority),
+                            absl::StrCat("/", resource_type, "/", key.id),
+                            key.query_params, /*fragment=*/"");
+-    CHECK(uri.ok());
++    ABSL_CHECK(uri.ok());
+     return uri->ToString();
+   }
+   // Old-style name.
+diff --git a/third_party/grpc/source/src/cpp/client/call_credentials.cc b/third_party/grpc/source/src/cpp/client/call_credentials.cc
+index 3ecc72d5980dc..543c8f68a3935 100644
+--- a/third_party/grpc/source/src/cpp/client/call_credentials.cc
++++ b/third_party/grpc/source/src/cpp/client/call_credentials.cc
+@@ -15,7 +15,7 @@
+ #include <grpc/support/port_platform.h>
+ #include <grpcpp/security/credentials.h>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_cat.h"
+ #include "src/core/lib/security/credentials/credentials.h"
+
+@@ -23,7 +23,7 @@ namespace grpc {
+
+ CallCredentials::CallCredentials(grpc_call_credentials* c_creds)
+     : c_creds_(c_creds) {
+-  CHECK_NE(c_creds, nullptr);
++  ABSL_CHECK_NE(c_creds, nullptr);
+ }
+
+ CallCredentials::~CallCredentials() { grpc_call_credentials_release(c_creds_); }
+diff --git a/third_party/grpc/source/src/cpp/client/channel_cc.cc b/third_party/grpc/source/src/cpp/client/channel_cc.cc
+index e99c416d17577..8b9945a221aff 100644
+--- a/third_party/grpc/source/src/cpp/client/channel_cc.cc
++++ b/third_party/grpc/source/src/cpp/client/channel_cc.cc
+@@ -39,7 +39,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/iomgr/iomgr.h"
+
+ namespace grpc {
+@@ -207,7 +207,7 @@ bool Channel::WaitForStateChangeImpl(grpc_connectivity_state last_observed,
+   void* tag = nullptr;
+   NotifyOnStateChangeImpl(last_observed, deadline, &cq, nullptr);
+   cq.Next(&tag, &ok);
+-  CHECK_EQ(tag, nullptr);
++  ABSL_CHECK_EQ(tag, nullptr);
+   return ok;
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/client/client_context.cc b/third_party/grpc/source/src/cpp/client/client_context.cc
+index e338d440b9ca0..2d542f6e02da5 100644
+--- a/third_party/grpc/source/src/cpp/client/client_context.cc
++++ b/third_party/grpc/source/src/cpp/client/client_context.cc
+@@ -37,7 +37,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/util/crash.h"
+
+@@ -123,7 +123,7 @@ void ClientContext::AddMetadata(const std::string& meta_key,
+ void ClientContext::set_call(grpc_call* call,
+                              const std::shared_ptr<Channel>& channel) {
+   internal::MutexLock lock(&mu_);
+-  CHECK_EQ(call_, nullptr);
++  ABSL_CHECK_EQ(call_, nullptr);
+   call_ = call;
+   channel_ = channel;
+   if (creds_ && !creds_->ApplyToCall(call_)) {
+@@ -146,7 +146,7 @@ void ClientContext::set_compression_algorithm(
+     grpc_core::Crash(absl::StrFormat(
+         "Name for compression algorithm '%d' unknown.", algorithm));
+   }
+-  CHECK_NE(algorithm_name, nullptr);
++  ABSL_CHECK_NE(algorithm_name, nullptr);
+   AddMetadata(GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY, algorithm_name);
+ }
+
+@@ -178,9 +178,9 @@ std::string ClientContext::peer() const {
+ }
+
+ void ClientContext::SetGlobalCallbacks(GlobalCallbacks* client_callbacks) {
+-  CHECK(g_client_callbacks == g_default_client_callbacks);
+-  CHECK_NE(client_callbacks, nullptr);
+-  CHECK(client_callbacks != g_default_client_callbacks);
++  ABSL_CHECK(g_client_callbacks == g_default_client_callbacks);
++  ABSL_CHECK_NE(client_callbacks, nullptr);
++  ABSL_CHECK(client_callbacks != g_default_client_callbacks);
+   g_client_callbacks = client_callbacks;
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/client/global_callback_hook.cc b/third_party/grpc/source/src/cpp/client/global_callback_hook.cc
+index e117214d1ccd1..af7bc4f07e79c 100644
+--- a/third_party/grpc/source/src/cpp/client/global_callback_hook.cc
++++ b/third_party/grpc/source/src/cpp/client/global_callback_hook.cc
+@@ -17,7 +17,7 @@
+ #include <memory>
+
+ #include "absl/base/no_destructor.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc {
+
+@@ -29,8 +29,8 @@ std::shared_ptr<GlobalCallbackHook> GetGlobalCallbackHook() {
+ }
+
+ void SetGlobalCallbackHook(GlobalCallbackHook* hook) {
+-  CHECK(hook != nullptr);
+-  CHECK(hook != (*g_callback_hook).get());
++  ABSL_CHECK(hook != nullptr);
++  ABSL_CHECK(hook != (*g_callback_hook).get());
+   *g_callback_hook = std::shared_ptr<GlobalCallbackHook>(hook);
+ }
+ }  // namespace grpc
+diff --git a/third_party/grpc/source/src/cpp/client/secure_credentials.cc b/third_party/grpc/source/src/cpp/client/secure_credentials.cc
+index ece505f9112c4..e4fd883961987 100644
+--- a/third_party/grpc/source/src/cpp/client/secure_credentials.cc
++++ b/third_party/grpc/source/src/cpp/client/secure_credentials.cc
+@@ -39,8 +39,8 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_join.h"
+@@ -271,7 +271,7 @@ std::shared_ptr<CallCredentials> ServiceAccountJWTAccessCredentials(
+     const std::string& json_key, long token_lifetime_seconds) {
+   grpc::internal::GrpcLibrary init;  // To call grpc_init().
+   if (token_lifetime_seconds <= 0) {
+-    LOG(ERROR) << "Trying to create JWTCredentials with non-positive lifetime";
++    ABSL_LOG(ERROR) << "Trying to create JWTCredentials with non-positive lifetime";
+     return WrapCallCredentials(nullptr);
+   }
+   gpr_timespec lifetime =
+@@ -360,7 +360,7 @@ class MetadataCredentialsPluginWrapper final : private internal::GrpcLibrary {
+       grpc_metadata creds_md[GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX],
+       size_t* num_creds_md, grpc_status_code* status,
+       const char** error_details) {
+-    CHECK(wrapper);
++    ABSL_CHECK(wrapper);
+     MetadataCredentialsPluginWrapper* w =
+         static_cast<MetadataCredentialsPluginWrapper*>(wrapper);
+     if (!w->plugin_) {
+@@ -391,7 +391,7 @@ class MetadataCredentialsPluginWrapper final : private internal::GrpcLibrary {
+   }
+
+   static char* DebugString(void* wrapper) {
+-    CHECK(wrapper);
++    ABSL_CHECK(wrapper);
+     MetadataCredentialsPluginWrapper* w =
+         static_cast<MetadataCredentialsPluginWrapper*>(wrapper);
+     return gpr_strdup(w->plugin_->DebugString().c_str());
+diff --git a/third_party/grpc/source/src/cpp/client/xds_credentials.cc b/third_party/grpc/source/src/cpp/client/xds_credentials.cc
+index b9771e2d340d6..1d4c06f261294 100644
+--- a/third_party/grpc/source/src/cpp/client/xds_credentials.cc
++++ b/third_party/grpc/source/src/cpp/client/xds_credentials.cc
+@@ -22,7 +22,7 @@
+
+ #include <memory>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc {
+ class XdsChannelCredentialsImpl final : public ChannelCredentials {
+@@ -31,13 +31,13 @@ class XdsChannelCredentialsImpl final : public ChannelCredentials {
+       const std::shared_ptr<ChannelCredentials>& fallback_creds)
+       : ChannelCredentials(
+             grpc_xds_credentials_create(fallback_creds->c_creds_)) {
+-    CHECK_NE(fallback_creds->c_creds_, nullptr);
++    ABSL_CHECK_NE(fallback_creds->c_creds_, nullptr);
+   }
+ };
+
+ std::shared_ptr<ChannelCredentials> XdsCredentials(
+     const std::shared_ptr<ChannelCredentials>& fallback_creds) {
+-  CHECK_NE(fallback_creds, nullptr);
++  ABSL_CHECK_NE(fallback_creds, nullptr);
+   return std::make_shared<XdsChannelCredentialsImpl>(fallback_creds);
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/common/alarm.cc b/third_party/grpc/source/src/cpp/common/alarm.cc
+index 7617ca64670d0..977583d941f79 100644
+--- a/third_party/grpc/source/src/cpp/common/alarm.cc
++++ b/third_party/grpc/source/src/cpp/common/alarm.cc
+@@ -29,7 +29,7 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "src/core/lib/event_engine/default_event_engine.h"
+ #include "src/core/lib/iomgr/error.h"
+@@ -64,10 +64,10 @@ class AlarmImpl : public grpc::internal::CompletionQueueTag {
+     GRPC_CQ_INTERNAL_REF(cq->cq(), "alarm");
+     cq_ = cq->cq();
+     tag_ = tag;
+-    CHECK(grpc_cq_begin_op(cq_, this));
++    ABSL_CHECK(grpc_cq_begin_op(cq_, this));
+     Ref();
+-    CHECK(cq_armed_.exchange(true) == false);
+-    CHECK(!callback_armed_.load());
++    ABSL_CHECK(cq_armed_.exchange(true) == false);
++    ABSL_CHECK(!callback_armed_.load());
+     cq_timer_handle_ = event_engine_->RunAfter(
+         grpc_core::Timestamp::FromTimespecRoundUp(deadline) -
+             grpc_core::ExecCtx::Get()->Now(),
+@@ -78,8 +78,8 @@ class AlarmImpl : public grpc::internal::CompletionQueueTag {
+     // Don't use any CQ at all. Instead just use the timer to fire the function
+     callback_ = std::move(f);
+     Ref();
+-    CHECK(callback_armed_.exchange(true) == false);
+-    CHECK(!cq_armed_.load());
++    ABSL_CHECK(callback_armed_.exchange(true) == false);
++    ABSL_CHECK(!cq_armed_.load());
+     callback_timer_handle_ = event_engine_->RunAfter(
+         grpc_core::Timestamp::FromTimespecRoundUp(deadline) -
+             grpc_core::ExecCtx::Get()->Now(),
+diff --git a/third_party/grpc/source/src/cpp/common/alts_util.cc b/third_party/grpc/source/src/cpp/common/alts_util.cc
+index 1a0a2149b1f4c..324ccf6b3af7b 100644
+--- a/third_party/grpc/source/src/cpp/common/alts_util.cc
++++ b/third_party/grpc/source/src/cpp/common/alts_util.cc
+@@ -28,7 +28,7 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/tsi/alts/handshaker/alts_tsi_handshaker.h"
+ #include "src/proto/grpc/gcp/altscontext.upb.h"
+ #include "upb/mem/arena.hpp"
+@@ -39,25 +39,25 @@ namespace experimental {
+ std::unique_ptr<AltsContext> GetAltsContextFromAuthContext(
+     const std::shared_ptr<const AuthContext>& auth_context) {
+   if (auth_context == nullptr) {
+-    LOG(ERROR) << "auth_context is nullptr.";
++    ABSL_LOG(ERROR) << "auth_context is nullptr.";
+     return nullptr;
+   }
+   std::vector<string_ref> ctx_vector =
+       auth_context->FindPropertyValues(TSI_ALTS_CONTEXT);
+   if (ctx_vector.size() != 1) {
+-    LOG(ERROR) << "contains zero or more than one ALTS context.";
++    ABSL_LOG(ERROR) << "contains zero or more than one ALTS context.";
+     return nullptr;
+   }
+   upb::Arena context_arena;
+   grpc_gcp_AltsContext* ctx = grpc_gcp_AltsContext_parse(
+       ctx_vector[0].data(), ctx_vector[0].size(), context_arena.ptr());
+   if (ctx == nullptr) {
+-    LOG(ERROR) << "fails to parse ALTS context.";
++    ABSL_LOG(ERROR) << "fails to parse ALTS context.";
+     return nullptr;
+   }
+   if (grpc_gcp_AltsContext_security_level(ctx) < GRPC_SECURITY_MIN ||
+       grpc_gcp_AltsContext_security_level(ctx) > GRPC_SECURITY_MAX) {
+-    LOG(ERROR) << "security_level is invalid.";
++    ABSL_LOG(ERROR) << "security_level is invalid.";
+     return nullptr;
+   }
+   return std::make_unique<AltsContext>(AltsContext(ctx));
+diff --git a/third_party/grpc/source/src/cpp/common/channel_arguments.cc b/third_party/grpc/source/src/cpp/common/channel_arguments.cc
+index af1838571ca74..b179328a42f97 100644
+--- a/third_party/grpc/source/src/cpp/common/channel_arguments.cc
++++ b/third_party/grpc/source/src/cpp/common/channel_arguments.cc
+@@ -26,7 +26,7 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/lib/iomgr/socket_mutator.h"
+
+@@ -45,7 +45,7 @@ ChannelArguments::ChannelArguments(const ChannelArguments& other)
+   for (const auto& a : other.args_) {
+     grpc_arg ap;
+     ap.type = a.type;
+-    CHECK(list_it_src->c_str() == a.key);
++    ABSL_CHECK(list_it_src->c_str() == a.key);
+     ap.key = const_cast<char*>(list_it_dst->c_str());
+     ++list_it_src;
+     ++list_it_dst;
+@@ -54,7 +54,7 @@ ChannelArguments::ChannelArguments(const ChannelArguments& other)
+         ap.value.integer = a.value.integer;
+         break;
+       case GRPC_ARG_STRING:
+-        CHECK(list_it_src->c_str() == a.value.string);
++        ABSL_CHECK(list_it_src->c_str() == a.value.string);
+         ap.value.string = const_cast<char*>(list_it_dst->c_str());
+         ++list_it_src;
+         ++list_it_dst;
+@@ -101,7 +101,7 @@ void ChannelArguments::SetSocketMutator(grpc_socket_mutator* mutator) {
+   for (auto& arg : args_) {
+     if (arg.type == mutator_arg.type &&
+         std::string(arg.key) == std::string(mutator_arg.key)) {
+-      CHECK(!replaced);
++      ABSL_CHECK(!replaced);
+       arg.value.pointer.vtable->destroy(arg.value.pointer.p);
+       arg.value.pointer = mutator_arg.value.pointer;
+       replaced = true;
+@@ -130,7 +130,7 @@ void ChannelArguments::SetUserAgentPrefix(
+     ++strings_it;
+     if (arg.type == GRPC_ARG_STRING) {
+       if (std::string(arg.key) == GRPC_ARG_PRIMARY_USER_AGENT_STRING) {
+-        CHECK(arg.value.string == strings_it->c_str());
++        ABSL_CHECK(arg.value.string == strings_it->c_str());
+         *(strings_it) = user_agent_prefix + " " + arg.value.string;
+         arg.value.string = const_cast<char*>(strings_it->c_str());
+         replaced = true;
+diff --git a/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc b/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc
+index e82b6260358ab..22e204c4a3127 100644
+--- a/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc
++++ b/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc
+@@ -26,8 +26,8 @@
+ #include <vector>
+
+ #include "absl/base/thread_annotations.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/experiments/experiments.h"
+ #include "src/core/util/crash.h"
+ #include "src/core/util/sync.h"
+@@ -85,7 +85,7 @@ struct CallbackAlternativeCQ {
+                                    gpr_time_from_millis(100, GPR_TIMESPAN)));
+                   continue;
+                 }
+-                DCHECK(ev.type == GRPC_OP_COMPLETE);
++                ABSL_DCHECK(ev.type == GRPC_OP_COMPLETE);
+                 // We can always execute the callback inline rather than
+                 // pushing it to another Executor thread because this
+                 // thread is definitely running on a background thread, does not
+@@ -135,7 +135,7 @@ CompletionQueue::CompletionQueue(grpc_completion_queue* take)
+ void CompletionQueue::Shutdown() {
+ #ifndef NDEBUG
+   if (!ServerListEmpty()) {
+-    LOG(ERROR) << "CompletionQueue shutdown being shutdown before its server.";
++    ABSL_LOG(ERROR) << "CompletionQueue shutdown being shutdown before its server.";
+   }
+ #endif
+   CompleteAvalanching();
+@@ -170,7 +170,7 @@ CompletionQueue::CompletionQueueTLSCache::CompletionQueueTLSCache(
+ }
+
+ CompletionQueue::CompletionQueueTLSCache::~CompletionQueueTLSCache() {
+-  CHECK(flushed_);
++  ABSL_CHECK(flushed_);
+ }
+
+ bool CompletionQueue::CompletionQueueTLSCache::Flush(void** tag, bool* ok) {
+@@ -203,7 +203,7 @@ void CompletionQueue::ReleaseCallbackAlternativeCQ(CompletionQueue* cq)
+   (void)cq;
+   // This accesses g_callback_alternative_cq without acquiring the mutex
+   // but it's considered safe because it just reads the pointer address.
+-  DCHECK(cq == g_callback_alternative_cq.cq);
++  ABSL_DCHECK(cq == g_callback_alternative_cq.cq);
+   g_callback_alternative_cq.Unref();
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc b/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc
+index 091e478b9ba13..ff181a50fb6fd 100644
+--- a/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc
++++ b/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc
+@@ -21,7 +21,7 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h"
+
+ namespace grpc {
+@@ -30,7 +30,7 @@ namespace experimental {
+ StaticDataCertificateProvider::StaticDataCertificateProvider(
+     const std::string& root_certificate,
+     const std::vector<IdentityKeyCertPair>& identity_key_cert_pairs) {
+-  CHECK(!root_certificate.empty() || !identity_key_cert_pairs.empty());
++  ABSL_CHECK(!root_certificate.empty() || !identity_key_cert_pairs.empty());
+   grpc_tls_identity_pairs* pairs_core = grpc_tls_identity_pairs_create();
+   for (const IdentityKeyCertPair& pair : identity_key_cert_pairs) {
+     grpc_tls_identity_pairs_add_pair(pairs_core, pair.private_key.c_str(),
+@@ -38,7 +38,7 @@ StaticDataCertificateProvider::StaticDataCertificateProvider(
+   }
+   c_provider_ = grpc_tls_certificate_provider_static_data_create(
+       root_certificate.c_str(), pairs_core);
+-  CHECK_NE(c_provider_, nullptr);
++  ABSL_CHECK_NE(c_provider_, nullptr);
+ };
+
+ StaticDataCertificateProvider::~StaticDataCertificateProvider() {
+@@ -59,7 +59,7 @@ FileWatcherCertificateProvider::FileWatcherCertificateProvider(
+   c_provider_ = grpc_tls_certificate_provider_file_watcher_create(
+       private_key_path.c_str(), identity_certificate_path.c_str(),
+       root_cert_path.c_str(), refresh_interval_sec);
+-  CHECK_NE(c_provider_, nullptr);
++  ABSL_CHECK_NE(c_provider_, nullptr);
+ };
+
+ FileWatcherCertificateProvider::~FileWatcherCertificateProvider() {
+diff --git a/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc b/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc
+index dfbd2e1c3e123..02a4678e9e902 100644
+--- a/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc
++++ b/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc
+@@ -31,7 +31,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc {
+ namespace experimental {
+@@ -39,7 +39,7 @@ namespace experimental {
+ TlsCustomVerificationCheckRequest::TlsCustomVerificationCheckRequest(
+     grpc_tls_custom_verification_check_request* request)
+     : c_request_(request) {
+-  CHECK_NE(c_request_, nullptr);
++  ABSL_CHECK_NE(c_request_, nullptr);
+ }
+
+ grpc::string_ref TlsCustomVerificationCheckRequest::target_name() const {
+@@ -119,8 +119,8 @@ CertificateVerifier::~CertificateVerifier() {
+ bool CertificateVerifier::Verify(TlsCustomVerificationCheckRequest* request,
+                                  std::function<void(grpc::Status)> callback,
+                                  grpc::Status* sync_status) {
+-  CHECK_NE(request, nullptr);
+-  CHECK_NE(request->c_request(), nullptr);
++  ABSL_CHECK_NE(request, nullptr);
++  ABSL_CHECK_NE(request->c_request(), nullptr);
+   {
+     internal::MutexLock lock(&mu_);
+     request_map_.emplace(request->c_request(), std::move(callback));
+@@ -143,8 +143,8 @@ bool CertificateVerifier::Verify(TlsCustomVerificationCheckRequest* request,
+ }
+
+ void CertificateVerifier::Cancel(TlsCustomVerificationCheckRequest* request) {
+-  CHECK_NE(request, nullptr);
+-  CHECK_NE(request->c_request(), nullptr);
++  ABSL_CHECK_NE(request, nullptr);
++  ABSL_CHECK_NE(request->c_request(), nullptr);
+   grpc_tls_certificate_verifier_cancel(verifier_, request->c_request());
+ }
+
+@@ -191,7 +191,7 @@ int ExternalCertificateVerifier::VerifyInCoreExternalVerifier(
+     internal::MutexLock lock(&self->mu_);
+     auto pair = self->request_map_.emplace(
+         request, AsyncRequestState(callback, callback_arg, request));
+-    CHECK(pair.second);
++    ABSL_CHECK(pair.second);
+     cpp_request = &pair.first->second.cpp_request;
+   }
+   grpc::Status sync_current_verifier_status;
+diff --git a/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc b/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc
+index 339a714bd2d44..1d50171ae254a 100644
+--- a/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc
++++ b/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc
+@@ -28,7 +28,7 @@
+ #include <memory>
+ #include <string>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc {
+ namespace experimental {
+@@ -105,13 +105,13 @@ void TlsCredentialsOptions::set_certificate_verifier(
+
+ void TlsCredentialsOptions::set_min_tls_version(grpc_tls_version tls_version) {
+   grpc_tls_credentials_options* options = mutable_c_credentials_options();
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   grpc_tls_credentials_options_set_min_tls_version(options, tls_version);
+ }
+
+ void TlsCredentialsOptions::set_max_tls_version(grpc_tls_version tls_version) {
+   grpc_tls_credentials_options* options = mutable_c_credentials_options();
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   grpc_tls_credentials_options_set_max_tls_version(options, tls_version);
+ }
+
+@@ -122,14 +122,14 @@ grpc_tls_credentials_options* TlsCredentialsOptions::c_credentials_options()
+
+ void TlsCredentialsOptions::set_check_call_host(bool check_call_host) {
+   grpc_tls_credentials_options* options = mutable_c_credentials_options();
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   grpc_tls_credentials_options_set_check_call_host(options, check_call_host);
+ }
+
+ void TlsChannelCredentialsOptions::set_verify_server_certs(
+     bool verify_server_certs) {
+   grpc_tls_credentials_options* options = mutable_c_credentials_options();
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   grpc_tls_credentials_options_set_verify_server_cert(options,
+                                                       verify_server_certs);
+ }
+@@ -137,7 +137,7 @@ void TlsChannelCredentialsOptions::set_verify_server_certs(
+ void TlsServerCredentialsOptions::set_cert_request_type(
+     grpc_ssl_client_certificate_request_type cert_request_type) {
+   grpc_tls_credentials_options* options = mutable_c_credentials_options();
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   grpc_tls_credentials_options_set_cert_request_type(options,
+                                                      cert_request_type);
+ }
+@@ -145,7 +145,7 @@ void TlsServerCredentialsOptions::set_cert_request_type(
+ void TlsServerCredentialsOptions::set_send_client_ca_list(
+     bool send_client_ca_list) {
+   grpc_tls_credentials_options* options = mutable_c_credentials_options();
+-  CHECK_NE(options, nullptr);
++  ABSL_CHECK_NE(options, nullptr);
+   grpc_tls_credentials_options_set_send_client_ca_list(options,
+                                                        send_client_ca_list);
+ }
+diff --git a/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc b/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc
+index c2acd8f0ecec4..830e42cb93ef0 100644
+--- a/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc
++++ b/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc
+@@ -27,7 +27,7 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/statusor.h"
+ #include "google/cloud/opentelemetry/resource_detector.h"
+ #include "opentelemetry/sdk/metrics/meter_provider.h"
+@@ -55,7 +55,7 @@ bool CsmChannelTargetSelector(absl::string_view target) {
+   if (!g_csm_plugin_enabled) return false;
+   auto uri = grpc_core::URI::Parse(target);
+   if (!uri.ok()) {
+-    LOG(ERROR) << "Failed to parse URI: " << target;
++    ABSL_LOG(ERROR) << "Failed to parse URI: " << target;
+     return false;
+   }
+   // CSM channels should have an "xds" scheme
+diff --git a/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc b/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc
+index 66cbb28abc5ef..a40cedd30c4dc 100644
+--- a/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc
++++ b/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc
+@@ -29,7 +29,7 @@
+ #include <unordered_map>
+ #include <variant>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/escaping.h"
+ #include "absl/strings/str_split.h"
+@@ -206,7 +206,7 @@ NextFromAttributeList(absl::Span<const RemoteAttribute> attributes,
+                       size_t start_index, size_t curr,
+                       google_protobuf_Struct* decoded_metadata,
+                       upb_Arena* arena) {
+-  DCHECK_GE(curr, start_index);
++  ABSL_DCHECK_GE(curr, start_index);
+   const size_t index = curr - start_index;
+   if (index >= attributes.size()) return std::nullopt;
+   const auto& attribute = attributes[index];
+diff --git a/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc b/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc
+index f43efaac9f1d4..ec4104972a043 100644
+--- a/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc
++++ b/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc
+@@ -35,7 +35,7 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
+@@ -101,7 +101,7 @@ OpenCensusClientFilter::MakeCallPromise(
+       path != nullptr ? path->Ref() : grpc_core::Slice(),
+       grpc_core::GetContext<grpc_core::Arena>(),
+       OpenCensusTracingEnabled() && tracing_enabled_);
+-  DCHECK_EQ(arena->GetContext<grpc_core::CallTracerAnnotationInterface>(),
++  ABSL_DCHECK_EQ(arena->GetContext<grpc_core::CallTracerAnnotationInterface>(),
+             nullptr);
+   grpc_core::SetContext<grpc_core::CallTracerAnnotationInterface>(tracer);
+   return next_promise_factory(std::move(call_args));
+@@ -412,7 +412,7 @@ void OpenCensusCallTracer::RecordApiLatency(absl::Duration api_latency,
+
+ CensusContext OpenCensusCallTracer::CreateCensusContextForCallAttempt() {
+   if (!tracing_enabled_) return CensusContext(context_.tags());
+-  DCHECK(context_.Context().IsValid());
++  ABSL_DCHECK(context_.Context().IsValid());
+   auto context = CensusContext(absl::StrCat("Attempt.", method_),
+                                &(context_.Span()), context_.tags());
+   grpc::internal::OpenCensusRegistry::Get()
+diff --git a/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc b/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc
+index 98d9b89c4d187..60fc4e4160f6c 100644
+--- a/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc
++++ b/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc
+@@ -28,8 +28,8 @@
+ #include <utility>
+
+ #include "absl/container/flat_hash_map.h"
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "src/core/lib/debug/trace.h"
+@@ -241,7 +241,7 @@ class EnvironmentAutoDetectHelper
+
+   void FetchMetadataServerAttributesAsynchronouslyLocked()
+       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
+-    CHECK(!attributes_to_fetch_.empty());
++    ABSL_CHECK(!attributes_to_fetch_.empty());
+     for (auto& element : attributes_to_fetch_) {
+       queries_.push_back(grpc_core::MakeOrphanable<grpc_core::GcpMetadataQuery>(
+           element.first, &pollent_,
+@@ -273,7 +273,7 @@ class EnvironmentAutoDetectHelper
+                 attributes_to_fetch_.erase(it);
+               } else {
+                 // This should not happen
+-                LOG(ERROR) << "An unexpected attribute was seen from the "
++                ABSL_LOG(ERROR) << "An unexpected attribute was seen from the "
+                               "MetadataServer: "
+                            << attribute;
+               }
+@@ -319,8 +319,8 @@ EnvironmentAutoDetect* g_autodetect = nullptr;
+ }  // namespace
+
+ void EnvironmentAutoDetect::Create(std::string project_id) {
+-  CHECK_EQ(g_autodetect, nullptr);
+-  CHECK(!project_id.empty());
++  ABSL_CHECK_EQ(g_autodetect, nullptr);
++  ABSL_CHECK(!project_id.empty());
+
+   g_autodetect = new EnvironmentAutoDetect(project_id);
+ }
+@@ -329,7 +329,7 @@ EnvironmentAutoDetect& EnvironmentAutoDetect::Get() { return *g_autodetect; }
+
+ EnvironmentAutoDetect::EnvironmentAutoDetect(std::string project_id)
+     : project_id_(std::move(project_id)) {
+-  CHECK(!project_id_.empty());
++  ABSL_CHECK(!project_id_.empty());
+ }
+
+ void EnvironmentAutoDetect::NotifyOnDone(absl::AnyInvocable<void()> callback) {
+diff --git a/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc b/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc
+index 9b3488a649c8b..b8784b4fedbe7 100644
+--- a/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc
++++ b/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc
+@@ -31,7 +31,7 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "absl/numeric/int128.h"
+ #include "absl/strings/escaping.h"
+ #include "absl/strings/match.h"
+@@ -359,14 +359,14 @@ void ObservabilityLoggingSink::FlushEntriesHelper(
+       &(call->context), &(call->request), &(call->response),
+       [this, call](Status status) {
+         if (!status.ok()) {
+-          LOG(ERROR) << "GCP Observability Logging Error "
++          ABSL_LOG(ERROR) << "GCP Observability Logging Error "
+                      << status.error_code() << ": " << status.error_message()
+                      << ". Dumping log entries.";
+           for (auto& entry : call->request.entries()) {
+             std::string output;
+             ::google::protobuf::TextFormat::PrintToString(entry.json_payload(),
+                                                           &output);
+-            LOG(INFO) << "Log Entry recorded at time: "
++            ABSL_LOG(INFO) << "Log Entry recorded at time: "
+                       << grpc_core::Timestamp::FromTimespecRoundUp(
+                              gpr_timespec{entry.timestamp().seconds(),
+                                           entry.timestamp().nanos(),
+@@ -412,14 +412,14 @@ void ObservabilityLoggingSink::MaybeTriggerFlushLocked() {
+   if (entries_.size() > kMaxEntriesBeforeDump ||
+       entries_memory_footprint_ > kMaxMemoryFootprintBeforeDump) {
+     // Buffer limits have been reached. Dump entries with LOG
+-    LOG(INFO) << "Buffer limit reached. Dumping log entries.";
++    ABSL_LOG(INFO) << "Buffer limit reached. Dumping log entries.";
+     for (auto& entry : entries_) {
+       google::protobuf::Struct proto;
+       std::string timestamp = entry.timestamp.ToString();
+       EntryToJsonStructProto(std::move(entry), &proto);
+       std::string output;
+       ::google::protobuf::TextFormat::PrintToString(proto, &output);
+-      LOG(INFO) << "Log Entry recorded at time: " << timestamp << " : "
++      ABSL_LOG(INFO) << "Log Entry recorded at time: " << timestamp << " : "
+                 << output;
+     }
+     entries_.clear();
+diff --git a/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h b/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h
+index c6f7f154f3efc..0a517249d0a49 100644
+--- a/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h
++++ b/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h
+@@ -25,7 +25,7 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/strings/string_view.h"
+ #include "absl/types/span.h"
+ #include "opentelemetry/common/attribute_value.h"
+@@ -100,7 +100,7 @@ class OpenTelemetryPluginImpl::KeyValueIterable
+     }
+     // Add per-call optional labels
+     if (!optional_labels_.empty()) {
+-      CHECK(optional_labels_.size() ==
++      ABSL_CHECK(optional_labels_.size() ==
+             static_cast<size_t>(grpc_core::ClientCallTracer::CallAttemptTracer::
+                                     OptionalLabelKey::kSize));
+       for (size_t i = 0; i < optional_labels_.size(); ++i) {
+diff --git a/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc b/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc
+index facf1f4a8447f..f0542fc2ef401 100644
+--- a/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc
++++ b/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc
+@@ -31,7 +31,7 @@
+ #include <utility>
+
+ #include "absl/functional/any_invocable.h"
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+@@ -224,7 +224,7 @@ std::shared_ptr<grpc_core::TcpTracerInterface> OpenTelemetryPluginImpl::
+ void OpenTelemetryPluginImpl::ClientCallTracer::CallAttemptTracer::
+     SetOptionalLabel(OptionalLabelKey key,
+                      grpc_core::RefCountedStringValue value) {
+-  CHECK(key < OptionalLabelKey::kSize);
++  ABSL_CHECK(key < OptionalLabelKey::kSize);
+   optional_labels_[static_cast<size_t>(key)] = std::move(value);
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc b/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc
+index ae20b68c5678c..76ef4f8b301aa 100644
+--- a/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc
++++ b/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc
+@@ -26,7 +26,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "opentelemetry/metrics/meter.h"
+ #include "opentelemetry/metrics/meter_provider.h"
+ #include "opentelemetry/metrics/sync_instruments.h"
+@@ -204,7 +204,7 @@ OpenTelemetryPluginBuilderImpl::SetServerSelector(
+ OpenTelemetryPluginBuilderImpl& OpenTelemetryPluginBuilderImpl::AddPluginOption(
+     std::unique_ptr<InternalOpenTelemetryPluginOption> option) {
+   // We allow a limit of 64 plugin options to be registered at this time.
+-  CHECK_LT(plugin_options_.size(), 64u);
++  ABSL_CHECK_LT(plugin_options_.size(), 64u);
+   plugin_options_.push_back(std::move(option));
+   return *this;
+ }
+@@ -264,7 +264,7 @@ OpenTelemetryPluginImpl::CallbackMetricReporter::CallbackMetricReporter(
+   for (const auto& handle : key->metrics()) {
+     const auto& descriptor =
+         grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-    CHECK(descriptor.instrument_type ==
++    ABSL_CHECK(descriptor.instrument_type ==
+           grpc_core::GlobalInstrumentsRegistry::InstrumentType::kCallbackGauge);
+     switch (descriptor.value_type) {
+       case grpc_core::GlobalInstrumentsRegistry::ValueType::kInt64: {
+@@ -296,14 +296,14 @@ void OpenTelemetryPluginImpl::CallbackMetricReporter::ReportInt64(
+   auto* callback_gauge_state =
+       std::get_if<std::unique_ptr<CallbackGaugeState<int64_t>>>(
+           &instrument_data.instrument);
+-  CHECK_NE(callback_gauge_state, nullptr);
++  ABSL_CHECK_NE(callback_gauge_state, nullptr);
+   const auto& descriptor =
+       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-  CHECK(descriptor.label_keys.size() == label_values.size());
+-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
++  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
++  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+   if ((*callback_gauge_state)->caches.find(key_) ==
+       (*callback_gauge_state)->caches.end()) {
+-    LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
++    ABSL_LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
+                   "different from the gauge used in Report. This indicates a "
+                   "misuse of the API. The value "
+                << value << " will not be recorded for instrument "
+@@ -333,14 +333,14 @@ void OpenTelemetryPluginImpl::CallbackMetricReporter::ReportDouble(
+   auto* callback_gauge_state =
+       std::get_if<std::unique_ptr<CallbackGaugeState<double>>>(
+           &instrument_data.instrument);
+-  CHECK_NE(callback_gauge_state, nullptr);
++  ABSL_CHECK_NE(callback_gauge_state, nullptr);
+   const auto& descriptor =
+       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-  CHECK(descriptor.label_keys.size() == label_values.size());
+-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
++  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
++  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+   if ((*callback_gauge_state)->caches.find(key_) ==
+       (*callback_gauge_state)->caches.end()) {
+-    LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
++    ABSL_LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
+                   "different from the gauge used in Report. This indicates a "
+                   "misuse of the API. The value "
+                << value << " will not be recorded for instrument "
+@@ -463,7 +463,7 @@ OpenTelemetryPluginImpl::OpenTelemetryPluginImpl(
+             "Compressed message bytes received per server call", "By");
+   }
+   // Store optional label keys for per call metrics
+-  CHECK(static_cast<size_t>(grpc_core::ClientCallTracer::CallAttemptTracer::
++  ABSL_CHECK(static_cast<size_t>(grpc_core::ClientCallTracer::CallAttemptTracer::
+                                 OptionalLabelKey::kSize) <=
+         kOptionalLabelsSizeLimit);
+   for (const auto& key : optional_label_keys) {
+@@ -477,7 +477,7 @@ OpenTelemetryPluginImpl::OpenTelemetryPluginImpl(
+   grpc_core::GlobalInstrumentsRegistry::ForEach(
+       [&, this](const grpc_core::GlobalInstrumentsRegistry::
+                     GlobalInstrumentDescriptor& descriptor) {
+-        CHECK(descriptor.optional_label_keys.size() <=
++        ABSL_CHECK(descriptor.optional_label_keys.size() <=
+               kOptionalLabelsSizeLimit);
+         if (instruments_data_.size() < descriptor.index + 1) {
+           instruments_data_.resize(descriptor.index + 1);
+@@ -592,7 +592,7 @@ OpenTelemetryPluginImpl::~OpenTelemetryPluginImpl() {
+         [](const std::unique_ptr<opentelemetry::metrics::Histogram<double>>&) {
+         },
+         [](const std::unique_ptr<CallbackGaugeState<int64_t>>& state) {
+-          CHECK(state->caches.empty());
++          ABSL_CHECK(state->caches.empty());
+           if (state->ot_callback_registered) {
+             state->instrument->RemoveCallback(
+                 &CallbackGaugeState<int64_t>::CallbackGaugeCallback,
+@@ -601,7 +601,7 @@ OpenTelemetryPluginImpl::~OpenTelemetryPluginImpl() {
+           }
+         },
+         [](const std::unique_ptr<CallbackGaugeState<double>>& state) {
+-          CHECK(state->caches.empty());
++          ABSL_CHECK(state->caches.empty());
+           if (state->ot_callback_registered) {
+             state->instrument->RemoveCallback(
+                 &CallbackGaugeState<double>::CallbackGaugeCallback,
+@@ -659,14 +659,14 @@ OpenTelemetryPluginImpl::IsEnabledForServer(
+ std::shared_ptr<grpc_core::StatsPlugin::ScopeConfig>
+ OpenTelemetryPluginImpl::GetChannelScopeConfig(
+     const OpenTelemetryPluginBuilder::ChannelScope& scope) const {
+-  CHECK(channel_scope_filter_ == nullptr || channel_scope_filter_(scope));
++  ABSL_CHECK(channel_scope_filter_ == nullptr || channel_scope_filter_(scope));
+   return std::make_shared<ClientScopeConfig>(this, scope);
+ }
+
+ std::shared_ptr<grpc_core::StatsPlugin::ScopeConfig>
+ OpenTelemetryPluginImpl::GetServerScopeConfig(
+     const grpc_core::ChannelArgs& args) const {
+-  CHECK(server_selector_ == nullptr || server_selector_(args));
++  ABSL_CHECK(server_selector_ == nullptr || server_selector_(args));
+   return std::make_shared<ServerScopeConfig>(this, args);
+ }
+
+@@ -679,13 +679,13 @@ void OpenTelemetryPluginImpl::AddCounter(
+     // This instrument is disabled.
+     return;
+   }
+-  CHECK(std::holds_alternative<
++  ABSL_CHECK(std::holds_alternative<
+         std::unique_ptr<opentelemetry::metrics::Counter<uint64_t>>>(
+       instrument_data.instrument));
+   const auto& descriptor =
+       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-  CHECK(descriptor.label_keys.size() == label_values.size());
+-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
++  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
++  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+   if (label_values.empty() && optional_values.empty()) {
+     std::get<std::unique_ptr<opentelemetry::metrics::Counter<uint64_t>>>(
+         instrument_data.instrument)
+@@ -709,13 +709,13 @@ void OpenTelemetryPluginImpl::AddCounter(
+     // This instrument is disabled.
+     return;
+   }
+-  CHECK(std::holds_alternative<
++  ABSL_CHECK(std::holds_alternative<
+         std::unique_ptr<opentelemetry::metrics::Counter<double>>>(
+       instrument_data.instrument));
+   const auto& descriptor =
+       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-  CHECK(descriptor.label_keys.size() == label_values.size());
+-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
++  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
++  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+   if (label_values.empty() && optional_values.empty()) {
+     std::get<std::unique_ptr<opentelemetry::metrics::Counter<double>>>(
+         instrument_data.instrument)
+@@ -739,13 +739,13 @@ void OpenTelemetryPluginImpl::RecordHistogram(
+     // This instrument is disabled.
+     return;
+   }
+-  CHECK(std::holds_alternative<
++  ABSL_CHECK(std::holds_alternative<
+         std::unique_ptr<opentelemetry::metrics::Histogram<uint64_t>>>(
+       instrument_data.instrument));
+   const auto& descriptor =
+       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-  CHECK(descriptor.label_keys.size() == label_values.size());
+-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
++  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
++  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+   if (label_values.empty() && optional_values.empty()) {
+     std::get<std::unique_ptr<opentelemetry::metrics::Histogram<uint64_t>>>(
+         instrument_data.instrument)
+@@ -771,13 +771,13 @@ void OpenTelemetryPluginImpl::RecordHistogram(
+     // This instrument is disabled.
+     return;
+   }
+-  CHECK(std::holds_alternative<
++  ABSL_CHECK(std::holds_alternative<
+         std::unique_ptr<opentelemetry::metrics::Histogram<double>>>(
+       instrument_data.instrument));
+   const auto& descriptor =
+       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-  CHECK(descriptor.label_keys.size() == label_values.size());
+-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
++  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
++  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+   if (label_values.empty() && optional_values.empty()) {
+     std::get<std::unique_ptr<opentelemetry::metrics::Histogram<double>>>(
+         instrument_data.instrument)
+@@ -805,7 +805,7 @@ void OpenTelemetryPluginImpl::AddCallback(
+     for (const auto& handle : callback->metrics()) {
+       const auto& descriptor =
+           grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-      CHECK(
++      ABSL_CHECK(
+           descriptor.instrument_type ==
+           grpc_core::GlobalInstrumentsRegistry::InstrumentType::kCallbackGauge);
+       switch (descriptor.value_type) {
+@@ -818,7 +818,7 @@ void OpenTelemetryPluginImpl::AddCallback(
+           auto* callback_gauge_state =
+               std::get_if<std::unique_ptr<CallbackGaugeState<int64_t>>>(
+                   &instrument_data.instrument);
+-          CHECK_NE(callback_gauge_state, nullptr);
++          ABSL_CHECK_NE(callback_gauge_state, nullptr);
+           (*callback_gauge_state)
+               ->caches.emplace(callback, CallbackGaugeState<int64_t>::Cache{});
+           if (!std::exchange((*callback_gauge_state)->ot_callback_registered,
+@@ -837,7 +837,7 @@ void OpenTelemetryPluginImpl::AddCallback(
+           auto* callback_gauge_state =
+               std::get_if<std::unique_ptr<CallbackGaugeState<double>>>(
+                   &instrument_data.instrument);
+-          CHECK_NE(callback_gauge_state, nullptr);
++          ABSL_CHECK_NE(callback_gauge_state, nullptr);
+           (*callback_gauge_state)
+               ->caches.emplace(callback, CallbackGaugeState<double>::Cache{});
+           if (!std::exchange((*callback_gauge_state)->ot_callback_registered,
+@@ -878,7 +878,7 @@ void OpenTelemetryPluginImpl::RemoveCallback(
+     for (const auto& handle : callback->metrics()) {
+       const auto& descriptor =
+           grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
+-      CHECK(
++      ABSL_CHECK(
+           descriptor.instrument_type ==
+           grpc_core::GlobalInstrumentsRegistry::InstrumentType::kCallbackGauge);
+       switch (descriptor.value_type) {
+@@ -891,9 +891,9 @@ void OpenTelemetryPluginImpl::RemoveCallback(
+           auto* callback_gauge_state =
+               std::get_if<std::unique_ptr<CallbackGaugeState<int64_t>>>(
+                   &instrument_data.instrument);
+-          CHECK_NE(callback_gauge_state, nullptr);
+-          CHECK((*callback_gauge_state)->ot_callback_registered);
+-          CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
++          ABSL_CHECK_NE(callback_gauge_state, nullptr);
++          ABSL_CHECK((*callback_gauge_state)->ot_callback_registered);
++          ABSL_CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
+           break;
+         }
+         case grpc_core::GlobalInstrumentsRegistry::ValueType::kDouble: {
+@@ -905,9 +905,9 @@ void OpenTelemetryPluginImpl::RemoveCallback(
+           auto* callback_gauge_state =
+               std::get_if<std::unique_ptr<CallbackGaugeState<double>>>(
+                   &instrument_data.instrument);
+-          CHECK_NE(callback_gauge_state, nullptr);
+-          CHECK((*callback_gauge_state)->ot_callback_registered);
+-          CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
++          ABSL_CHECK_NE(callback_gauge_state, nullptr);
++          ABSL_CHECK((*callback_gauge_state)->ot_callback_registered);
++          ABSL_CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
+           break;
+         }
+         default:
+@@ -931,7 +931,7 @@ void OpenTelemetryPluginImpl::CallbackGaugeState<ValueType>::Observe(
+   const auto& descriptor =
+       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor({id});
+   for (const auto& pair : cache) {
+-    CHECK(pair.first.size() <= (descriptor.label_keys.size() +
++    ABSL_CHECK(pair.first.size() <= (descriptor.label_keys.size() +
+                                 descriptor.optional_label_keys.size()));
+     if (descriptor.label_keys.empty() &&
+         descriptor.optional_label_keys.empty()) {
+@@ -970,7 +970,7 @@ void OpenTelemetryPluginImpl::CallbackGaugeState<ValueType>::
+     auto* registered_metric_callback = elem.first;
+     auto iter = callback_gauge_state->ot_plugin->callback_timestamps_.find(
+         registered_metric_callback);
+-    CHECK(iter != callback_gauge_state->ot_plugin->callback_timestamps_.end());
++    ABSL_CHECK(iter != callback_gauge_state->ot_plugin->callback_timestamps_.end());
+     if (now - iter->second < registered_metric_callback->min_interval()) {
+       // Use cached value.
+       callback_gauge_state->Observe(result, elem.second);
+diff --git a/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc b/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc
+index 6670878c7c247..0d188bd6ed7dd 100644
+--- a/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc
++++ b/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc
+@@ -26,7 +26,7 @@
+ #include <type_traits>
+ #include <utility>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/debug/trace.h"
+ #include "src/core/load_balancing/backend_metric_data.h"
+
+@@ -210,7 +210,7 @@ ServerMetricRecorder::GetMetricsIfChanged() const {
+   }
+   if (GRPC_TRACE_FLAG_ENABLED(backend_metric)) {
+     const auto& data = result->data;
+-    LOG(INFO) << "[" << this
++    ABSL_LOG(INFO) << "[" << this
+               << "] GetMetrics() returned: seq:" << result->sequence_number
+               << " cpu:" << data.cpu_utilization
+               << " mem:" << data.mem_utilization
+diff --git a/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc b/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc
+index 5623dbfa36c68..a0c65087e268f 100644
+--- a/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc
++++ b/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc
+@@ -25,8 +25,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+
+ namespace grpc {
+ namespace internal {
+@@ -51,14 +51,14 @@ ExternalConnectionAcceptorImpl::ExternalConnectionAcceptorImpl(
+     ServerBuilder::experimental_type::ExternalConnectionType type,
+     std::shared_ptr<ServerCredentials> creds)
+     : name_(name), creds_(std::move(creds)) {
+-  CHECK(type ==
++  ABSL_CHECK(type ==
+         ServerBuilder::experimental_type::ExternalConnectionType::FROM_FD);
+ }
+
+ std::unique_ptr<experimental::ExternalConnectionAcceptor>
+ ExternalConnectionAcceptorImpl::GetAcceptor() {
+   grpc_core::MutexLock lock(&mu_);
+-  CHECK(!has_acceptor_);
++  ABSL_CHECK(!has_acceptor_);
+   has_acceptor_ = true;
+   return std::unique_ptr<experimental::ExternalConnectionAcceptor>(
+       new AcceptorWrapper(shared_from_this()));
+@@ -69,7 +69,7 @@ void ExternalConnectionAcceptorImpl::HandleNewConnection(
+   grpc_core::MutexLock lock(&mu_);
+   if (shutdown_ || !started_) {
+     // TODO(yangg) clean up.
+-    LOG(ERROR) << "NOT handling external connection with fd " << p->fd
++    ABSL_LOG(ERROR) << "NOT handling external connection with fd " << p->fd
+                << ", started " << started_ << ", shutdown " << shutdown_;
+     return;
+   }
+@@ -85,9 +85,9 @@ void ExternalConnectionAcceptorImpl::Shutdown() {
+
+ void ExternalConnectionAcceptorImpl::Start() {
+   grpc_core::MutexLock lock(&mu_);
+-  CHECK(!started_);
+-  CHECK(has_acceptor_);
+-  CHECK(!shutdown_);
++  ABSL_CHECK(!started_);
++  ABSL_CHECK(has_acceptor_);
++  ABSL_CHECK(!shutdown_);
+   started_ = true;
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc b/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc
+index bb86083bb54b1..5c45a6f5cc256 100644
+--- a/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc
++++ b/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc
+@@ -28,8 +28,8 @@
+ #include <memory>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/proto/grpc/health/v1/health.upb.h"
+ #include "upb/base/string_view.h"
+ #include "upb/mem/arena.hpp"
+@@ -108,7 +108,7 @@ void DefaultHealthCheckService::UnregisterWatch(
+
+ DefaultHealthCheckService::HealthCheckServiceImpl*
+ DefaultHealthCheckService::GetHealthCheckService() {
+-  CHECK(impl_ == nullptr);
++  ABSL_CHECK(impl_ == nullptr);
+   impl_ = std::make_unique<HealthCheckServiceImpl>(this);
+   return impl_.get();
+ }
+@@ -257,7 +257,7 @@ DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::WatchReactor(
+     ++service_->num_watches_;
+   }
+   bool success = DecodeRequest(*request, &service_name_);
+-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+           << service_name_ << "\": watch call started";
+   if (!success) {
+     MaybeFinishLocked(Status(StatusCode::INTERNAL, "could not parse request"));
+@@ -269,13 +269,13 @@ DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::WatchReactor(
+
+ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
+     SendHealth(ServingStatus status) {
+-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+           << service_name_ << "\": SendHealth() for ServingStatus " << status;
+   grpc::internal::MutexLock lock(&mu_);
+   // If there's already a send in flight, cache the new status, and
+   // we'll start a new send for it when the one in flight completes.
+   if (write_pending_) {
+-    VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++    ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+             << service_name_ << "\": queuing write";
+     pending_status_ = status;
+     return;
+@@ -304,7 +304,7 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
+         Status(StatusCode::INTERNAL, "could not encode response"));
+     return;
+   }
+-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+           << service_name_ << "\": starting write for ServingStatus " << status;
+   write_pending_ = true;
+   StartWrite(&response_);
+@@ -312,7 +312,7 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
+
+ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
+     OnWriteDone(bool ok) {
+-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+           << service_name_ << "\": OnWriteDone(): ok=" << ok;
+   response_.Clear();
+   grpc::internal::MutexLock lock(&mu_);
+@@ -337,7 +337,7 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
+ }
+
+ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::OnDone() {
+-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+           << service_name_ << "\": OnDone()";
+   service_->database_->UnregisterWatch(service_name_, this);
+   {
+@@ -352,12 +352,12 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::OnDone() {
+
+ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
+     MaybeFinishLocked(Status status) {
+-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+           << service_name_
+           << "\": MaybeFinishLocked() with code=" << status.error_code()
+           << " msg=" << status.error_message();
+   if (!finish_called_) {
+-    VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
++    ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+             << service_name_ << "\": actually calling Finish()";
+     finish_called_ = true;
+     Finish(status);
+diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc b/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc
+index 70b8c0851e39b..59d43faf795f9 100644
+--- a/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc
++++ b/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc
+@@ -20,7 +20,7 @@
+
+ #if !defined(GPR_LINUX) && !defined(GPR_WINDOWS) && !defined(GPR_APPLE)
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/util/crash.h"
+ #include "src/cpp/server/load_reporter/get_cpu_stats.h"
+
+@@ -29,7 +29,7 @@ namespace load_reporter {
+
+ std::pair<uint64_t, uint64_t> GetCpuStatsImpl() {
+   uint64_t busy = 0, total = 0;
+-  LOG(ERROR)
++  ABSL_LOG(ERROR)
+       << "Platforms other than Linux, Windows, and MacOS are not supported.";
+   return std::make_pair(busy, total);
+ }
+diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc b/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc
+index 5faa03a4fadcb..ebec64b2e04d7 100644
+--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc
++++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc
+@@ -27,8 +27,8 @@
+ #include <set>
+ #include <unordered_map>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/lib/iomgr/socket_utils.h"
+ #include "src/cpp/server/load_reporter/constants.h"
+
+@@ -74,7 +74,7 @@ std::set<V> UnorderedMapOfSetExtract(std::unordered_map<K, std::set<V>>& map,
+ // From a non-empty container, returns a pointer to a random element.
+ template <typename C>
+ const typename C::value_type* RandomElement(const C& container) {
+-  CHECK(!container.empty());
++  ABSL_CHECK(!container.empty());
+   auto it = container.begin();
+   std::advance(it, std::rand() % container.size());
+   return &(*it);
+@@ -85,11 +85,11 @@ const typename C::value_type* RandomElement(const C& container) {
+ LoadRecordKey::LoadRecordKey(const std::string& client_ip_and_token,
+                              std::string user_id)
+     : user_id_(std::move(user_id)) {
+-  CHECK_GE(client_ip_and_token.size(), 2u);
++  ABSL_CHECK_GE(client_ip_and_token.size(), 2u);
+   int ip_hex_size;
+-  CHECK(sscanf(client_ip_and_token.substr(0, 2).c_str(), "%d", &ip_hex_size) ==
++  ABSL_CHECK(sscanf(client_ip_and_token.substr(0, 2).c_str(), "%d", &ip_hex_size) ==
+         1);
+-  CHECK(ip_hex_size == 0 || ip_hex_size == kIpv4AddressLength ||
++  ABSL_CHECK(ip_hex_size == 0 || ip_hex_size == kIpv4AddressLength ||
+         ip_hex_size == kIpv6AddressLength);
+   size_t cur_pos = 2;
+   client_ip_hex_ = client_ip_and_token.substr(cur_pos, ip_hex_size);
+@@ -109,7 +109,7 @@ std::string LoadRecordKey::GetClientIpBytes() const {
+   } else if (client_ip_hex_.size() == kIpv4AddressLength) {
+     uint32_t ip_bytes;
+     if (sscanf(client_ip_hex_.c_str(), "%x", &ip_bytes) != 1) {
+-      LOG(ERROR) << "Can't parse client IP (" << client_ip_hex_
++      ABSL_LOG(ERROR) << "Can't parse client IP (" << client_ip_hex_
+                  << ") from a hex string to an integer.";
+       return "";
+     }
+@@ -121,7 +121,7 @@ std::string LoadRecordKey::GetClientIpBytes() const {
+     for (size_t i = 0; i < 4; ++i) {
+       if (sscanf(client_ip_hex_.substr(i * 8, (i + 1) * 8).c_str(), "%x",
+                  ip_bytes + i) != 1) {
+-        LOG(ERROR) << "Can't parse client IP part ("
++        ABSL_LOG(ERROR) << "Can't parse client IP part ("
+                    << client_ip_hex_.substr(i * 8, (i + 1) * 8)
+                    << ") from a hex string to an integer.";
+         return "";
+@@ -146,18 +146,18 @@ void PerBalancerStore::MergeRow(const LoadRecordKey& key,
+   // During suspension, the load data received will be dropped.
+   if (!suspended_) {
+     load_record_map_[key].MergeFrom(value);
+-    VLOG(2) << "[PerBalancerStore " << this
++    ABSL_VLOG(2) << "[PerBalancerStore " << this
+             << "] Load data merged (Key: " << key.ToString()
+             << ", Value: " << value.ToString() << ").";
+   } else {
+-    VLOG(2) << "[PerBalancerStore " << this
++    ABSL_VLOG(2) << "[PerBalancerStore " << this
+             << "] Load data dropped (Key: " << key.ToString()
+             << ", Value: " << value.ToString() << ").";
+   }
+   // We always keep track of num_calls_in_progress_, so that when this
+   // store is resumed, we still have a correct value of
+   // num_calls_in_progress_.
+-  CHECK(static_cast<int64_t>(num_calls_in_progress_) +
++  ABSL_CHECK(static_cast<int64_t>(num_calls_in_progress_) +
+             value.GetNumCallsInProgressDelta() >=
+         0);
+   num_calls_in_progress_ += value.GetNumCallsInProgressDelta();
+@@ -166,23 +166,23 @@ void PerBalancerStore::MergeRow(const LoadRecordKey& key,
+ void PerBalancerStore::Suspend() {
+   suspended_ = true;
+   load_record_map_.clear();
+-  VLOG(2) << "[PerBalancerStore " << this << "] Suspended.";
++  ABSL_VLOG(2) << "[PerBalancerStore " << this << "] Suspended.";
+ }
+
+ void PerBalancerStore::Resume() {
+   suspended_ = false;
+-  VLOG(2) << "[PerBalancerStore " << this << "] Resumed.";
++  ABSL_VLOG(2) << "[PerBalancerStore " << this << "] Resumed.";
+ }
+
+ uint64_t PerBalancerStore::GetNumCallsInProgressForReport() {
+-  CHECK(!suspended_);
++  ABSL_CHECK(!suspended_);
+   last_reported_num_calls_in_progress_ = num_calls_in_progress_;
+   return num_calls_in_progress_;
+ }
+
+ void PerHostStore::ReportStreamCreated(const std::string& lb_id,
+                                        const std::string& load_key) {
+-  CHECK(lb_id != kInvalidLbId);
++  ABSL_CHECK(lb_id != kInvalidLbId);
+   SetUpForNewLbId(lb_id, load_key);
+   // Prior to this one, there was no load balancer receiving report, so we may
+   // have unassigned orphaned stores to assign to this new balancer.
+@@ -208,9 +208,9 @@ void PerHostStore::ReportStreamCreated(const std::string& lb_id,
+
+ void PerHostStore::ReportStreamClosed(const std::string& lb_id) {
+   auto it_store_for_gone_lb = per_balancer_stores_.find(lb_id);
+-  CHECK(it_store_for_gone_lb != per_balancer_stores_.end());
++  ABSL_CHECK(it_store_for_gone_lb != per_balancer_stores_.end());
+   // Remove this closed stream from our records.
+-  CHECK(UnorderedMapOfSetEraseKeyValue(load_key_to_receiving_lb_ids_,
++  ABSL_CHECK(UnorderedMapOfSetEraseKeyValue(load_key_to_receiving_lb_ids_,
+                                        it_store_for_gone_lb->second->load_key(),
+                                        lb_id));
+   std::set<PerBalancerStore*> orphaned_stores =
+@@ -254,9 +254,9 @@ const std::set<PerBalancerStore*>* PerHostStore::GetAssignedStores(
+ void PerHostStore::AssignOrphanedStore(PerBalancerStore* orphaned_store,
+                                        const std::string& new_receiver) {
+   auto it = assigned_stores_.find(new_receiver);
+-  CHECK(it != assigned_stores_.end());
++  ABSL_CHECK(it != assigned_stores_.end());
+   it->second.insert(orphaned_store);
+-  LOG(INFO) << "[PerHostStore " << this << "] Re-assigned orphaned store ("
++  ABSL_LOG(INFO) << "[PerHostStore " << this << "] Re-assigned orphaned store ("
+             << orphaned_store << ") with original LB ID of "
+             << orphaned_store->lb_id() << " to new receiver " << new_receiver;
+ }
+@@ -265,8 +265,8 @@ void PerHostStore::SetUpForNewLbId(const std::string& lb_id,
+                                    const std::string& load_key) {
+   // The top-level caller (i.e., LoadReportService) should guarantee the
+   // lb_id is unique for each reporting stream.
+-  CHECK(per_balancer_stores_.find(lb_id) == per_balancer_stores_.end());
+-  CHECK(assigned_stores_.find(lb_id) == assigned_stores_.end());
++  ABSL_CHECK(per_balancer_stores_.find(lb_id) == per_balancer_stores_.end());
++  ABSL_CHECK(assigned_stores_.find(lb_id) == assigned_stores_.end());
+   load_key_to_receiving_lb_ids_[load_key].insert(lb_id);
+   std::unique_ptr<PerBalancerStore> per_balancer_store(
+       new PerBalancerStore(lb_id, load_key));
+@@ -300,14 +300,14 @@ void LoadDataStore::MergeRow(const std::string& hostname,
+   if (in_progress_delta != 0) {
+     auto it_tracker = unknown_balancer_id_trackers_.find(key.lb_id());
+     if (it_tracker == unknown_balancer_id_trackers_.end()) {
+-      VLOG(2) << "[LoadDataStore " << this
++      ABSL_VLOG(2) << "[LoadDataStore " << this
+               << "] Start tracking unknown balancer (lb_id_: " << key.lb_id()
+               << ").";
+       unknown_balancer_id_trackers_.insert(
+           {key.lb_id(), static_cast<uint64_t>(in_progress_delta)});
+     } else if ((it_tracker->second += in_progress_delta) == 0) {
+       unknown_balancer_id_trackers_.erase(it_tracker);
+-      VLOG(2) << "[LoadDataStore " << this
++      ABSL_VLOG(2) << "[LoadDataStore " << this
+               << "] Stop tracking unknown balancer (lb_id_: " << key.lb_id()
+               << ").";
+     }
+@@ -330,7 +330,7 @@ void LoadDataStore::ReportStreamCreated(const std::string& hostname,
+ void LoadDataStore::ReportStreamClosed(const std::string& hostname,
+                                        const std::string& lb_id) {
+   auto it_per_host_store = per_host_stores_.find(hostname);
+-  CHECK(it_per_host_store != per_host_stores_.end());
++  ABSL_CHECK(it_per_host_store != per_host_stores_.end());
+   it_per_host_store->second.ReportStreamClosed(lb_id);
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc
+index c2aae6635fc9d..f29bb08aecebd 100644
+--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc
++++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc
+@@ -28,8 +28,8 @@
+ #include <set>
+ #include <tuple>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "opencensus/tags/tag_key.h"
+ #include "src/cpp/server/load_reporter/constants.h"
+ #include "src/cpp/server/load_reporter/get_cpu_stats.h"
+@@ -167,10 +167,10 @@ double CensusViewProvider::GetRelatedViewDataRowDouble(
+     const ViewDataMap& view_data_map, const char* view_name,
+     size_t view_name_len, const std::vector<std::string>& tag_values) {
+   auto it_vd = view_data_map.find(std::string(view_name, view_name_len));
+-  CHECK(it_vd != view_data_map.end());
+-  CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kDouble);
++  ABSL_CHECK(it_vd != view_data_map.end());
++  ABSL_CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kDouble);
+   auto it_row = it_vd->second.double_data().find(tag_values);
+-  CHECK(it_row != it_vd->second.double_data().end());
++  ABSL_CHECK(it_row != it_vd->second.double_data().end());
+   return it_row->second;
+ }
+
+@@ -178,11 +178,11 @@ uint64_t CensusViewProvider::GetRelatedViewDataRowInt(
+     const ViewDataMap& view_data_map, const char* view_name,
+     size_t view_name_len, const std::vector<std::string>& tag_values) {
+   auto it_vd = view_data_map.find(std::string(view_name, view_name_len));
+-  CHECK(it_vd != view_data_map.end());
+-  CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kInt64);
++  ABSL_CHECK(it_vd != view_data_map.end());
++  ABSL_CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kInt64);
+   auto it_row = it_vd->second.int_data().find(tag_values);
+-  CHECK(it_row != it_vd->second.int_data().end());
+-  CHECK_GE(it_row->second, 0);
++  ABSL_CHECK(it_row != it_vd->second.int_data().end());
++  ABSL_CHECK_GE(it_row->second, 0);
+   return it_row->second;
+ }
+
+@@ -199,17 +199,17 @@ CensusViewProviderDefaultImpl::CensusViewProviderDefaultImpl() {
+ }
+
+ CensusViewProvider::ViewDataMap CensusViewProviderDefaultImpl::FetchViewData() {
+-  VLOG(2) << "[CVP " << this << "] Starts fetching Census view data.";
++  ABSL_VLOG(2) << "[CVP " << this << "] Starts fetching Census view data.";
+   ViewDataMap view_data_map;
+   for (auto& p : view_map_) {
+     const std::string& view_name = p.first;
+     ::opencensus::stats::View& view = p.second;
+     if (view.IsValid()) {
+       view_data_map.emplace(view_name, view.GetData());
+-      VLOG(2) << "[CVP " << this << "] Fetched view data (view: " << view_name
++      ABSL_VLOG(2) << "[CVP " << this << "] Fetched view data (view: " << view_name
+               << ").";
+     } else {
+-      VLOG(2) << "[CVP " << this
++      ABSL_VLOG(2) << "[CVP " << this
+               << "] Can't fetch view data because view is invalid (view: "
+               << view_name << ").";
+     }
+@@ -220,13 +220,13 @@ CensusViewProvider::ViewDataMap CensusViewProviderDefaultImpl::FetchViewData() {
+ std::string LoadReporter::GenerateLbId() {
+   while (true) {
+     if (next_lb_id_ > UINT32_MAX) {
+-      LOG(ERROR) << "[LR " << this
++      ABSL_LOG(ERROR) << "[LR " << this
+                  << "] The LB ID exceeds the max valid value!";
+       return "";
+     }
+     int64_t lb_id = next_lb_id_++;
+     // Overflow should never happen.
+-    CHECK_GE(lb_id, 0);
++    ABSL_CHECK_GE(lb_id, 0);
+     // Convert to padded hex string for a 32-bit LB ID. E.g, "0000ca5b".
+     char buf[kLbIdLength + 1];
+     snprintf(buf, sizeof(buf), "%08" PRIx64, lb_id);
+@@ -295,11 +295,11 @@ LoadReporter::GenerateLoads(const std::string& hostname,
+                             const std::string& lb_id) {
+   grpc_core::MutexLock lock(&store_mu_);
+   auto assigned_stores = load_data_store_.GetAssignedStores(hostname, lb_id);
+-  CHECK_NE(assigned_stores, nullptr);
+-  CHECK(!assigned_stores->empty());
++  ABSL_CHECK_NE(assigned_stores, nullptr);
++  ABSL_CHECK(!assigned_stores->empty());
+   ::google::protobuf::RepeatedPtrField<grpc::lb::v1::Load> loads;
+   for (PerBalancerStore* per_balancer_store : *assigned_stores) {
+-    CHECK(!per_balancer_store->IsSuspended());
++    ABSL_CHECK(!per_balancer_store->IsSuspended());
+     if (!per_balancer_store->load_record_map().empty()) {
+       for (const auto& p : per_balancer_store->load_record_map()) {
+         const auto& key = p.first;
+@@ -384,7 +384,7 @@ void LoadReporter::ReportStreamCreated(const std::string& hostname,
+                                        const std::string& load_key) {
+   grpc_core::MutexLock lock(&store_mu_);
+   load_data_store_.ReportStreamCreated(hostname, lb_id, load_key);
+-  LOG(INFO) << "[LR " << this << "] Report stream created (host: " << hostname
++  ABSL_LOG(INFO) << "[LR " << this << "] Report stream created (host: " << hostname
+             << ", LB ID: " << lb_id << ", load key: " << load_key << ").";
+ }
+
+@@ -392,7 +392,7 @@ void LoadReporter::ReportStreamClosed(const std::string& hostname,
+                                       const std::string& lb_id) {
+   grpc_core::MutexLock lock(&store_mu_);
+   load_data_store_.ReportStreamClosed(hostname, lb_id);
+-  LOG(INFO) << "[LR " << this << "] Report stream closed (host: " << hostname
++  ABSL_LOG(INFO) << "[LR " << this << "] Report stream closed (host: " << hostname
+             << ", LB ID: " << lb_id << ").";
+ }
+
+@@ -433,7 +433,7 @@ void LoadReporter::ProcessViewDataCallEnd(
+       // implementation.
+       // TODO(juanlishen): Check whether this situation happens in OSS C++.
+       if (client_ip_and_token.empty()) {
+-        VLOG(2) << "Skipping processing Opencensus record with empty "
++        ABSL_VLOG(2) << "Skipping processing Opencensus record with empty "
+                    "client_ip_and_token tag.";
+         continue;
+       }
+@@ -495,7 +495,7 @@ void LoadReporter::ProcessViewDataOtherCallMetrics(
+ }
+
+ void LoadReporter::FetchAndSample() {
+-  VLOG(2) << "[LR " << this
++  ABSL_VLOG(2) << "[LR " << this
+           << "] Starts fetching Census view data and sampling LB feedback "
+              "record.";
+   CensusViewProvider::ViewDataMap view_data_map =
+diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc
+index 9870bf4d0d6b6..5826afc4044cf 100644
+--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc
++++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc
+@@ -24,8 +24,8 @@
+ #include <grpcpp/support/status.h>
+ #include <inttypes.h>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/cpp/server/load_reporter/constants.h"
+
+ // IWYU pragma: no_include "google/protobuf/duration.pb.h"
+@@ -34,8 +34,8 @@ namespace grpc {
+ namespace load_reporter {
+
+ void LoadReporterAsyncServiceImpl::CallableTag::Run(bool ok) {
+-  CHECK(handler_function_ != nullptr);
+-  CHECK_NE(handler_, nullptr);
++  ABSL_CHECK(handler_function_ != nullptr);
++  ABSL_CHECK_NE(handler_, nullptr);
+   handler_function_(std::move(handler_), ok);
+ }
+
+@@ -81,15 +81,15 @@ void LoadReporterAsyncServiceImpl::ScheduleNextFetchAndSample() {
+     next_fetch_and_sample_alarm_->Set(cq_.get(), next_fetch_and_sample_time,
+                                       this);
+   }
+-  VLOG(2) << "[LRS " << this << "] Next fetch-and-sample scheduled.";
++  ABSL_VLOG(2) << "[LRS " << this << "] Next fetch-and-sample scheduled.";
+ }
+
+ void LoadReporterAsyncServiceImpl::FetchAndSample(bool ok) {
+   if (!ok) {
+-    LOG(INFO) << "[LRS " << this << "] Fetch-and-sample is stopped.";
++    ABSL_LOG(INFO) << "[LRS " << this << "] Fetch-and-sample is stopped.";
+     return;
+   }
+-  VLOG(2) << "[LRS " << this << "] Starting a fetch-and-sample...";
++  ABSL_VLOG(2) << "[LRS " << this << "] Starting a fetch-and-sample...";
+   load_reporter_->FetchAndSample();
+   ScheduleNextFetchAndSample();
+ }
+@@ -109,7 +109,7 @@ void LoadReporterAsyncServiceImpl::Work(void* arg) {
+   while (true) {
+     if (!service->cq_->Next(&tag, &ok)) {
+       // The completion queue is shutting down.
+-      CHECK(service->shutdown_);
++      ABSL_CHECK(service->shutdown_);
+       break;
+     }
+     if (tag == service) {
+@@ -164,7 +164,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnRequestDelivered(
+     // tag will not pop out if the call never starts (
+     // https://github.com/grpc/grpc/issues/10136). So we need to manually
+     // release the ownership of the handler in this case.
+-    CHECK_NE(on_done_notified_.ReleaseHandler(), nullptr);
++    ABSL_CHECK_NE(on_done_notified_.ReleaseHandler(), nullptr);
+   }
+   if (!ok || shutdown_) {
+     // The value of ok being false means that the server is shutting down.
+@@ -189,7 +189,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnRequestDelivered(
+   }
+   // LB ID is unique for each load reporting stream.
+   lb_id_ = load_reporter_->GenerateLbId();
+-  LOG(INFO) << "[LRS " << service_
++  ABSL_LOG(INFO) << "[LRS " << service_
+             << "] Call request delivered (lb_id_: " << lb_id_
+             << ", handler: " << this
+             << "). Start reading the initial request...";
+@@ -200,7 +200,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnReadDone(
+   if (!ok || shutdown_) {
+     if (!ok && call_status_ < INITIAL_REQUEST_RECEIVED) {
+       // The client may have half-closed the stream or the stream is broken.
+-      LOG(INFO) << "[LRS " << service_
++      ABSL_LOG(INFO) << "[LRS " << service_
+                 << "] Failed reading the initial request from the stream "
+                    "(lb_id_: "
+                 << lb_id_ << ", handler: " << this
+@@ -225,7 +225,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnReadDone(
+       load_report_interval_ms_ =
+           static_cast<unsigned long>((load_report_interval.seconds() * 1000) +
+                                      (load_report_interval.nanos() / 1000));
+-      LOG(INFO) << "[LRS " << service_
++      ABSL_LOG(INFO) << "[LRS " << service_
+                 << "] Initial request received. Start load reporting (load "
+                    "balanced host: "
+                 << load_balanced_hostname_
+@@ -249,7 +249,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnReadDone(
+     }
+   } else {
+     // Another request received! This violates the spec.
+-    LOG(ERROR) << "[LRS " << service_
++    ABSL_LOG(ERROR) << "[LRS " << service_
+                << "] Another request received (lb_id_: " << lb_id_
+                << ", handler: " << this << ").";
+     Shutdown(std::move(self), "OnReadDone+second_request");
+@@ -281,7 +281,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::ScheduleNextReport(
+     next_report_alarm_ = std::make_unique<Alarm>();
+     next_report_alarm_->Set(cq_, next_report_time, &next_outbound_);
+   }
+-  VLOG(2) << "[LRS " << service_
++  ABSL_VLOG(2) << "[LRS " << service_
+           << "] Next load report scheduled (lb_id_: " << lb_id_
+           << ", handler: " << this << ").";
+ }
+@@ -317,7 +317,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::SendReport(
+                               std::placeholders::_1, std::placeholders::_2),
+                     std::move(self));
+     stream_.Write(response, &next_outbound_);
+-    LOG(INFO) << "[LRS " << service_
++    ABSL_LOG(INFO) << "[LRS " << service_
+               << "] Sending load report (lb_id_: " << lb_id_
+               << ", handler: " << this
+               << ", loads count: " << response.load().size() << ")...";
+@@ -326,12 +326,12 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::SendReport(
+
+ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnDoneNotified(
+     std::shared_ptr<ReportLoadHandler> self, bool ok) {
+-  CHECK(ok);
++  ABSL_CHECK(ok);
+   done_notified_ = true;
+   if (ctx_.IsCancelled()) {
+     is_cancelled_ = true;
+   }
+-  LOG(INFO) << "[LRS " << service_
++  ABSL_LOG(INFO) << "[LRS " << service_
+             << "] Load reporting call is notified done (handler: " << this
+             << ", is_cancelled: " << is_cancelled_ << ").";
+   Shutdown(std::move(self), "OnDoneNotified");
+@@ -340,7 +340,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnDoneNotified(
+ void LoadReporterAsyncServiceImpl::ReportLoadHandler::Shutdown(
+     std::shared_ptr<ReportLoadHandler> self, const char* reason) {
+   if (!shutdown_) {
+-    LOG(INFO) << "[LRS " << service_
++    ABSL_LOG(INFO) << "[LRS " << service_
+               << "] Shutting down the handler (lb_id_: " << lb_id_
+               << ", handler: " << this << ", reason: " << reason << ").";
+     shutdown_ = true;
+@@ -371,7 +371,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnFinishDone(
+     // NOLINTNEXTLINE(performance-unnecessary-value-param)
+     std::shared_ptr<ReportLoadHandler> /*self*/, bool ok) {
+   if (ok) {
+-    LOG(INFO) << "[LRS " << service_
++    ABSL_LOG(INFO) << "[LRS " << service_
+               << "] Load reporting finished (lb_id_: " << lb_id_
+               << ", handler: " << this << ").";
+   }
+diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h
+index e5597a3818855..c383ef0f26d79 100644
+--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h
++++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h
+@@ -32,7 +32,7 @@
+ #include <string>
+ #include <utility>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+ #include "src/core/util/sync.h"
+ #include "src/core/util/thd.h"
+ #include "src/cpp/server/load_reporter/load_reporter.h"
+@@ -80,8 +80,8 @@ class LoadReporterAsyncServiceImpl
+     CallableTag(HandlerFunction func,
+                 std::shared_ptr<ReportLoadHandler> handler)
+         : handler_function_(std::move(func)), handler_(std::move(handler)) {
+-      CHECK(handler_function_ != nullptr);
+-      CHECK_NE(handler_, nullptr);
++      ABSL_CHECK(handler_function_ != nullptr);
++      ABSL_CHECK_NE(handler_, nullptr);
+     }
+
+     // Runs the tag. This should be called only once. The handler is no longer
+diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/util.cc b/third_party/grpc/source/src/cpp/server/load_reporter/util.cc
+index 4d2ddc9c42c6b..d68615c8b7837 100644
+--- a/third_party/grpc/source/src/cpp/server/load_reporter/util.cc
++++ b/third_party/grpc/source/src/cpp/server/load_reporter/util.cc
+@@ -25,7 +25,7 @@
+ #include <cmath>
+ #include <string>
+
+-#include "absl/log/log.h"
++#include "absl/log/absl_log.h"
+
+ namespace grpc {
+ namespace load_reporter {
+@@ -41,7 +41,7 @@ void AddLoadReportingCost(grpc::ServerContext* ctx,
+            cost_name.size());
+     ctx->AddTrailingMetadata(GRPC_LB_COST_MD_KEY, buf);
+   } else {
+-    LOG(ERROR) << "Call metric value is not normal.";
++    ABSL_LOG(ERROR) << "Call metric value is not normal.";
+   }
+ }
+
+diff --git a/third_party/grpc/source/src/cpp/server/orca/orca_service.cc b/third_party/grpc/source/src/cpp/server/orca/orca_service.cc
+index 31f3a07cc1002..aff1e47eefac6 100644
+--- a/third_party/grpc/source/src/cpp/server/orca/orca_service.cc
++++ b/third_party/grpc/source/src/cpp/server/orca/orca_service.cc
+@@ -35,8 +35,8 @@
+ #include <optional>
+ #include <utility>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/string_view.h"
+ #include "absl/time/time.h"
+ #include "google/protobuf/duration.upb.h"
+@@ -68,7 +68,7 @@ OrcaService::Reactor::Reactor(OrcaService* service, absl::string_view peer,
+   Slice slice;
+   grpc::Status status = request_buffer->DumpToSingleSlice(&slice);
+   if (!status.ok()) {
+-    LOG_EVERY_N_SEC(WARNING, 1)
++    ABSL_LOG_EVERY_N_SEC(WARNING, 1)
+         << "OrcaService failed to extract request from peer: " << peer
+         << " error:" << status.error_message();
+     FinishRpc(Status(StatusCode::INTERNAL, status.error_message()));
+@@ -81,7 +81,7 @@ OrcaService::Reactor::Reactor(OrcaService* service, absl::string_view peer,
+           reinterpret_cast<const char*>(slice.begin()), slice.size(),
+           arena.ptr());
+   if (request == nullptr) {
+-    LOG_EVERY_N_SEC(WARNING, 1)
++    ABSL_LOG_EVERY_N_SEC(WARNING, 1)
+         << "OrcaService failed to parse request proto from peer: " << peer;
+     FinishRpc(Status(StatusCode::INTERNAL, "could not parse request proto"));
+     return;
+@@ -175,7 +175,7 @@ OrcaService::OrcaService(ServerMetricRecorder* const server_metric_recorder,
+                          Options options)
+     : server_metric_recorder_(server_metric_recorder),
+       min_report_duration_(options.min_report_duration) {
+-  CHECK_NE(server_metric_recorder_, nullptr);
++  ABSL_CHECK_NE(server_metric_recorder_, nullptr);
+   AddMethod(new internal::RpcServiceMethod(
+       "/xds.service.orca.v3.OpenRcaService/StreamCoreMetrics",
+       internal::RpcMethod::SERVER_STREAMING, /*handler=*/nullptr));
+diff --git a/third_party/grpc/source/src/cpp/server/server_builder.cc b/third_party/grpc/source/src/cpp/server/server_builder.cc
+index 1e611449931e4..f262236812678 100644
+--- a/third_party/grpc/source/src/cpp/server/server_builder.cc
++++ b/third_party/grpc/source/src/cpp/server/server_builder.cc
+@@ -44,8 +44,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "src/core/ext/transport/chttp2/server/chttp2_server.h"
+ #include "src/core/server/server.h"
+ #include "src/core/util/string.h"
+@@ -137,7 +137,7 @@ ServerBuilder& ServerBuilder::RegisterService(const std::string& host,
+ ServerBuilder& ServerBuilder::RegisterAsyncGenericService(
+     AsyncGenericService* service) {
+   if (generic_service_ || callback_generic_service_) {
+-    LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
++    ABSL_LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
+                   "Dropping the service "
+                << service;
+   } else {
+@@ -149,7 +149,7 @@ ServerBuilder& ServerBuilder::RegisterAsyncGenericService(
+ ServerBuilder& ServerBuilder::RegisterCallbackGenericService(
+     CallbackGenericService* service) {
+   if (generic_service_ || callback_generic_service_) {
+-    LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
++    ABSL_LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
+                   "Dropping the service "
+                << service;
+   } else {
+@@ -186,7 +186,7 @@ void ServerBuilder::experimental_type::SetAuthorizationPolicyProvider(
+ void ServerBuilder::experimental_type::EnableCallMetricRecording(
+     experimental::ServerMetricRecorder* server_metric_recorder) {
+   builder_->AddChannelArgument(GRPC_ARG_SERVER_CALL_METRIC_RECORDING, 1);
+-  CHECK_EQ(builder_->server_metric_recorder_, nullptr);
++  ABSL_CHECK_EQ(builder_->server_metric_recorder_, nullptr);
+   builder_->server_metric_recorder_ = server_metric_recorder;
+ }
+
+@@ -387,14 +387,14 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
+
+   if (has_sync_methods) {
+     // This is a Sync server
+-    VLOG(2) << "Synchronous server. Num CQs: " << sync_server_settings_.num_cqs
++    ABSL_VLOG(2) << "Synchronous server. Num CQs: " << sync_server_settings_.num_cqs
+             << ", Min pollers: " << sync_server_settings_.min_pollers
+             << ", Max Pollers: " << sync_server_settings_.max_pollers
+             << ", CQ timeout (msec): " << sync_server_settings_.cq_timeout_msec;
+   }
+
+   if (has_callback_methods) {
+-    VLOG(2) << "Callback server.";
++    ABSL_VLOG(2) << "Callback server.";
+   }
+
+   std::unique_ptr<grpc::Server> server(new grpc::Server(
+@@ -439,13 +439,13 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
+     if (passive_listener != nullptr) {
+       auto* creds = unstarted_listener.credentials->c_creds();
+       if (creds == nullptr) {
+-        LOG(ERROR) << "Credentials missing for PassiveListener";
++        ABSL_LOG(ERROR) << "Credentials missing for PassiveListener";
+         return nullptr;
+       }
+       auto success = grpc_server_add_passive_listener(
+           core_server, creds, std::move(passive_listener));
+       if (!success.ok()) {
+-        LOG(ERROR) << "Failed to create a passive listener: "
++        ABSL_LOG(ERROR) << "Failed to create a passive listener: "
+                    << success.ToString();
+         return nullptr;
+       }
+@@ -453,7 +453,7 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
+   }
+
+   if (!has_frequently_polled_cqs) {
+-    LOG(ERROR)
++    ABSL_LOG(ERROR)
+         << "At least one of the completion queues must be frequently polled";
+     return nullptr;
+   }
+@@ -477,7 +477,7 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
+   } else {
+     for (const auto& value : services_) {
+       if (value->service->has_generic_methods()) {
+-        LOG(ERROR) << "Some methods were marked generic but there is no "
++        ABSL_LOG(ERROR) << "Some methods were marked generic but there is no "
+                       "generic service registered.";
+         return nullptr;
+       }
+@@ -518,7 +518,7 @@ ServerBuilder& ServerBuilder::EnableWorkaround(grpc_workaround_list id) {
+     case GRPC_WORKAROUND_ID_CRONET_COMPRESSION:
+       return AddChannelArgument(GRPC_ARG_WORKAROUND_CRONET_COMPRESSION, 1);
+     default:
+-      LOG(ERROR) << "Workaround " << id << " does not exist or is obsolete.";
++      ABSL_LOG(ERROR) << "Workaround " << id << " does not exist or is obsolete.";
+       return *this;
+   }
+ }
+diff --git a/third_party/grpc/source/src/cpp/server/server_cc.cc b/third_party/grpc/source/src/cpp/server/server_cc.cc
+index 2d30879de66d5..78c12bf2b34a5 100644
+--- a/third_party/grpc/source/src/cpp/server/server_cc.cc
++++ b/third_party/grpc/source/src/cpp/server/server_cc.cc
+@@ -63,8 +63,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "src/core/ext/transport/inproc/inproc_transport.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+@@ -238,7 +238,7 @@ void ServerInterface::RegisteredAsyncRequest::IssueRequest(
+     ServerCompletionQueue* notification_cq) {
+   // The following call_start_batch is internally-generated so no need for an
+   // explanatory log on failure.
+-  CHECK(grpc_server_request_registered_call(
++  ABSL_CHECK(grpc_server_request_registered_call(
+             server_->server(), registered_method, &call_, &context_->deadline_,
+             context_->client_metadata_.arr(), payload, call_cq_->cq(),
+             notification_cq->cq(), this) == GRPC_CALL_OK);
+@@ -252,8 +252,8 @@ ServerInterface::GenericAsyncRequest::GenericAsyncRequest(
+     : BaseAsyncRequest(server, context, stream, call_cq, notification_cq, tag,
+                        delete_on_finalize) {
+   grpc_call_details_init(&call_details_);
+-  CHECK(notification_cq);
+-  CHECK(call_cq);
++  ABSL_CHECK(notification_cq);
++  ABSL_CHECK(call_cq);
+   if (issue_request) {
+     IssueRequest();
+   }
+@@ -287,7 +287,7 @@ bool ServerInterface::GenericAsyncRequest::FinalizeResult(void** tag,
+ void ServerInterface::GenericAsyncRequest::IssueRequest() {
+   // The following call_start_batch is internally-generated so no need for an
+   // explanatory log on failure.
+-  CHECK(grpc_server_request_call(server_->server(), &call_, &call_details_,
++  ABSL_CHECK(grpc_server_request_call(server_->server(), &call_, &call_details_,
+                                  context_->client_metadata_.arr(),
+                                  call_cq_->cq(), notification_cq_->cq(),
+                                  this) == GRPC_CALL_OK);
+@@ -444,7 +444,7 @@ class Server::SyncRequest final : public grpc::internal::CompletionQueueTag {
+       deserialized_request_ = handler->Deserialize(call_, request_payload_,
+                                                    &request_status_, nullptr);
+       if (!request_status_.ok()) {
+-        VLOG(2) << "Failed to deserialize message.";
++        ABSL_VLOG(2) << "Failed to deserialize message.";
+       }
+       request_payload_ = nullptr;
+       interceptor_methods_.AddInterceptionHookPoint(
+@@ -478,7 +478,7 @@ class Server::SyncRequest final : public grpc::internal::CompletionQueueTag {
+
+     // Ensure the cq_ is shutdown
+     grpc::PhonyTag ignored_tag;
+-    CHECK(cq_.Pluck(&ignored_tag) == false);
++    ABSL_CHECK(cq_.Pluck(&ignored_tag) == false);
+
+     // Cleanup structures allocated during Run/ContinueRunAfterInterception
+     wrapped_call_.Destroy();
+@@ -640,8 +640,8 @@ class Server::CallbackRequest final
+     void Run(bool ok) {
+       void* ignored = req_;
+       bool new_ok = ok;
+-      CHECK(!req_->FinalizeResult(&ignored, &new_ok));
+-      CHECK(ignored == req_);
++      ABSL_CHECK(!req_->FinalizeResult(&ignored, &new_ok));
++      ABSL_CHECK(ignored == req_);
+
+       if (!ok) {
+         // The call has been shutdown.
+@@ -687,7 +687,7 @@ class Server::CallbackRequest final
+             req_->call_, req_->request_payload_, &req_->request_status_,
+             &req_->handler_data_);
+         if (!(req_->request_status_.ok())) {
+-          VLOG(2) << "Failed to deserialize message.";
++          ABSL_VLOG(2) << "Failed to deserialize message.";
+         }
+         req_->request_payload_ = nullptr;
+         req_->interceptor_methods_.AddInterceptionHookPoint(
+@@ -822,8 +822,8 @@ class Server::SyncRequestThreadManager : public grpc::ThreadManager {
+
+     // Under the AllocatingRequestMatcher model we will never see an invalid tag
+     // here.
+-    DCHECK_NE(sync_req, nullptr);
+-    DCHECK(ok);
++    ABSL_DCHECK_NE(sync_req, nullptr);
++    ABSL_DCHECK(ok);
+
+     sync_req->Run(global_callbacks_, resources);
+   }
+@@ -995,8 +995,8 @@ Server::~Server() {
+ }
+
+ void Server::SetGlobalCallbacks(GlobalCallbacks* callbacks) {
+-  CHECK(!grpc::g_callbacks);
+-  CHECK(callbacks);
++  ABSL_CHECK(!grpc::g_callbacks);
++  ABSL_CHECK(callbacks);
+   grpc::g_callbacks.reset(callbacks);
+ }
+
+@@ -1040,7 +1040,7 @@ static grpc_server_register_method_payload_handling PayloadHandlingForMethod(
+ bool Server::RegisterService(const std::string* addr, grpc::Service* service) {
+   bool has_async_methods = service->has_async_methods();
+   if (has_async_methods) {
+-    CHECK_EQ(service->server_, nullptr)
++    ABSL_CHECK_EQ(service->server_, nullptr)
+         << "Can only register an asynchronous service against one server.";
+     service->server_ = this;
+   }
+@@ -1056,7 +1056,7 @@ bool Server::RegisterService(const std::string* addr, grpc::Service* service) {
+         server_, method->name(), addr ? addr->c_str() : nullptr,
+         PayloadHandlingForMethod(method.get()), 0);
+     if (method_registration_tag == nullptr) {
+-      VLOG(2) << "Attempt to register " << method->name() << " multiple times";
++      ABSL_VLOG(2) << "Attempt to register " << method->name() << " multiple times";
+       return false;
+     }
+
+@@ -1097,7 +1097,7 @@ bool Server::RegisterService(const std::string* addr, grpc::Service* service) {
+ }
+
+ void Server::RegisterAsyncGenericService(grpc::AsyncGenericService* service) {
+-  CHECK_EQ(service->server_, nullptr)
++  ABSL_CHECK_EQ(service->server_, nullptr)
+       << "Can only register an async generic service against one server.";
+   service->server_ = this;
+   has_async_generic_service_ = true;
+@@ -1105,7 +1105,7 @@ void Server::RegisterAsyncGenericService(grpc::AsyncGenericService* service) {
+
+ void Server::RegisterCallbackGenericService(
+     grpc::CallbackGenericService* service) {
+-  CHECK_EQ(service->server_, nullptr)
++  ABSL_CHECK_EQ(service->server_, nullptr)
+       << "Can only register a callback generic service against one server.";
+   service->server_ = this;
+   has_callback_generic_service_ = true;
+@@ -1122,7 +1122,7 @@ void Server::RegisterCallbackGenericService(
+
+ int Server::AddListeningPort(const std::string& addr,
+                              grpc::ServerCredentials* creds) {
+-  CHECK(!started_);
++  ABSL_CHECK(!started_);
+   int port = creds->AddPortToServer(addr, server_);
+   global_callbacks_->AddPort(this, addr, creds, port);
+   return port;
+@@ -1138,7 +1138,7 @@ void Server::UnrefWithPossibleNotify() {
+     // No refs outstanding means that shutdown has been initiated and no more
+     // callback requests are outstanding.
+     grpc::internal::MutexLock lock(&mu_);
+-    CHECK(shutdown_);
++    ABSL_CHECK(shutdown_);
+     shutdown_done_ = true;
+     shutdown_done_cv_.Signal();
+   }
+@@ -1156,7 +1156,7 @@ void Server::UnrefAndWaitLocked() {
+ }
+
+ void Server::Start(grpc::ServerCompletionQueue** cqs, size_t num_cqs) {
+-  CHECK(!started_);
++  ABSL_CHECK(!started_);
+   global_callbacks_->PreServerStart(this);
+   started_ = true;
+
+diff --git a/third_party/grpc/source/src/cpp/server/server_context.cc b/third_party/grpc/source/src/cpp/server/server_context.cc
+index ca8e3a4728fd9..4d97574be974f 100644
+--- a/third_party/grpc/source/src/cpp/server/server_context.cc
++++ b/third_party/grpc/source/src/cpp/server/server_context.cc
+@@ -50,8 +50,8 @@
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+ #include "src/core/lib/resource_quota/arena.h"
+@@ -153,7 +153,7 @@ class ServerContextBase::CompletionOp final
+       return;
+     }
+     // Start a phony op so that we can return the tag
+-    CHECK(grpc_call_start_batch(call_.call(), nullptr, 0, core_cq_tag_,
++    ABSL_CHECK(grpc_call_start_batch(call_.call(), nullptr, 0, core_cq_tag_,
+                                 nullptr) == GRPC_CALL_OK);
+   }
+
+@@ -195,7 +195,7 @@ void ServerContextBase::CompletionOp::FillOps(internal::Call* call) {
+   interceptor_methods_.SetCallOpSetInterface(this);
+   // The following call_start_batch is internally-generated so no need for an
+   // explanatory log on failure.
+-  CHECK(grpc_call_start_batch(call->call(), &ops, 1, core_cq_tag_, nullptr) ==
++  ABSL_CHECK(grpc_call_start_batch(call->call(), &ops, 1, core_cq_tag_, nullptr) ==
+         GRPC_CALL_OK);
+   // No interceptors to run here
+ }
+@@ -300,7 +300,7 @@ ServerContextBase::CallWrapper::~CallWrapper() {
+ void ServerContextBase::BeginCompletionOp(
+     internal::Call* call, std::function<void(bool)> callback,
+     grpc::internal::ServerCallbackCall* callback_controller) {
+-  CHECK(!completion_op_);
++  ABSL_CHECK(!completion_op_);
+   if (rpc_info_) {
+     rpc_info_->Ref();
+   }
+@@ -344,7 +344,7 @@ void ServerContextBase::TryCancel() const {
+       grpc_call_cancel_with_status(call_.call, GRPC_STATUS_CANCELLED,
+                                    "Cancelled on the server side", nullptr);
+   if (err != GRPC_CALL_OK) {
+-    LOG(ERROR) << "TryCancel failed with: " << err;
++    ABSL_LOG(ERROR) << "TryCancel failed with: " << err;
+   }
+ }
+
+@@ -372,7 +372,7 @@ void ServerContextBase::set_compression_algorithm(
+     grpc_core::Crash(absl::StrFormat(
+         "Name for compression algorithm '%d' unknown.", algorithm));
+   }
+-  CHECK_NE(algorithm_name, nullptr);
++  ABSL_CHECK_NE(algorithm_name, nullptr);
+   AddInitialMetadata(GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY, algorithm_name);
+ }
+
+@@ -402,7 +402,7 @@ void ServerContextBase::SetLoadReportingCosts(
+ void ServerContextBase::CreateCallMetricRecorder(
+     experimental::ServerMetricRecorder* server_metric_recorder) {
+   if (call_.call == nullptr) return;
+-  CHECK_EQ(call_metric_recorder_, nullptr);
++  ABSL_CHECK_EQ(call_metric_recorder_, nullptr);
+   grpc_core::Arena* arena = grpc_call_get_arena(call_.call);
+   auto* backend_metric_state =
+       arena->New<BackendMetricState>(server_metric_recorder);
+diff --git a/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc b/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc
+index 6ce2d70570b05..debbed215508d 100644
+--- a/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc
++++ b/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc
+@@ -22,14 +22,14 @@
+
+ #include <memory>
+
+-#include "absl/log/check.h"
++#include "absl/log/absl_check.h"
+
+ namespace grpc {
+
+ std::shared_ptr<ServerCredentials> XdsServerCredentials(
+     const std::shared_ptr<ServerCredentials>& fallback_credentials) {
+-  CHECK_NE(fallback_credentials, nullptr);
+-  CHECK_NE(fallback_credentials->c_creds_, nullptr);
++  ABSL_CHECK_NE(fallback_credentials, nullptr);
++  ABSL_CHECK_NE(fallback_credentials->c_creds_, nullptr);
+   return std::shared_ptr<ServerCredentials>(new ServerCredentials(
+       grpc_xds_server_credentials_create(fallback_credentials->c_creds_)));
+ }
+diff --git a/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc b/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc
+index 6cdf78c95bca8..9a51e8e96492a 100644
+--- a/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc
++++ b/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc
+@@ -20,8 +20,8 @@
+
+ #include <climits>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
++#include "absl/log/absl_check.h"
++#include "absl/log/absl_log.h"
+ #include "absl/strings/str_format.h"
+ #include "src/core/lib/resource_quota/resource_quota.h"
+ #include "src/core/util/crash.h"
+@@ -39,7 +39,7 @@ ThreadManager::WorkerThread::WorkerThread(ThreadManager* thd_mgr)
+       [](void* th) { static_cast<ThreadManager::WorkerThread*>(th)->Run(); },
+       this, &created_);
+   if (!created_) {
+-    LOG(ERROR) << "Could not create grpc_sync_server worker-thread";
++    ABSL_LOG(ERROR) << "Could not create grpc_sync_server worker-thread";
+   }
+ }
+
+@@ -67,7 +67,7 @@ ThreadManager::ThreadManager(const char*, grpc_resource_quota* resource_quota,
+ ThreadManager::~ThreadManager() {
+   {
+     grpc_core::MutexLock lock(&mu_);
+-    CHECK_EQ(num_threads_, 0);
++    ABSL_CHECK_EQ(num_threads_, 0);
+   }
+
+   CleanupCompletedThreads();
+@@ -141,7 +141,7 @@ void ThreadManager::Initialize() {
+
+   for (int i = 0; i < min_pollers_; i++) {
+     WorkerThread* worker = new WorkerThread(this);
+-    CHECK(worker->created());  // Must be able to create the minimum
++    ABSL_CHECK(worker->created());  // Must be able to create the minimum
+     worker->Start();
+   }
+ }
+diff --git a/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc b/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc
+index 54f5c8d36c4d5..d203b0b342751 100644
+--- a/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc
++++ b/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc
+@@ -125,7 +125,7 @@ void AwaitNextBatchLocked(std::unique_lock<std::mutex>& lock, int timeout_ms) {
+ void AddCensusDataToBuffer(const CensusData& data) {
+   std::unique_lock<std::mutex> lk(g_census_data_buffer_mutex);
+   if (g_census_data_buffer->size() >= GetMaxExportBufferSize()) {
+-    VLOG(2) << "Reached maximum census data buffer size, discarding this "
++    ABSL_VLOG(2) << "Reached maximum census data buffer size, discarding this "
+                "CensusData entry";
+   } else {
+     g_census_data_buffer->push(data);
+--
+2.48.1.601.g30ceb7b040-goog
+
diff --git a/third_party/grpc/patches/0003-fucshia-Drop-CreateDirectoryReloaderCrlProvider.patch b/third_party/grpc/patches/0003-fucshia-Drop-CreateDirectoryReloaderCrlProvider.patch
new file mode 100644
index 0000000000000..661d22d6f2fc8
--- /dev/null
+++ b/third_party/grpc/patches/0003-fucshia-Drop-CreateDirectoryReloaderCrlProvider.patch
@@ -0,0 +1,129 @@
+From d5b3fa3438738a44a9caaaf6f2420b1817744868 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Mon, 17 Feb 2025 13:56:18 +0000
+Subject: [PATCH] fucshia: Drop CreateDirectoryReloaderCrlProvider()
+
+The API depends on MakeDirectoryReader(), which is currently
+implemented for Windows and Posix but not Fuchsia. #ifdef it
+out in Fuchsia.
+
+---
+ .../grpc/source/include/grpc/grpc_crl_provider.h       |  2 ++
+ .../security/credentials/tls/grpc_tls_crl_provider.cc  | 10 +++++++++-
+ .../security/credentials/tls/grpc_tls_crl_provider.h   | 10 ++++++++--
+ 3 files changed, 19 insertions(+), 3 deletions(-)
+
+diff --git a/third_party/grpc/source/include/grpc/grpc_crl_provider.h b/third_party/grpc/source/include/grpc/grpc_crl_provider.h
+index e9a6db95cd9f0..83c7dcf38743f 100644
+--- a/third_party/grpc/source/include/grpc/grpc_crl_provider.h
++++ b/third_party/grpc/source/include/grpc/grpc_crl_provider.h
+@@ -68,6 +68,7 @@ class CrlProvider {
+ absl::StatusOr<std::shared_ptr<CrlProvider>> CreateStaticCrlProvider(
+     absl::Span<const std::string> crls);
+ 
++#if !defined(__Fuchsia__)
+ // Creates a CRL Provider that periodically and asynchronously reloads a
+ // directory. The refresh_duration minimum is 60 seconds. The
+ // reload_error_callback provides a way for the user to specifically log or
+@@ -78,6 +79,7 @@ absl::StatusOr<std::shared_ptr<CrlProvider>> CreateStaticCrlProvider(
+ absl::StatusOr<std::shared_ptr<CrlProvider>> CreateDirectoryReloaderCrlProvider(
+     absl::string_view directory, std::chrono::seconds refresh_duration,
+     std::function<void(absl::Status)> reload_error_callback);
++#endif  // !defined(__Fuchsia__)
+ 
+ }  // namespace experimental
+ }  // namespace grpc_core
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
+index 4fec5db6fbd5a..b3bff3eeb3cd9 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
+@@ -43,9 +43,12 @@
+ #include "src/core/lib/event_engine/default_event_engine.h"
+ #include "src/core/lib/iomgr/exec_ctx.h"
+ #include "src/core/lib/slice/slice.h"
+-#include "src/core/util/directory_reader.h"
+ #include "src/core/util/load_file.h"
+ 
++#if !defined(__Fuchsia__)
++#include "src/core/util/directory_reader.h"
++#endif  // !defined(__Fuchsia__)
++
+ namespace grpc_core {
+ namespace experimental {
+ 
+@@ -70,6 +73,7 @@ absl::StatusOr<std::string> IssuerFromCrl(X509_CRL* crl) {
+   return ret;
+ }
+ 
++#if !defined(__Fuchsia__)
+ absl::StatusOr<std::shared_ptr<Crl>> ReadCrlFromFile(
+     const std::string& crl_path) {
+   absl::StatusOr<Slice> crl_slice = LoadFile(crl_path, false);
+@@ -83,6 +87,7 @@ absl::StatusOr<std::shared_ptr<Crl>> ReadCrlFromFile(
+   }
+   return crl;
+ }
++#endif  // !defined(__Fuchsia__)
+ 
+ }  // namespace
+ 
+@@ -144,6 +149,7 @@ std::shared_ptr<Crl> StaticCrlProvider::GetCrl(
+   return it->second;
+ }
+ 
++#if !defined(__Fuchsia__)
+ absl::StatusOr<std::shared_ptr<CrlProvider>> CreateDirectoryReloaderCrlProvider(
+     absl::string_view directory, std::chrono::seconds refresh_duration,
+     std::function<void(absl::Status)> reload_error_callback) {
+@@ -253,6 +259,8 @@ std::shared_ptr<Crl> DirectoryReloaderCrlProvider::GetCrl(
+   }
+   return it->second;
+ }
++#endif  // !defined(__Fuchsia__)
++
+ 
+ }  // namespace experimental
+ }  // namespace grpc_core
+diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h
+index cd89301de81a9..a6382507cacbb 100644
+--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h
++++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h
+@@ -36,10 +36,14 @@
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+-#include "src/core/util/directory_reader.h"
+ #include "src/core/util/sync.h"
+ #include "src/core/util/time.h"
+ 
++#if !defined(__Fuchsia__)
++#include "src/core/util/directory_reader.h"
++#endif  // !defined(__Fuchsia__)
++
++
+ namespace grpc_core {
+ namespace experimental {
+ 
+@@ -88,6 +92,7 @@ class CertificateInfoImpl : public CertificateInfo {
+   const std::string authority_key_identifier_;
+ };
+ 
++#if !defined(__Fuchsia__)
+ // Defining this here lets us hide implementation details (and includes) from
+ // the header in include
+ class DirectoryReloaderCrlProvider
+@@ -122,8 +127,9 @@ class DirectoryReloaderCrlProvider
+   std::optional<grpc_event_engine::experimental::EventEngine::TaskHandle>
+       refresh_handle_;
+ };
++#endif  // !defined(__Fuchsia__)
+ 
+ }  // namespace experimental
+ }  // namespace grpc_core
+ 
+-#endif  // GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H
+\ No newline at end of file
++#endif  // GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H
+-- 
+2.48.1.601.g30ceb7b040-goog
+
diff --git a/third_party/hunspell/google.patch b/third_party/hunspell/google.patch
new file mode 100644
index 0000000000000..391dd10391e81
--- /dev/null
+++ b/third_party/hunspell/google.patch
@@ -0,0 +1,1363 @@
+diff --git a/src/hunspell/affixmgr.cxx b/src/hunspell/affixmgr.cxx
+index 87ab6c5..4499a06 100644
+--- a/src/hunspell/affixmgr.cxx
++++ b/src/hunspell/affixmgr.cxx
+@@ -85,11 +85,19 @@
+ 
+ #include "csutil.hxx"
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++AffixMgr::AffixMgr(hunspell::BDictReader* reader,
++                   const std::vector<HashMgr*>& ptr)
++  : alldic(ptr)
++  , pHMgr(ptr[0]) {
++  bdict_reader = reader;
++#else
+ AffixMgr::AffixMgr(const char* affpath,
+                    const std::vector<HashMgr*>& ptr,
+                    const char* key)
+   : alldic(ptr)
+   , pHMgr(ptr[0]) {
++#endif
+ 
+   // register hash manager and load affix data from aff file
+   csconv = NULL;
+@@ -163,9 +171,17 @@ AffixMgr::AffixMgr(const char* affpath,
+     sFlag[i] = NULL;
+   }
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++  // Define dummy parameters for parse_file() to avoid changing the parameters
++  // of parse_file(). This may make it easier to merge the changes of the
++  // original hunspell.
++  const char* affpath = NULL;
++  const char* key = NULL;
++#else
+   for (int j = 0; j < CONTSIZE; j++) {
+     contclasses[j] = 0;
+   }
++#endif
+ 
+   if (parse_file(affpath, key)) {
+     HUNSPELL_WARNING(stderr, "Failure loading aff file %s\n", affpath);
+@@ -243,7 +259,44 @@ void AffixMgr::finishFileMgr(FileMgr* afflst) {
+ 
+ // read in aff file and build up prefix and suffix entry objects
+ int AffixMgr::parse_file(const char* affpath, const char* key) {
++  std::string line;
++#ifdef HUNSPELL_CHROME_CLIENT
++  // open the affix file
++  // We're always UTF-8
++  utf8 = 1;
++
++  // A BDICT file stores PFX and SFX lines in a special section and it provides
++  // a special line iterator for reading PFX and SFX lines.
++  // We create a FileMgr object from this iterator and parse PFX and SFX lines
++  // before parsing other lines.
++  hunspell::LineIterator affix_iterator = bdict_reader->GetAffixLineIterator();
++  FileMgr* iterator = new FileMgr(&affix_iterator);
++  if (!iterator) {
++    HUNSPELL_WARNING(stderr,
++        "error: could not create a FileMgr from an affix line iterator.\n");
++    return 1;
++  }
++
++  while (iterator->getline(line)) {
++    char ft = ' ';
++    if (line.compare(0, 3, "PFX") == 0) ft = complexprefixes ? 'S' : 'P';
++    if (line.compare(0, 3, "SFX") == 0) ft = complexprefixes ? 'P' : 'S';
++    if (ft != ' ')
++      parse_affix(line, ft, iterator, NULL);
++  }
++  delete iterator;
+ 
++  // Create a FileMgr object for reading lines except PFX and SFX lines.
++  // We don't need to change the loop below since our FileMgr emulates the
++  // original one.
++  hunspell::LineIterator other_iterator = bdict_reader->GetOtherLineIterator();
++  FileMgr * afflst = new FileMgr(&other_iterator);
++  if (!afflst) {
++    HUNSPELL_WARNING(stderr,
++        "error: could not create a FileMgr from an other line iterator.\n");
++    return 1;
++  }
++#else
+   // checking flag duplication
+   char dupflags[CONTSIZE];
+   char dupflags_ini = 1;
+@@ -258,16 +311,17 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
+         stderr, "error: could not open affix description file %s\n", affpath);
+     return 1;
+   }
++#endif
+ 
+   // step one is to parse the affix file building up the internal
+   // affix data structures
+ 
+   // read in each line ignoring any that do not
+   // start with a known line type indicator
+-  std::string line;
+   while (afflst->getline(line)) {
+     mychomp(line);
+ 
++#ifndef HUNSPELL_CHROME_CLIENT
+     /* remove byte order mark */
+     if (firstline) {
+       firstline = 0;
+@@ -277,6 +331,7 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
+         line.erase(0, 3);
+       }
+     }
++#endif
+ 
+     /* parse in the keyboard string */
+     if (line.compare(0, 3, "KEY", 3) == 0) {
+@@ -677,6 +732,7 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
+       checksharps = 1;
+     }
+ 
++#ifndef HUNSPELL_CHROME_CLIENT
+     /* parse this affix: P - prefix, S - suffix */
+     // affix type
+     char ft = ' ';
+@@ -694,6 +750,7 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
+         return 1;
+       }
+     }
++#endif
+   }
+ 
+   finishFileMgr(afflst);
+@@ -1270,6 +1327,24 @@ std::string AffixMgr::prefix_check_twosfx_morph(const char* word,
+ // Is word a non-compound with a REP substitution (see checkcompoundrep)?
+ int AffixMgr::cpdrep_check(const char* word, int wl) {
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++  const char *pattern, *pattern2;
++  hunspell::ReplacementIterator iterator = bdict_reader->GetReplacementIterator();
++  while (iterator.GetNext(&pattern, &pattern2)) {
++    const char* r = word;
++    const size_t lenr = strlen(pattern2);
++    const size_t lenp = strlen(pattern);
++
++    // search every occurence of the pattern in the word
++    while ((r=strstr(r, pattern)) != NULL) {
++      std::string candidate(word);
++      candidate.replace(r-word, lenp, pattern2);
++      if (candidate_check(candidate.c_str(), candidate.size())) return 1;
++      r++; // search for the next letter
++    }
++  }
++
++#else
+   if ((wl < 2) || get_reptable().empty())
+     return 0;
+ 
+@@ -1288,6 +1363,7 @@ int AffixMgr::cpdrep_check(const char* word, int wl) {
+       }
+     }
+   }
++#endif
+ 
+  return 0;
+ }
+@@ -4359,7 +4435,7 @@ void AffixMgr::reverse_condition(std::string& piece) {
+       case '^': {
+         if (*(k - 1) == ']')
+           neg = 1;
+-        else
++        else if (neg)
+           *(k - 1) = *k;
+         break;
+       }
+@@ -4457,6 +4533,7 @@ bool AffixMgr::parse_affix(const std::string& line,
+       case 1: {
+         np++;
+         aflag = pHMgr->decode_flag(std::string(start_piece, iter).c_str());
++#ifndef HUNSPELL_CHROME_CLIENT // We don't check for duplicates.
+         if (((at == 'S') && (dupflags[aflag] & dupSFX)) ||
+             ((at == 'P') && (dupflags[aflag] & dupPFX))) {
+           HUNSPELL_WARNING(
+@@ -4465,6 +4542,7 @@ bool AffixMgr::parse_affix(const std::string& line,
+               af->getlinenum());
+         }
+         dupflags[aflag] += (char)((at == 'S') ? dupSFX : dupPFX);
++#endif
+         break;
+       }
+       // piece 3 - is cross product indicator
+diff --git a/src/hunspell/affixmgr.hxx b/src/hunspell/affixmgr.hxx
+index 38842a3..e03a4a3 100644
+--- a/src/hunspell/affixmgr.hxx
++++ b/src/hunspell/affixmgr.hxx
+@@ -89,6 +89,40 @@
+ class PfxEntry;
+ class SfxEntry;
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++
++#include <vector>
++
++// This class provides an implementation of the contclasses array in AffixMgr
++// that is normally a large static array. We should almost never need more than
++// 256 elements, so this class only allocates that much to start off with. If
++// elements higher than that are actually used, we'll automatically expand.
++class ContClasses {
++ public:
++  ContClasses() {
++    // Pre-allocate a buffer so that typically, we'll never have to resize.
++    EnsureSizeIs(256);
++  }
++
++  char& operator[](size_t index) {
++    EnsureSizeIs(index + 1);
++    return data[index];
++  }
++
++  void EnsureSizeIs(size_t new_size) {
++    if (data.size() >= new_size)
++      return;  // Nothing to do.
++
++    size_t old_size = data.size();
++    data.resize(new_size);
++    memset(&data[old_size], 0, new_size - old_size);
++  }
++
++  std::vector<char> data;
++};
++
++#endif  // HUNSPELL_CHROME_CLIENT
++
+ class AffixMgr {
+   PfxEntry* pStart[SETSIZE];
+   SfxEntry* sStart[SETSIZE];
+@@ -170,11 +204,19 @@ class AffixMgr {
+   int fullstrip;
+ 
+   int havecontclass;           // boolean variable
++#ifdef HUNSPELL_CHROME_CLIENT
++  ContClasses         contclasses;
++#else
+   char contclasses[CONTSIZE];  // flags of possible continuing classes (twofold
+                                // affix)
++#endif
+ 
+  public:
++#ifdef HUNSPELL_CHROME_CLIENT
++  AffixMgr(hunspell::BDictReader* reader, const std::vector<HashMgr*>& ptr);
++#else
+   AffixMgr(const char* affpath, const std::vector<HashMgr*>& ptr, const char* key = NULL);
++#endif
+   ~AffixMgr();
+   struct hentry* affix_check(const char* word,
+                              int len,
+@@ -334,6 +376,10 @@ class AffixMgr {
+   int get_fullstrip() const;
+ 
+  private:
++#ifdef HUNSPELL_CHROME_CLIENT
++  // Not owned by us, owned by the Hunspell object.
++  hunspell::BDictReader* bdict_reader;
++#endif
+   int parse_file(const char* affpath, const char* key);
+   bool parse_flag(const std::string& line, unsigned short* out, FileMgr* af);
+   bool parse_num(const std::string& line, int* out, FileMgr* af);
+diff --git a/src/hunspell/filemgr.cxx b/src/hunspell/filemgr.cxx
+index 4a14de8..1671db8 100644
+--- a/src/hunspell/filemgr.cxx
++++ b/src/hunspell/filemgr.cxx
+@@ -75,6 +75,32 @@
+ #include "filemgr.hxx"
+ #include "csutil.hxx"
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++#include "third_party/hunspell/google/bdict_reader.h"
++
++FileMgr::FileMgr(hunspell::LineIterator* iterator) : iterator_(iterator) {
++}
++
++FileMgr::~FileMgr() {
++}
++
++bool FileMgr::getline(std::string& line) {
++  // Read one line from a BDICT file and return it, if we can read a line
++  // without errors.
++  const char* result = iterator_->Advance();
++  if (result)
++    line = result;
++  return result;
++}
++
++int FileMgr::getlinenum() {
++  // This function is used only for displaying a line number that causes a
++  // parser error. For a BDICT file, providing a line number doesn't help
++  // identifying the place where causes a parser error so much since it is a
++  // binary file. So, we just return 0.
++  return 0;
++}
++#else
+ int FileMgr::fail(const char* err, const char* par) {
+   fprintf(stderr, err, par);
+   return -1;
+@@ -115,3 +141,4 @@ bool FileMgr::getline(std::string& dest) {
+ int FileMgr::getlinenum() {
+   return linenum;
+ }
++#endif
+diff --git a/src/hunspell/filemgr.hxx b/src/hunspell/filemgr.hxx
+index 62433ae..9016822 100644
+--- a/src/hunspell/filemgr.hxx
++++ b/src/hunspell/filemgr.hxx
+@@ -77,6 +77,29 @@
+ #include <string>
+ #include <fstream>
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++namespace hunspell {
++class LineIterator;
++}  // namespace hunspell
++
++// A class which encapsulates operations of reading a BDICT file.
++// Chrome uses a BDICT file to compress hunspell dictionaries. A BDICT file is
++// a binary file converted from a DIC file and an AFF file. (See
++// "bdict_reader.h" for its format.)
++// This class encapsulates the operations of reading a BDICT file and emulates
++// the original FileMgr operations for AffixMgr so that it can read a BDICT
++// file without so many changes.
++class FileMgr {
++ public:
++  FileMgr(hunspell::LineIterator* iterator);
++  ~FileMgr();
++  bool getline(std::string& line);
++  int getlinenum();
++
++ protected:
++  hunspell::LineIterator* iterator_;
++};
++#else
+ class FileMgr {
+  private:
+   FileMgr(const FileMgr&);
+@@ -96,3 +119,4 @@ class FileMgr {
+   int getlinenum();
+ };
+ #endif
++#endif
+diff --git a/src/hunspell/hashmgr.cxx b/src/hunspell/hashmgr.cxx
+index 7e843c3..fbebdbf 100644
+--- a/src/hunspell/hashmgr.cxx
++++ b/src/hunspell/hashmgr.cxx
+@@ -82,8 +82,14 @@
+ 
+ // build a hash table from a munched word list
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++HashMgr::HashMgr(hunspell::BDictReader* reader)
++    : bdict_reader(reader),
++#else
+ HashMgr::HashMgr(const char* tpath, const char* apath, const char* key)
+-    : tablesize(0),
++    :
++#endif
++      tablesize(0),
+       tableptr(NULL),
+       flag_mode(FLAG_CHAR),
+       complexprefixes(0),
+@@ -97,8 +103,14 @@ HashMgr::HashMgr(const char* tpath, const char* apath, const char* key)
+       aliasm(NULL) {
+   langnum = 0;
+   csconv = 0;
++#ifdef HUNSPELL_CHROME_CLIENT
++  // No tables to load, just the AF lines.
++  load_config(NULL, NULL);
++  int ec = LoadAFLines();
++#else
+   load_config(apath, key);
+   int ec = load_tables(tpath, key);
++#endif
+   if (ec) {
+     /* error condition - what should we do here */
+     HUNSPELL_WARNING(stderr, "Hash Manager Error : %d\n", ec);
+@@ -156,14 +168,57 @@ HashMgr::~HashMgr() {
+ #endif
+ #endif
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++  EmptyHentryCache();
++  for (std::vector<std::string*>::iterator it = pointer_to_strings_.begin();
++       it != pointer_to_strings_.end(); ++it) {
++    delete *it;
++  }
++#endif
+ #ifdef MOZILLA_CLIENT
+   delete[] csconv;
+ #endif
+ }
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++void HashMgr::EmptyHentryCache() {
++  // We need to delete each cache entry, and each additional one in the linked
++  // list of homonyms.
++  for (HEntryCache::iterator i = hentry_cache.begin();
++       i != hentry_cache.end(); ++i) {
++    hentry* cur = i->second;
++    while (cur) {
++      hentry* next = cur->next_homonym;
++      DeleteHashEntry(cur);
++      cur = next;
++    }
++  }
++  hentry_cache.clear();
++}
++#endif
++
+ // lookup a root word in the hashtable
+ 
+ struct hentry* HashMgr::lookup(const char* word) const {
++#ifdef HUNSPELL_CHROME_CLIENT
++  int affix_ids[hunspell::BDict::MAX_AFFIXES_PER_WORD];
++  int affix_count = bdict_reader->FindWord(word, affix_ids);
++  if (affix_count == 0) { // look for custom added word
++    std::map<std::string_view, int>::const_iterator iter = 
++      custom_word_to_affix_id_map_.find(word);
++    if (iter != custom_word_to_affix_id_map_.end()) {
++      affix_count = 1;
++      affix_ids[0] = iter->second;
++    }
++  }
++
++  static const int kMaxWordLen = 128;
++  static char word_buf[kMaxWordLen];
++  // To take account of null-termination, we use upto 127.
++  strncpy(word_buf, word, kMaxWordLen - 1);
++
++  return AffixIDsToHentry(word_buf, affix_ids, affix_count);
++#else
+   struct hentry* dp;
+   if (tableptr) {
+     dp = tableptr[hash(word)];
+@@ -175,6 +230,7 @@ struct hentry* HashMgr::lookup(const char* word) const {
+     }
+   }
+   return NULL;
++#endif
+ }
+ 
+ // add a word to the hash table (private)
+@@ -185,6 +241,8 @@ int HashMgr::add_word(const std::string& in_word,
+                       const std::string* in_desc,
+                       bool onlyupcase,
+                       int captype) {
++// TODO: The following 40 lines or so are actually new. Should they be included?
++#ifndef HUNSPELL_CHROME_CLIENT
+   const std::string* word = &in_word;
+   const std::string* desc = in_desc;
+ 
+@@ -416,6 +474,17 @@ int HashMgr::add_word(const std::string& in_word,
+ 
+   delete desc_copy;
+   delete word_copy;
++#else
++  std::map<std::string_view, int>::iterator iter =
++      custom_word_to_affix_id_map_.find(in_word);
++  if (iter == custom_word_to_affix_id_map_.end()) {  // word needs to be added
++    std::string* new_string_word = new std::string(in_word);
++    pointer_to_strings_.push_back(new_string_word);
++    std::string_view sp(*(new_string_word));
++    custom_word_to_affix_id_map_[sp] = 0; // no affixes for custom words
++    return 1;
++  }
++#endif
+   return 0;
+ }
+ 
+@@ -480,6 +549,12 @@ int HashMgr::get_clen_and_captype(const std::string& word, int* captype) {
+ 
+ // remove word (personal dictionary function for standalone applications)
+ int HashMgr::remove(const std::string& word) {
++#ifdef HUNSPELL_CHROME_CLIENT
++  std::map<std::string_view, int>::iterator iter =
++      custom_word_to_affix_id_map_.find(word);
++  if (iter != custom_word_to_affix_id_map_.end())
++      custom_word_to_affix_id_map_.erase(iter);
++#else
+   struct hentry* dp = lookup(word.c_str());
+   while (dp) {
+     if (dp->alen == 0 || !TESTAFF(dp->astr, forbiddenword, dp->alen)) {
+@@ -497,6 +572,7 @@ int HashMgr::remove(const std::string& word) {
+     }
+     dp = dp->next_homonym;
+   }
++#endif
+   return 0;
+ }
+ 
+@@ -555,6 +631,44 @@ int HashMgr::add_with_affix(const std::string& word, const std::string& example)
+ // walk the hash table entry by entry - null at end
+ // initialize: col=-1; hp = NULL; hp = walk_hashtable(&col, hp);
+ struct hentry* HashMgr::walk_hashtable(int& col, struct hentry* hp) const {
++#ifdef HUNSPELL_CHROME_CLIENT
++  // Return NULL if dictionary is not valid.
++  if (!bdict_reader->IsValid())
++    return NULL;
++
++  // This function is only ever called by one place and not nested. We can
++  // therefore keep static state between calls and use |col| as a "reset" flag
++  // to avoid changing the API. It is set to -1 for the first call.
++  // Allocate the iterator on the heap to prevent an exit time destructor.
++  static hunspell::WordIterator& word_iterator =
++      *new hunspell::WordIterator(bdict_reader->GetAllWordIterator());
++  if (col < 0) {
++    col = 1;
++    word_iterator = bdict_reader->GetAllWordIterator();
++  }
++
++  int affix_ids[hunspell::BDict::MAX_AFFIXES_PER_WORD];
++  static const int kMaxWordLen = 128;
++  static char word[kMaxWordLen];
++  int affix_count = word_iterator.Advance(word, kMaxWordLen, affix_ids);
++  if (affix_count == 0)
++    return NULL;
++  short word_len = static_cast<short>(strlen(word));
++
++  // Since hunspell 1.2.8, an hentry struct becomes a variable-length struct,
++  // i.e. a struct which uses its array 'word[1]' as a variable-length array.
++  // As noted above, this function is not nested. So, we just use a static
++  // struct which consists of an hentry and a char[kMaxWordLen], and initialize
++  // the static struct and return it for now.
++  // No need to create linked lists for the extra affixes.
++  static struct {
++    hentry entry;
++    char word[kMaxWordLen];
++  } hash_entry;
++
++  return InitHashEntry(&hash_entry.entry, sizeof(hash_entry),
++                       &word[0], word_len, affix_ids[0]);
++#else
+   if (hp && hp->next != NULL)
+     return hp->next;
+   for (col++; col < tablesize; col++) {
+@@ -564,10 +678,12 @@ struct hentry* HashMgr::walk_hashtable(int& col, struct hentry* hp) const {
+   // null at end and reset to start
+   col = -1;
+   return NULL;
++#endif
+ }
+ 
+ // load a munched word list and build a hash table on the fly
+ int HashMgr::load_tables(const char* tpath, const char* key) {
++#ifndef HUNSPELL_CHROME_CLIENT
+   // open dictionary file
+   FileMgr* dict = new FileMgr(tpath, key);
+   if (dict == NULL)
+@@ -698,12 +814,16 @@ int HashMgr::load_tables(const char* tpath, const char* key) {
+   }
+ 
+   delete dict;
++#endif
+   return 0;
+ }
+ 
+ // the hash function is a simple load and rotate
+ // algorithm borrowed
+ int HashMgr::hash(const char* word) const {
++#ifdef HUNSPELL_CHROME_CLIENT
++    return 0;
++#else
+   unsigned long hv = 0;
+   for (int i = 0; i < 4 && *word != 0; i++)
+     hv = (hv << 8) | (*word++);
+@@ -712,6 +832,7 @@ int HashMgr::hash(const char* word) const {
+     hv ^= (*word++);
+   }
+   return (unsigned long)hv % tablesize;
++#endif
+ }
+ 
+ int HashMgr::decode_flags(unsigned short** result, const std::string& flags, FileMgr* af) const {
+@@ -921,7 +1042,12 @@ int HashMgr::load_config(const char* affpath, const char* key) {
+   int firstline = 1;
+ 
+   // open the affix file
++#ifdef HUNSPELL_CHROME_CLIENT
++  hunspell::LineIterator iterator = bdict_reader->GetOtherLineIterator();
++  FileMgr * afflst = new FileMgr(&iterator);
++#else
+   FileMgr* afflst = new FileMgr(affpath, key);
++#endif
+   if (!afflst) {
+     HUNSPELL_WARNING(
+         stderr, "Error - could not open affix description file %s\n", affpath);
+@@ -1161,6 +1287,132 @@ bool HashMgr::parse_aliasf(const std::string& line, FileMgr* af) {
+   return true;
+ }
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++int HashMgr::LoadAFLines()
++{
++  utf8 = 1;  // We always use UTF-8.
++
++  // Read in all the AF lines which tell us the rules for each affix group ID.
++  hunspell::LineIterator iterator = bdict_reader->GetAfLineIterator();
++  FileMgr afflst(&iterator);
++  std::string line;
++  while (afflst.getline(line)) {
++    int rv = parse_aliasf(line, &afflst);
++    if (rv)
++      return rv;
++  }
++
++  return 0;
++}
++
++hentry* HashMgr::InitHashEntry(hentry* entry,
++                               size_t item_size,
++                               const char* word,
++                               int word_length,
++                               int affix_index) const {
++  // Return if the given buffer doesn't have enough space for a hentry struct
++  // or the given word is too long.
++  // Our BDICT cannot handle words longer than (128 - 1) bytes. So, it is
++  // better to return an error if the given word is too long and prevent
++  // an unexpected result caused by a long word.
++  const int kMaxWordLen = 128;
++  if (item_size < sizeof(hentry) + word_length + 1 ||
++      word_length >= kMaxWordLen)
++    return NULL;
++
++  // Initialize a hentry struct with the given parameters, and
++  // append the given string at the end of this hentry struct.
++  memset(entry, 0, item_size);
++
++  // `get_aliasf` only uses the dictionary file in the case of an error.
++  // Should that occur, `FileMgr::getlinenum` is called. But for a BDICT file,
++  // the line number doesn't help identify the place which caused the parser
++  // error. As a result, `getlinenum` always returns 0. Since we don't actually
++  // need the dictionary file, and since `InitHashEntry` is called for every
++  // dictionary entry, eliminate the overhead of creating the `FileMgr` object
++  // every time.
++  static FileMgr dummyDictionaryFile(NULL);
++  entry->alen = static_cast<short>(const_cast<HashMgr*>(this)->get_aliasf(
++      affix_index, &entry->astr, &dummyDictionaryFile));
++  entry->blen = static_cast<unsigned char>(word_length);
++  std::vector<w_char> w;
++  entry->clen = u8_u16(w, word);
++  memcpy(&entry->word, word, word_length);
++
++  return entry;
++}
++
++hentry* HashMgr::CreateHashEntry(const char* word,
++                                 int word_length,
++                                 int affix_index) const {
++  // Return if the given word is too long.
++  // (See the comment in HashMgr::InitHashEntry().)
++  const int kMaxWordLen = 128;
++  if (word_length >= kMaxWordLen)
++    return NULL;
++
++  const size_t kEntrySize = sizeof(hentry) + word_length + 1;
++  struct hentry* entry = reinterpret_cast<hentry*>(malloc(kEntrySize));
++  if (entry)
++    InitHashEntry(entry, kEntrySize, word, word_length, affix_index);
++
++  return entry;
++}
++
++void HashMgr::DeleteHashEntry(hentry* entry) const {
++  free(entry);
++}
++
++hentry* HashMgr::AffixIDsToHentry(char* word,
++                                  int* affix_ids, 
++                                  int affix_count) const
++{
++  if (affix_count == 0)
++    return NULL;
++
++  HEntryCache& cache = const_cast<HashMgr*>(this)->hentry_cache;
++  std::string std_word(word);
++  HEntryCache::iterator found = cache.find(std_word);
++  if (found != cache.end()) {
++    // We must return an existing hentry for the same word if we've previously
++    // handed one out. Hunspell will compare pointers in some cases to see if
++    // two words it has found are the same.
++    return found->second;
++  }
++
++  short word_len = static_cast<short>(strlen(word));
++
++  // We can get a number of prefixes per word. There will normally be only one,
++  // but if not, there will be a linked list of "hentry"s for the "homonym"s 
++  // for the word.
++  struct hentry* first_he = NULL;
++  struct hentry* prev_he = NULL;  // For making linked list.
++  for (int i = 0; i < affix_count; i++) {
++    struct hentry* he = CreateHashEntry(word, word_len, affix_ids[i]);
++    if (!he)
++      break;
++    if (i == 0)
++      first_he = he;
++    if (prev_he)
++      prev_he->next_homonym = he;
++    prev_he = he;
++  }
++
++  cache[std_word] = first_he;  // Save this word in the cache for later.
++  return first_he;
++}
++
++hentry* HashMgr::GetHentryFromHEntryCache(char* word) {
++  HEntryCache& cache = const_cast<HashMgr*>(this)->hentry_cache;
++  std::string std_word(word);
++  HEntryCache::iterator found = cache.find(std_word);
++  if (found != cache.end())
++    return found->second;
++  else
++    return NULL;
++}
++#endif
++
+ int HashMgr::is_aliasf() const {
+   return (aliasf != NULL);
+ }
+diff --git a/src/hunspell/hashmgr.hxx b/src/hunspell/hashmgr.hxx
+index b6eaddd..7328b4c 100644
+--- a/src/hunspell/hashmgr.hxx
++++ b/src/hunspell/hashmgr.hxx
+@@ -79,6 +79,13 @@
+ #include "filemgr.hxx"
+ #include "w_char.hxx"
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++#include <map>
++#include <string_view>
++
++#include "third_party/hunspell/google/bdict_reader.h"
++#endif
++
+ enum flag { FLAG_CHAR, FLAG_LONG, FLAG_NUM, FLAG_UNI };
+ 
+ // morphological description of a dictionary item can contain
+@@ -88,6 +95,12 @@ enum flag { FLAG_CHAR, FLAG_LONG, FLAG_NUM, FLAG_UNI };
+ #define MORPH_PHON_RATIO 500
+ 
+ class HashMgr {
++#ifdef HUNSPELL_CHROME_CLIENT
++  // Not owned by this class, owned by the Hunspell object.
++  hunspell::BDictReader* bdict_reader;
++  std::map<std::string_view, int> custom_word_to_affix_id_map_;
++  std::vector<std::string*> pointer_to_strings_;
++#endif
+   int tablesize;
+   struct hentry** tableptr;
+   flag flag_mode;
+@@ -111,7 +124,23 @@ class HashMgr {
+   std::vector<replentry> reptable;
+ 
+  public:
++#ifdef HUNSPELL_CHROME_CLIENT
++  HashMgr(hunspell::BDictReader* reader);
++
++  // Return the hentry corresponding to the given word. Returns NULL if the
++  // word is not there in the cache.
++  hentry* GetHentryFromHEntryCache(char* word);
++
++  // Called before we do a new operation. This will empty the cache of pointers
++  // to hentries that we have cached. In Chrome, we make these on-demand, but
++  // they must live as long as the single spellcheck operation that they're part
++  // of since Hunspell will save pointers to various ones as it works.
++  //
++  // This function allows that cache to be emptied and not grow infinitely.
++  void EmptyHentryCache();
++#else
+   HashMgr(const char* tpath, const char* apath, const char* key = NULL);
++#endif
+   ~HashMgr();
+ 
+   struct hentry* lookup(const char*) const;
+@@ -144,6 +173,40 @@ class HashMgr {
+                int captype);
+   int load_config(const char* affpath, const char* key);
+   bool parse_aliasf(const std::string& line, FileMgr* af);
++
++#ifdef HUNSPELL_CHROME_CLIENT
++  // Loads the AF lines from a BDICT.
++  // A BDICT file compresses its AF lines to save memory.
++  // This function decompresses each AF line and call parse_aliasf().
++  int LoadAFLines();
++
++  // Helper functions that create a new hentry struct, initialize it, and
++  // delete it.
++  // These functions encapsulate non-trivial operations in creating and
++  // initializing a hentry struct from BDICT data to avoid changing code so much
++  // even when a hentry struct is changed.
++  hentry* InitHashEntry(hentry* entry,
++                        size_t item_size,
++                        const char* word,
++                        int word_length,
++                        int affix_index) const;
++  hentry* CreateHashEntry(const char* word,
++                          int word_length,
++                          int affix_index) const;
++  void DeleteHashEntry(hentry* entry) const;
++
++  // Converts the list of affix IDs to a linked list of hentry structures. The
++  // hentry structures will point to the given word. The returned pointer will
++  // be a statically allocated variable that will change for the next call. The
++  // |word| buffer must be the same.
++  hentry* AffixIDsToHentry(char* word, int* affix_ids, int affix_count) const;
++
++  // See EmptyHentryCache above. Note that each one is actually a linked list
++  // followed by the homonym pointer.
++  typedef std::map<std::string, hentry*> HEntryCache;
++  HEntryCache hentry_cache;
++#endif
++
+   int add_hidden_capitalized_word(const std::string& word,
+                                   int wcl,
+                                   unsigned short* flags,
+diff --git a/src/hunspell/htypes.hxx b/src/hunspell/htypes.hxx
+index 8e03a03..f96ea1d 100644
+--- a/src/hunspell/htypes.hxx
++++ b/src/hunspell/htypes.hxx
+@@ -38,6 +38,16 @@
+ #ifndef HTYPES_HXX_
+ #define HTYPES_HXX_
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++// This is a workaround for preventing errors in parsing Turkish BDICs, which
++// contain very long AF lines (~ 12,000 chars).
++// TODO(hbono) change the HashMgr::parse_aliasf() function to be able to parse
++// longer lines than MAXDELEN.
++#define MAXDELEN    (8192 * 2)
++#else
++#define MAXDELEN    8192
++#endif  // HUNSPELL_CHROME_CLIENT
++
+ #define ROTATE_LEN 5
+ 
+ #define ROTATE(v, q) \
+diff --git a/src/hunspell/hunspell.cxx b/src/hunspell/hunspell.cxx
+index 35266c9..bab2ff2 100644
+--- a/src/hunspell/hunspell.cxx
++++ b/src/hunspell/hunspell.cxx
+@@ -77,19 +77,28 @@
+ #include "hunspell.hxx"
+ #include "suggestmgr.hxx"
+ #include "hunspell.h"
++#ifndef HUNSPELL_CHROME_CLIENT
++#    include "config.h"
++#endif
+ #include "csutil.hxx"
+ 
+ #include <limits>
+ #include <string>
+ 
+-#define MAXWORDUTF8LEN (MAXWORDLEN * 3)
++#define MAXWORDUTF8LEN (MAXWORDLEN * 2)
+ 
+ class HunspellImpl
+ {
+ public:
++#ifdef HUNSPELL_CHROME_CLIENT
++  explicit HunspellImpl(base::span<const unsigned char> bdict_data);
++#else
+   HunspellImpl(const char* affpath, const char* dpath, const char* key = NULL);
++#endif
+   ~HunspellImpl();
++#ifndef HUNSPELL_CHROME_CLIENT
+   int add_dic(const char* dpath, const char* key = NULL);
++#endif
+   std::vector<std::string> suffix_suggest(const std::string& root_word);
+   std::vector<std::string> generate(const std::string& word, const std::vector<std::string>& pl);
+   std::vector<std::string> generate(const std::string& word, const std::string& pattern);
+@@ -127,7 +136,9 @@ private:
+   AffixMgr* pAMgr;
+   std::vector<HashMgr*> m_HMgrs;
+   SuggestMgr* pSMgr;
++#ifndef HUNSPELL_CHROME_CLIENT // We are using BDict instead.
+   char* affixpath;
++#endif
+   std::string encoding;
+   struct cs_info* csconv;
+   int langnum;
+@@ -135,6 +146,11 @@ private:
+   int complexprefixes;
+   std::vector<std::string> wordbreak;
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++  // Not owned by us, owned by the Hunspell object.
++  hunspell::BDictReader* bdict_reader;
++#endif
++
+ private:
+   std::vector<std::string> analyze_internal(const std::string& word);
+   bool spell_internal(const std::string& word, int* info = NULL, std::string* root = NULL);
+@@ -169,18 +185,34 @@ private:
+   HunspellImpl& operator=(const HunspellImpl&);
+ };
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++HunspellImpl::HunspellImpl(base::span<const unsigned char> bdict_data) {
++#else
+ HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* key) {
++#endif
+   csconv = NULL;
+   utf8 = 0;
+   complexprefixes = 0;
++#ifndef HUNSPELL_CHROME_CLIENT
+   affixpath = mystrdup(affpath);
++#endif
++
++#ifdef HUNSPELL_CHROME_CLIENT
++  bdict_reader = new hunspell::BDictReader;
++  bdict_reader->Init(bdict_data);
++
++  /* first set up the hash manager */
++  m_HMgrs.push_back(new HashMgr(bdict_reader));
+ 
++  pAMgr = new AffixMgr(bdict_reader, m_HMgrs); // TODO: 'key' ?
++#else
+   /* first set up the hash manager */
+   m_HMgrs.push_back(new HashMgr(dpath, affpath, key));
+ 
+   /* next set up the affix manager */
+   /* it needs access to the hash manager lookup methods */
+   pAMgr = new AffixMgr(affpath, m_HMgrs, key);
++#endif
+ 
+   /* get the preferred try string and the dictionary */
+   /* encoding from the Affix Manager for that dictionary */
+@@ -194,7 +226,11 @@ HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* k
+   wordbreak = pAMgr->get_breaktable();
+ 
+   /* and finally set up the suggestion manager */
++#ifdef HUNSPELL_CHROME_CLIENT
++  pSMgr = new SuggestMgr(bdict_reader, try_string, MAXSUGGESTION, pAMgr);
++#else
+   pSMgr = new SuggestMgr(try_string, MAXSUGGESTION, pAMgr);
++#endif
+   if (try_string)
+     free(try_string);
+ }
+@@ -210,11 +246,17 @@ HunspellImpl::~HunspellImpl() {
+   delete[] csconv;
+ #endif
+   csconv = NULL;
++#ifdef HUNSPELL_CHROME_CLIENT
++    if (bdict_reader) delete bdict_reader;
++    bdict_reader = NULL;
++#else
+   if (affixpath)
+     free(affixpath);
+   affixpath = NULL;
++#endif
+ }
+ 
++#ifndef HUNSPELL_CHROME_CLIENT
+ // load extra dictionaries
+ int HunspellImpl::add_dic(const char* dpath, const char* key) {
+   if (!affixpath)
+@@ -222,6 +264,7 @@ int HunspellImpl::add_dic(const char* dpath, const char* key) {
+   m_HMgrs.push_back(new HashMgr(dpath, affixpath, key));
+   return 0;
+ }
++#endif
+ 
+ 
+ // make a copy of src at dest while removing all characters
+@@ -450,6 +493,9 @@ bool HunspellImpl::spell(const std::string& word, int* info, std::string* root)
+ }
+ 
+ bool HunspellImpl::spell_internal(const std::string& word, int* info, std::string* root) {
++#ifdef HUNSPELL_CHROME_CLIENT
++  if (m_HMgrs[0]) m_HMgrs[0]->EmptyHentryCache();
++#endif
+   struct hentry* rv = NULL;
+ 
+   int info2 = 0;
+@@ -785,6 +831,13 @@ struct hentry* HunspellImpl::checkword(const std::string& w, int* info, std::str
+   if (!len)
+     return NULL;
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++  // We need to check if the word length is valid to make coverity (Event
++  // fixed_size_dest: Possible overrun of N byte fixed size buffer) happy.
++  if ((utf8 && strlen(word) >= MAXWORDUTF8LEN) || (!utf8 && strlen(word) >= MAXWORDLEN))
++    return NULL;
++#endif
++
+   // word reversing wrapper for complex prefixes
+   if (complexprefixes) {
+     if (!usebuffer) {
+@@ -985,6 +1038,9 @@ std::vector<std::string> HunspellImpl::suggest(const std::string& word) {
+ 
+ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
+         bool& capwords, size_t& abbv, int& captype) {
++#ifdef HUNSPELL_CHROME_CLIENT
++  if (m_HMgrs[0]) m_HMgrs[0]->EmptyHentryCache();
++#endif
+   captype = NOCAP;
+   abbv = 0;
+   capwords = false;
+@@ -2021,18 +2077,25 @@ int HunspellImpl::input_conv(const char* word, char* dest, size_t destsize) {
+   return 0;
+ }
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++Hunspell::Hunspell(base::span<const unsigned char> bdict_data)
++  : m_Impl(new HunspellImpl(bdict_data)) {
++#else
+ Hunspell::Hunspell(const char* affpath, const char* dpath, const char* key)
+   : m_Impl(new HunspellImpl(affpath, dpath, key)) {
++#endif
+ }
+ 
+ Hunspell::~Hunspell() {
+   delete m_Impl;
+ }
+ 
++#ifndef HUNSPELL_CHROME_CLIENT
+ // load extra dictionaries
+ int Hunspell::add_dic(const char* dpath, const char* key) {
+   return m_Impl->add_dic(dpath, key);
+ }
++#endif
+ 
+ bool Hunspell::spell(const std::string& word, int* info, std::string* root) {
+   return m_Impl->spell(word, info, root);
+@@ -2159,22 +2222,32 @@ int Hunspell::input_conv(const char* word, char* dest, size_t destsize) {
+ }
+ 
+ Hunhandle* Hunspell_create(const char* affpath, const char* dpath) {
++#ifdef HUNSPELL_CHROME_CLIENT
++        return NULL;
++#else
+   return reinterpret_cast<Hunhandle*>(new HunspellImpl(affpath, dpath));
++#endif
+ }
+ 
+ Hunhandle* Hunspell_create_key(const char* affpath,
+                                const char* dpath,
+                                const char* key) {
++#ifdef HUNSPELL_CHROME_CLIENT
++        return NULL;
++#else
+   return reinterpret_cast<Hunhandle*>(new HunspellImpl(affpath, dpath, key));
++#endif
+ }
+ 
+ void Hunspell_destroy(Hunhandle* pHunspell) {
+   delete reinterpret_cast<HunspellImpl*>(pHunspell);
+ }
+ 
++#ifndef HUNSPELL_CHROME_CLIENT
+ int Hunspell_add_dic(Hunhandle* pHunspell, const char* dpath) {
+   return reinterpret_cast<HunspellImpl*>(pHunspell)->add_dic(dpath);
+ }
++#endif
+ 
+ int Hunspell_spell(Hunhandle* pHunspell, const char* word) {
+   return reinterpret_cast<HunspellImpl*>(pHunspell)->spell(word);
+diff --git a/src/hunspell/hunspell.hxx b/src/hunspell/hunspell.hxx
+index a06bdd4..d3c2689 100644
+--- a/src/hunspell/hunspell.hxx
++++ b/src/hunspell/hunspell.hxx
+@@ -76,9 +76,14 @@
+ #include <string>
+ #include <vector>
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++#include "base/containers/span.h"
++#include "third_party/hunspell/google/bdict_reader.h"
++#endif
++
+ #define SPELL_XML "<?xml?>"
+ 
+-#define MAXSUGGESTION 15
++#define MAXSUGGESTION 5
+ #define MAXSHARPS 5
+ 
+ #ifndef MAXWORDLEN
+@@ -112,11 +117,17 @@ class LIBHUNSPELL_DLL_EXPORTED Hunspell {
+    * long path names (without the long path prefix Hunspell will use fopen()
+    * with system-dependent character encoding instead of _wfopen()).
+    */
++#ifdef HUNSPELL_CHROME_CLIENT
++  explicit Hunspell(base::span<const unsigned char> bdict_data);
++#else
+   Hunspell(const char* affpath, const char* dpath, const char* key = NULL);
++#endif
+   ~Hunspell();
+ 
++#ifndef HUNSPELL_CHROME_CLIENT
+   /* load extra dictionaries (only dic files) */
+   int add_dic(const char* dpath, const char* key = NULL);
++#endif
+ 
+   /* spell(word) - spellcheck word
+    * output: false = bad word, true = good word
+diff --git a/src/hunspell/replist.cxx b/src/hunspell/replist.cxx
+index cabe382..a6dc708 100644
+--- a/src/hunspell/replist.cxx
++++ b/src/hunspell/replist.cxx
+@@ -161,6 +161,7 @@ int RepList::add(const std::string& in_pat1, const std::string& pat2) {
+   mystrrep(r->outstrings[type], "_", " ");
+   dat[pos++] = r;
+   // sort to the right place in the list
++#if 0
+   int i;
+   for (i = pos - 1; i > 0; i--) {
+     if (strcmp(r->pattern.c_str(), dat[i - 1]->pattern.c_str()) < 0) {
+@@ -169,6 +170,15 @@ int RepList::add(const std::string& in_pat1, const std::string& pat2) {
+       break;
+   }
+   dat[i] = r;
++#else
++  for (int i = pos - 1; i > 0; i--) {
++    r = dat[i];
++    if (r->pattern < dat[i - 1]->pattern) {
++      dat[i] = dat[i - 1];
++      dat[i - 1] = r;
++    } else break;
++  }
++#endif
+   return 0;
+ }
+ 
+diff --git a/src/hunspell/replist.hxx b/src/hunspell/replist.hxx
+index 1e3efa4..c35a373 100644
+--- a/src/hunspell/replist.hxx
++++ b/src/hunspell/replist.hxx
+@@ -72,6 +72,12 @@
+ #ifndef REPLIST_HXX_
+ #define REPLIST_HXX_
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++// Compilation issues in spellchecker.cc think near is a macro, therefore
++// removing it here solves that problem.
++#undef near
++#endif
++
+ #include "w_char.hxx"
+ 
+ #include <string>
+diff --git a/src/hunspell/suggestmgr.cxx b/src/hunspell/suggestmgr.cxx
+index dba084e..a37100d 100644
+--- a/src/hunspell/suggestmgr.cxx
++++ b/src/hunspell/suggestmgr.cxx
+@@ -82,7 +82,112 @@ const w_char W_VLINE = {'\0', '|'};
+ 
+ #define MAX_CHAR_DISTANCE 4
+ 
++#ifdef HUNSPELL_CHROME_CLIENT
++namespace {
++// A simple class which creates temporary hentry objects which are available
++// only in a scope. To conceal memory operations from SuggestMgr functions,
++// this object automatically deletes all hentry objects created through
++// CreateScopedHashEntry() calls in its destructor. So, the following snippet
++// raises a memory error.
++//
++//   hentry* bad_copy = NULL;
++//   {
++//     ScopedHashEntryFactory factory;
++//     hentry* scoped_copy = factory.CreateScopedHashEntry(0, source);
++//     ...
++//     bad_copy = scoped_copy;
++//   }
++//   if (bad_copy->word[0])  // memory for scoped_copy has been deleted!
++//
++// As listed in the above snippet, it is simple to use this class.
++// 1. Declare an instance of this ScopedHashEntryFactory, and;
++// 2. Call its CreateHashEntry() member instead of using 'new hentry' or
++//    'operator='.
++//
++class ScopedHashEntryFactory {
++ public:
++  ScopedHashEntryFactory();
++  ~ScopedHashEntryFactory();
++
++  // Creates a temporary copy of the given hentry struct.
++  // The returned copy is available only while this object is available.
++  // NOTE: this function just calls memcpy() in creating a copy of the given
++  // hentry struct, i.e. it does NOT copy objects referred by pointers of the
++  // given hentry struct.
++  hentry* CreateScopedHashEntry(int index, const hentry* source);
++
++ private:
++  // A struct which encapsulates the new hentry struct introduced in hunspell
++  // 1.2.8. For a pointer to an hentry struct 'h', hunspell 1.2.8 stores a word
++  // (including a NUL character) into 'h->word[0]',...,'h->word[h->blen]' even
++  // though arraysize(h->word[]) is 1. Also, it changed 'astr' to a pointer so
++  // it can store affix flags into 'h->astr[0]',...,'h->astr[alen-1]'. To handle
++  // this new hentry struct, we define a struct which combines three values: an
++  // hentry struct 'hentry'; a char array 'word[kMaxWordLen]', and; an unsigned
++  // short array 'astr' so a hentry struct 'h' returned from
++  // CreateScopedHashEntry() satisfies the following equations:
++  //   hentry* h = factory.CreateScopedHashEntry(0, source);
++  //   h->word[0] == ((HashEntryItem*)h)->entry.word[0].
++  //   h->word[1] == ((HashEntryItem*)h)->word[0].
++  //   ...
++  //   h->word[h->blen] == ((HashEntryItem*)h)->word[h->blen-1].
++  //   h->astr[0] == ((HashEntryItem*)h)->astr[0].
++  //   h->astr[1] == ((HashEntryItem*)h)->astr[1].
++  //   ...
++  //   h->astr[h->alen-1] == ((HashEntryItem*)h)->astr[h->alen-1].
++  enum {
++    kMaxWordLen = 128,
++    kMaxAffixLen = 8,
++  };
++  struct HashEntryItem {
++    hentry entry;
++    char word[kMaxWordLen];
++    unsigned short astr[kMaxAffixLen];
++  };
++
++  HashEntryItem hash_items_[MAX_ROOTS];
++};
++
++ScopedHashEntryFactory::ScopedHashEntryFactory() {
++  memset(&hash_items_[0], 0, sizeof(hash_items_));
++}
++
++ScopedHashEntryFactory::~ScopedHashEntryFactory() {
++}
++
++hentry* ScopedHashEntryFactory::CreateScopedHashEntry(int index,
++                                                      const hentry* source) {
++  if (index >= MAX_ROOTS || source->blen >= kMaxWordLen)
++    return NULL;
++
++  // Retrieve a HashEntryItem struct from our spool, initialize it, and
++  // returns the address of its 'hentry' member.
++  size_t source_size = sizeof(hentry) + source->blen + 1;
++  HashEntryItem* hash_item = &hash_items_[index];
++  memcpy(&hash_item->entry, source, source_size);
++  if (source->astr) {
++    hash_item->entry.alen = source->alen;
++    if (hash_item->entry.alen > kMaxAffixLen)
++      hash_item->entry.alen = kMaxAffixLen;
++    memcpy(hash_item->astr, source->astr, hash_item->entry.alen * sizeof(hash_item->astr[0]));
++    hash_item->entry.astr = &hash_item->astr[0];
++  }
++  return &hash_item->entry;
++}
++
++}  // namespace
++#endif
++
++
++#ifdef HUNSPELL_CHROME_CLIENT
++SuggestMgr::SuggestMgr(hunspell::BDictReader* reader,
++                       const char * tryme, int maxn, 
++                       AffixMgr * aptr)
++{
++  bdict_reader = reader;
++#else
+ SuggestMgr::SuggestMgr(const char* tryme, unsigned int maxn, AffixMgr* aptr) {
++#endif
+   // register affix manager and check in string of chars to
+   // try when building candidate suggestions
+   pAMgr = aptr;
+@@ -455,6 +560,21 @@ int SuggestMgr::replchars(std::vector<std::string>& wlst,
+   int wl = strlen(word);
+   if (wl < 2 || !pAMgr)
+     return wlst.size();
++
++// TODO: wrong, 'ns' doesn't exist any more
++#ifdef HUNSPELL_CHROME_CLIENT
++  const char *pattern, *pattern2;
++  hunspell::ReplacementIterator iterator = bdict_reader->GetReplacementIterator();
++  while (iterator.GetNext(&pattern, &pattern2)) {
++    const char* r = word;
++    size_t lenr = strlen(pattern2);
++    size_t lenp = strlen(pattern);
++
++    // search every occurence of the pattern in the word
++    while ((r=strstr(r, pattern)) != NULL) {
++      candidate = word;
++      candidate.replace(r-word, lenp, pattern2);
++#else
+   const std::vector<replentry>& reptable = pAMgr->get_reptable();
+   for (size_t i = 0; i < reptable.size(); ++i) {
+     const char* r = word;
+@@ -474,6 +594,7 @@ int SuggestMgr::replchars(std::vector<std::string>& wlst,
+       candidate.resize(r - word);
+       candidate.append(reptable[i].outstrings[type]);
+       candidate.append(r + reptable[i].pattern.size());
++#endif
+       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
+       // check REP suggestions with space
+       size_t sp = candidate.find(' ');
+@@ -1131,6 +1252,9 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
+ 
+   struct hentry* hp = NULL;
+   int col = -1;
++#ifdef HUNSPELL_CHROME_CLIENT
++  ScopedHashEntryFactory hash_entry_factory;
++#endif
+   phonetable* ph = (pAMgr) ? pAMgr->get_phonetable() : NULL;
+   std::string target;
+   std::string candidate;
+@@ -1257,7 +1381,11 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
+ 
+       if (sc > scores[lp]) {
+         scores[lp] = sc;
++#ifdef HUNSPELL_CHROME_CLIENT
++        roots[lp] = hash_entry_factory.CreateScopedHashEntry(lp, hp);
++#else
+         roots[lp] = hp;
++#endif
+         lval = sc;
+         for (int j = 0; j < MAX_ROOTS; j++)
+           if (scores[j] < lval) {
+@@ -2197,8 +2325,8 @@ void SuggestMgr::lcs(const char* s,
+     m = strlen(s);
+     n = strlen(s2);
+   }
+-  c = (char*)malloc((m + 1) * (n + 1));
+-  b = (char*)malloc((m + 1) * (n + 1));
++  c = (char *) calloc(m + 1, n + 1);
++  b = (char *) calloc(m + 1, n + 1);
+   if (!c || !b) {
+     if (c)
+       free(c);
+@@ -2207,10 +2335,6 @@ void SuggestMgr::lcs(const char* s,
+     *result = NULL;
+     return;
+   }
+-  for (i = 1; i <= m; i++)
+-    c[i * (n + 1)] = 0;
+-  for (j = 0; j <= n; j++)
+-    c[j] = 0;
+   for (i = 1; i <= m; i++) {
+     for (j = 1; j <= n; j++) {
+       if (((utf8) && (su[i - 1] == su2[j - 1])) ||
+diff --git a/src/hunspell/suggestmgr.hxx b/src/hunspell/suggestmgr.hxx
+index 7137be2..237d670 100644
+--- a/src/hunspell/suggestmgr.hxx
++++ b/src/hunspell/suggestmgr.hxx
+@@ -116,7 +116,11 @@ class SuggestMgr {
+   int complexprefixes;
+ 
+  public:
++#ifdef HUNSPELL_CHROME_CLIENT
++  SuggestMgr(hunspell::BDictReader* reader, const char * tryme, int maxn, AffixMgr *aptr);
++#else
+   SuggestMgr(const char* tryme, unsigned int maxn, AffixMgr* aptr);
++#endif
+   ~SuggestMgr();
+ 
+   bool suggest(std::vector<std::string>& slst, const char* word, int* onlycmpdsug);
+@@ -126,6 +130,10 @@ class SuggestMgr {
+   std::string suggest_gen(const std::vector<std::string>& pl, const std::string& pattern);
+ 
+  private:
++#ifdef HUNSPELL_CHROME_CLIENT
++   // Not owned by us, owned by the Hunspell object.
++   hunspell::BDictReader* bdict_reader;
++#endif
+   void testsug(std::vector<std::string>& wlst,
+                const std::string& candidate,
+                int cpdsuggest,
diff --git a/third_party/iaccessible2/set_selection_ranges.patch b/third_party/iaccessible2/set_selection_ranges.patch
new file mode 100644
index 0000000000000..2871ceed3d991
--- /dev/null
+++ b/third_party/iaccessible2/set_selection_ranges.patch
@@ -0,0 +1,467 @@
+diff --git a/third_party/iaccessible2/ia2_api_all.idl b/third_party/iaccessible2/ia2_api_all.idl
+index dd7ddf72b5ba1..c8b3f354d96d8 100644
+--- a/third_party/iaccessible2/ia2_api_all.idl
++++ b/third_party/iaccessible2/ia2_api_all.idl
+@@ -1324,7 +1324,8 @@ IA2_STATE_PINNED =					0x80000
+  @section _interfaces Interfaces
+   IAccessible2\n
+   IAccessible2_2\n
+-  IAccessible2_3 [Deprecated]\n
++  IAccessible2_3\n
++  IAccessible2_4\n
+   IAccessibleAction\n
+   IAccessibleApplication\n
+   IAccessibleComponent\n
+@@ -2085,6 +2086,81 @@ interface IAccessible2_2 : IAccessible2
+ 
+ }
+ 
++/**
++ * This structure represents a directional range of the content. It is defined
++ * by two points in the content, where each one is defined by an accessible
++ * object and an offset relative to it. A typical case of a range point is
++ * a text accessible and text offset within it.
++ *
++ * The "anchor" is one point of the range and typically remains constant.
++ * The other point is the "active" point, which typically corresponds to
++ * the user's focus or point of interest. The user moves the active point to
++ * expand or collapse the range. In most cases, anchor is the start of the range
++ * and active is the end. However, in case of selection, when selecting
++ * backwards (e.g. pressing shift+left arrow in a text field), the start of
++ * the range is the active point, as the user moves this to manipulate
++ * the selection.
++ */
++typedef struct IA2Range {
++  IUnknown* anchor;
++  long anchorOffset;
++  IUnknown* active;
++  long activeOffset;
++} IA2Range;
++
++/**
++ * @brief This interface is an extension of IAccessible2_2 and IAccessible2
++ * interfaces.
++ */
++[object, uuid(5BE18059-762E-4E73-9476-ABA294FED411)]
++interface IAccessible2_3 : IAccessible2_2
++{
++  /**
++   * @brief Returns an array of ranges for selections within the accessible.
++   * @param [out] ranges
++     The array of selection ranges, allocated by the server. The client must
++     free it with CoTaskMemFree.
++   * @param [out] nRanges
++     the array length
++   * @retval S_OK
++   * @retval S_FALSE returned if there is no selection within the accessible
++  */
++  [propget] HRESULT selectionRanges
++    (
++      [out, size_is(,*nRanges)] IA2Range **ranges,
++      [out, retval] long *nRanges
++    );
++}
++
++/**
++ * @brief This interface is an extension of IAccessible2_3 which exposes a
++ * single method for setting the current selection given a number of selection
++ * ranges.
++ *
++ * This interface is preliminary as it has not been adopted by any standard yet.
++ */
++[object, uuid(610a7bec-91bb-444d-a336-a0daf13c4c29)]
++interface IAccessible2_4 : IAccessible2_3
++{
++  /**
++   * @brief Sets the current selection to the provided ranges. The provided
++   * ranges don't need to be contained within this accessible.
++   * @param [in] nRanges
++   *     The length of the array containing the selection ranges.
++   * @param [in] ranges
++   *     The array of selection ranges, allocated by the client with
++   *     CoTaskMemAlloc and freed by the client with CoTaskMemFree.
++   * @retval S_OK Returned if the selection was made successfully.
++   * @retval S_FALSE Returned if the selection could not be made.
++   * @retval E_INVALIDARG Returned if any of the input arguments are invalid.
++   */
++  HRESULT setSelectionRanges
++  (
++      [in] long nRanges,
++      [in, size_is(nRanges)] IA2Range* ranges
++      );
++}
++
+ /*************************************************************************
+  *
+  *  File Name (AccessibleComponent.idl)
+@@ -2209,6 +2285,7 @@ interface IAccessibleComponent : IUnknown
+      [out, retval] IA2Color *background
+     );
+ }
++
+ /*************************************************************************
+  *
+  *  File Name (AccessibleValue.idl)
+@@ -5682,6 +5759,7 @@ library IAccessible2Lib
+     importlib ("oleacc.dll");
+     interface IAccessible2;
+     interface IAccessible2_2;
++    interface IAccessible2_3;
+     interface IAccessibleAction;
+     interface IAccessibleApplication;
+     interface IAccessibleComponent;
+diff --git a/third_party/iaccessible2/set_selection_ranges.patch b/third_party/iaccessible2/set_selection_ranges.patch
+index 17229419061ce..159ad89b234d2 100644
+--- a/third_party/iaccessible2/set_selection_ranges.patch
++++ b/third_party/iaccessible2/set_selection_ranges.patch
+@@ -1,19 +1,66 @@
+ diff --git a/third_party/iaccessible2/ia2_api_all.idl b/third_party/iaccessible2/ia2_api_all.idl
+-index 97bf11594646..07121230dc73 100644
++index dd7ddf72b5ba1..3c7ccf935f55e 100644
+ --- a/third_party/iaccessible2/ia2_api_all.idl
+ +++ b/third_party/iaccessible2/ia2_api_all.idl
+-@@ -1296,6 +1296,7 @@ IA2_STATE_PINNED =					0x80000
++@@ -1324,7 +1324,8 @@ IA2_STATE_PINNED =					0x80000
++  @section _interfaces Interfaces
+    IAccessible2\n
+    IAccessible2_2\n
+-   IAccessible2_3\n
++-  IAccessible2_3 [Deprecated]\n
+++  IAccessible2_3\n
+ +  IAccessible2_4\n
+    IAccessibleAction\n
+    IAccessibleApplication\n
+    IAccessibleComponent\n
+-@@ -2104,6 +2105,36 @@ interface IAccessible2_3 : IAccessible2_2
+-       [out, retval] long *nRanges
+-     );
++@@ -2085,6 +2086,81 @@ interface IAccessible2_2 : IAccessible2
++ 
+  }
++ 
+++/**
+++ * This structure represents a directional range of the content. It is defined
+++ * by two points in the content, where each one is defined by an accessible
+++ * object and an offset relative to it. A typical case of a range point is
+++ * a text accessible and text offset within it.
+++ *
+++ * The "anchor" is one point of the range and typically remains constant.
+++ * The other point is the "active" point, which typically corresponds to
+++ * the user's focus or point of interest. The user moves the active point to
+++ * expand or collapse the range. In most cases, anchor is the start of the range
+++ * and active is the end. However, in case of selection, when selecting
+++ * backwards (e.g. pressing shift+left arrow in a text field), the start of
+++ * the range is the active point, as the user moves this to manipulate
+++ * the selection.
+++ */
+++typedef struct IA2Range {
+++  IUnknown* anchor;
+++  long anchorOffset;
+++  IUnknown* active;
+++  long activeOffset;
+++} IA2Range;
+++
+++/**
+++ * @brief This interface is an extension of IAccessible2_2 and IAccessible2
+++ * interfaces.
+++ */
+++[object, uuid(5BE18059-762E-4E73-9476-ABA294FED411)]
+++interface IAccessible2_3 : IAccessible2_2
+++{
+++  /**
+++   * @brief Returns an array of ranges for selections within the accessible.
+++   * @param [out] ranges
+++     The array of selection ranges, allocated by the server. The client must
+++     free it with CoTaskMemFree.
+++   * @param [out] nRanges
+++     the array length
+++   * @retval S_OK
+++   * @retval S_FALSE returned if there is no selection within the accessible
+++  */
+++  [propget] HRESULT selectionRanges
+++    (
+++      [out, size_is(,*nRanges)] IA2Range **ranges,
+++      [out, retval] long *nRanges
+++    );
+++}
+ +
+ +/**
+ + * @brief This interface is an extension of IAccessible2_3 which exposes a
+@@ -47,3 +94,277 @@ index 97bf11594646..07121230dc73 100644
+  /*************************************************************************
+   *
+   *  File Name (AccessibleComponent.idl)
++@@ -2209,6 +2285,7 @@ interface IAccessibleComponent : IUnknown
++      [out, retval] IA2Color *background
++     );
++ }
+++
++ /*************************************************************************
++  *
++  *  File Name (AccessibleValue.idl)
++diff --git a/third_party/iaccessible2/set_selection_ranges.patch b/third_party/iaccessible2/set_selection_ranges.patch
++index 17229419061ce..688ea6c94f911 100644
++--- a/third_party/iaccessible2/set_selection_ranges.patch
+++++ b/third_party/iaccessible2/set_selection_ranges.patch
++@@ -1,21 +1,69 @@
++ diff --git a/third_party/iaccessible2/ia2_api_all.idl b/third_party/iaccessible2/ia2_api_all.idl
++-index 97bf11594646..07121230dc73 100644
+++index dd7ddf72b5ba1..cb32591e99b63 100644
++ --- a/third_party/iaccessible2/ia2_api_all.idl
++ +++ b/third_party/iaccessible2/ia2_api_all.idl
++-@@ -1296,6 +1296,7 @@ IA2_STATE_PINNED =					0x80000
+++@@ -1324,7 +1324,8 @@ IA2_STATE_PINNED =					0x80000
+++  @section _interfaces Interfaces
++    IAccessible2\n
++    IAccessible2_2\n
++-   IAccessible2_3\n
+++-  IAccessible2_3 [Deprecated]\n
++++  IAccessible2_3\n
++ +  IAccessible2_4\n
++    IAccessibleAction\n
++    IAccessibleApplication\n
++    IAccessibleComponent\n
++-@@ -2104,6 +2105,36 @@ interface IAccessible2_3 : IAccessible2_2
++-       [out, retval] long *nRanges
+++@@ -2209,6 +2210,82 @@ interface IAccessibleComponent : IUnknown
+++      [out, retval] IA2Color *background
++      );
++  }
++ +
++ +/**
++++ * This structure represents a directional range of the content. It is defined
++++ * by two points in the content, where each one is defined by an accessible
++++ * object and an offset relative to it. A typical case of a range point is
++++ * a text accessible and text offset within it.
++++ *
++++ * The "anchor" is one point of the range and typically remains constant.
++++ * The other point is the "active" point, which typically corresponds to
++++ * the user's focus or point of interest. The user moves the active point to
++++ * expand or collapse the range. In most cases, anchor is the start of the range
++++ * and active is the end. However, in case of selection, when selecting
++++ * backwards (e.g. pressing shift+left arrow in a text field), the start of
++++ * the range is the active point, as the user moves this to manipulate
++++ * the selection.
++++ */
++++typedef struct IA2Range {
++++  IUnknown* anchor;
++++  long anchorOffset;
++++  IUnknown* active;
++++  long activeOffset;
++++} IA2Range;
++++
++++/**
++++ * @brief This interface is an extension of IAccessible2_2 and IAccessible2
++++ * interfaces.
++++ */
++++[object, uuid(5BE18059-762E-4E73-9476-ABA294FED411)]
++++interface IAccessible2_3 : IAccessible2_2
++++{
++++  /**
++++   * @brief Returns an array of ranges for selections within the accessible.
++++   * @param [out] ranges
++++     The array of selection ranges, allocated by the server. The client must
++++     free it with CoTaskMemFree.
++++   * @param [out] nRanges
++++     the array length
++++   * @retval S_OK
++++   * @retval S_FALSE returned if there is no selection within the accessible
++++  */
++++  [propget] HRESULT selectionRanges
++++    (
++++      [out, size_is(,*nRanges)] IA2Range **ranges,
++++      [out, retval] long *nRanges
++++    );
++++}
++++
++++/**
++ + * @brief This interface is an extension of IAccessible2_3 which exposes a
++ + * single method for setting the current selection given a number of selection
++ + * ranges.
++@@ -46,4 +94,185 @@ index 97bf11594646..07121230dc73 100644
++ +
++  /*************************************************************************
++   *
++-  *  File Name (AccessibleComponent.idl)
+++  *  File Name (AccessibleValue.idl)
+++diff --git a/third_party/iaccessible2/set_selection_ranges.patch b/third_party/iaccessible2/set_selection_ranges.patch
+++index 17229419061ce..7105fa56ee2be 100644
+++--- a/third_party/iaccessible2/set_selection_ranges.patch
++++++ b/third_party/iaccessible2/set_selection_ranges.patch
+++@@ -1,21 +1,45 @@
+++ diff --git a/third_party/iaccessible2/ia2_api_all.idl b/third_party/iaccessible2/ia2_api_all.idl
+++-index 97bf11594646..07121230dc73 100644
++++index dd7ddf72b5ba1..dca6d6e201222 100644
+++ --- a/third_party/iaccessible2/ia2_api_all.idl
+++ +++ b/third_party/iaccessible2/ia2_api_all.idl
+++-@@ -1296,6 +1296,7 @@ IA2_STATE_PINNED =					0x80000
++++@@ -1324,7 +1324,8 @@ IA2_STATE_PINNED =					0x80000
++++  @section _interfaces Interfaces
+++    IAccessible2\n
+++    IAccessible2_2\n
+++-   IAccessible2_3\n
++++-  IAccessible2_3 [Deprecated]\n
+++++  IAccessible2_3\n
+++ +  IAccessible2_4\n
+++    IAccessibleAction\n
+++    IAccessibleApplication\n
+++    IAccessibleComponent\n
+++-@@ -2104,6 +2105,36 @@ interface IAccessible2_3 : IAccessible2_2
+++-       [out, retval] long *nRanges
++++@@ -2209,6 +2210,58 @@ interface IAccessibleComponent : IUnknown
++++      [out, retval] IA2Color *background
+++      );
+++  }
+++ +
+++ +/**
+++++ * This structure represents a directional range of the content. It is defined
+++++ * by two points in the content, where each one is defined by an accessible
+++++ * object and an offset relative to it. A typical case of a range point is
+++++ * a text accessible and text offset within it.
+++++ *
+++++ * The "anchor" is one point of the range and typically remains constant.
+++++ * The other point is the "active" point, which typically corresponds to
+++++ * the user's focus or point of interest. The user moves the active point to
+++++ * expand or collapse the range. In most cases, anchor is the start of the range
+++++ * and active is the end. However, in case of selection, when selecting
+++++ * backwards (e.g. pressing shift+left arrow in a text field), the start of
+++++ * the range is the active point, as the user moves this to manipulate
+++++ * the selection.
+++++ */
+++++typedef struct IA2Range {
+++++  IUnknown* anchor;
+++++  long anchorOffset;
+++++  IUnknown* active;
+++++  long activeOffset;
+++++} IA2Range;
+++++
+++++/**
+++ + * @brief This interface is an extension of IAccessible2_3 which exposes a
+++ + * single method for setting the current selection given a number of selection
+++ + * ranges.
+++@@ -46,4 +70,124 @@ index 97bf11594646..07121230dc73 100644
+++ +
+++  /*************************************************************************
+++   *
+++-  *  File Name (AccessibleComponent.idl)
++++  *  File Name (AccessibleValue.idl)
++++diff --git a/third_party/iaccessible2/set_selection_ranges.patch b/third_party/iaccessible2/set_selection_ranges.patch
++++index 17229419061ce..754c46e4c2067 100644
++++--- a/third_party/iaccessible2/set_selection_ranges.patch
+++++++ b/third_party/iaccessible2/set_selection_ranges.patch
++++@@ -1,21 +1,45 @@
++++ diff --git a/third_party/iaccessible2/ia2_api_all.idl b/third_party/iaccessible2/ia2_api_all.idl
++++-index 97bf11594646..07121230dc73 100644
+++++index dd7ddf72b5ba1..433965f8a77f6 100644
++++ --- a/third_party/iaccessible2/ia2_api_all.idl
++++ +++ b/third_party/iaccessible2/ia2_api_all.idl
++++-@@ -1296,6 +1296,7 @@ IA2_STATE_PINNED =					0x80000
+++++@@ -1324,7 +1324,8 @@ IA2_STATE_PINNED =					0x80000
+++++  @section _interfaces Interfaces
++++    IAccessible2\n
++++    IAccessible2_2\n
++++-   IAccessible2_3\n
+++++-  IAccessible2_3 [Deprecated]\n
++++++  IAccessible2_3
++++ +  IAccessible2_4\n
++++    IAccessibleAction\n
++++    IAccessibleApplication\n
++++    IAccessibleComponent\n
++++-@@ -2104,6 +2105,36 @@ interface IAccessible2_3 : IAccessible2_2
++++-       [out, retval] long *nRanges
+++++@@ -2209,6 +2210,58 @@ interface IAccessibleComponent : IUnknown
+++++      [out, retval] IA2Color *background
++++      );
++++  }
++++ +
++++ +/**
++++++ * This structure represents a directional range of the content. It is defined
++++++ * by two points in the content, where each one is defined by an accessible
++++++ * object and an offset relative to it. A typical case of a range point is
++++++ * a text accessible and text offset within it.
++++++ *
++++++ * The "anchor" is one point of the range and typically remains constant.
++++++ * The other point is the "active" point, which typically corresponds to
++++++ * the user's focus or point of interest. The user moves the active point to
++++++ * expand or collapse the range. In most cases, anchor is the start of the range
++++++ * and active is the end. However, in case of selection, when selecting
++++++ * backwards (e.g. pressing shift+left arrow in a text field), the start of
++++++ * the range is the active point, as the user moves this to manipulate
++++++ * the selection.
++++++ */
++++++typedef struct IA2Range {
++++++  IUnknown* anchor;
++++++  long anchorOffset;
++++++  IUnknown* active;
++++++  long activeOffset;
++++++} IA2Range;
++++++
++++++/**
++++ + * @brief This interface is an extension of IAccessible2_3 which exposes a
++++ + * single method for setting the current selection given a number of selection
++++ + * ranges.
++++@@ -46,4 +70,63 @@ index 97bf11594646..07121230dc73 100644
++++ +
++++  /*************************************************************************
++++   *
++++-  *  File Name (AccessibleComponent.idl)
+++++  *  File Name (AccessibleValue.idl)
+++++diff --git a/third_party/iaccessible2/set_selection_ranges.patch b/third_party/iaccessible2/set_selection_ranges.patch
+++++index 17229419061ce..3e2081010d688 100644
+++++--- a/third_party/iaccessible2/set_selection_ranges.patch
++++++++ b/third_party/iaccessible2/set_selection_ranges.patch
+++++@@ -1,21 +1,43 @@
+++++ diff --git a/third_party/iaccessible2/ia2_api_all.idl b/third_party/iaccessible2/ia2_api_all.idl
+++++-index 97bf11594646..07121230dc73 100644
++++++index dd7ddf72b5ba1..bb6602208e69b 100644
+++++ --- a/third_party/iaccessible2/ia2_api_all.idl
+++++ +++ b/third_party/iaccessible2/ia2_api_all.idl
+++++-@@ -1296,6 +1296,7 @@ IA2_STATE_PINNED =					0x80000
++++++@@ -1325,6 +1325,7 @@ IA2_STATE_PINNED =					0x80000
+++++    IAccessible2\n
+++++    IAccessible2_2\n
+++++-   IAccessible2_3\n
++++++   IAccessible2_3 [Deprecated]\n
+++++ +  IAccessible2_4\n
+++++    IAccessibleAction\n
+++++    IAccessibleApplication\n
+++++    IAccessibleComponent\n
+++++-@@ -2104,6 +2105,36 @@ interface IAccessible2_3 : IAccessible2_2
+++++-       [out, retval] long *nRanges
++++++@@ -2209,6 +2210,58 @@ interface IAccessibleComponent : IUnknown
++++++      [out, retval] IA2Color *background
+++++      );
+++++  }
+++++ +
+++++ +/**
+++++++ * This structure represents a directional range of the content. It is defined
+++++++ * by two points in the content, where each one is defined by an accessible
+++++++ * object and an offset relative to it. A typical case of a range point is
+++++++ * a text accessible and text offset within it.
+++++++ *
+++++++ * The "anchor" is one point of the range and typically remains constant.
+++++++ * The other point is the "active" point, which typically corresponds to
+++++++ * the user's focus or point of interest. The user moves the active point to
+++++++ * expand or collapse the range. In most cases, anchor is the start of the range
+++++++ * and active is the end. However, in case of selection, when selecting
+++++++ * backwards (e.g. pressing shift+left arrow in a text field), the start of
+++++++ * the range is the active point, as the user moves this to manipulate
+++++++ * the selection.
+++++++ */
+++++++typedef struct IA2Range {
+++++++  IUnknown* anchor;
+++++++  long anchorOffset;
+++++++  IUnknown* active;
+++++++  long activeOffset;
+++++++} IA2Range;
+++++++
+++++++/**
+++++ + * @brief This interface is an extension of IAccessible2_3 which exposes a
+++++ + * single method for setting the current selection given a number of selection
+++++ + * ranges.
+++++@@ -46,4 +68,4 @@ index 97bf11594646..07121230dc73 100644
+++++ +
+++++  /*************************************************************************
+++++   *
+++++-  *  File Name (AccessibleComponent.idl)
++++++  *  File Name (AccessibleValue.idl)
diff --git a/third_party/jacoco/3pp/patches/0001-hardcode-properties.patch b/third_party/jacoco/3pp/patches/0001-hardcode-properties.patch
new file mode 100644
index 0000000000000..8abb81f75a476
--- /dev/null
+++ b/third_party/jacoco/3pp/patches/0001-hardcode-properties.patch
@@ -0,0 +1,43 @@
+diff --git a/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/Agent.java b/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/Agent.java
+index 1f1696ff..b46239d1 100644
+--- a/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/Agent.java
++++ b/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/Agent.java
+@@ -176,13 +176,9 @@ public class Agent implements IAgent {
+ 
+ 	private String createSessionId() {
+ 		String host;
+-		try {
+-			host = InetAddress.getLocalHost().getHostName();
+-		} catch (final Exception e) {
+-			// Also catch platform specific exceptions (like on Android) to
+-			// avoid bailing out here
+-			host = "unknownhost";
+-		}
++		// Local modification: Do not try to get host address for StrictMode.
++		// See crbug.com/1401476.
++		host = "unknownhost";
+ 		return host + "-" + AbstractRuntime.createRandomId();
+ 	}
+ 
+diff --git a/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/ConfigLoader.java b/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/ConfigLoader.java
+index c0d524fc..f6a2a66d 100644
+--- a/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/ConfigLoader.java
++++ b/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/ConfigLoader.java
+@@ -34,7 +34,16 @@ final class ConfigLoader {
+ 
+ 	static Properties load(final String resource, final Properties system) {
+ 		final Properties result = new Properties();
+-		loadResource(resource, result);
++		// Local modification: Do not read from resource file on android because
++		// strict mode doesn't allow this. See crbug.com/1401476. Using
++		// hardcoded properties here.
++		boolean isAndroid = "Android Runtime"
++				.equals(System.getProperty("java.runtime.name"));
++		if (isAndroid) {
++			result.setProperty("output", "none");
++		} else {
++			loadResource(resource, result);
++		}
+ 		loadSystemProperties(system, result);
+ 		substSystemProperties(result, system);
+ 		return result;
diff --git a/third_party/jacoco/3pp/patches/0002-dont-use-injected-class-runtime.patch b/third_party/jacoco/3pp/patches/0002-dont-use-injected-class-runtime.patch
new file mode 100644
index 0000000000000..a5dd9249194c8
--- /dev/null
+++ b/third_party/jacoco/3pp/patches/0002-dont-use-injected-class-runtime.patch
@@ -0,0 +1,20 @@
+diff --git a/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/PreMain.java b/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/PreMain.java
+index daa00e0a..95cf1d53 100644
+--- a/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/PreMain.java
++++ b/org.jacoco.agent.rt/src/org/jacoco/agent/rt/internal/PreMain.java
+@@ -58,9 +58,12 @@ public final class PreMain {
+ 	private static IRuntime createRuntime(final Instrumentation inst)
+ 			throws Exception {
+ 
+-		if (redefineJavaBaseModule(inst)) {
+-			return new InjectedClassRuntime(Object.class, "$JaCoCo");
+-		}
++		// TODO(crbug/1452152): InjectedClassRuntime doesn't work well with
++		// Nougat.
++		// Uncomment once Nougat is phased out and Oreo+ is brought in.
++		// if (redefineJavaBaseModule(inst)) {
++		// return new InjectedClassRuntime(Object.class, "$JaCoCo");
++		// }
+ 
+ 		return ModifiedSystemClassRuntime.createFor(inst,
+ 				"java/lang/UnknownError");
diff --git a/third_party/jacoco/3pp/patches/0003-dont-use-condy-probe-array-strategy.patch b/third_party/jacoco/3pp/patches/0003-dont-use-condy-probe-array-strategy.patch
new file mode 100644
index 0000000000000..721adf24bea78
--- /dev/null
+++ b/third_party/jacoco/3pp/patches/0003-dont-use-condy-probe-array-strategy.patch
@@ -0,0 +1,38 @@
+diff --git a/org.jacoco.core/src/org/jacoco/core/internal/instr/ProbeArrayStrategyFactory.java b/org.jacoco.core/src/org/jacoco/core/internal/instr/ProbeArrayStrategyFactory.java
+index 58d74220..7605927d 100644
+--- a/org.jacoco.core/src/org/jacoco/core/internal/instr/ProbeArrayStrategyFactory.java
++++ b/org.jacoco.core/src/org/jacoco/core/internal/instr/ProbeArrayStrategyFactory.java
+@@ -51,10 +51,12 @@ public final class ProbeArrayStrategyFactory {
+ 			if (counter.getCount() == 0) {
+ 				return new NoneProbeArrayStrategy();
+ 			}
+-			if (version >= Opcodes.V11 && counter.hasMethods()) {
+-				return new CondyProbeArrayStrategy(className, true, classId,
+-						accessorGenerator);
+-			}
++			// TODO(crbug/1452152): CondyProbeArrayStrategy doesn't work well
++			// with Nougat
++			// if (version >= Opcodes.V11 && counter.hasMethods()) {
++			// return new CondyProbeArrayStrategy(className, true, classId,
++			// accessorGenerator);
++			// }
+ 			if (version >= Opcodes.V1_8 && counter.hasMethods()) {
+ 				return new InterfaceFieldProbeArrayStrategy(className, classId,
+ 						counter.getCount(), accessorGenerator);
+@@ -63,10 +65,12 @@ public final class ProbeArrayStrategyFactory {
+ 						counter.getCount(), accessorGenerator);
+ 			}
+ 		} else {
+-			if (version >= Opcodes.V11) {
+-				return new CondyProbeArrayStrategy(className, false, classId,
+-						accessorGenerator);
+-			}
++			// TODO(crbug/1452152): CondyProbeArrayStrategy doesn't work well
++			// with Nougat
++			// if (version >= Opcodes.V11) {
++			// return new CondyProbeArrayStrategy(className, false, classId,
++			// accessorGenerator);
++			// }
+ 			return new ClassFieldProbeArrayStrategy(className, classId,
+ 					InstrSupport.needsFrames(version), accessorGenerator);
+ 		}
diff --git a/third_party/libtess2/patches/0000-leq-cfi.patch b/third_party/libtess2/patches/0000-leq-cfi.patch
new file mode 100644
index 0000000000000..42369f7147725
--- /dev/null
+++ b/third_party/libtess2/patches/0000-leq-cfi.patch
@@ -0,0 +1,93 @@
+diff --git a/third_party/libtess2/src/Source/dict.c b/third_party/libtess2/src/Source/dict.c
+index 650adda21d848..579ab09b170dc 100644
+--- a/third_party/libtess2/src/Source/dict.c
++++ b/third_party/libtess2/src/Source/dict.c
+@@ -35,7 +35,7 @@
+ #include "dict.h"
+ 
+ /* really tessDictListNewDict */
+-Dict *dictNewDict( TESSalloc* alloc, void *frame, int (*leq)(void *frame, DictKey key1, DictKey key2) )
++Dict *dictNewDict( TESSalloc* alloc, void *frame, int (*leq)(TESStesselator *frame, ActiveRegion *key1, ActiveRegion *key2) )
+ {
+ 	Dict *dict = (Dict *)alloc->memalloc( alloc->userData, sizeof( Dict ));
+ 	DictNode *head;
+@@ -68,7 +68,7 @@ void dictDeleteDict( TESSalloc* alloc, Dict *dict )
+ }
+ 
+ /* really tessDictListInsertBefore */
+-DictNode *dictInsertBefore( Dict *dict, DictNode *node, DictKey key )
++DictNode *dictInsertBefore( Dict *dict, DictNode *node, ActiveRegion *key )
+ {
+ 	DictNode *newNode;
+ 
+@@ -97,7 +97,7 @@ void dictDelete( Dict *dict, DictNode *node ) /*ARGSUSED*/
+ }
+ 
+ /* really tessDictListSearch */
+-DictNode *dictSearch( Dict *dict, DictKey key )
++DictNode *dictSearch( Dict *dict, ActiveRegion *key )
+ {
+ 	DictNode *node = &dict->head;
+ 
+diff --git a/third_party/libtess2/src/Source/dict.h b/third_party/libtess2/src/Source/dict.h
+index 4cf322657b7d7..e72aabf16e191 100644
+--- a/third_party/libtess2/src/Source/dict.h
++++ b/third_party/libtess2/src/Source/dict.h
+@@ -32,11 +32,13 @@
+ #ifndef DICT_LIST_H
+ #define DICT_LIST_H
+ 
+-typedef void *DictKey;
++#include "../Include/tesselator.h"
++#include "mesh.h"
++
+ typedef struct Dict Dict;
+ typedef struct DictNode DictNode;
+ 
+-Dict *dictNewDict( TESSalloc* alloc, void *frame, int (*leq)(void *frame, DictKey key1, DictKey key2) );
++Dict *dictNewDict( TESSalloc* alloc, void *frame, int (*leq)(TESStesselator *frame, ActiveRegion *key1, ActiveRegion *key2) );
+ 
+ void dictDeleteDict( TESSalloc* alloc, Dict *dict );
+ 
+@@ -44,8 +46,8 @@ void dictDeleteDict( TESSalloc* alloc, Dict *dict );
+ * to the given key.  If there is no such key, returns a node whose
+ * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
+ */
+-DictNode *dictSearch( Dict *dict, DictKey key );
+-DictNode *dictInsertBefore( Dict *dict, DictNode *node, DictKey key );
++DictNode *dictSearch( Dict *dict, ActiveRegion *key );
++DictNode *dictInsertBefore( Dict *dict, DictNode *node, ActiveRegion *key );
+ void dictDelete( Dict *dict, DictNode *node );
+ 
+ #define dictKey(n)	((n)->key)
+@@ -59,7 +61,7 @@ void dictDelete( Dict *dict, DictNode *node );
+ /*** Private data structures ***/
+ 
+ struct DictNode {
+-	DictKey	key;
++	ActiveRegion *key;
+ 	DictNode *next;
+ 	DictNode *prev;
+ };
+@@ -68,7 +70,7 @@ struct Dict {
+ 	DictNode head;
+ 	void *frame;
+ 	struct BucketAlloc *nodePool;
+-	int (*leq)(void *frame, DictKey key1, DictKey key2);
++	int (*leq)(TESStesselator *frame, ActiveRegion *key1, ActiveRegion *key2);
+ };
+ 
+ #endif
+diff --git a/third_party/libtess2/src/Source/sweep.c b/third_party/libtess2/src/Source/sweep.c
+index 32a56bf406040..8bcd839f73cc4 100644
+--- a/third_party/libtess2/src/Source/sweep.c
++++ b/third_party/libtess2/src/Source/sweep.c
+@@ -1115,7 +1115,7 @@ static void InitEdgeDict( TESStesselator *tess )
+ 	TESSreal w, h;
+ 	TESSreal smin, smax, tmin, tmax;
+ 
+-	tess->dict = dictNewDict( &tess->alloc, tess, (int (*)(void *, DictKey, DictKey)) EdgeLeq );
++	tess->dict = dictNewDict( &tess->alloc, tess, EdgeLeq );
+ 	if (tess->dict == NULL) longjmp(tess->env,1);
+ 
+ 	/* If the bbox is empty, ensure that sentinels are not coincident by slightly enlarging it. */
diff --git a/third_party/libusb/assign-endpoints-checks.patch b/third_party/libusb/assign-endpoints-checks.patch
new file mode 100644
index 0000000000000..7ed09bdb2430a
--- /dev/null
+++ b/third_party/libusb/assign-endpoints-checks.patch
@@ -0,0 +1,17 @@
+diff --git a/third_party/libusb/src/libusb/os/windows_usb.c b/third_party/libusb/src/libusb/os/windows_usb.c
+index 259897e..4469992 100644
+--- a/third_party/libusb/src/libusb/os/windows_usb.c
++++ b/third_party/libusb/src/libusb/os/windows_usb.c
+@@ -663,6 +663,12 @@ static int windows_assign_endpoints(struct libusb_device_handle *dev_handle, int
+ 		return r;
+ 	}
+ 
++	if (iface >= conf_desc->bNumInterfaces ||
++	    altsetting >= conf_desc->interface[iface].num_altsetting) {
++		usbi_dbg("interface %d, altsetting %d out of range", iface, altsetting);
++		return LIBUSB_ERROR_INVALID_PARAM;
++	}
++
+ 	if_desc = &conf_desc->interface[iface].altsetting[altsetting];
+ 	safe_free(priv->usb_interface[iface].endpoint);
+ 
diff --git a/third_party/libusb/composite-hid-close.patch b/third_party/libusb/composite-hid-close.patch
new file mode 100644
index 0000000000000..d6749cf931ae3
--- /dev/null
+++ b/third_party/libusb/composite-hid-close.patch
@@ -0,0 +1,32 @@
+diff --git a/libusb/os/windows_usb.c b/libusb/os/windows_usb.c
+index 9ae11b1..259897e 100644
+--- a/libusb/os/windows_usb.c
++++ b/libusb/os/windows_usb.c
+@@ -4236,6 +4236,7 @@ static void composite_close(int sub_api, struct libusb_device_handle *dev_handle
+ 	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
+ 	uint8_t i;
+ 	bool available[SUB_API_MAX];
++	bool has_hid = false;
+ 
+ 	for (i = 0; i<SUB_API_MAX; i++) {
+ 		available[i] = false;
+@@ -4245,6 +4246,8 @@ static void composite_close(int sub_api, struct libusb_device_handle *dev_handle
+ 		if ( (priv->usb_interface[i].apib->id == USB_API_WINUSBX)
+ 		  && (priv->usb_interface[i].sub_api != SUB_API_NOTSET) ) {
+ 			available[priv->usb_interface[i].sub_api] = true;
++		} else if (priv->usb_interface[i].apib->id == USB_API_HID) {
++			has_hid = true;
+ 		}
+ 	}
+ 
+@@ -4253,6 +4256,10 @@ static void composite_close(int sub_api, struct libusb_device_handle *dev_handle
+ 			usb_api_backend[USB_API_WINUSBX].close(i, dev_handle);
+ 		}
+ 	}
++
++	if (has_hid) {
++		usb_api_backend[USB_API_HID].close(sub_api, dev_handle);
++	}
+ }
+ 
+ static int composite_claim_interface(int sub_api, struct libusb_device_handle *dev_handle, int iface)
diff --git a/third_party/libusb/darwin-sigfpe.patch b/third_party/libusb/darwin-sigfpe.patch
new file mode 100644
index 0000000000000..3c74db1857015
--- /dev/null
+++ b/third_party/libusb/darwin-sigfpe.patch
@@ -0,0 +1,22 @@
+diff --git a/libusb/os/darwin_usb.c b/libusb/os/darwin_usb.c
+index b0ee5b2..fe40899 100644
+--- a/libusb/os/darwin_usb.c
++++ b/libusb/os/darwin_usb.c
+@@ -1449,8 +1449,14 @@ static int submit_bulk_transfer(struct usbi_transfer *itransfer) {
+ 
+   cInterface = &priv->interfaces[iface];
+ 
+-  (*(cInterface->interface))->GetPipeProperties (cInterface->interface, pipeRef, &direction, &number,
+-                                                 &transferType, &maxPacketSize, &interval);
++  ret = (*(cInterface->interface))->GetPipeProperties (cInterface->interface, pipeRef, &direction, &number,
++                                                       &transferType, &maxPacketSize, &interval);
++
++  if (ret) {
++    usbi_err (TRANSFER_CTX (transfer), "bulk transfer failed (dir = %s): %s (code = 0x%08x)", IS_XFERIN(transfer) ? "In" : "Out",
++              darwin_error_str(ret), ret);
++    return darwin_to_libusb (ret);
++  }
+ 
+   if (0 != (transfer->length % maxPacketSize)) {
+     /* do not need a zero packet */
+
diff --git a/third_party/libusb/linux-udev.patch b/third_party/libusb/linux-udev.patch
new file mode 100644
index 0000000000000..93249c04d1272
--- /dev/null
+++ b/third_party/libusb/linux-udev.patch
@@ -0,0 +1,209 @@
+Index: third_party/libusb/src/libusb/os/linux_udev.cc
+diff --git a/third_party/libusb/src/libusb/os/linux_udev.c b/third_party/libusb/src/libusb/os/linux_udev.cc
+similarity index 83%
+rename from third_party/libusb/src/libusb/os/linux_udev.c
+rename to third_party/libusb/src/libusb/os/linux_udev.cc
+index 99ac943410557de1a5cdd54082932db972040c2c..1b51ce44f4973c39b906d472b2a0cab51f987d3c 100644
+--- a/third_party/libusb/src/libusb/os/linux_udev.c
++++ b/third_party/libusb/src/libusb/os/linux_udev.cc
+@@ -37,11 +37,14 @@
+ #include <sys/utsname.h>
+ #include <sys/socket.h>
+ #include <unistd.h>
+-#include <libudev.h>
+ 
++extern "C" {
+ #include "libusb.h"
+ #include "libusbi.h"
+ #include "linux_usbfs.h"
++}
++
++#include "device/udev_linux/udev.h"
+ 
+ /* udev context */
+ static struct udev *udev_ctx = NULL;
+@@ -58,30 +61,30 @@ int linux_udev_start_event_monitor(void)
+ 	int r;
+ 
+ 	assert(udev_ctx == NULL);
+-	udev_ctx = udev_new();
++	udev_ctx = device::udev_new();
+ 	if (!udev_ctx) {
+ 		usbi_err(NULL, "could not create udev context");
+ 		return LIBUSB_ERROR_OTHER;
+ 	}
+ 
+-	udev_monitor = udev_monitor_new_from_netlink(udev_ctx, "udev");
++	udev_monitor = device::udev_monitor_new_from_netlink(udev_ctx, "udev");
+ 	if (!udev_monitor) {
+ 		usbi_err(NULL, "could not initialize udev monitor");
+ 		goto err_free_ctx;
+ 	}
+ 
+-	r = udev_monitor_filter_add_match_subsystem_devtype(udev_monitor, "usb", 0);
++	r = device::udev_monitor_filter_add_match_subsystem_devtype(udev_monitor, "usb", 0);
+ 	if (r) {
+ 		usbi_err(NULL, "could not initialize udev monitor filter for \"usb\" subsystem");
+ 		goto err_free_monitor;
+ 	}
+ 
+-	if (udev_monitor_enable_receiving(udev_monitor)) {
++	if (device::udev_monitor_enable_receiving(udev_monitor)) {
+ 		usbi_err(NULL, "failed to enable the udev monitor");
+ 		goto err_free_monitor;
+ 	}
+ 
+-	udev_monitor_fd = udev_monitor_get_fd(udev_monitor);
++	udev_monitor_fd = device::udev_monitor_get_fd(udev_monitor);
+ 
+ 	/* Some older versions of udev are not non-blocking by default,
+ 	 * so make sure this is set */
+@@ -114,11 +117,11 @@ err_close_pipe:
+ 	close(udev_control_pipe[0]);
+ 	close(udev_control_pipe[1]);
+ err_free_monitor:
+-	udev_monitor_unref(udev_monitor);
++	device::udev_monitor_unref(udev_monitor);
+ 	udev_monitor = NULL;
+ 	udev_monitor_fd = -1;
+ err_free_ctx:
+-	udev_unref(udev_ctx);
++	device::udev_unref(udev_ctx);
+ 	udev_ctx = NULL;
+ 	return LIBUSB_ERROR_OTHER;
+ }
+@@ -141,12 +144,12 @@ int linux_udev_stop_event_monitor(void)
+ 	pthread_join(linux_event_thread, NULL);
+ 
+ 	/* Release the udev monitor */
+-	udev_monitor_unref(udev_monitor);
++	device::udev_monitor_unref(udev_monitor);
+ 	udev_monitor = NULL;
+ 	udev_monitor_fd = -1;
+ 
+ 	/* Clean up the udev context */
+-	udev_unref(udev_ctx);
++	device::udev_unref(udev_ctx);
+ 	udev_ctx = NULL;
+ 
+ 	/* close and reset control pipe */
+@@ -183,7 +186,7 @@ static void *linux_udev_event_thread_main(void *arg)
+ 		}
+ 		if (fds[1].revents & POLLIN) {
+ 			usbi_mutex_static_lock(&linux_hotplug_lock);
+-			udev_dev = udev_monitor_receive_device(udev_monitor);
++			udev_dev = device::udev_monitor_receive_device(udev_monitor);
+ 			if (udev_dev)
+ 				udev_hotplug_event(udev_dev);
+ 			usbi_mutex_static_unlock(&linux_hotplug_lock);
+@@ -200,12 +203,12 @@ static int udev_device_info(struct libusb_context *ctx, int detached,
+ 			    uint8_t *devaddr, const char **sys_name) {
+ 	const char *dev_node;
+ 
+-	dev_node = udev_device_get_devnode(udev_dev);
++	dev_node = device::udev_device_get_devnode(udev_dev);
+ 	if (!dev_node) {
+ 		return LIBUSB_ERROR_OTHER;
+ 	}
+ 
+-	*sys_name = udev_device_get_sysname(udev_dev);
++	*sys_name = device::udev_device_get_sysname(udev_dev);
+ 	if (!*sys_name) {
+ 		return LIBUSB_ERROR_OTHER;
+ 	}
+@@ -223,7 +226,7 @@ static void udev_hotplug_event(struct udev_device* udev_dev)
+ 	int r;
+ 
+ 	do {
+-		udev_action = udev_device_get_action(udev_dev);
++		udev_action = device::udev_device_get_action(udev_dev);
+ 		if (!udev_action) {
+ 			break;
+ 		}
+@@ -246,7 +249,7 @@ static void udev_hotplug_event(struct udev_device* udev_dev)
+ 		}
+ 	} while (0);
+ 
+-	udev_device_unref(udev_dev);
++	device::udev_device_unref(udev_dev);
+ }
+ 
+ int linux_udev_scan_devices(struct libusb_context *ctx)
+@@ -259,33 +262,33 @@ int linux_udev_scan_devices(struct libusb_context *ctx)
+ 
+ 	assert(udev_ctx != NULL);
+ 
+-	enumerator = udev_enumerate_new(udev_ctx);
++	enumerator = device::udev_enumerate_new(udev_ctx);
+ 	if (NULL == enumerator) {
+ 		usbi_err(ctx, "error creating udev enumerator");
+ 		return LIBUSB_ERROR_OTHER;
+ 	}
+ 
+-	udev_enumerate_add_match_subsystem(enumerator, "usb");
+-	udev_enumerate_scan_devices(enumerator);
+-	devices = udev_enumerate_get_list_entry(enumerator);
++	device::udev_enumerate_add_match_subsystem(enumerator, "usb");
++	device::udev_enumerate_scan_devices(enumerator);
++	devices = device::udev_enumerate_get_list_entry(enumerator);
+ 
+ 	udev_list_entry_foreach(entry, devices) {
+-		const char *path = udev_list_entry_get_name(entry);
++		const char *path = device::udev_list_entry_get_name(entry);
+ 		uint8_t busnum = 0, devaddr = 0;
+ 
+-		udev_dev = udev_device_new_from_syspath(udev_ctx, path);
++		udev_dev = device::udev_device_new_from_syspath(udev_ctx, path);
+ 
+ 		r = udev_device_info(ctx, 0, udev_dev, &busnum, &devaddr, &sys_name);
+ 		if (r) {
+-			udev_device_unref(udev_dev);
++			device::udev_device_unref(udev_dev);
+ 			continue;
+ 		}
+ 
+ 		linux_enumerate_device(ctx, busnum, devaddr, sys_name);
+-		udev_device_unref(udev_dev);
++		device::udev_device_unref(udev_dev);
+ 	}
+ 
+-	udev_enumerate_unref(enumerator);
++	device::udev_enumerate_unref(enumerator);
+ 
+ 	return LIBUSB_SUCCESS;
+ }
+@@ -296,7 +299,7 @@ void linux_udev_hotplug_poll(void)
+ 
+ 	usbi_mutex_static_lock(&linux_hotplug_lock);
+ 	do {
+-		udev_dev = udev_monitor_receive_device(udev_monitor);
++		udev_dev = device::udev_monitor_receive_device(udev_monitor);
+ 		if (udev_dev) {
+ 			usbi_dbg("Handling hotplug event from hotplug_poll");
+ 			udev_hotplug_event(udev_dev);
+Index: third_party/libusb/src/libusb/os/linux_usbfs.h
+diff --git a/third_party/libusb/src/libusb/os/linux_usbfs.h b/third_party/libusb/src/libusb/os/linux_usbfs.h
+index 1f5b191f4a745937efe52695d7dbaa949a15df08..eedeaaf3654f22ecaac9fd1332d32b2855450bce 100644
+--- a/third_party/libusb/src/libusb/os/linux_usbfs.h
++++ b/third_party/libusb/src/libusb/os/linux_usbfs.h
+@@ -159,10 +159,20 @@ struct usbfs_disconnect_claim {
+ extern usbi_mutex_static_t linux_hotplug_lock;
+ 
+ #if defined(HAVE_LIBUDEV)
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
+ int linux_udev_start_event_monitor(void);
+ int linux_udev_stop_event_monitor(void);
+ int linux_udev_scan_devices(struct libusb_context *ctx);
+ void linux_udev_hotplug_poll(void);
++
++#ifdef __cplusplus
++}
++#endif
++
+ #else
+ int linux_netlink_start_event_monitor(void);
+ int linux_netlink_stop_event_monitor(void);
diff --git a/third_party/libusb/open-fd.patch b/third_party/libusb/open-fd.patch
new file mode 100644
index 0000000000000..5c5eb120e05c8
--- /dev/null
+++ b/third_party/libusb/open-fd.patch
@@ -0,0 +1,236 @@
+diff --git a/third_party/libusb/src/libusb/core.c b/third_party/libusb/src/libusb/core.c
+index e816284..abc4f89 100644
+--- a/third_party/libusb/src/libusb/core.c
++++ b/third_party/libusb/src/libusb/core.c
+@@ -1129,6 +1129,83 @@ int API_EXPORTED libusb_open(libusb_device *dev,
+ }
+ 
+ /** \ingroup dev
++ * Open a device and obtain a device handle. A handle allows you to perform
++ * I/O on the device in question.
++ *
++ * Instead of opening the device itself this function accepts an open file
++ * descriptor that it will take ownership of.
++ *
++ * Internally, this function adds a reference to the device and makes it
++ * available to you through libusb_get_device(). This reference is removed
++ * during libusb_close().
++ *
++ * This is a non-blocking function; no requests are sent over the bus.
++ *
++ * \param dev the device to open
++ * \param fd open file handle to the device
++ * \param handle output location for the returned device handle pointer. Only
++ * populated when the return code is 0.
++ * \returns 0 on success
++ * \returns LIBUSB_ERROR_NO_MEM on memory allocation failure
++ * \returns LIBUSB_ERROR_ACCESS if the user has insufficient permissions
++ * \returns LIBUSB_ERROR_NO_DEVICE if the device has been disconnected
++ * \returns another LIBUSB_ERROR code on other failure
++ */
++int API_EXPORTED libusb_open_fd(libusb_device *dev,
++  int fd,
++  libusb_device_handle **handle)
++{
++  struct libusb_context *ctx = DEVICE_CTX(dev);
++  struct libusb_device_handle *_handle;
++  size_t priv_size = usbi_backend->device_handle_priv_size;
++  int r;
++  usbi_dbg("open %d.%d", dev->bus_number, dev->device_address);
++
++  if (!dev->attached) {
++    return LIBUSB_ERROR_NO_DEVICE;
++  }
++
++  _handle = malloc(sizeof(*_handle) + priv_size);
++  if (!_handle)
++    return LIBUSB_ERROR_NO_MEM;
++
++  r = usbi_mutex_init(&_handle->lock, NULL);
++  if (r) {
++    free(_handle);
++    return LIBUSB_ERROR_OTHER;
++  }
++
++  _handle->dev = libusb_ref_device(dev);
++  _handle->auto_detach_kernel_driver = 0;
++  _handle->claimed_interfaces = 0;
++  memset(&_handle->os_priv, 0, priv_size);
++
++  r = usbi_backend->open_fd(_handle, fd);
++  if (r < 0) {
++    usbi_dbg("open %d.%d returns %d", dev->bus_number, dev->device_address, r);
++    libusb_unref_device(dev);
++    usbi_mutex_destroy(&_handle->lock);
++    free(_handle);
++    return r;
++  }
++
++  usbi_mutex_lock(&ctx->open_devs_lock);
++  list_add(&_handle->list, &ctx->open_devs);
++  usbi_mutex_unlock(&ctx->open_devs_lock);
++  *handle = _handle;
++
++  /* At this point, we want to interrupt any existing event handlers so
++   * that they realise the addition of the new device's poll fd. One
++   * example when this is desirable is if the user is running a separate
++   * dedicated libusbx events handling thread, which is running with a long
++   * or infinite timeout. We want to interrupt that iteration of the loop,
++   * so that it picks up the new fd, and then continues. */
++  usbi_fd_notification(ctx);
++
++  return 0;
++}
++
++/** \ingroup dev
+  * Convenience function for finding a device with a particular
+  * <tt>idVendor</tt>/<tt>idProduct</tt> combination. This function is intended
+  * for those scenarios where you are using libusbx to knock up a quick test
+diff --git a/third_party/libusb/src/libusb/libusb.h b/third_party/libusb/src/libusb/libusb.h
+index d144b3e..5d60951 100644
+--- a/third_party/libusb/src/libusb/libusb.h
++++ b/third_party/libusb/src/libusb/libusb.h
+@@ -1371,6 +1371,8 @@ int LIBUSB_CALL libusb_get_max_iso_packet_size(libusb_device *dev,
+ 	unsigned char endpoint);
+ 
+ int LIBUSB_CALL libusb_open(libusb_device *dev, libusb_device_handle **handle);
++int LIBUSB_CALL libusb_open_fd(libusb_device *dev, int fd,
++	libusb_device_handle **handle);
+ void LIBUSB_CALL libusb_close(libusb_device_handle *dev_handle);
+ libusb_device * LIBUSB_CALL libusb_get_device(libusb_device_handle *dev_handle);
+ 
+diff --git a/third_party/libusb/src/libusb/libusbi.h b/third_party/libusb/src/libusb/libusbi.h
+index bc608b92..eb2f0e6 100644
+--- a/third_party/libusb/src/libusb/libusbi.h
++++ b/third_party/libusb/src/libusb/libusbi.h
+@@ -615,6 +615,11 @@ struct usbi_os_backend {
+ 	 */
+ 	int (*open)(struct libusb_device_handle *handle);
+ 
++	/* Like open() above but uses the file descriptor provided instead of opening
++	 * one on its own.
++	 */
++	int (*open_fd)(struct libusb_device_handle *handle, int fd);
++
+ 	/* Close a device such that the handle cannot be used again. Your backend
+ 	 * should destroy any resources that were allocated in the open path.
+ 	 * This may also be a good place to call usbi_remove_pollfd() to inform
+diff --git a/third_party/libusb/src/libusb/os/darwin_usb.c b/third_party/libusb/src/libusb/os/darwin_usb.c
+index f95706a..f6b397e 100644
+--- a/third_party/libusb/src/libusb/os/darwin_usb.c
++++ b/third_party/libusb/src/libusb/os/darwin_usb.c
+@@ -1877,6 +1877,7 @@ const struct usbi_os_backend darwin_backend = {
+         .get_config_descriptor = darwin_get_config_descriptor,
+ 
+         .open = darwin_open,
++        .open_fd = NULL, /* not implemented */
+         .close = darwin_close,
+         .get_configuration = darwin_get_configuration,
+         .set_configuration = darwin_set_configuration,
+diff --git a/third_party/libusb/src/libusb/os/linux_usbfs.c b/third_party/libusb/src/libusb/os/linux_usbfs.c
+index 142fa2b..e965856 100644
+--- a/third_party/libusb/src/libusb/os/linux_usbfs.c
++++ b/third_party/libusb/src/libusb/os/linux_usbfs.c
+@@ -1259,26 +1259,12 @@ static int linux_default_scan_devices (struct libusb_context *ctx)
+ }
+ #endif
+ 
+-static int op_open(struct libusb_device_handle *handle)
++static int op_open_fd(struct libusb_device_handle *handle, int fd)
+ {
+ 	struct linux_device_handle_priv *hpriv = _device_handle_priv(handle);
+ 	int r;
+ 
+-	hpriv->fd = _get_usbfs_fd(handle->dev, O_RDWR, 0);
+-	if (hpriv->fd < 0) {
+-		if (hpriv->fd == LIBUSB_ERROR_NO_DEVICE) {
+-			/* device will still be marked as attached if hotplug monitor thread
+-			 * hasn't processed remove event yet */
+-			usbi_mutex_static_lock(&linux_hotplug_lock);
+-			if (handle->dev->attached) {
+-				usbi_dbg("open failed with no device, but device still attached");
+-				linux_device_disconnected(handle->dev->bus_number,
+-						handle->dev->device_address, NULL);
+-			}
+-			usbi_mutex_static_unlock(&linux_hotplug_lock);
+-		}
+-		return hpriv->fd;
+-	}
++	hpriv->fd = fd;
+ 
+ 	r = ioctl(hpriv->fd, IOCTL_USBFS_GET_CAPABILITIES, &hpriv->caps);
+ 	if (r < 0) {
+@@ -1296,6 +1282,29 @@ static int op_open(struct libusb_device_handle *handle)
+ 	return usbi_add_pollfd(HANDLE_CTX(handle), hpriv->fd, POLLOUT);
+ }
+ 
++static int op_open(struct libusb_device_handle *handle)
++{
++	struct linux_device_handle_priv *hpriv = _device_handle_priv(handle);
++	int fd = _get_usbfs_fd(handle->dev, O_RDWR, 0);
++
++	if (fd < 0) {
++		if (fd == LIBUSB_ERROR_NO_DEVICE) {
++			/* device will still be marked as attached if hotplug monitor thread
++			 * hasn't processed remove event yet */
++			usbi_mutex_static_lock(&linux_hotplug_lock);
++			if (handle->dev->attached) {
++				usbi_dbg("open failed with no device, but device still attached");
++				linux_device_disconnected(handle->dev->bus_number,
++						handle->dev->device_address, NULL);
++			}
++			usbi_mutex_static_unlock(&linux_hotplug_lock);
++		}
++		return fd;
++	}
++
++	return op_open_fd(handle, fd);
++}
++
+ static void op_close(struct libusb_device_handle *dev_handle)
+ {
+ 	int fd = _device_handle_priv(dev_handle)->fd;
+@@ -2570,6 +2579,7 @@ const struct usbi_os_backend linux_usbfs_backend = {
+ 	.get_config_descriptor_by_value = op_get_config_descriptor_by_value,
+ 
+ 	.open = op_open,
++	.open_fd = op_open_fd,
+ 	.close = op_close,
+ 	.get_configuration = op_get_configuration,
+ 	.set_configuration = op_set_configuration,
+diff --git a/third_party/libusb/src/libusb/os/openbsd_usb.c b/third_party/libusb/src/libusb/os/openbsd_usb.c
+index 2997e53..2d24f2c 100644
+--- a/third_party/libusb/src/libusb/os/openbsd_usb.c
++++ b/third_party/libusb/src/libusb/os/openbsd_usb.c
+@@ -98,6 +98,7 @@ const struct usbi_os_backend openbsd_backend = {
+ 	obsd_get_device_list,
+ 	NULL,				/* hotplug_poll */
+ 	obsd_open,
++	NULL,       /* open_fd */
+ 	obsd_close,
+ 
+ 	obsd_get_device_descriptor,
+diff --git a/third_party/libusb/src/libusb/os/wince_usb.c b/third_party/libusb/src/libusb/os/wince_usb.c
+index 90c129b..c069c56 100644
+--- a/third_party/libusb/src/libusb/os/wince_usb.c
++++ b/third_party/libusb/src/libusb/os/wince_usb.c
+@@ -990,6 +990,7 @@ const struct usbi_os_backend wince_backend = {
+         wince_get_device_list,
+ 	NULL,				/* hotplug_poll */
+         wince_open,
++        NULL, /* open_fd */
+         wince_close,
+ 
+         wince_get_device_descriptor,
+diff --git a/third_party/libusb/src/libusb/os/windows_usb.c b/third_party/libusb/src/libusb/os/windows_usb.c
+index 4469992..bc4def6 100644
+--- a/third_party/libusb/src/libusb/os/windows_usb.c
++++ b/third_party/libusb/src/libusb/os/windows_usb.c
+@@ -2290,6 +2290,7 @@ const struct usbi_os_backend windows_backend = {
+ 	windows_get_device_list,
+ 	NULL,				/* hotplug_poll */
+ 	windows_open,
++	NULL,       /* open_fd */
+ 	windows_close,
+ 
+ 	windows_get_device_descriptor,
diff --git a/third_party/libusb/os-priv-alignment.patch b/third_party/libusb/os-priv-alignment.patch
new file mode 100644
index 0000000000000..b7fa4f8a5d0dd
--- /dev/null
+++ b/third_party/libusb/os-priv-alignment.patch
@@ -0,0 +1,43 @@
+diff --git a/third_party/libusb/src/libusb/libusbi.h b/third_party/libusb/src/libusb/libusbi.h
+index 289d43fd2911c..970d2491acdb8 100644
+--- a/third_party/libusb/src/libusb/libusbi.h
++++ b/third_party/libusb/src/libusb/libusbi.h
+@@ -39,6 +39,20 @@
+ #include "libusb.h"
+ #include "version.h"
+ 
++/* Attribute to ensure that a structure member is aligned to a natural
++ * pointer alignment. Used for os_priv member. */
++#if defined(_MSC_VER)
++#if defined(_WIN64)
++#define PTR_ALIGNED __declspec(align(8))
++#else
++#define PTR_ALIGNED __declspec(align(4))
++#endif
++#elif defined(__GNUC__)
++#define PTR_ALIGNED __attribute__((aligned(sizeof(void *))))
++#else
++#define PTR_ALIGNED
++#endif
++
+ /* Inside the libusbx code, mark all public functions as follows:
+  *   return_type API_EXPORTED function_name(params) { ... }
+  * But if the function returns a pointer, mark it as follows:
+@@ -308,7 +322,7 @@ struct libusb_device {
+ 	struct libusb_device_descriptor device_descriptor;
+ 	int attached;
+ 
+-	unsigned char os_priv
++	PTR_ALIGNED unsigned char os_priv
+ #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+ 	[] /* valid C99 code */
+ #else
+@@ -325,7 +339,7 @@ struct libusb_device_handle {
+ 	struct list_head list;
+ 	struct libusb_device *dev;
+ 	int auto_detach_kernel_driver;
+-	unsigned char os_priv
++	PTR_ALIGNED unsigned char os_priv
+ #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+ 	[] /* valid C99 code */
+ #else
diff --git a/third_party/libusb/unsigned-shifts.patch b/third_party/libusb/unsigned-shifts.patch
new file mode 100644
index 0000000000000..b63cba2c68e5e
--- /dev/null
+++ b/third_party/libusb/unsigned-shifts.patch
@@ -0,0 +1,94 @@
+diff --git a/third_party/libusb/src/libusb/core.c b/third_party/libusb/src/libusb/core.c
+index 34ed488216641..be7e479c29aa9 100644
+--- a/third_party/libusb/src/libusb/core.c
++++ b/third_party/libusb/src/libusb/core.c
+@@ -1538,12 +1538,12 @@ int API_EXPORTED libusb_claim_interface(libusb_device_handle *dev,
+ 		return LIBUSB_ERROR_NO_DEVICE;
+ 
+ 	usbi_mutex_lock(&dev->lock);
+-	if (dev->claimed_interfaces & (1 << interface_number))
++	if (dev->claimed_interfaces & (1U << interface_number))
+ 		goto out;
+ 
+ 	r = usbi_backend->claim_interface(dev, interface_number);
+ 	if (r == 0)
+-		dev->claimed_interfaces |= 1 << interface_number;
++		dev->claimed_interfaces |= 1U << interface_number;
+ 
+ out:
+ 	usbi_mutex_unlock(&dev->lock);
+@@ -1579,14 +1579,14 @@ int API_EXPORTED libusb_release_interface(libusb_device_handle *dev,
+ 		return LIBUSB_ERROR_INVALID_PARAM;
+ 
+ 	usbi_mutex_lock(&dev->lock);
+-	if (!(dev->claimed_interfaces & (1 << interface_number))) {
++	if (!(dev->claimed_interfaces & (1U << interface_number))) {
+ 		r = LIBUSB_ERROR_NOT_FOUND;
+ 		goto out;
+ 	}
+ 
+ 	r = usbi_backend->release_interface(dev, interface_number);
+ 	if (r == 0)
+-		dev->claimed_interfaces &= ~(1 << interface_number);
++		dev->claimed_interfaces &= ~(1U << interface_number);
+ 
+ out:
+ 	usbi_mutex_unlock(&dev->lock);
+@@ -1628,7 +1628,7 @@ int API_EXPORTED libusb_set_interface_alt_setting(libusb_device_handle *dev,
+ 		return LIBUSB_ERROR_NO_DEVICE;
+ 	}
+ 
+-	if (!(dev->claimed_interfaces & (1 << interface_number))) {
++	if (!(dev->claimed_interfaces & (1U << interface_number))) {
+ 		usbi_mutex_unlock(&dev->lock);
+ 		return LIBUSB_ERROR_NOT_FOUND;
+ 	}
+diff --git a/third_party/libusb/src/libusb/os/darwin_usb.c b/third_party/libusb/src/libusb/os/darwin_usb.c
+index 4d4024aaeee6a..0f5da1dd670b0 100644
+--- a/third_party/libusb/src/libusb/os/darwin_usb.c
++++ b/third_party/libusb/src/libusb/os/darwin_usb.c
+@@ -165,7 +165,7 @@ static int ep_to_pipeRef(struct libusb_device_handle *dev_handle, uint8_t ep, ui
+   for (iface = 0 ; iface < USB_MAXINTERFACES ; iface++) {
+     cInterface = &priv->interfaces[iface];
+ 
+-    if (dev_handle->claimed_interfaces & (1 << iface)) {
++    if (dev_handle->claimed_interfaces & (1U << iface)) {
+       for (i = 0 ; i < cInterface->num_endpoints ; i++) {
+         if (cInterface->endpoint_addrs[i] == ep) {
+           *pipep = i + 1;
+@@ -665,7 +665,7 @@ static int darwin_cache_device_descriptor (struct libusb_context *ctx, struct da
+       (void)(*device)->GetUSBDeviceInformation (device, &info);
+ 
+       /* note that the device was suspended */
+-      if (info & (1 << kUSBInformationDeviceIsSuspendedBit) || 0 == info)
++      if (info & (1U << kUSBInformationDeviceIsSuspendedBit) || 0 == info)
+         try_unsuspend = 1;
+ #endif
+ 
+@@ -995,7 +995,7 @@ static void darwin_close (struct libusb_device_handle *dev_handle) {
+ 
+   /* make sure all interfaces are released */
+   for (i = 0 ; i < USB_MAXINTERFACES ; i++)
+-    if (dev_handle->claimed_interfaces & (1 << i))
++    if (dev_handle->claimed_interfaces & (1U << i))
+       libusb_release_interface (dev_handle, i);
+ 
+   if (0 == dpriv->open_count) {
+@@ -1042,7 +1042,7 @@ static int darwin_set_configuration(struct libusb_device_handle *dev_handle, int
+   /* Setting configuration will invalidate the interface, so we need
+      to reclaim it. First, dispose of existing interfaces, if any. */
+   for (i = 0 ; i < USB_MAXINTERFACES ; i++)
+-    if (dev_handle->claimed_interfaces & (1 << i))
++    if (dev_handle->claimed_interfaces & (1U << i))
+       darwin_release_interface (dev_handle, i);
+ 
+   kresult = (*(dpriv->device))->SetConfiguration (dpriv->device, config);
+@@ -1051,7 +1051,7 @@ static int darwin_set_configuration(struct libusb_device_handle *dev_handle, int
+ 
+   /* Reclaim any interfaces. */
+   for (i = 0 ; i < USB_MAXINTERFACES ; i++)
+-    if (dev_handle->claimed_interfaces & (1 << i))
++    if (dev_handle->claimed_interfaces & (1U << i))
+       darwin_claim_interface (dev_handle, i);
+ 
+   dpriv->active_config = config;
diff --git a/third_party/libusb/upstream-tick147.patch b/third_party/libusb/upstream-tick147.patch
new file mode 100644
index 0000000000000..28acfc6f968ee
--- /dev/null
+++ b/third_party/libusb/upstream-tick147.patch
@@ -0,0 +1,13 @@
+diff --git a/third_party/libusb/src/libusb/os/darwin_usb.c b/third_party/libusb/src/libusb/os/darwin_usb.c
+index 58467c3..07d6d61 100644
+--- a/third_party/libusb/src/libusb/os/darwin_usb.c
++++ b/third_party/libusb/src/libusb/os/darwin_usb.c
+@@ -1268,7 +1268,7 @@ static int darwin_release_interface(struct libusb_device_handle *dev_handle, int
+   if (kresult != kIOReturnSuccess)
+     usbi_warn (HANDLE_CTX (dev_handle), "Release: %s", darwin_error_str(kresult));
+ 
+-  cInterface->interface = IO_OBJECT_NULL;
++  cInterface->interface = NULL;
+ 
+   return darwin_to_libusb (kresult);
+ }
diff --git a/third_party/libusb/windows-build.patch b/third_party/libusb/windows-build.patch
new file mode 100644
index 0000000000000..ef2dc04a0ab1a
--- /dev/null
+++ b/third_party/libusb/windows-build.patch
@@ -0,0 +1,54 @@
+diff --git a/libusb/libusb.h b/libusb/libusb.h
+index e8e1201..15bd0d5 100644
+--- a/libusb/libusb.h
++++ b/libusb/libusb.h
+@@ -25,6 +25,12 @@
+ #define LIBUSB_H
+ 
+ #ifdef _MSC_VER
++// Disable warning 4200 for [0].
++#pragma warning(push)
++#pragma warning(disable: 4200)
++#endif
++
++#ifdef _MSC_VER
+ /* on MS environments, the inline keyword is available in C++ only */
+ #if !defined(__cplusplus)
+ #define inline __inline
+@@ -1938,4 +1944,8 @@ void LIBUSB_CALL libusb_hotplug_deregister_callback(libusb_context *ctx,
+ }
+ #endif
+ 
++#ifdef _MSC_VER
++#pragma warning(pop)
++#endif
++
+ #endif
+diff --git a/libusb/os/threads_posix.c b/libusb/os/threads_posix.c
+index 9769f58..46f6db7 100644
+--- a/libusb/os/threads_posix.c
++++ b/libusb/os/threads_posix.c
+@@ -20,11 +20,6 @@
+  */
+ 
+ #if defined(__linux__) || defined(__OpenBSD__)
+-# if defined(__linux__)
+-#  define _GNU_SOURCE
+-# else
+-#  define _BSD_SOURCE
+-# endif
+ # include <unistd.h>
+ # include <sys/syscall.h>
+ #elif defined(__APPLE__)
+diff --git a/libusb/os/windows_usb.c b/libusb/os/windows_usb.c
+index 63357b1..51ce55d 100644
+--- a/libusb/os/windows_usb.c
++++ b/libusb/os/windows_usb.c
+@@ -2142,6 +2142,7 @@ static int windows_handle_events(struct libusb_context *ctx, struct pollfd *fds,
+ 			windows_handle_callback(transfer, io_result, io_size);
+ 		} else {
+ 			usbi_err(ctx, "could not find a matching transfer for fd %x", fds[i]);
++			usbi_mutex_unlock(&ctx->open_devs_lock);
+ 			return LIBUSB_ERROR_NOT_FOUND;
+ 		}
+ 	}
diff --git a/third_party/libxml/chromium/chromium-issue-894933.patch b/third_party/libxml/chromium/chromium-issue-894933.patch
new file mode 100644
index 0000000000000..418fed5411449
--- /dev/null
+++ b/third_party/libxml/chromium/chromium-issue-894933.patch
@@ -0,0 +1,113 @@
+diff --git a/third_party/libxml/src/parser.c b/third_party/libxml/src/parser.c
+index 3a8a0d79e966..4e767091683d 100644
+--- a/third_party/libxml/src/parser.c
++++ b/third_party/libxml/src/parser.c
+@@ -2081,8 +2081,8 @@ static void xmlSHRINK (xmlParserCtxtPtr ctxt) {
+ 	xmlGROW (ctxt);
+ 
+ static void xmlGROW (xmlParserCtxtPtr ctxt) {
+-    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;
+-    unsigned long curBase = ctxt->input->cur - ctxt->input->base;
++    ptrdiff_t curEnd = ctxt->input->end - ctxt->input->cur;
++    ptrdiff_t curBase = ctxt->input->cur - ctxt->input->base;
+ 
+     if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||
+          (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&
+@@ -8857,6 +8857,18 @@ xmlParseQNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *name,
+  *     caller if it was copied, this can be detected by val[*len] == 0.
+  */
+ 
++#define GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end) \
++    const xmlChar *oldbase = ctxt->input->base;\
++    GROW;\
++    if (ctxt->instate == XML_PARSER_EOF)\
++        return(NULL);\
++    if (oldbase != ctxt->input->base) {\
++        ptrdiff_t delta = ctxt->input->base - oldbase;\
++        start = start + delta;\
++        in = in + delta;\
++    }\
++    end = ctxt->input->end;
++
+ static xmlChar *
+ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
+                          int normalize)
+@@ -8886,14 +8898,7 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
+     end = ctxt->input->end;
+     start = in;
+     if (in >= end) {
+-        const xmlChar *oldbase = ctxt->input->base;
+-	GROW;
+-	if (oldbase != ctxt->input->base) {
+-	    long delta = ctxt->input->base - oldbase;
+-	    start = start + delta;
+-	    in = in + delta;
+-	}
+-	end = ctxt->input->end;
++        GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
+     }
+     if (normalize) {
+         /*
+@@ -8910,16 +8915,7 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
+ 	    in++;
+ 	    start = in;
+ 	    if (in >= end) {
+-		const xmlChar *oldbase = ctxt->input->base;
+-		GROW;
+-                if (ctxt->instate == XML_PARSER_EOF)
+-                    return(NULL);
+-		if (oldbase != ctxt->input->base) {
+-		    long delta = ctxt->input->base - oldbase;
+-		    start = start + delta;
+-		    in = in + delta;
+-		}
+-		end = ctxt->input->end;
++                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
+                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
+                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
+                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
+@@ -8933,16 +8929,7 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
+ 	    col++;
+ 	    if ((*in++ == 0x20) && (*in == 0x20)) break;
+ 	    if (in >= end) {
+-		const xmlChar *oldbase = ctxt->input->base;
+-		GROW;
+-                if (ctxt->instate == XML_PARSER_EOF)
+-                    return(NULL);
+-		if (oldbase != ctxt->input->base) {
+-		    long delta = ctxt->input->base - oldbase;
+-		    start = start + delta;
+-		    in = in + delta;
+-		}
+-		end = ctxt->input->end;
++                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
+                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
+                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
+                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
+@@ -8971,7 +8958,7 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
+                 if (ctxt->instate == XML_PARSER_EOF)
+                     return(NULL);
+ 		if (oldbase != ctxt->input->base) {
+-		    long delta = ctxt->input->base - oldbase;
++		    ptrdiff_t delta = ctxt->input->base - oldbase;
+ 		    start = start + delta;
+ 		    in = in + delta;
+ 		    last = last + delta;
+@@ -8998,16 +8985,7 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
+ 	    in++;
+ 	    col++;
+ 	    if (in >= end) {
+-		const xmlChar *oldbase = ctxt->input->base;
+-		GROW;
+-                if (ctxt->instate == XML_PARSER_EOF)
+-                    return(NULL);
+-		if (oldbase != ctxt->input->base) {
+-		    long delta = ctxt->input->base - oldbase;
+-		    start = start + delta;
+-		    in = in + delta;
+-		}
+-		end = ctxt->input->end;
++                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
+                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
+                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
+                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
diff --git a/third_party/libxml/chromium/counted_by.patch b/third_party/libxml/chromium/counted_by.patch
new file mode 100644
index 0000000000000..834507277e724
--- /dev/null
+++ b/third_party/libxml/chromium/counted_by.patch
@@ -0,0 +1,50 @@
+From 32b70e255e10067bb9666129973d5c067eacd290 Mon Sep 17 00:00:00 2001
+From: Daniel Cheng <dcheng@chromium.org>
+Date: Wed, 5 Feb 2025 15:06:34 -0800
+Subject: [PATCH] Use __has_attribute to check for __counted_by__ support
+
+The initial clang patch to support __counted_by__ was landed and
+reverted several times. There are some clang toolchains (e.g. the
+Android toolchain) that report themselves as version 18 but do not
+support __counted_by__. While it is debatable if Android should be
+shipping a pre-release clang, using __has_attribute should be a bit
+simpler overall.
+
+Note that this doesn't migrate everything else to use __has_attribute:
+while clang has always supported __has_attribute, gcc didn't support
+it until a bit later.
+
+Change-Id: I4a612f6373ec298c4bf9793a74e4c3a9e9a30591
+---
+ third_party/libxml/src/libxml.h | 10 ++++++++--
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+diff --git a/third_party/libxml/src/libxml.h b/third_party/libxml/src/libxml.h
+index 1fe3825f4d3f8..dde9a9c92f014 100644
+--- a/third_party/libxml/src/libxml.h
++++ b/third_party/libxml/src/libxml.h
+@@ -29,6 +29,12 @@
+ #include "config.h"
+ #include <libxml/xmlversion.h>
+
++#if defined(__has_attribute)
++#define XML_HAS_ATTRIBUTE(x) __has_attribute(x)
++#else
++#define XML_HAS_ATTRIBUTE(x) 0
++#endif
++
+ #if !defined(_WIN32) && \
+     !defined(__CYGWIN__) && \
+     (defined(__clang__) || \
+@@ -48,8 +54,8 @@
+   #define ATTRIBUTE_DESTRUCTOR __attribute__((destructor))
+ #endif
+
+-#if (defined(__clang__) && __clang_major__ >= 18) || \
+-    (defined(__GNUC__) && __GNUC__ >= 15)
++#if XML_HAS_ATTRIBUTE(__counted_by__)
+   #define ATTRIBUTE_COUNTED_BY(c) __attribute__((__counted_by__(c)))
+ #else
+   #define ATTRIBUTE_COUNTED_BY(c)
+--
+2.48.1.502.g6dc24dfdaf-goog
diff --git a/third_party/libxml/chromium/remove-getentropy.patch b/third_party/libxml/chromium/remove-getentropy.patch
new file mode 100644
index 0000000000000..d32ad0532dc94
--- /dev/null
+++ b/third_party/libxml/chromium/remove-getentropy.patch
@@ -0,0 +1,59 @@
+This patch removes calls to getentropy() and BCryptGetRandom() because they
+aren't implemented or supported on certain platforms based on the trybot
+results I saw. I will try upstreaming a configure script flag soon to replace
+this patch file. This patch is safe because it reverts the random number
+generation behavior before a recent libxml upstream patch.
+
+diff --git a/dict.c b/dict.c
+index ccd8b542..6273437e 100644
+--- a/dict.c
++++ b/dict.c
+@@ -928,13 +928,8 @@ xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
+ #ifdef _WIN32
+   #define WIN32_LEAN_AND_MEAN
+   #include <windows.h>
+-  #include <bcrypt.h>
+-#elif HAVE_DECL_GETENTROPY
+-  #include <unistd.h>
+-  #include <sys/random.h>
+-#else
+-  #include <time.h>
+ #endif
++#include <time.h>
+ 
+ static xmlMutex xmlRngMutex;
+ 
+@@ -951,25 +946,6 @@ xmlInitRandom(void) {
+     xmlInitMutex(&xmlRngMutex);
+ 
+     {
+-#ifdef _WIN32
+-        NTSTATUS status;
+-
+-        status = BCryptGenRandom(NULL, (unsigned char *) globalRngState,
+-                                 sizeof(globalRngState),
+-                                 BCRYPT_USE_SYSTEM_PREFERRED_RNG);
+-        if (!BCRYPT_SUCCESS(status))
+-            xmlAbort("libxml2: BCryptGenRandom failed with error code %lu\n",
+-                     GetLastError());
+-#elif HAVE_DECL_GETENTROPY
+-        while (1) {
+-            if (getentropy(globalRngState, sizeof(globalRngState)) == 0)
+-                break;
+-
+-            if (errno != EINTR)
+-                xmlAbort("libxml2: getentropy failed with error code %d\n",
+-                         errno);
+-        }
+-#else
+         int var;
+ 
+         globalRngState[0] =
+@@ -978,7 +954,6 @@ xmlInitRandom(void) {
+         globalRngState[1] =
+                 HASH_ROL((unsigned) ((size_t) &xmlRngMutex & 0xFFFFFFFF), 16) ^
+                 HASH_ROL((unsigned) ((size_t) &var & 0xFFFFFFFF), 24);
+-#endif
+     }
+ }
+ 
diff --git a/third_party/libxml/chromium/undo-sax-deprecation.patch b/third_party/libxml/chromium/undo-sax-deprecation.patch
new file mode 100644
index 0000000000000..d618d46ceaee3
--- /dev/null
+++ b/third_party/libxml/chromium/undo-sax-deprecation.patch
@@ -0,0 +1,15 @@
+diff --git a/include/libxml/parser.h b/include/libxml/parser.h
+index d104b874..6dc4ca9b 100644
+--- a/include/libxml/parser.h
++++ b/include/libxml/parser.h
+@@ -899,7 +899,9 @@ XMLPUBFUN xmlDocPtr
+ 		xmlSAXParseDoc		(xmlSAXHandlerPtr sax,
+ 					 const xmlChar *cur,
+ 					 int recovery);
+-XML_DEPRECATED
++// TODO(https://github.com/google/maldoca/issues/87): Re-Deprecate this when
++//   maldoca stops using xmlSAXParseMemory.
++//XML_DEPRECATED
+ XMLPUBFUN xmlDocPtr
+ 		xmlSAXParseMemory	(xmlSAXHandlerPtr sax,
+ 					 const char *buffer,
diff --git a/third_party/libxslt/chromium/xslt-locale.patch b/third_party/libxslt/chromium/xslt-locale.patch
new file mode 100644
index 0000000000000..4e8ef11056e38
--- /dev/null
+++ b/third_party/libxslt/chromium/xslt-locale.patch
@@ -0,0 +1,45 @@
+WebKit sets a custom xslt sort function with the expectation that libxslt passes
+strings directly from the input. If locale support is enabled, libxslt will
+transform the string using into something WebKit does not expect. This will
+break third_party/WebKit/LayoutTests/fast/xsl/sort-locale.xml. By disabling
+POSIX and Windows locale support, we preserve the behavior WebKit expects in
+XsltUnicodeSortFunction.
+
+In addition, it would seem that strxfrm_l is not supported on Fuchsia as using
+it without this patch causes a compile error.
+
+diff --git a/libxslt/xsltlocale.c b/libxslt/xsltlocale.c
+index 5a929188..9324f284 100644
+--- a/libxslt/xsltlocale.c
++++ b/libxslt/xsltlocale.c
+@@ -19,29 +19,7 @@
+ #include "xsltlocale.h"
+ #include "xsltutils.h"
+ 
+-#ifdef HAVE_STRXFRM_L
+-
+-  #define XSLT_LOCALE_POSIX
+-
+-  #ifdef HAVE_LOCALE_H
+-    #include <locale.h>
+-  #endif
+-  #ifdef HAVE_XLOCALE_H
+-    #include <xlocale.h>
+-  #endif
+-
+-#elif defined(_WIN32)
+-
+-  #define XSLT_LOCALE_WINAPI
+-
+-  #include <windows.h>
+-  #include <winnls.h>
+-
+-#else
+-
+-  #define XSLT_LOCALE_NONE
+-
+-#endif
++#define XSLT_LOCALE_NONE
+ 
+ #define TOUPPER(c) (c & ~0x20)
+ #define TOLOWER(c) (c | 0x20)
diff --git a/third_party/libzip/patches/0001-Replace-usage-of-sprintf-with-snprintf.patch b/third_party/libzip/patches/0001-Replace-usage-of-sprintf-with-snprintf.patch
new file mode 100644
index 0000000000000..a0774633c8fa5
--- /dev/null
+++ b/third_party/libzip/patches/0001-Replace-usage-of-sprintf-with-snprintf.patch
@@ -0,0 +1,78 @@
+From 740c39a00040ae0dd3c7fe46f2962ffafc5dbd1a Mon Sep 17 00:00:00 2001
+From: Rohit Rao <rohitrao@chromium.org>
+Date: Thu, 25 Aug 2022 16:03:07 -0400
+Subject: [PATCH] Replace usage of sprintf with snprintf.
+
+---
+ third_party/libzip/src/lib/zip_error_strerror.c        |  7 ++++---
+ .../libzip/src/lib/zip_source_file_stdio_named.c       | 10 ++++++----
+ 2 files changed, 10 insertions(+), 7 deletions(-)
+
+diff --git a/third_party/libzip/src/lib/zip_error_strerror.c b/third_party/libzip/src/lib/zip_error_strerror.c
+index 93b24eab1786e..895a51e6fa63a 100644
+--- a/third_party/libzip/src/lib/zip_error_strerror.c
++++ b/third_party/libzip/src/lib/zip_error_strerror.c
+@@ -48,7 +48,7 @@ zip_error_strerror(zip_error_t *err) {
+     zip_error_fini(err);
+ 
+     if (err->zip_err < 0 || err->zip_err >= _zip_nerr_str) {
+-	sprintf(buf, "Unknown error %d", err->zip_err);
++	snprintf(buf, 128, "Unknown error %d", err->zip_err);
+ 	zs = NULL;
+ 	ss = buf;
+     }
+@@ -72,10 +72,11 @@ zip_error_strerror(zip_error_t *err) {
+     if (ss == NULL)
+ 	return zs;
+     else {
+-	if ((s = (char *)malloc(strlen(ss) + (zs ? strlen(zs) + 2 : 0) + 1)) == NULL)
++	size_t length = strlen(ss) + (zs ? strlen(zs) + 2 : 0) + 1;
++	if ((s = (char *)malloc(length)) == NULL)
+ 	    return _zip_err_str[ZIP_ER_MEMORY];
+ 
+-	sprintf(s, "%s%s%s", (zs ? zs : ""), (zs ? ": " : ""), ss);
++	snprintf(s, length, "%s%s%s", (zs ? zs : ""), (zs ? ": " : ""), ss);
+ 	err->str = s;
+ 
+ 	return s;
+diff --git a/third_party/libzip/src/lib/zip_source_file_stdio_named.c b/third_party/libzip/src/lib/zip_source_file_stdio_named.c
+index dae8177c49697..97c1301ab460d 100644
+--- a/third_party/libzip/src/lib/zip_source_file_stdio_named.c
++++ b/third_party/libzip/src/lib/zip_source_file_stdio_named.c
+@@ -129,7 +129,8 @@ _zip_stdio_op_create_temp_output(zip_source_file_context_t *ctx) {
+     FILE *tfp;
+     struct stat st;
+ 
+-    if ((temp = (char *)malloc(strlen(ctx->fname) + 8)) == NULL) {
++    size_t temp_size = strlen(ctx->fname) + 8;
++    if ((temp = (char *)malloc(temp_size)) == NULL) {
+ 	zip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);
+ 	return -1;
+     }
+@@ -141,7 +142,7 @@ _zip_stdio_op_create_temp_output(zip_source_file_context_t *ctx) {
+ 	mode = -1;
+     }
+ 
+-    sprintf(temp, "%s.XXXXXX", ctx->fname);
++    snprintf(temp, temp_size, "%s.XXXXXX", ctx->fname);
+ 
+     if ((tfd = _zip_mkstempm(temp, mode)) == -1) {
+ 	zip_error_set(&ctx->error, ZIP_ER_TMPOPEN, errno);
+@@ -174,11 +175,12 @@ _zip_stdio_op_create_temp_output_cloning(zip_source_file_context_t *ctx, zip_uin
+ 	return -1;
+     }
+ 
+-    if ((temp = (char *)malloc(strlen(ctx->fname) + 8)) == NULL) {
++    size_t temp_size = strlen(ctx->fname) + 8;
++    if ((temp = (char *)malloc(temp_size)) == NULL) {
+ 	zip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);
+ 	return -1;
+     }
+-    sprintf(temp, "%s.XXXXXX", ctx->fname);
++    snprintf(temp, temp_size, "%s.XXXXXX", ctx->fname);
+ 
+ #ifdef HAVE_CLONEFILE
+ #ifndef __clang_analyzer__
+-- 
+2.37.2.672.g94769d06f0-goog
+
diff --git a/third_party/libzip/patches/0001-add-built-config.h.patch b/third_party/libzip/patches/0001-add-built-config.h.patch
new file mode 100644
index 0000000000000..d93e34def9584
--- /dev/null
+++ b/third_party/libzip/patches/0001-add-built-config.h.patch
@@ -0,0 +1,82 @@
+From 346351bec3c6a50994568576b8bc6c8ff770a0dc Mon Sep 17 00:00:00 2001
+From: Michael Crouse <mcrouse@chromium.org>
+Date: Tue, 5 Jan 2021 09:08:54 -0800
+Subject: [PATCH] add built config.h
+
+---
+ third_party/libzip/src/config.h | 62 +++++++++++++++++++++++++++++++++
+ 1 file changed, 62 insertions(+)
+ create mode 100644 third_party/libzip/src/config.h
+
+diff --git a/third_party/libzip/src/config.h b/third_party/libzip/src/config.h
+new file mode 100644
+index 000000000000..536e20b32e6f
+--- /dev/null
++++ b/third_party/libzip/src/config.h
+@@ -0,0 +1,62 @@
++#ifndef HAD_CONFIG_H
++#define HAD_CONFIG_H
++#ifndef _HAD_ZIPCONF_H
++#include "zipconf.h"
++#endif
++/* BEGIN DEFINES */
++/* #undef HAVE___PROGNAME */
++/* #undef HAVE__CLOSE */
++/* #undef HAVE__DUP */
++/* #undef HAVE__FDOPEN */
++/* #undef HAVE__FILENO */
++/* #undef HAVE__SETMODE */
++/* #undef HAVE__SNPRINTF */
++/* #undef HAVE__STRDUP */
++/* #undef HAVE__STRICMP */
++/* #undef HAVE__STRTOI64 */
++/* #undef HAVE__STRTOUI64 */
++/* #undef HAVE__UMASK */
++/* #undef HAVE__UNLINK */
++/* #undef HAVE_ARC4RANDOM */
++/* #undef HAVE_CLONEFILE */
++/* #undef HAVE_COMMONCRYPTO */
++/* #undef HAVE_CRYPTO */
++/* #undef HAVE_FICLONERANGE */
++#define HAVE_FILENO
++#define HAVE_FSEEKO
++#define HAVE_FTELLO
++/* #undef HAVE_GETPROGNAME */
++/* #undef HAVE_GNUTLS */
++/* #undef HAVE_LIBBZ2 */
++/* #undef HAVE_LIBLZMA */
++#define HAVE_LOCALTIME_R
++/* #undef HAVE_MBEDTLS */
++/* #undef HAVE_MKSTEMP */
++/* #undef HAVE_NULLABLE */
++/* #undef HAVE_OPENSSL */
++/* #undef HAVE_SETMODE */
++#define HAVE_SNPRINTF
++#define HAVE_STRCASECMP
++#define HAVE_STRDUP
++/* #undef HAVE_STRICMP */
++#define HAVE_STRTOLL
++#define HAVE_STRTOULL
++/* #undef HAVE_STRUCT_TM_TM_ZONE */
++#define HAVE_STDBOOL_H
++#define HAVE_STRINGS_H
++#define HAVE_UNISTD_H
++/* #undef HAVE_WINDOWS_CRYPTO */
++#define SIZEOF_OFF_T 8
++#define SIZEOF_SIZE_T 8
++/* #undef HAVE_DIRENT_H */
++#define HAVE_FTS_H
++/* #undef HAVE_NDIR_H */
++/* #undef HAVE_SYS_DIR_H */
++/* #undef HAVE_SYS_NDIR_H */
++/* #undef WORDS_BIGENDIAN */
++#define HAVE_SHARED
++/* END DEFINES */
++#define PACKAGE "libzip"
++#define VERSION "1.7.3"
++
++#endif /* HAD_CONFIG_H */
+\ No newline at end of file
+-- 
+2.29.2.729.g45daf8777d-goog
+
diff --git a/third_party/libzip/patches/0001-add-built-zip_err_str.c.patch b/third_party/libzip/patches/0001-add-built-zip_err_str.c.patch
new file mode 100644
index 0000000000000..f4dcf1d27b46e
--- /dev/null
+++ b/third_party/libzip/patches/0001-add-built-zip_err_str.c.patch
@@ -0,0 +1,104 @@
+From 327a318dbdb7d91986cc0d8fa46b44118bf8463d Mon Sep 17 00:00:00 2001
+From: Michael Crouse <mcrouse@chromium.org>
+Date: Tue, 5 Jan 2021 09:06:54 -0800
+Subject: [PATCH] add built zip_err_str.c
+
+---
+ third_party/libzip/src/zip_err_str.c | 84 ++++++++++++++++++++++++++++
+ 1 file changed, 84 insertions(+)
+ create mode 100644 third_party/libzip/src/zip_err_str.c
+
+diff --git a/third_party/libzip/src/zip_err_str.c b/third_party/libzip/src/zip_err_str.c
+new file mode 100644
+index 000000000000..d3efa54a1fe4
+--- /dev/null
++++ b/third_party/libzip/src/zip_err_str.c
+@@ -0,0 +1,84 @@
++/*
++  This file was generated automatically by CMake
++  from zip.h; make changes there.
++*/
++
++#include "lib/zipint.h"
++
++const char * const _zip_err_str[] = {
++    "No error",
++    "Multi-disk zip archives not supported",
++    "Renaming temporary file failed",
++    "Closing zip archive failed",
++    "Seek error",
++    "Read error",
++    "Write error",
++    "CRC error",
++    "Containing zip archive was closed",
++    "No such file",
++    "File already exists",
++    "Can't open file",
++    "Failure to create temporary file",
++    "Zlib error",
++    "Malloc failure",
++    "Entry has been changed",
++    "Compression method not supported",
++    "Premature end of file",
++    "Invalid argument",
++    "Not a zip archive",
++    "Internal error",
++    "Zip archive inconsistent",
++    "Can't remove file",
++    "Entry has been deleted",
++    "Encryption method not supported",
++    "Read-only archive",
++    "No password provided",
++    "Wrong password provided",
++    "Operation not supported",
++    "Resource still in use",
++    "Tell error",
++    "Compressed data invalid",
++    "Operation cancelled",
++};
++
++const int _zip_nerr_str = sizeof(_zip_err_str)/sizeof(_zip_err_str[0]);
++
++#define N ZIP_ET_NONE
++#define S ZIP_ET_SYS
++#define Z ZIP_ET_ZLIB
++
++const int _zip_err_type[] = {
++    N,
++    N,
++    S,
++    S,
++    S,
++    S,
++    S,
++    N,
++    N,
++    N,
++    N,
++    S,
++    S,
++    Z,
++    N,
++    N,
++    N,
++    N,
++    N,
++    N,
++    N,
++    N,
++    S,
++    N,
++    N,
++    N,
++    N,
++    N,
++    N,
++    N,
++    S,
++    N,
++    N,
++};
+\ No newline at end of file
+-- 
+2.29.2.729.g45daf8777d-goog
+
diff --git a/third_party/libzip/patches/0001-add-built-zipconf.h.patch b/third_party/libzip/patches/0001-add-built-zipconf.h.patch
new file mode 100644
index 0000000000000..fcebf740805ff
--- /dev/null
+++ b/third_party/libzip/patches/0001-add-built-zipconf.h.patch
@@ -0,0 +1,71 @@
+From a944ceb9e95664e0590771b769b455bf7e0382c9 Mon Sep 17 00:00:00 2001
+From: Michael Crouse <mcrouse@chromium.org>
+Date: Tue, 5 Jan 2021 09:10:20 -0800
+Subject: [PATCH] add built zipconf.h
+
+---
+ third_party/libzip/src/zipconf.h | 51 ++++++++++++++++++++++++++++++++
+ 1 file changed, 51 insertions(+)
+ create mode 100644 third_party/libzip/src/zipconf.h
+
+diff --git a/third_party/libzip/src/zipconf.h b/third_party/libzip/src/zipconf.h
+new file mode 100644
+index 000000000000..cc5abcc681ff
+--- /dev/null
++++ b/third_party/libzip/src/zipconf.h
+@@ -0,0 +1,51 @@
++#ifndef _HAD_ZIPCONF_H
++#define _HAD_ZIPCONF_H
++
++/*
++   zipconf.h -- platform specific include file
++
++   This file was generated automatically by CMake
++   based on ../cmake-zipconf.h.in.
++ */
++
++#define LIBZIP_VERSION "1.7.3"
++#define LIBZIP_VERSION_MAJOR 1
++#define LIBZIP_VERSION_MINOR 7
++#define LIBZIP_VERSION_MICRO 3
++
++/* #undef ZIP_STATIC */
++
++#define _Nullable
++#define _Nonnull
++
++#if !defined(__STDC_FORMAT_MACROS)
++#define __STDC_FORMAT_MACROS 1
++#endif
++#include <inttypes.h>
++
++typedef int8_t zip_int8_t;
++typedef uint8_t zip_uint8_t;
++typedef int16_t zip_int16_t;
++typedef uint16_t zip_uint16_t;
++typedef int32_t zip_int32_t;
++typedef uint32_t zip_uint32_t;
++typedef int64_t zip_int64_t;
++typedef uint64_t zip_uint64_t;
++
++#define ZIP_INT8_MIN	 (-ZIP_INT8_MAX-1)
++#define ZIP_INT8_MAX	 0x7f
++#define ZIP_UINT8_MAX	 0xff
++
++#define ZIP_INT16_MIN	 (-ZIP_INT16_MAX-1)
++#define ZIP_INT16_MAX	 0x7fff
++#define ZIP_UINT16_MAX	 0xffff
++
++#define ZIP_INT32_MIN	 (-ZIP_INT32_MAX-1L)
++#define ZIP_INT32_MAX	 0x7fffffffL
++#define ZIP_UINT32_MAX	 0xffffffffLU
++
++#define ZIP_INT64_MIN	 (-ZIP_INT64_MAX-1LL)
++#define ZIP_INT64_MAX	 0x7fffffffffffffffLL
++#define ZIP_UINT64_MAX	 0xffffffffffffffffULL
++
++#endif /* zipconf.h */
+\ No newline at end of file
+-- 
+2.29.2.729.g45daf8777d-goog
+
diff --git a/third_party/libzip/patches/0001-patch-configs.patch b/third_party/libzip/patches/0001-patch-configs.patch
new file mode 100644
index 0000000000000..24bc27e8d823d
--- /dev/null
+++ b/third_party/libzip/patches/0001-patch-configs.patch
@@ -0,0 +1,113 @@
+From f74866358fc0b8e7b77c4603a4dd70b09e6ccbbd Mon Sep 17 00:00:00 2001
+From: mcrouse <mcrouse@google.com>
+Date: Fri, 5 Feb 2021 16:20:25 +0000
+Subject: [PATCH] patch configs for windows
+
+---
+ third_party/libzip/src/config.h  | 18 ++++++++++++++++--
+ third_party/libzip/src/zipconf.h | 12 ++++++++++--
+ 2 files changed, 26 insertions(+), 4 deletions(-)
+
+diff --git a/third_party/libzip/src/config.h b/third_party/libzip/src/config.h
+index 536e20b32e6f..15dfff401971 100644
+--- a/third_party/libzip/src/config.h
++++ b/third_party/libzip/src/config.h
+@@ -3,6 +3,9 @@
+ #ifndef _HAD_ZIPCONF_H
+ #include "zipconf.h"
+ #endif
++
++#include "build/build_config.h"
++
+ /* BEGIN DEFINES */
+ /* #undef HAVE___PROGNAME */
+ /* #undef HAVE__CLOSE */
+@@ -23,28 +26,39 @@
+ /* #undef HAVE_CRYPTO */
+ /* #undef HAVE_FICLONERANGE */
+ #define HAVE_FILENO
++#if !defined(OS_WIN)
+ #define HAVE_FSEEKO
+ #define HAVE_FTELLO
++#endif
+ /* #undef HAVE_GETPROGNAME */
+ /* #undef HAVE_GNUTLS */
+ /* #undef HAVE_LIBBZ2 */
+ /* #undef HAVE_LIBLZMA */
++/* #undef HAVE_LOCALTIME_R */
++#if !defined(OS_WIN)
+ #define HAVE_LOCALTIME_R
++#endif
+ /* #undef HAVE_MBEDTLS */
+ /* #undef HAVE_MKSTEMP */
+ /* #undef HAVE_NULLABLE */
+ /* #undef HAVE_OPENSSL */
+ /* #undef HAVE_SETMODE */
+ #define HAVE_SNPRINTF
++#if !defined(OS_WIN)
+ #define HAVE_STRCASECMP
++#endif
+ #define HAVE_STRDUP
+-/* #undef HAVE_STRICMP */
++#if defined(OS_WIN)
++#define HAVE_STRICMP
++#endif
+ #define HAVE_STRTOLL
+ #define HAVE_STRTOULL
+ /* #undef HAVE_STRUCT_TM_TM_ZONE */
+ #define HAVE_STDBOOL_H
++#if !defined(OS_WIN)
+ #define HAVE_STRINGS_H
+ #define HAVE_UNISTD_H
++#endif
+ /* #undef HAVE_WINDOWS_CRYPTO */
+ #define SIZEOF_OFF_T 8
+ #define SIZEOF_SIZE_T 8
+@@ -59,4 +73,4 @@
+ #define PACKAGE "libzip"
+ #define VERSION "1.7.3"
+ 
+-#endif /* HAD_CONFIG_H */
+\ No newline at end of file
++#endif /* HAD_CONFIG_H */
+diff --git a/third_party/libzip/src/zipconf.h b/third_party/libzip/src/zipconf.h
+index 4db748234649..f79875034709 100644
+--- a/third_party/libzip/src/zipconf.h
++++ b/third_party/libzip/src/zipconf.h
+@@ -8,12 +8,16 @@
+    based on ../cmake-zipconf.h.in.
+  */
+ 
++#include "build/build_config.h"
++
+ #define LIBZIP_VERSION "1.7.3"
+ #define LIBZIP_VERSION_MAJOR 1
+ #define LIBZIP_VERSION_MINOR 7
+ #define LIBZIP_VERSION_MICRO 3
+ 
+-/* #undef ZIP_STATIC */
++#define ZIP_STATIC
+ 
+ #define _Nullable
+ #define _Nonnull
+@@ -32,6 +36,10 @@ typedef uint32_t zip_uint32_t;
+ typedef int64_t zip_int64_t;
+ typedef uint64_t zip_uint64_t;
+ 
++#if defined(OS_WIN)
++typedef int mode_t;
++#endif
++
+ #define ZIP_INT8_MIN (-ZIP_INT8_MAX - 1)
+ #define ZIP_INT8_MAX 0x7f
+ #define ZIP_UINT8_MAX 0xff
+@@ -48,4 +56,4 @@ typedef uint64_t zip_uint64_t;
+ #define ZIP_INT64_MAX 0x7fffffffffffffffLL
+ #define ZIP_UINT64_MAX 0xffffffffffffffffULL
+ 
+-#endif /* zipconf.h */
+\ No newline at end of file
++#endif /* zipconf.h */
+-- 
+2.30.0.365.g02bc693789-goog
+
diff --git a/third_party/lzma_sdk/chromium.patch b/third_party/lzma_sdk/chromium.patch
new file mode 100644
index 0000000000000..168ca263574d8
--- /dev/null
+++ b/third_party/lzma_sdk/chromium.patch
@@ -0,0 +1,46 @@
+diff -r /Users/waffles/Downloads/lzma2409/Asm/x86/LzmaDecOpt.asm ./Asm/x86/LzmaDecOpt.asm
+42c42,44
+< _TEXT$LZMADECOPT SEGMENT ALIGN(64) 'CODE'
+---
+> ; Make this deterministic
+> ; _TEXT$LZMADECOPT SEGMENT ALIGN(64) 'CODE'
+> LZMADEC SEGMENT ALIGN(64) 'CODE'
+1336c1338
+< _TEXT$LZMADECOPT ENDS
+---
+> LZMADEC ENDS
+diff -r /Users/waffles/Downloads/lzma2409/C/CpuArch.h ./C/CpuArch.h
+413c413,417
+< 
+---
+> // Disable MY_CPU_LE_UNALIGN. Although the underlying ISA may be able to load
+> // unaligned words, doing so via pointer casts is undefined behavior in C and
+> // C++, under both strict aliasing and because it is invalid to construct
+> // unaligned pointers. Instead, load the bytes generically and leave optimizing
+> // this to the compiler.
+419,420c423,424
+<     #define MY_CPU_LE_UNALIGN
+<     #define MY_CPU_LE_UNALIGN_64
+---
+>     // #define MY_CPU_LE_UNALIGN
+>     // #define MY_CPU_LE_UNALIGN_64
+diff -r /Users/waffles/Downloads/lzma2409/C/LzFind.c ./C/LzFind.c
+598c598
+< 
+---
+> #if 0
+642c642
+< 
+---
+> #endif // #if 0
+diff -r /Users/waffles/Downloads/lzma2409/C/Util/SfxSetup/SfxSetup.c ./C/Util/SfxSetup/SfxSetup.c
+13a14,17
+> // SHELLEXECUTEINFO
+> #include <windows.h>
+> #include <shellapi.h>
+> 
+144c148
+< #define kSignatureSearchLimit (1 << 22)
+---
+> #define kSignatureSearchLimit (1 << 26)
+
diff --git a/third_party/mediapipe/patches/0001-Fix-sentencepiece-include.patch b/third_party/mediapipe/patches/0001-Fix-sentencepiece-include.patch
new file mode 100644
index 0000000000000..47ef3bde001ba
--- /dev/null
+++ b/third_party/mediapipe/patches/0001-Fix-sentencepiece-include.patch
@@ -0,0 +1,26 @@
+From 7d8ce443d26b21d8232877a33fea6fc36060f4ac Mon Sep 17 00:00:00 2001
+From: Steven Holte <holte@google.com>
+Date: Thu, 25 Jul 2024 20:00:28 +0000
+Subject: [PATCH] Fix sentencepiece include.
+
+Change-Id: I889974f0ee47e53d5302f688e88df803bd11861c
+---
+ .../tasks/cc/text/tokenizers/sentencepiece_tokenizer.h          | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/tasks/cc/text/tokenizers/sentencepiece_tokenizer.h b/third_party/mediapipe/src/mediapipe/tasks/cc/text/tokenizers/sentencepiece_tokenizer.h
+index 85881c9e8e82..050d621afb11 100644
+--- a/third_party/mediapipe/src/mediapipe/tasks/cc/text/tokenizers/sentencepiece_tokenizer.h
++++ b/third_party/mediapipe/src/mediapipe/tasks/cc/text/tokenizers/sentencepiece_tokenizer.h
+@@ -25,7 +25,7 @@ limitations under the License.
+ #include "absl/strings/string_view.h"
+ #include "mediapipe/framework/port/logging.h"
+ #include "mediapipe/tasks/cc/text/tokenizers/tokenizer.h"
+-#include "sentencepiece/src/sentencepiece_processor.h"  // from @com_google_sentencepiece
++#include "src/sentencepiece_processor.h"  // from @com_google_sentencepiece
+ 
+ namespace mediapipe {
+ namespace tasks {
+-- 
+2.46.0.rc1.232.g9752f9e123-goog
+
diff --git a/third_party/mediapipe/patches/compile-with-gpu-on-windows.patch b/third_party/mediapipe/patches/compile-with-gpu-on-windows.patch
new file mode 100644
index 0000000000000..49ae324dfcede
--- /dev/null
+++ b/third_party/mediapipe/patches/compile-with-gpu-on-windows.patch
@@ -0,0 +1,261 @@
+From f54d1ebaf0b039ea47c09383ff445ae686025390 Mon Sep 17 00:00:00 2001
+From: Piotr Bialecki <bialpio@chromium.org>
+Date: Thu, 24 Aug 2023 16:01:51 -0700
+Subject: [PATCH] Compile MediaPipe with GPU support on Windows on ANGLE
+
+Major changes:
+- Allow mediapipe to be built with pthreads disabled.
+- Turn off LeakCheckDisabler, Chromium cannot depend on it.
+---
+ .../mediapipe/src/mediapipe/gpu/gl_base.h     |  3 ++
+ .../src/mediapipe/gpu/gl_calculator_helper.h  |  6 ++--
+ .../mediapipe/src/mediapipe/gpu/gl_context.cc | 29 +++++++++++++++----
+ .../mediapipe/src/mediapipe/gpu/gl_context.h  |  7 ++---
+ .../src/mediapipe/gpu/gl_context_egl.cc       |  6 ++++
+ .../src/mediapipe/gpu/gl_context_internal.h   | 12 +++++++-
+ .../src/mediapipe/gpu/gpu_service.cc          |  5 ++--
+ 7 files changed, 54 insertions(+), 14 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_base.h b/third_party/mediapipe/src/mediapipe/gpu/gl_base.h
+index a16bcffa3b27b..64e288d5aca75 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gl_base.h
++++ b/third_party/mediapipe/src/mediapipe/gpu/gl_base.h
+@@ -78,6 +78,9 @@
+ #undef Bool
+ #undef Success
+ 
++// When using Windows, we may end up pulling a #define for GetObject.
++#undef GetObject
++
+ #endif  // defined(__APPLE__)
+ 
+ namespace mediapipe {
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.h b/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.h
+index 467defe4cae70..6b45031c6f7ff 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.h
++++ b/third_party/mediapipe/src/mediapipe/gpu/gl_calculator_helper.h
+@@ -16,6 +16,7 @@
+ #define MEDIAPIPE_GPU_GL_CALCULATOR_HELPER_H_
+ 
+ #include <memory>
++#include <type_traits>
+ 
+ #include "absl/base/attributes.h"
+ #include "absl/memory/memory.h"
+@@ -98,8 +99,9 @@ class GlCalculatorHelper {
+   //
+   // Therefore, instead of using std::function<void(void)>, we use a template
+   // that only accepts arguments with a void result type.
+-  template <typename T, typename = typename std::enable_if<std::is_void<
+-                            typename std::result_of<T()>::type>::value>::type>
++  template <typename T,
++            typename = typename std::enable_if<std::is_void<
++                typename std::invoke_result<T>::type>::value>::type>
+   void RunInGlContext(T f) {
+     RunInGlContext([f] {
+       f();
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc b/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
+index 0be605db552c6..302bfb8466f31 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
++++ b/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
+@@ -14,6 +14,10 @@
+ 
+ #include "mediapipe/gpu/gl_context.h"
+ 
++#if !MEDIAPIPE_DISABLE_PTHREADS
++#include <pthread.h>
++#endif
++
+ #include <sys/types.h>
+ 
+ #include <algorithm>
+@@ -95,17 +99,29 @@ static void SetThreadName(const char* name) {
+ }
+ 
+ GlContext::DedicatedThread::DedicatedThread() {
++#if !MEDIAPIPE_DISABLE_PTHREADS
+   ABSL_CHECK_EQ(pthread_create(&gl_thread_id_, nullptr, ThreadBody, this), 0);
++#else
++  gl_thread_ = std::thread(&DedicatedThread::ThreadBody, this);
++#endif
+ }
+ 
+ GlContext::DedicatedThread::~DedicatedThread() {
+   if (IsCurrentThread()) {
+     ABSL_CHECK(self_destruct_);
++#if !MEDIAPIPE_DISABLE_PTHREADS
+     ABSL_CHECK_EQ(pthread_detach(gl_thread_id_), 0);
++#else
++    gl_thread_.detach();
++#endif
+   } else {
+     // Give an invalid job to signal termination.
+     PutJob({});
++#if !MEDIAPIPE_DISABLE_PTHREADS
+     ABSL_CHECK_EQ(pthread_join(gl_thread_id_, nullptr), 0);
++#else
++    gl_thread_.join();
++#endif
+   }
+ }
+ 
+@@ -131,11 +147,14 @@ void GlContext::DedicatedThread::PutJob(Job job) {
+   has_jobs_cv_.SignalAll();
+ }
+ 
++#if !MEDIAPIPE_DISABLE_PTHREADS
++// static
+ void* GlContext::DedicatedThread::ThreadBody(void* instance) {
+   DedicatedThread* thread = static_cast<DedicatedThread*>(instance);
+   thread->ThreadBody();
+   return nullptr;
+ }
++#endif
+ 
+ #ifdef __APPLE__
+ #define AUTORELEASEPOOL @autoreleasepool
+@@ -199,7 +218,11 @@ void GlContext::DedicatedThread::RunWithoutWaiting(GlVoidFunction gl_func) {
+ }
+ 
+ bool GlContext::DedicatedThread::IsCurrentThread() {
++#if !MEDIAPIPE_DISABLE_PTHREADS
+   return pthread_equal(gl_thread_id_, pthread_self());
++#else
++  return std::this_thread::get_id() == gl_thread_.get_id();
++#endif
+ }
+ 
+ bool GlContext::ParseGlVersion(absl::string_view version_string, GLint* major,
+@@ -499,10 +522,6 @@ void GlContext::RunWithoutWaiting(GlVoidFunction gl_func) {
+ }
+ 
+ std::weak_ptr<GlContext>& GlContext::CurrentContext() {
+-  // Workaround for b/67878799.
+-#ifndef __EMSCRIPTEN__
+-  absl::LeakCheckDisabler disable_leak_check;
+-#endif
+   ABSL_CONST_INIT thread_local std::weak_ptr<GlContext> current_context;
+   return current_context;
+ }
+@@ -1126,7 +1145,7 @@ void GlContext::SetStandardTextureParams(GLenum target, GLint internal_format) {
+   glTexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+ }
+ 
+-const GlContext::Attachment<GLuint> kUtilityFramebuffer(
++ABSL_CONST_INIT const GlContext::Attachment<GLuint> kUtilityFramebuffer(
+     [](GlContext&) -> GlContext::Attachment<GLuint>::Ptr {
+       GLuint framebuffer;
+       glGenFramebuffers(1, &framebuffer);
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_context.h b/third_party/mediapipe/src/mediapipe/gpu/gl_context.h
+index e491bb9b06ce1..35c93064960ba 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gl_context.h
++++ b/third_party/mediapipe/src/mediapipe/gpu/gl_context.h
+@@ -15,8 +15,6 @@
+ #ifndef MEDIAPIPE_GPU_GL_CONTEXT_H_
+ #define MEDIAPIPE_GPU_GL_CONTEXT_H_
+ 
+-#include <pthread.h>
+-
+ #include <atomic>
+ #include <cstdint>
+ #include <functional>
+@@ -285,8 +283,9 @@ class GlContext : public std::enable_shared_from_this<GlContext> {
+   //
+   // Therefore, instead of using std::function<void(void)>, we use a template
+   // that only accepts arguments with a void result type.
+-  template <typename T, typename = typename std::enable_if<std::is_void<
+-                            typename std::result_of<T()>::type>::value>::type>
++  template <typename T,
++            typename = typename std::enable_if<std::is_void<
++                typename std::invoke_result<T>::type>::value>::type>
+   void Run(T f) {
+     Run([f] {
+       f();
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_context_egl.cc b/third_party/mediapipe/src/mediapipe/gpu/gl_context_egl.cc
+index 48b6192b29c18..ea3582961956a 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gl_context_egl.cc
++++ b/third_party/mediapipe/src/mediapipe/gpu/gl_context_egl.cc
+@@ -35,6 +35,7 @@ namespace mediapipe {
+ 
+ namespace {
+ 
++#if !MEDIAPIPE_DISABLE_PTHREADS
+ static pthread_key_t egl_release_thread_key;
+ static pthread_once_t egl_release_key_once = PTHREAD_ONCE_INIT;
+ 
+@@ -71,6 +72,7 @@ static void EnsureEglThreadRelease() {
+   pthread_setspecific(egl_release_thread_key,
+                       reinterpret_cast<void*>(0xDEADBEEF));
+ }
++#endif
+ 
+ static absl::StatusOr<EGLDisplay> GetInitializedDefaultEglDisplay() {
+   EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+@@ -289,7 +291,11 @@ void GlContext::GetCurrentContextBinding(GlContext::ContextBinding* binding) {
+ 
+ absl::Status GlContext::SetCurrentContextBinding(
+     const ContextBinding& new_binding) {
++#if !MEDIAPIPE_DISABLE_PTHREADS
+   EnsureEglThreadRelease();
++#else
++  ABSL_LOG(WARNING) << __func__ << ": make sure this thread releases EGL resources!";
++#endif
+   EGLDisplay display = new_binding.display;
+   if (display == EGL_NO_DISPLAY) {
+     display = eglGetCurrentDisplay();
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_context_internal.h b/third_party/mediapipe/src/mediapipe/gpu/gl_context_internal.h
+index d683d4447d768..52ad42a0fa8bd 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gl_context_internal.h
++++ b/third_party/mediapipe/src/mediapipe/gpu/gl_context_internal.h
+@@ -24,6 +24,10 @@
+ #endif  // TARGET_OS_OSX
+ #endif  // __APPLE__
+ 
++#if MEDIAPIPE_DISABLE_PTHREADS
++#include <thread>
++#endif
++
+ #include "mediapipe/gpu/gl_context.h"
+ 
+ namespace mediapipe {
+@@ -43,7 +47,6 @@ class GlContext::DedicatedThread {
+   void SelfDestruct();
+ 
+  private:
+-  static void* ThreadBody(void* instance);
+   void ThreadBody();
+ 
+   using Job = std::function<void(void)>;
+@@ -53,7 +56,14 @@ class GlContext::DedicatedThread {
+   absl::Mutex mutex_;
+   // Used to wait for a job's completion.
+   absl::CondVar gl_job_done_cv_ ABSL_GUARDED_BY(mutex_);
++
++#if !MEDIAPIPE_DISABLE_PTHREADS
++  static void* ThreadBody(void* instance);
++
+   pthread_t gl_thread_id_;
++#else
++  std::thread gl_thread_;
++#endif
+ 
+   std::deque<Job> jobs_ ABSL_GUARDED_BY(mutex_);
+   absl::CondVar has_jobs_cv_ ABSL_GUARDED_BY(mutex_);
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gpu_service.cc b/third_party/mediapipe/src/mediapipe/gpu/gpu_service.cc
+index 53a0e0f479052..ef77952dff8c7 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gpu_service.cc
++++ b/third_party/mediapipe/src/mediapipe/gpu/gpu_service.cc
+@@ -16,7 +16,8 @@
+ 
+ namespace mediapipe {
+ 
+-const GraphService<GpuResources> kGpuService(
+-    "kGpuService", GraphServiceBase::kAllowDefaultInitialization);
++ABSL_CONST_INIT const GraphService<GpuResources> kGpuService(
++    "kGpuService",
++    GraphServiceBase::kAllowDefaultInitialization);
+ 
+ }  // namespace mediapipe
+-- 
+2.48.0.rc2.279.g1de40edade-goog
+
diff --git a/third_party/mediapipe/patches/dont-use-dedicated-context-for-some-calculators.patch b/third_party/mediapipe/patches/dont-use-dedicated-context-for-some-calculators.patch
new file mode 100644
index 0000000000000..94b511259860b
--- /dev/null
+++ b/third_party/mediapipe/patches/dont-use-dedicated-context-for-some-calculators.patch
@@ -0,0 +1,27 @@
+From b50be3ef2ad96122ac6c3fb3a54f8a58c7d1c459 Mon Sep 17 00:00:00 2001
+From: Piotr Bialecki <bialpio@chromium.org>
+Date: Wed, 11 Oct 2023 13:38:42 -0700
+Subject: [PATCH] MediaPipe: don't use dedicated context for some calculators
+
+---
+ .../mediapipe/src/mediapipe/gpu/gpu_shared_data_internal.cc   | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gpu_shared_data_internal.cc b/third_party/mediapipe/src/mediapipe/gpu/gpu_shared_data_internal.cc
+index b9b9c26f05dfa..1fa8135cc02a0 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gpu_shared_data_internal.cc
++++ b/third_party/mediapipe/src/mediapipe/gpu/gpu_shared_data_internal.cc
+@@ -129,9 +129,7 @@ absl::Status GpuResources::PrepareGpuNode(CalculatorNode* node) {
+ #ifndef __EMSCRIPTEN__
+   // TODO Allow calculators to request a separate context.
+   // For now, allow a few calculators to run in their own context.
+-  bool gets_own_context = (node_type == "ImageFrameToGpuBufferCalculator") ||
+-                          (node_type == "GpuBufferToImageFrameCalculator") ||
+-                          (node_type == "GlSurfaceSinkCalculator");
++  bool gets_own_context = false;
+ 
+   const auto& options =
+       node->GetCalculatorState().Options<mediapipe::GlContextOptions>();
+-- 
+2.42.0.609.gbb76f46606-goog
+
diff --git a/third_party/mediapipe/patches/fix-FormatMessage-win-api-usage.patch b/third_party/mediapipe/patches/fix-FormatMessage-win-api-usage.patch
new file mode 100644
index 0000000000000..32f29085ca609
--- /dev/null
+++ b/third_party/mediapipe/patches/fix-FormatMessage-win-api-usage.patch
@@ -0,0 +1,71 @@
+From 37bca891a95dc041035f9b30e6a178a2a65653e6 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Thu, 23 Jan 2025 00:03:31 +0000
+Subject: [PATCH] Fix FormatMessage() Windows API usage
+
+The type passed to FormatMessage() depends on the UNICODE build flag.
+
+Unrelated to that, also move the `#include <Windows.h>` outside of the
+mediapipe namespace. This was causing weird ODR issues in win arm64.
+
+---
+From 37bca891a95dc041035f9b30e6a178a2a65653e6 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Thu, 23 Jan 2025 00:03:31 +0000
+Subject: [PATCH] commit
+
+---
+ .../framework/deps/platform_strings.cc         | 18 +++++++++++++-----
+ 1 file changed, 13 insertions(+), 5 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/platform_strings.cc b/third_party/mediapipe/src/mediapipe/framework/deps/platform_strings.cc
+index fa8f3c791f21c..be0b3979e86f9 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/deps/platform_strings.cc
++++ b/third_party/mediapipe/src/mediapipe/framework/deps/platform_strings.cc
+@@ -16,31 +16,39 @@
+
+ #include <string>
+
+-namespace mediapipe {
+ #ifdef _WIN32
+ #include <Windows.h>
++#endif
+
++namespace mediapipe {
++#ifdef _WIN32
+ std::string FormatLastError() {
+   DWORD message_id = GetLastError();
+   if (message_id == 0) {
+     return std::string("(no error reported)");
+   }
+
+-  LPSTR message_buffer = nullptr;
++  using WinStringType =
++#ifdef UNICODE
++      LPWSTR;
++#else
++      LPSTR;
++#endif
++  WinStringType message_buffer = nullptr;
+   DWORD size = FormatMessage(
+       /*dwFlags=*/(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
+                    FORMAT_MESSAGE_IGNORE_INSERTS),
+       /*lpSource=*/NULL,
+       /*dwMessageId=*/message_id,
+       /*dwLanguageId=*/MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+-      /*lpBuffer=*/(LPSTR)&message_buffer,
++      /*lpBuffer=*/(WinStringType)&message_buffer,
+       /*nSize=*/0,
+       /*Arguments=*/NULL);
+   if (size == 0) {
+     return "(error while trying to format the error message)";
+   }
+
+-  std::string message(message_buffer, size);
++  PlatformString message(message_buffer, size);
+   LocalFree(message_buffer);
+   return NativeToUtf8(message);
+ }
+--
+2.48.1.262.g85cc9f2d1e-goog
+
diff --git a/third_party/mediapipe/patches/make-matrix-string-functions-conditional.patch b/third_party/mediapipe/patches/make-matrix-string-functions-conditional.patch
new file mode 100644
index 0000000000000..fd19b91bc2712
--- /dev/null
+++ b/third_party/mediapipe/patches/make-matrix-string-functions-conditional.patch
@@ -0,0 +1,31 @@
+Puts a couple of functions in Matrix behind an ifdef. These functions use
+TextFormat, which is only in protobuf full.
+
+diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc
+index 3254e7fc2a491..5cefbfc9d31cb 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc
++++ b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.cc
+@@ -49,7 +49,8 @@ void MatrixFromMatrixDataProto(const MatrixData& matrix_data, Matrix* matrix) {
+   }
+ }
+ 
+-#if !defined(MEDIAPIPE_MOBILE) && !defined(MEDIAPIPE_LITE)
++#if !defined(MEDIAPIPE_MOBILE) && !defined(MEDIAPIPE_LITE) && \
++    !defined(MEDIAPIPE_PROTO_LITE)
+ std::string MatrixAsTextProto(const Matrix& matrix) {
+   MatrixData matrix_data;
+   MatrixDataProtoFromMatrix(matrix, &matrix_data);
+diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h
+index 99729aedcb6c6..13a6576157186 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h
++++ b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h
+@@ -38,7 +38,8 @@ void MatrixDataProtoFromMatrix(const Matrix& matrix, MatrixData* matrix_data);
+ // audio into a Matrix proto.
+ void MatrixFromMatrixDataProto(const MatrixData& matrix_data, Matrix* matrix);
+ 
+-#if !defined(MEDIAPIPE_MOBILE) && !defined(MEDIAPIPE_LITE)
++#if !defined(MEDIAPIPE_MOBILE) && !defined(MEDIAPIPE_LITE) && \
++    !defined(MEDIAPIPE_PROTO_LITE)
+ // Produce a Text format MatrixData string.  Mainly useful for test code.
+ std::string MatrixAsTextProto(const Matrix& matrix);
+ // Produce a Matrix from a text format MatrixData proto representation.
diff --git a/third_party/mediapipe/patches/matrix_undefine_exceptions.patch b/third_party/mediapipe/patches/matrix_undefine_exceptions.patch
new file mode 100644
index 0000000000000..99b1682a78a41
--- /dev/null
+++ b/third_party/mediapipe/patches/matrix_undefine_exceptions.patch
@@ -0,0 +1,26 @@
+Eigen looks for __EXCEPTIONS to determine if exceptions are enabled. On macOS
+matrix is compiled with -ObjC++, which sets __EXCEPTIONS, causing the build to
+fail. The right solution is likely to change Eigen to look for a different
+define, or perhaps an override to ignore __EXCEPTIONS.
+
+
+diff --git a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h
+index 13a6576157186..0eed6fed87841 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h
++++ b/third_party/mediapipe/src/mediapipe/framework/formats/matrix.h
+@@ -21,6 +21,15 @@
+ #ifndef MEDIAPIPE_FRAMEWORK_FORMATS_MATRIX_H_
+ #define MEDIAPIPE_FRAMEWORK_FORMATS_MATRIX_H_
+ 
++// TODO: Eigen looks for __EXCEPTIONS to determine if exceptions are enabled.
++// This file may be compiled with -ObjC++ on macOS, which sets __EXCEPTIONS,
++// causing the build to fail. The right solution is likely to change Eigen
++// to look for a different define, or perhaps an override to ignore
++// __EXCEPTIONS.
++#if defined(__EXCEPTIONS)
++#undef __EXCEPTIONS
++#endif
++
+ #include <string>
+ 
+ #include "Eigen/Core"
diff --git a/third_party/mediapipe/patches/no-consume.patch b/third_party/mediapipe/patches/no-consume.patch
new file mode 100644
index 0000000000000..d44c15d8abdff
--- /dev/null
+++ b/third_party/mediapipe/patches/no-consume.patch
@@ -0,0 +1,108 @@
+From a9bc54a3a92c437b101794a062fb6c28404f929d Mon Sep 17 00:00:00 2001
+From: Ahmed Moussa <ahmedmoussa@google.com>
+Date: Tue, 27 Aug 2024 21:28:32 +0000
+Subject: [PATCH 2/2] no-consume
+
+---
+ .../src/mediapipe/framework/packet.h          | 73 +------------------
+ 1 file changed, 3 insertions(+), 70 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/framework/packet.h b/third_party/mediapipe/src/mediapipe/framework/packet.h
+index ef0b5d113925b..a5501848e9f2b 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/packet.h
++++ b/third_party/mediapipe/src/mediapipe/framework/packet.h
+@@ -691,53 +691,14 @@ inline Packet& Packet::operator=(const Packet& packet) {
+
+ template <typename T>
+ inline absl::StatusOr<std::unique_ptr<T>> Packet::Consume() {
+-  // If type validation fails, returns error.
+-  MP_RETURN_IF_ERROR(ValidateAsType<T>());
+-  // Clients who use this function are responsible for ensuring that no
+-  // other thread is doing anything with this Packet.
+-  if (!holder_->HasForeignOwner() && holder_.use_count() == 1) {
+-    VLOG(2) << "Consuming the data of " << DebugString();
+-    absl::StatusOr<std::unique_ptr<T>> release_result =
+-        holder_->AsMutable<T>()->Release();
+-    if (release_result.ok()) {
+-      VLOG(2) << "Setting " << DebugString() << " to empty.";
+-      holder_.reset();
+-    }
+-    return release_result;
+-  }
+-  // If packet isn't the sole owner of the holder, returns kFailedPrecondition
+-  // error with message.
+-  return absl::Status(absl::StatusCode::kFailedPrecondition,
+-                      "Packet isn't the sole owner of the holder.");
++  return absl::InternalError("Consume isn't supported.");
+ }
+
+ template <typename T>
+ inline absl::StatusOr<std::unique_ptr<T>> Packet::ConsumeOrCopy(
+     bool* was_copied,
+     typename std::enable_if<!std::is_array<T>::value>::type*) {
+-  MP_RETURN_IF_ERROR(ValidateAsType<T>());
+-  // If holder is the sole owner of the underlying data, consumes this packet.
+-  if (!holder_->HasForeignOwner() && holder_.use_count() == 1) {
+-    VLOG(2) << "Consuming the data of " << DebugString();
+-    absl::StatusOr<std::unique_ptr<T>> release_result =
+-        holder_->AsMutable<T>()->Release();
+-    if (release_result.ok()) {
+-      VLOG(2) << "Setting " << DebugString() << " to empty.";
+-      holder_.reset();
+-    }
+-    if (was_copied) {
+-      *was_copied = false;
+-    }
+-    return release_result;
+-  }
+-  VLOG(2) << "Copying the data of " << DebugString();
+-  std::unique_ptr<T> data_ptr = absl::make_unique<T>(Get<T>());
+-  VLOG(2) << "Setting " << DebugString() << " to empty.";
+-  holder_.reset();
+-  if (was_copied) {
+-    *was_copied = true;
+-  }
+-  return std::move(data_ptr);
++  return absl::InternalError("ConsumeOrCopy isn't supported.");
+ }
+
+ template <typename T>
+@@ -745,35 +706,7 @@ inline absl::StatusOr<std::unique_ptr<T>> Packet::ConsumeOrCopy(
+     bool* was_copied,
+     typename std::enable_if<std::is_array<T>::value &&
+                             std::extent<T>::value != 0>::type*) {
+-  MP_RETURN_IF_ERROR(ValidateAsType<T>());
+-  // If holder is the sole owner of the underlying data, consumes this packet.
+-  if (!holder_->HasForeignOwner() && holder_.use_count() == 1) {
+-    VLOG(2) << "Consuming the data of " << DebugString();
+-    absl::StatusOr<std::unique_ptr<T>> release_result =
+-        holder_->AsMutable<T>()->Release();
+-    if (release_result.ok()) {
+-      VLOG(2) << "Setting " << DebugString() << " to empty.";
+-      holder_.reset();
+-    }
+-    if (was_copied) {
+-      *was_copied = false;
+-    }
+-    return release_result;
+-  }
+-  VLOG(2) << "Copying the data of " << DebugString();
+-  const auto& original_array = Get<T>();
+-  // Type T is bounded array type, such as int[N] and float[M].
+-  // The new operator creates a new bounded array.
+-  std::unique_ptr<T> data_ptr(reinterpret_cast<T*>(new T));
+-  // Copies bounded array data into data_ptr.
+-  std::copy(std::begin(original_array), std::end(original_array),
+-            std::begin(*data_ptr));
+-  VLOG(2) << "Setting " << DebugString() << " to empty.";
+-  holder_.reset();
+-  if (was_copied) {
+-    *was_copied = true;
+-  }
+-  return std::move(data_ptr);
++  return absl::InternalError("ConsumeOrCopy isn't supported.");
+ }
+
+ template <typename T>
+--
+2.46.0.295.g3b9ea8a38a-goog
diff --git a/third_party/mediapipe/patches/remove-absl-flag-in-inference_calculator_utils.patch b/third_party/mediapipe/patches/remove-absl-flag-in-inference_calculator_utils.patch
new file mode 100644
index 0000000000000..396a3ce542aaf
--- /dev/null
+++ b/third_party/mediapipe/patches/remove-absl-flag-in-inference_calculator_utils.patch
@@ -0,0 +1,68 @@
+From 1bc6a60afc4f514492c8ef8dce797a1951c20618 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Wed, 22 Jan 2025 17:41:31 +0000
+Subject: [PATCH] Remove ABSL_FLAG in inference_calculator_utils
+
+This is disallowed in Chromium builds. Use the default flag value instead.
+
+---
+ .../calculators/tensor/inference_calculator_utils.cc       | 7 +------
+ .../calculators/tensor/inference_calculator_utils.h        | 3 ---
+ 2 files changed, 1 insertion(+), 9 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.cc b/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.cc
+index 8d7761f6ab73e..cedd5216c84c6 100644
+--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.cc
++++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.cc
+@@ -20,7 +20,6 @@
+ #include <string>
+ #include <vector>
+
+-#include "absl/flags/flag.h"
+ #include "absl/log/absl_log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+@@ -39,10 +38,6 @@
+ #include "tensorflow/lite/portable_type_to_tflitetype.h"
+ #include "tensorflow/lite/string_util.h"
+
+-ABSL_FLAG(int, xnnpack_default_num_threads, 0,
+-          "Default number of xnnpack threads to use. If unset, determines a "
+-          "good default number based on the platform.");
+-
+ #if !defined(__EMSCRIPTEN__) || defined(__EMSCRIPTEN_PTHREADS__)
+ #include "mediapipe/util/cpu_util.h"
+ #endif  // !__EMSCRIPTEN__ || __EMSCRIPTEN_PTHREADS__
+@@ -51,7 +46,7 @@ namespace mediapipe {
+ namespace {
+
+ int GetXnnpackDefaultNumThreads() {
+-  int default_from_flag = absl::GetFlag(FLAGS_xnnpack_default_num_threads);
++  int default_from_flag = 0;
+   if (default_from_flag > 0) {
+     return default_from_flag;
+   }
+diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.h b/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.h
+index 917700d8e3a11..aa045dd3d037e 100644
+--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.h
++++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_utils.h
+@@ -18,7 +18,6 @@
+ #include <cstddef>
+ #include <cstdint>
+
+-#include "absl/flags/declare.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "mediapipe/calculators/tensor/inference_calculator.pb.h"
+@@ -28,8 +27,6 @@
+ #include "tensorflow/lite/interpreter.h"
+ #include "tensorflow/lite/util.h"
+
+-ABSL_DECLARE_FLAG(int, xnnpack_default_num_threads);
+-
+ namespace mediapipe {
+
+ // Returns number of threads to configure XNNPACK delegate with.
+--
+2.48.0.rc2.279.g1de40edade-goog
+
diff --git a/third_party/mediapipe/patches/remove-absl-flag-in-resource_util_default.cc.patch b/third_party/mediapipe/patches/remove-absl-flag-in-resource_util_default.cc.patch
new file mode 100644
index 0000000000000..bd55d5d97b282
--- /dev/null
+++ b/third_party/mediapipe/patches/remove-absl-flag-in-resource_util_default.cc.patch
@@ -0,0 +1,42 @@
+From ab466d542a21a5a22b055669e5d2e6065f5e4ae1 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Fri, 14 Jul 2023 14:22:14 -0700
+Subject: [PATCH] remove absl flag in resource_util_default.cc
+
+---
+ .../mediapipe/src/mediapipe/util/resource_util_default.cc | 8 +-------
+ 1 file changed, 1 insertion(+), 7 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/util/resource_util_default.cc b/third_party/mediapipe/src/mediapipe/util/resource_util_default.cc
+index 919729548161d..40f8924a753b1 100644
+--- a/third_party/mediapipe/src/mediapipe/util/resource_util_default.cc
++++ b/third_party/mediapipe/src/mediapipe/util/resource_util_default.cc
+@@ -14,16 +14,10 @@
+ 
+ #include <fstream>
+ 
+-#include "absl/flags/flag.h"
+ #include "absl/status/statusor.h"
+ #include "mediapipe/framework/deps/file_path.h"
+ #include "mediapipe/framework/port/file_helpers.h"
+ 
+-ABSL_FLAG(
+-    std::string, resource_root_dir, "",
+-    "The absolute path to the resource directory."
+-    "If specified, resource_root_dir will be prepended to the original path.");
+-
+ namespace mediapipe {
+ 
+ using mediapipe::file::GetContents;
+@@ -50,7 +44,7 @@ absl::StatusOr<std::string> PathToResourceAsFile(const std::string& path,
+   if (file::Exists(bazel_path).ok()) {
+     return bazel_path;
+   }
+-  return JoinPath(absl::GetFlag(FLAGS_resource_root_dir), path);
++  return path;
+ }
+ 
+ }  // namespace mediapipe
+-- 
+2.48.0.rc2.279.g1de40edade-goog
+
diff --git a/third_party/mediapipe/patches/remove-mediapipe-op-resolver-default-value.patch b/third_party/mediapipe/patches/remove-mediapipe-op-resolver-default-value.patch
new file mode 100644
index 0000000000000..510e475b094cd
--- /dev/null
+++ b/third_party/mediapipe/patches/remove-mediapipe-op-resolver-default-value.patch
@@ -0,0 +1,26 @@
+From 06541975ff9831725cca097ca92c4964208e6f35 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Tue, 18 Jul 2023 15:43:33 -0700
+Subject: [PATCH] remove mediapipe op resolver default value
+
+---
+ .../mediapipe/src/mediapipe/tasks/cc/core/base_options.h       | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/tasks/cc/core/base_options.h b/third_party/mediapipe/src/mediapipe/tasks/cc/core/base_options.h
+index 738d71093bab9..877d17e741ccc 100644
+--- a/third_party/mediapipe/src/mediapipe/tasks/cc/core/base_options.h
++++ b/third_party/mediapipe/src/mediapipe/tasks/cc/core/base_options.h
+@@ -92,8 +92,7 @@ struct BaseOptions {
+ 
+   // A non-default OpResolver to support custom Ops or specify a subset of
+   // built-in Ops.
+-  std::unique_ptr<tflite::OpResolver> op_resolver =
+-      absl::make_unique<MediaPipeBuiltinOpResolver>();
++  std::unique_ptr<tflite::OpResolver> op_resolver;
+ 
+   // Options for the chosen delegate. If not set, the default delegate options
+   // is used.
+-- 
+2.41.0.255.g8b1d071c50-goog
+
diff --git a/third_party/mediapipe/patches/remove-resource_util_windows.cc-functionality.patch b/third_party/mediapipe/patches/remove-resource_util_windows.cc-functionality.patch
new file mode 100644
index 0000000000000..662ad9d857c5a
--- /dev/null
+++ b/third_party/mediapipe/patches/remove-resource_util_windows.cc-functionality.patch
@@ -0,0 +1,100 @@
+From 1e93ad4a477c57390993434179fa5754e8947356 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Wed, 22 Jan 2025 16:22:53 +0000
+Subject: [PATCH] commit
+
+---
+ .../mediapipe/util/resource_util_windows.cc   | 63 +------------------
+ 1 file changed, 3 insertions(+), 60 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/util/resource_util_windows.cc b/third_party/mediapipe/src/mediapipe/util/resource_util_windows.cc
+index e28094eef367d..5e3b202379bf2 100644
+--- a/third_party/mediapipe/src/mediapipe/util/resource_util_windows.cc
++++ b/third_party/mediapipe/src/mediapipe/util/resource_util_windows.cc
+@@ -12,80 +12,23 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include <fstream>
+-
+-#include "absl/flags/flag.h"
+-#include "absl/status/statusor.h"
+-#include "mediapipe/framework/deps/file_path.h"
+-#include "mediapipe/framework/port/file_helpers.h"
+-#include "mediapipe/framework/port/singleton.h"
+-#include "tools/cpp/runfiles/runfiles.h"
+-
+-ABSL_FLAG(
+-    std::string, resource_root_dir, "",
+-    "The absolute path to the resource directory."
+-    "If specified, resource_root_dir will be prepended to the original path.");
++#include "mediapipe/util/resource_util.h"
+ 
+ namespace mediapipe {
+ 
+-using mediapipe::file::GetContents;
+-using mediapipe::file::JoinPath;
+-
+ namespace internal {
+-namespace {
+-
+-class RunfilesHolder {
+- public:
+-  // TODO: We should ideally use `CreateForTests` when this is
+-  // accessed from unit tests.
+-  RunfilesHolder()
+-      : runfiles_(
+-            ::bazel::tools::cpp::runfiles::Runfiles::Create("", nullptr)) {}
+-
+-  std::string Rlocation(const std::string& path) {
+-    if (!runfiles_) {
+-      // Return the original path when Runfiles is not available (e.g. for
+-      // Python)
+-      return JoinPath(absl::GetFlag(FLAGS_resource_root_dir), path);
+-    }
+-    return runfiles_->Rlocation(path);
+-  }
+-
+- private:
+-  std::unique_ptr<::bazel::tools::cpp::runfiles::Runfiles> runfiles_;
+-};
+-
+-std::string PathToResourceAsFileInternal(const std::string& path) {
+-  return Singleton<RunfilesHolder>::get()->Rlocation(path);
+-}
+-
+-}  // namespace
+ 
+ absl::Status DefaultGetResourceContents(const std::string& path,
+                                         std::string* output,
+                                         bool read_as_binary) {
+-  std::string resource_path = PathToResourceAsFileInternal(path);
+-  return GetContents(path, output, read_as_binary);
++  return absl::UnimplementedError("not suported in chromium");
+ }
+ 
+ }  // namespace internal
+ 
+ absl::StatusOr<std::string> PathToResourceAsFile(const std::string& path,
+                                                  bool /*shadow_copy*/) {
+-  std::string qualified_path = path;
+-  if (absl::StartsWith(qualified_path, "./")) {
+-    qualified_path = "mediapipe" + qualified_path.substr(1);
+-  } else if (path[0] != '/') {
+-    qualified_path = "mediapipe/" + qualified_path;
+-  }
+-
+-  // Try to load the file from bazel-bin. If it does not exist, fall back to the
+-  // resource folder.
+-  auto bazel_path = internal::PathToResourceAsFileInternal(qualified_path);
+-  if (file::Exists(bazel_path).ok()) {
+-    return bazel_path;
+-  }
+-  return JoinPath(absl::GetFlag(FLAGS_resource_root_dir), path);
++  return absl::UnimplementedError("not suported in chromium");
+ }
+ 
+ }  // namespace mediapipe
+-- 
+2.48.0.rc2.279.g1de40edade-goog
+
diff --git a/third_party/mediapipe/patches/remove-unused-absl-check-include.patch b/third_party/mediapipe/patches/remove-unused-absl-check-include.patch
new file mode 100644
index 0000000000000..c7a49de22ed00
--- /dev/null
+++ b/third_party/mediapipe/patches/remove-unused-absl-check-include.patch
@@ -0,0 +1,26 @@
+From d420b3f06c788364052c9a6700812516db0d637d Mon Sep 17 00:00:00 2001
+From: Ken Rockot <rockot@google.com>
+Date: Mon, 8 Jan 2024 13:14:29 -0800
+Subject: [PATCH] Remove unused absl/log/check.h include
+
+This include is not allowed in Chromium builds. It can be removed
+because it's not used.
+---
+ .../mediapipe/src/mediapipe/framework/calculator_graph.cc        | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc b/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc
+index 8f9e7d777febf..ccaa720487cd3 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc
++++ b/third_party/mediapipe/src/mediapipe/framework/calculator_graph.cc
+@@ -28,7 +28,6 @@
+ #include "absl/container/flat_hash_set.h"
+ #include "absl/log/absl_check.h"
+ #include "absl/log/absl_log.h"
+-#include "absl/log/check.h"
+ #include "absl/memory/memory.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+--
+2.48.1.262.g85cc9f2d1e-goog
+
diff --git a/third_party/mediapipe/patches/remove-unused-absl-debugging-include.patch b/third_party/mediapipe/patches/remove-unused-absl-debugging-include.patch
new file mode 100644
index 0000000000000..2b06646a25da4
--- /dev/null
+++ b/third_party/mediapipe/patches/remove-unused-absl-debugging-include.patch
@@ -0,0 +1,27 @@
+From cb5dd219d0a51493c335d05c7468121794954b09 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Wed, 22 Jan 2025 18:52:28 +0000
+Subject: [PATCH] Remove absl debugging include
+
+This include is not allowed by GN. It can be removed
+because it's not used.
+
+---
+ third_party/mediapipe/src/mediapipe/gpu/gl_context.cc | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc b/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
+index 05cbe856af0d2..3daf2ddfe8cd1 100644
+--- a/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
++++ b/third_party/mediapipe/src/mediapipe/gpu/gl_context.cc
+@@ -40,7 +40,6 @@
+ #include "mediapipe/gpu/gpu_buffer_format.h"
+
+ #ifndef __EMSCRIPTEN__
+-#include "absl/debugging/leak_check.h"
+ #include "mediapipe/gpu/gl_thread_collector.h"
+ #endif
+
+--
+2.48.1.262.g85cc9f2d1e-goog
+
diff --git a/third_party/mediapipe/patches/remove-xnnpack-from-cpu-delegate.patch b/third_party/mediapipe/patches/remove-xnnpack-from-cpu-delegate.patch
new file mode 100644
index 0000000000000..2779ecf782058
--- /dev/null
+++ b/third_party/mediapipe/patches/remove-xnnpack-from-cpu-delegate.patch
@@ -0,0 +1,53 @@
+From 5e641c88033a4670c9235d63d4463f2dc4113db6 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Fri, 14 Jul 2023 14:42:11 -0700
+Subject: [PATCH] remove xnnpack from cpu delegate
+
+---
+ .../tensor/inference_calculator_cpu.cc           | 16 ----------------
+ 1 file changed, 16 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_cpu.cc b/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_cpu.cc
+index 4c8ba21ad6a6f..3374566c55536 100644
+--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_cpu.cc
++++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/inference_calculator_cpu.cc
+@@ -33,7 +33,6 @@
+ #if defined(MEDIAPIPE_ANDROID)
+ #include "tensorflow/lite/delegates/nnapi/nnapi_delegate.h"
+ #endif  // ANDROID
+-#include "tensorflow/lite/delegates/xnnpack/xnnpack_delegate.h"
+ 
+ namespace mediapipe {
+ namespace api2 {
+@@ -109,7 +108,6 @@ InferenceCalculatorCpuImpl::MaybeCreateDelegate(CalculatorContext* cc) {
+         input_side_packet_delegate = kDelegate(cc).Get();
+     RET_CHECK(
+         input_side_packet_delegate.has_tflite() ||
+-        input_side_packet_delegate.has_xnnpack() ||
+         input_side_packet_delegate.has_nnapi() ||
+         input_side_packet_delegate.delegate_case() ==
+             mediapipe::InferenceCalculatorOptions::Delegate::DELEGATE_NOT_SET)
+@@ -146,20 +144,6 @@ InferenceCalculatorCpuImpl::MaybeCreateDelegate(CalculatorContext* cc) {
+   }
+ #endif  // MEDIAPIPE_ANDROID
+ 
+-#if defined(__EMSCRIPTEN__) || MEDIAPIPE_FORCE_CPU_INFERENCE
+-  const bool use_xnnpack = true;
+-#else
+-  const bool use_xnnpack = opts_has_delegate && opts_delegate.has_xnnpack();
+-#endif  // defined(__EMSCRIPTEN__)
+-
+-  if (use_xnnpack) {
+-    auto xnnpack_opts = TfLiteXNNPackDelegateOptionsDefault();
+-    xnnpack_opts.num_threads =
+-        GetXnnpackNumThreads(opts_has_delegate, opts_delegate);
+-    return TfLiteDelegatePtr(TfLiteXNNPackDelegateCreate(&xnnpack_opts),
+-                             &TfLiteXNNPackDelegateDelete);
+-  }
+-
+   return nullptr;
+ }
+ 
+-- 
+2.48.0.rc2.279.g1de40edade-goog
+
diff --git a/third_party/mediapipe/patches/replace-absl-log-usages.patch b/third_party/mediapipe/patches/replace-absl-log-usages.patch
new file mode 100644
index 0000000000000..3176674bd0540
--- /dev/null
+++ b/third_party/mediapipe/patches/replace-absl-log-usages.patch
@@ -0,0 +1,162 @@
+From b4ebbbe0492cc67324417fe9216b7c6b222b6d6b Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Wed, 22 Jan 2025 20:18:30 +0000
+Subject: [PATCH] Replace LOG()/VLOG() with ABSL_* ones
+
+LOG() and VLOG() are disallowed because they conflict with the Chromium //base
+macros, but the aliases ABSL_LOG() and ABSL_VLOG() are allowed.
+Also remove one unused absl/log/check.h #include, which runs into the same
+issue.
+
+---
+ .../tensor/vector_to_tensor_calculator.cc         |  2 --
+ .../mediapipe/framework/input_stream_handler.cc   |  5 ++---
+ .../mediapipe/framework/validated_graph_config.cc | 15 +++++++--------
+ .../src/mediapipe/framework/vlog_utils.cc         |  5 ++---
+ 4 files changed, 11 insertions(+), 16 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/calculators/tensor/vector_to_tensor_calculator.cc b/third_party/mediapipe/src/mediapipe/calculators/tensor/vector_to_tensor_calculator.cc
+index a0ba58cc17d68..2b8d3c8a5b2c6 100644
+--- a/third_party/mediapipe/src/mediapipe/calculators/tensor/vector_to_tensor_calculator.cc
++++ b/third_party/mediapipe/src/mediapipe/calculators/tensor/vector_to_tensor_calculator.cc
+@@ -18,8 +18,6 @@ limitations under the License.
+ #include <utility>
+ #include <vector>
+
+-#include "absl/log/check.h"
+-#include "absl/log/log.h"
+ #include "absl/status/status.h"
+ #include "mediapipe/calculators/tensor/vector_to_tensor_calculator.pb.h"
+ #include "mediapipe/framework/api2/node.h"
+diff --git a/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc b/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc
+index ee4a86adf26b8..88ee6dddc4bf6 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc
++++ b/third_party/mediapipe/src/mediapipe/framework/input_stream_handler.cc
+@@ -22,7 +22,6 @@
+
+ #include "absl/log/absl_check.h"
+ #include "absl/log/absl_log.h"
+-#include "absl/log/log.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+ #include "absl/strings/substitute.h"
+@@ -50,12 +49,12 @@ class FillInputSetLogger {
+  private:
+   void OutputLogs() const {
+     if (!missing_streams_.empty()) {
+-      VLOG(1) << absl::StrCat(
++      ABSL_VLOG(1) << absl::StrCat(
+           node_name_, ": Filled input set at ts: ", timestamp_.DebugString(),
+           " with MISSING packets in input streams: ",
+           absl::StrJoin(missing_streams_, ", "), ".");
+     } else {
+-      VLOG(1) << absl::StrCat(
++      ABSL_VLOG(1) << absl::StrCat(
+           node_name_, ": Filled input set at ts: ", timestamp_.DebugString());
+     }
+   }
+diff --git a/third_party/mediapipe/src/mediapipe/framework/validated_graph_config.cc b/third_party/mediapipe/src/mediapipe/framework/validated_graph_config.cc
+index e5d44b1efe138..126cd9b0f1107 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/validated_graph_config.cc
++++ b/third_party/mediapipe/src/mediapipe/framework/validated_graph_config.cc
+@@ -20,7 +20,6 @@
+ #include "absl/container/flat_hash_set.h"
+ #include "absl/log/absl_check.h"
+ #include "absl/log/absl_log.h"
+-#include "absl/log/log.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_join.h"
+@@ -712,7 +711,7 @@ absl::Status ValidatedGraphConfig::AddInputStreamsForNode(
+       }
+     } else {
+       if (edge_info.back_edge) {
+-        VLOG(1) << "Encountered expected behavior: the back edge \"" << name
++        ABSL_VLOG(1) << "Encountered expected behavior: the back edge \"" << name
+                 << "\" for node with (possibly sorted) index " << node_index
+                 << " name " << node_type_info->Contract().GetNodeName()
+                 << " has an output stream which we have not yet seen.";
+@@ -768,7 +767,7 @@ NodeTypeInfo::NodeRef ValidatedGraphConfig::NodeForSorterIndex(
+
+ absl::Status ValidatedGraphConfig::TopologicalSortNodes() {
+ #if !(defined(MEDIAPIPE_LITE) || defined(MEDIAPIPE_MOBILE))
+-  VLOG(2) << "BEFORE TOPOLOGICAL SORT:\n" << config_.DebugString();
++  ABSL_VLOG(2) << "BEFORE TOPOLOGICAL SORT:\n" << config_.DebugString();
+ #endif  // !(MEDIAPIPE_LITE || MEDIAPIPE_MOBILE)
+   // The topological sorter assumes the nodes in the graph are identified
+   // by consecutive indexes 0, 1, 2, ... We sort the generators and
+@@ -788,7 +787,7 @@ absl::Status ValidatedGraphConfig::TopologicalSortNodes() {
+       if (output_streams_[upstream].parent_node.type !=
+               NodeTypeInfo::NodeType::GRAPH_INPUT_STREAM &&
+           !input_streams_[index].back_edge) {
+-        VLOG(3) << "Adding an edge for stream \"" << name << "\" from "
++        ABSL_VLOG(3) << "Adding an edge for stream \"" << name << "\" from "
+                 << output_streams_[upstream].parent_node.index << " to "
+                 << input_streams_[index].parent_node.index;
+         sorter.AddEdge(
+@@ -810,7 +809,7 @@ absl::Status ValidatedGraphConfig::TopologicalSortNodes() {
+     auto iter = side_packet_to_producer_.find(name);
+     if (iter != side_packet_to_producer_.end()) {
+       int upstream = iter->second;
+-      VLOG(3) << "Adding an edge for side packet \"" << name << "\" from "
++      ABSL_VLOG(3) << "Adding an edge for side packet \"" << name << "\" from "
+               << output_side_packets_[upstream].parent_node.index << " to "
+               << input_side_packets_[index].parent_node.index;
+       sorter.AddEdge(
+@@ -836,7 +835,7 @@ absl::Status ValidatedGraphConfig::TopologicalSortNodes() {
+   while (sorter.GetNext(&index, &cyclic, &cycle_indexes)) {
+     NodeTypeInfo::NodeRef node = NodeForSorterIndex(index);
+     if (node.type == NodeTypeInfo::NodeType::PACKET_GENERATOR) {
+-      VLOG(3) << "Taking generator with index " << node.index
++      ABSL_VLOG(3) << "Taking generator with index " << node.index
+               << " in the original order";
+       tmp_generators.emplace_back(std::move(generators_[node.index]));
+       tmp_generators.back().SetNodeIndex(tmp_generators.size() - 1);
+@@ -844,7 +843,7 @@ absl::Status ValidatedGraphConfig::TopologicalSortNodes() {
+           config_.mutable_packet_generator(node.index));
+       sorted_nodes_.push_back(&tmp_generators.back());
+     } else {
+-      VLOG(3) << "Taking calculator with index " << node.index
++      ABSL_VLOG(3) << "Taking calculator with index " << node.index
+               << " in the original order";
+       tmp_calculators.emplace_back(std::move(calculators_[node.index]));
+       tmp_calculators.back().SetNodeIndex(tmp_calculators.size() - 1);
+@@ -872,7 +871,7 @@ absl::Status ValidatedGraphConfig::TopologicalSortNodes() {
+   node_configs.Swap(config_.mutable_node());
+   tmp_calculators.swap(calculators_);
+ #if !(defined(MEDIAPIPE_LITE) || defined(MEDIAPIPE_MOBILE))
+-  VLOG(2) << "AFTER TOPOLOGICAL SORT:\n" << config_.DebugString();
++  ABSL_VLOG(2) << "AFTER TOPOLOGICAL SORT:\n" << config_.DebugString();
+ #endif  // !(MEDIAPIPE_LITE || MEDIAPIPE_MOBILE)
+   return absl::OkStatus();
+ }
+diff --git a/third_party/mediapipe/src/mediapipe/framework/vlog_utils.cc b/third_party/mediapipe/src/mediapipe/framework/vlog_utils.cc
+index 6faaabb3b045a..1710d4083751d 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/vlog_utils.cc
++++ b/third_party/mediapipe/src/mediapipe/framework/vlog_utils.cc
+@@ -1,7 +1,6 @@
+ #include "mediapipe/framework/vlog_utils.h"
+
+ #include "absl/log/absl_log.h"
+-#include "absl/log/log.h"
+ #include "absl/strings/str_split.h"  // IWYU pragma: keep
+ #include "absl/strings/string_view.h"
+ #include "mediapipe/framework/port/logging.h"
+@@ -12,12 +11,12 @@ void VlogLargeMessage(int verbose_level, absl::string_view message) {
+ #if defined(MEDIAPIPE_MOBILE)
+   if (message.size() > 4096) {
+     for (const auto& line : absl::StrSplit(message, '\n')) {
+-      VLOG(verbose_level) << line;
++      ABSL_VLOG(verbose_level) << line;
+     }
+     return;
+   }
+ #endif
+-  VLOG(verbose_level) << message;
++  ABSL_VLOG(verbose_level) << message;
+ }
+
+ }  // namespace mediapipe
+--
+2.48.1.262.g85cc9f2d1e-goog
+
diff --git a/third_party/mediapipe/patches/set-executable-bit-for-files-with-shebang.patch b/third_party/mediapipe/patches/set-executable-bit-for-files-with-shebang.patch
new file mode 100644
index 0000000000000..39c6d94cbf73a
--- /dev/null
+++ b/third_party/mediapipe/patches/set-executable-bit-for-files-with-shebang.patch
@@ -0,0 +1,26 @@
+From 250b8d62a045bee022180a060a51a87d39100592 Mon Sep 17 00:00:00 2001
+From: Victor Hugo Vianna Silva <victorvianna@google.com>
+Date: Mon, 20 Jan 2025 02:59:52 +0000
+Subject: [PATCH] set executable bit for files with shebang
+
+---
+ third_party/mediapipe/src/run_llm_inference.sh         | 0
+ third_party/mediapipe/src/setup_android_sdk_and_ndk.sh | 0
+ third_party/mediapipe/src/setup_opencv.sh              | 0
+ 3 files changed, 0 insertions(+), 0 deletions(-)
+ mode change 100644 => 100755 third_party/mediapipe/src/run_llm_inference.sh
+ mode change 100644 => 100755 third_party/mediapipe/src/setup_android_sdk_and_ndk.sh
+ mode change 100644 => 100755 third_party/mediapipe/src/setup_opencv.sh
+
+diff --git a/third_party/mediapipe/src/run_llm_inference.sh b/third_party/mediapipe/src/run_llm_inference.sh
+old mode 100644
+new mode 100755
+diff --git a/third_party/mediapipe/src/setup_android_sdk_and_ndk.sh b/third_party/mediapipe/src/setup_android_sdk_and_ndk.sh
+old mode 100644
+new mode 100755
+diff --git a/third_party/mediapipe/src/setup_opencv.sh b/third_party/mediapipe/src/setup_opencv.sh
+old mode 100644
+new mode 100755
+--
+2.48.0.rc2.279.g1de40edade-goog
+
diff --git a/third_party/mediapipe/patches/type-map-fix-unused-variable-warning.patch b/third_party/mediapipe/patches/type-map-fix-unused-variable-warning.patch
new file mode 100644
index 0000000000000..516ac3f218085
--- /dev/null
+++ b/third_party/mediapipe/patches/type-map-fix-unused-variable-warning.patch
@@ -0,0 +1,25 @@
+From 2c3b206fd7bde1b86c65c440008afd382f040d3f Mon Sep 17 00:00:00 2001
+From: Piotr Bialecki <bialpio@chromium.org>
+Date: Fri, 14 Feb 2025 14:52:58 -0800
+Subject: [PATCH] Fix unused variable compiler warning in type_map.h
+
+---
+ third_party/mediapipe/src/mediapipe/framework/type_map.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/framework/type_map.h b/third_party/mediapipe/src/mediapipe/framework/type_map.h
+index f03f48ce7851c..123668766bd98 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/type_map.h
++++ b/third_party/mediapipe/src/mediapipe/framework/type_map.h
+@@ -148,7 +148,7 @@ class StaticMap {
+    public:
+     ValueInserter(const char* file_and_line, const KeyType& key,
+                   const MediaPipeTypeData& value) {
+-      MapName* static_map = GetMap();
++      StaticMap* static_map = GetMap();
+       absl::MutexLock l(&(static_map->map_lock_));
+ 
+       typename MapType::iterator it = static_map->internal_map_.find(key);
+-- 
+2.47.1.windows.2
+
diff --git a/third_party/mediapipe/patches/unnecessary-const.patch b/third_party/mediapipe/patches/unnecessary-const.patch
new file mode 100644
index 0000000000000..8db4d122d46f4
--- /dev/null
+++ b/third_party/mediapipe/patches/unnecessary-const.patch
@@ -0,0 +1,13 @@
+diff --git a/third_party/mediapipe/src/mediapipe/framework/api2/contract.h b/third_party/mediapipe/src/mediapipe/framework/api2/contract.h
+index 90e4c38cd0c4b..9d842f7b0643c 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/api2/contract.h
++++ b/third_party/mediapipe/src/mediapipe/framework/api2/contract.h
+@@ -214,7 +214,7 @@ class TaggedContract {
+ 
+   template <class Tuple, Tuple (C2T::*member)() const>
+   struct GetMember {
+-    static constexpr const auto get() { return (c2.*member)(); }
++    static constexpr auto get() { return (c2.*member)(); }
+   };
+ 
+   using TaggedInputs =
diff --git a/third_party/mediapipe/patches/update-any-usage.patch b/third_party/mediapipe/patches/update-any-usage.patch
new file mode 100644
index 0000000000000..1d24e87588110
--- /dev/null
+++ b/third_party/mediapipe/patches/update-any-usage.patch
@@ -0,0 +1,42 @@
+diff --git a/third_party/mediapipe/src/mediapipe/framework/calculator.proto b/third_party/mediapipe/src/mediapipe/framework/calculator.proto
+index 9984ee25056a9..26c0cd85f96c2 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/calculator.proto
++++ b/third_party/mediapipe/src/mediapipe/framework/calculator.proto
+@@ -21,7 +21,7 @@ package mediapipe;
+ 
+ import public "mediapipe/framework/calculator_options.proto";
+ 
+-import "google/protobuf/any.proto";
++import "google/protobuf/any_lite.proto";
+ import "mediapipe/framework/mediapipe_options.proto";
+ import "mediapipe/framework/packet_factory.proto";
+ import "mediapipe/framework/packet_generator.proto";
+@@ -273,7 +273,7 @@ message CalculatorGraphConfig {
+     // Each node_options message must have a different message type.
+     // If the same message type is specified in |options| and |node_options|,
+     // only the message in |options| is used.
+-    repeated google.protobuf.Any node_options = 8;
++    repeated google.protobuf.AnyLite node_options = 8;
+ 
+     // Note: the following fields are only applicable to calculators, not
+     // subgraphs.
+@@ -432,5 +432,5 @@ message CalculatorGraphConfig {
+   MediaPipeOptions options = 1001;
+ 
+   // The types and default values for graph options, in proto3 syntax.
+-  repeated google.protobuf.Any graph_options = 1002;
++  repeated google.protobuf.AnyLite graph_options = 1002;
+ }
+diff --git a/third_party/mediapipe/src/mediapipe/framework/port/any_proto.h b/third_party/mediapipe/src/mediapipe/framework/port/any_proto.h
+index 979585b26534e..a77907b6cd1cf 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/port/any_proto.h
++++ b/third_party/mediapipe/src/mediapipe/framework/port/any_proto.h
+@@ -22,7 +22,7 @@ namespace protobuf {
+ 
+ #if !defined(MEDIAPIPE_PROTO_LITE) || !defined(MEDIAPIPE_PROTO_THIRD_PARTY)
+ // The full definition of protobuf::Any for most platforms.
+-using Any = google::protobuf::Any;
++using Any = google::protobuf::AnyLite;
+ #else
+ // A dummy definition of protobuf::Any for third_party/protobuf:protobuf-lite.
+ class Any {
diff --git a/third_party/mediapipe/patches/use-re2-instead-of-std-regex.patch b/third_party/mediapipe/patches/use-re2-instead-of-std-regex.patch
new file mode 100644
index 0000000000000..5a1bbb625676f
--- /dev/null
+++ b/third_party/mediapipe/patches/use-re2-instead-of-std-regex.patch
@@ -0,0 +1,65 @@
+From b7928899936522b3d03aef1cca566030510f6a01 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 26 Jul 2023 11:24:47 -0700
+Subject: [PATCH] use re2 instead of std regex
+
+---
+ .../src/mediapipe/framework/deps/re2.h        | 42 ++-----------------
+ 1 file changed, 3 insertions(+), 39 deletions(-)
+
+diff --git a/third_party/mediapipe/src/mediapipe/framework/deps/re2.h b/third_party/mediapipe/src/mediapipe/framework/deps/re2.h
+index 61f7985ee62fe..4079d9c0d1916 100644
+--- a/third_party/mediapipe/src/mediapipe/framework/deps/re2.h
++++ b/third_party/mediapipe/src/mediapipe/framework/deps/re2.h
+@@ -15,45 +15,9 @@
+ #ifndef MEDIAPIPE_FRAMEWORK_DEPS_RE2_H_
+ #define MEDIAPIPE_FRAMEWORK_DEPS_RE2_H_
+ 
+-#include <regex>  // NOLINT
++#include "re2/re2.h"
+ 
+-namespace mediapipe {
+-
+-// Implements a subset of RE2 using std::regex_match.
+-class RE2 {
+- public:
+-  RE2(const std::string& pattern) : std_regex_(pattern) {}
+-  static bool FullMatch(std::string text, const RE2& re) {
+-    return std::regex_match(text, re.std_regex_);
+-  }
+-  static bool PartialMatch(std::string text, const RE2& re) {
+-    return std::regex_search(text, re.std_regex_);
+-  }
+-  static int GlobalReplace(std::string* text, const RE2& re,
+-                           const std::string& rewrite) {
+-    std::smatch sm;
+-    std::regex_search(*text, sm, re.std_regex_);
+-    *text = std::regex_replace(*text, re.std_regex_, rewrite);
+-    return std::max(0, static_cast<int>(sm.size()) - 1);
+-  }
+-
+- private:
+-  std::regex std_regex_;
+-};
+-
+-// Implements LazyRE2 using std::call_once.
+-class LazyRE2 {
+- public:
+-  RE2& operator*() const {
+-    std::call_once(once_, [&]() { ptr_ = new RE2(pattern_); });
+-    return *ptr_;
+-  }
+-  RE2* operator->() const { return &**this; }
+-  const char* pattern_;
+-  mutable RE2* ptr_;
+-  mutable std::once_flag once_;
+-};
+-
+-}  // namespace mediapipe
++using re2::LazyRE2;
++using re2::RE2;
+ 
+ #endif  // MEDIAPIPE_FRAMEWORK_DEPS_RE2_H_
+-- 
+2.41.0.487.g6d72f3e995-goog
+
diff --git a/third_party/node/patches/chromium_d3_types_index.patch b/third_party/node/patches/chromium_d3_types_index.patch
new file mode 100644
index 0000000000000..326ed433004ba
--- /dev/null
+++ b/third_party/node/patches/chromium_d3_types_index.patch
@@ -0,0 +1,35 @@
+diff -u a/index.d.ts b/index.d.ts
+--- a/index.d.ts	2023-04-18 22:15:22.964321937 +0000
++++ b/index.d.ts	2023-04-18 23:40:36.717062410 +0000
+@@ -19,31 +19,16 @@
+ 
+ export * from 'd3-array';
+ export * from 'd3-axis';
+-export * from 'd3-brush';
+-export * from 'd3-chord';
+ export * from 'd3-color';
+-export * from 'd3-contour';
+-export * from 'd3-delaunay';
+-export * from 'd3-dispatch';
+ export * from 'd3-drag';
+-export * from 'd3-dsv';
+-export * from 'd3-ease';
+-export * from 'd3-fetch';
+ export * from 'd3-force';
+ export * from 'd3-format';
+-export * from 'd3-geo';
+-export * from 'd3-hierarchy';
+ export * from 'd3-interpolate';
+ export * from 'd3-path';
+-export * from 'd3-polygon';
+-export * from 'd3-quadtree';
+-export * from 'd3-random';
+ export * from 'd3-scale';
+ export * from 'd3-scale-chromatic';
+ export * from 'd3-selection';
+ export * from 'd3-shape';
+ export * from 'd3-time';
+ export * from 'd3-time-format';
+-export * from 'd3-timer';
+ export * from 'd3-transition';
+-export * from 'd3-zoom';
diff --git a/third_party/node/patches/html_minifier.patch b/third_party/node/patches/html_minifier.patch
new file mode 100644
index 0000000000000..cce31233a3c09
--- /dev/null
+++ b/third_party/node/patches/html_minifier.patch
@@ -0,0 +1,12 @@
+diff --git a/src/htmlminifier.js b/src/htmlminifier.js
+index d7efa99148a21..eb19dd6b33ff3 100644
+--- a/src/htmlminifier.js
++++ b/src/htmlminifier.js
+@@ -5,7 +5,6 @@ var decode = require('he').decode;
+ var HTMLParser = require('./htmlparser').HTMLParser;
+ var RelateUrl = require('relateurl');
+ var TokenChain = require('./tokenchain');
+-var UglifyJS = require('uglify-js');
+ var utils = require('./utils');
+ 
+ function trimWhitespace(str) {
diff --git a/third_party/node/patches/lit_html.patch b/third_party/node/patches/lit_html.patch
new file mode 100644
index 0000000000000..9d83747c049fc
--- /dev/null
+++ b/third_party/node/patches/lit_html.patch
@@ -0,0 +1,11 @@
+diff --git a/node_modules/lit-html/lit-html.js b/node_modules/lit-html/lit-html.js
+index d63809f23984d..d97e52ec65b10 100644
+--- a/node_modules/lit-html/lit-html.js
++++ b/node_modules/lit-html/lit-html.js
+@@ -3,5 +3,5 @@
+  * Copyright 2017 Google LLC
+  * SPDX-License-Identifier: BSD-3-Clause
+  */
+-const t=globalThis,i=t.trustedTypes,s=i?i.createPolicy("lit-html",{createHTML:t=>t}):void 0,e="$lit$",h=`lit$${(Math.random()+"").slice(9)}$`,o="?"+h,n=`<${o}>`,r=document,l=()=>r.createComment(""),c=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a=Array.isArray,u=t=>a(t)||"function"==typeof t?.[Symbol.iterator],d="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p=/'/g,g=/"/g,$=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),b=y(2),w=Symbol.for("lit-noChange"),T=Symbol.for("lit-nothing"),A=new WeakMap,E=r.createTreeWalker(r,129);function C(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s?s.createHTML(i):i}const P=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f?"!--"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m):void 0!==u[3]&&(c=m):c===m?">"===u[0]?(c=r??f,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith("/>")?" ":"";l+=c===f?s+n:d>=0?(o.push(a),s.slice(0,d)+e+s.slice(d)+h+x):s+h+(-2===d?i:x)}return[C(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P(t,s);if(this.el=V.createElement(f,n),E.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes)}for(;null!==(r=E.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e)){const i=v[a++],s=r.getAttribute(t).split(h),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k:"?"===e[1]?H:"@"===e[1]?I:R}),r.removeAttribute(t)}else t.startsWith(h)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h),s=t.length-1;if(s>0){r.textContent=i?i.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l()),E.nextNode(),d.push({type:2,index:++c});r.append(t[s],l())}}}else if(8===r.nodeType)if(r.data===o)d.push({type:2,index:c});else{let t=-1;for(;-1!==(t=r.data.indexOf(h,t+1));)d.push({type:7,index:c}),t+=h.length-1}c++}}static createElement(t,i){const s=r.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N(t,h._$AS(t,i.values),h,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r).importNode(i,!0);E.currentNode=e;let h=E.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L(h,this,t)),this._$AV.push(i),l=s[++n]}o!==l?.index&&(h=E.nextNode(),o++)}return E.currentNode=r,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++}}class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),c(t)?t===T||null==t||""===t?(this._$AH!==T&&this._$AR(),this._$AH=T):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):u(t)?this.T(t):this._(t)}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t))}_(t){this._$AH!==T&&c(this._$AH)?this._$AA.nextSibling.data=t:this.$(r.createTextNode(t)),this._$AH=t}g(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V.createElement(C(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else{const t=new S(e,this),s=t.u(this.options);t.p(i),this.$(s),this._$AH=t}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new V(t)),i}T(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.k(l()),this.k(l()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e)}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t))}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N(this,t,i,0),o=!c(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else{const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c(r)||r!==this._$AH[n],r===T?t=T:t!==T&&(t+=(r??"")+h[n+1]),this._$AH[n]=r}o&&!e&&this.O(t)}O(t){t===T?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"")}}class k extends R{constructor(){super(...arguments),this.type=3}O(t){this.element[this.name]=t===T?void 0:t}}class H extends R{constructor(){super(...arguments),this.type=4}O(t){this.element.toggleAttribute(this.name,!!t&&t!==T)}}class I extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5}_$AI(t,i=this){if((t=N(this,t,i,0)??T)===w)return;const s=this._$AH,e=t===T&&s!==T||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T&&(s===T||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t)}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t)}}const z={j:e,P:h,A:o,C:1,M:P,L:S,R:u,V:N,D:M,I:R,H,N:I,U:k,B:L},Z=t.litHtmlPolyfillSupport;Z?.(V,M),(t.litHtmlVersions??=[]).push("3.1.0");const j=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M(i.insertBefore(l(),t),t,void 0,s??{})}return h._$AI(t),h};export{z as _$LH,x as html,w as noChange,T as nothing,j as render,b as svg};
++const t=globalThis,i=t.trustedTypes,s=i?i.createPolicy("lit-html-desktop",{createHTML:t=>t}):void 0,e="$lit$",h=`lit$${(Math.random()+"").slice(9)}$`,o="?"+h,n=`<${o}>`,r=document,l=()=>r.createComment(""),c=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a=Array.isArray,u=t=>a(t)||"function"==typeof t?.[Symbol.iterator],d="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p=/'/g,g=/"/g,$=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),b=y(2),w=Symbol.for("lit-noChange"),T=Symbol.for("lit-nothing"),A=new WeakMap,E=r.createTreeWalker(r,129);function C(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s?s.createHTML(i):i}const P=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f?"!--"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m):void 0!==u[3]&&(c=m):c===m?">"===u[0]?(c=r??f,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith("/>")?" ":"";l+=c===f?s+n:d>=0?(o.push(a),s.slice(0,d)+e+s.slice(d)+h+x):s+h+(-2===d?i:x)}return[C(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P(t,s);if(this.el=V.createElement(f,n),E.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes)}for(;null!==(r=E.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e)){const i=v[a++],s=r.getAttribute(t).split(h),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k:"?"===e[1]?H:"@"===e[1]?I:R}),r.removeAttribute(t)}else t.startsWith(h)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h),s=t.length-1;if(s>0){r.textContent=i?i.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l()),E.nextNode(),d.push({type:2,index:++c});r.append(t[s],l())}}}else if(8===r.nodeType)if(r.data===o)d.push({type:2,index:c});else{let t=-1;for(;-1!==(t=r.data.indexOf(h,t+1));)d.push({type:7,index:c}),t+=h.length-1}c++}}static createElement(t,i){const s=r.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N(t,h._$AS(t,i.values),h,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r).importNode(i,!0);E.currentNode=e;let h=E.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L(h,this,t)),this._$AV.push(i),l=s[++n]}o!==l?.index&&(h=E.nextNode(),o++)}return E.currentNode=r,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++}}class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),c(t)?t===T||null==t||""===t?(this._$AH!==T&&this._$AR(),this._$AH=T):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):u(t)?this.T(t):this._(t)}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t))}_(t){this._$AH!==T&&c(this._$AH)?this._$AA.nextSibling.data=t:this.$(r.createTextNode(t)),this._$AH=t}g(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V.createElement(C(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else{const t=new S(e,this),s=t.u(this.options);t.p(i),this.$(s),this._$AH=t}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new V(t)),i}T(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.k(l()),this.k(l()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e)}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t))}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N(this,t,i,0),o=!c(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else{const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c(r)||r!==this._$AH[n],r===T?t=T:t!==T&&(t+=(r??"")+h[n+1]),this._$AH[n]=r}o&&!e&&this.O(t)}O(t){t===T?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"")}}class k extends R{constructor(){super(...arguments),this.type=3}O(t){this.element[this.name]=t===T?void 0:t}}class H extends R{constructor(){super(...arguments),this.type=4}O(t){this.element.toggleAttribute(this.name,!!t&&t!==T)}}class I extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5}_$AI(t,i=this){if((t=N(this,t,i,0)??T)===w)return;const s=this._$AH,e=t===T&&s!==T||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T&&(s===T||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t)}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t)}}const z={j:e,P:h,A:o,C:1,M:P,L:S,R:u,V:N,D:M,I:R,H,N:I,U:k,B:L},Z=t.litHtmlPolyfillSupport;Z?.(V,M),(t.litHtmlVersions??=[]).push("3.1.0");const j=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M(i.insertBefore(l(),t),t,void 0,s??{})}return h._$AI(t),h};export{z as _$LH,x as html,w as noChange,T as nothing,j as render,b as svg};
+ //# sourceMappingURL=lit-html.js.map
diff --git a/third_party/node/patches/types_chai.patch b/third_party/node/patches/types_chai.patch
new file mode 100644
index 0000000000000..180c33145197b
--- /dev/null
+++ b/third_party/node/patches/types_chai.patch
@@ -0,0 +1,18 @@
+diff --git a/node_modules/@types/chai/index.d.ts b/node_modules/@types/chai/index.d.ts
+index f1cdab73a0635..f35471312637a 100644
+--- a/node_modules/@types/chai/index.d.ts
++++ b/node_modules/@types/chai/index.d.ts
+@@ -2090,11 +2090,8 @@ declare namespace Chai {
+     }
+ }
+ 
+-declare const chai: Chai.ChaiStatic;
+-
+-declare module "chai" {
+-    export = chai;
+-}
++export const assert: Chai.AssertStatic;
++export const expect: Chai.ExpectStatic;
+ 
+ interface Object {
+     should: Chai.Assertion;
diff --git a/third_party/node/patches/typescript.patch b/third_party/node/patches/typescript.patch
new file mode 100644
index 0000000000000..09a6bdd4af862
--- /dev/null
+++ b/third_party/node/patches/typescript.patch
@@ -0,0 +1,40 @@
+diff --git a/node_modules/typescript/lib/lib.dom.d.ts b/node_modules/typescript/lib/lib.dom.d.ts
+index 9ecd352b1050f..08c42c975bf51 100644
+--- a/node_modules/typescript/lib/lib.dom.d.ts
++++ b/node_modules/typescript/lib/lib.dom.d.ts
+@@ -7712,7 +7712,10 @@ interface Element extends Node, ARIAMixin, Animatable, ChildNode, NonDocumentTyp
+      */
+     id: string;
+     /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/innerHTML) */
+-    innerHTML: string;
++    // Chromium modification to work around
++    // https://github.com/microsoft/TypeScript/issues/30024.
++    get innerHTML(): string;
++    set innerHTML(html: string|TrustedHTML);
+     /**
+      * Returns the local name.
+      *
+@@ -12092,7 +12095,10 @@ interface HTMLScriptElement extends HTMLElement {
+      *
+      * [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLScriptElement/src)
+      */
+-    src: string;
++    // Chromium modification to work around
++    // https://github.com/microsoft/TypeScript/issues/30024.
++    get src(): string;
++    set src(url: string|TrustedScriptURL);
+     /**
+      * Retrieves or sets the text of the object as a string.
+      *
+@@ -21026,7 +21032,10 @@ interface ShadowRoot extends DocumentFragment, DocumentOrShadowRoot {
+     /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ShadowRoot/host) */
+     readonly host: Element;
+     /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ShadowRoot/innerHTML) */
+-    innerHTML: string;
++    // Chromium modification to work around
++    // https://github.com/microsoft/TypeScript/issues/30024.
++    get innerHTML(): string;
++    set innerHTML(html: string|TrustedHTML);
+     /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ShadowRoot/mode) */
+     readonly mode: ShadowRootMode;
+     onslotchange: ((this: ShadowRoot, ev: Event) => any) | null;
diff --git a/third_party/openxr/src_overrides/patches/0001-Ignore-Android-Content-Provider-Paths.patch b/third_party/openxr/src_overrides/patches/0001-Ignore-Android-Content-Provider-Paths.patch
new file mode 100644
index 0000000000000..ae867882a4d26
--- /dev/null
+++ b/third_party/openxr/src_overrides/patches/0001-Ignore-Android-Content-Provider-Paths.patch
@@ -0,0 +1,67 @@
+From 156287a5bdf7e9e37266d0a14d80f89f23332b21 Mon Sep 17 00:00:00 2001
+From: Alexander Cooper <alcooper@chromium.org>
+Date: Wed, 4 Dec 2024 14:34:00 -0800
+Subject: [PATCH] Ignore Android Content Provider Paths
+
+---
+ .../openxr/src_overrides/src/loader/android_utilities.cpp   | 6 ++++++
+ .../openxr/src_overrides/src/loader/manifest_file.cpp       | 4 ++--
+ 2 files changed, 8 insertions(+), 2 deletions(-)
+
+diff --git a/third_party/openxr/src_overrides/src/loader/android_utilities.cpp b/third_party/openxr/src_overrides/src/loader/android_utilities.cpp
+index 1f7424b8e6d02..7b80602780682 100644
+--- a/third_party/openxr/src_overrides/src/loader/android_utilities.cpp
++++ b/third_party/openxr/src_overrides/src/loader/android_utilities.cpp
+@@ -26,6 +26,7 @@
+ #define ALOGI(...) __android_log_print(ANDROID_LOG_INFO, "OpenXR-Loader", __VA_ARGS__)
+ 
+ namespace openxr_android {
++#ifndef XRLOADER_DISABLE_CONTENT_PROVIDERS
+ using wrap::android::content::ContentUris;
+ using wrap::android::content::Context;
+ using wrap::android::database::Cursor;
+@@ -290,8 +291,12 @@ static bool getActiveRuntimeCursor(wrap::android::content::Context const &contex
+     }
+     return true;
+ }
++#endif  // #ifndef XRLOADER_DISABLE_CONTENT_PROVIDERS
+ 
+ int getActiveRuntimeVirtualManifest(wrap::android::content::Context const &context, Json::Value &virtualManifest) {
++#if defined(XRLOADER_DISABLE_CONTENT_PROVIDERS)
++    return -1;
++#else
+     jni::Array<std::string> projection = makeArray({active_runtime::Columns::PACKAGE_NAME, active_runtime::Columns::NATIVE_LIB_DIR,
+                                                     active_runtime::Columns::SO_FILENAME, active_runtime::Columns::HAS_FUNCTIONS});
+ 
+@@ -347,6 +352,7 @@ int getActiveRuntimeVirtualManifest(wrap::android::content::Context const &conte
+     ALOGE("Unable to open any of the broker provided runtimes.");
+     cursor.close();
+     return -1;
++#endif  // defined(XRLOADER_DISABLE_CONTENT_PROVIDERS)
+ }
+ }  // namespace openxr_android
+ 
+diff --git a/third_party/openxr/src_overrides/src/loader/manifest_file.cpp b/third_party/openxr/src_overrides/src/loader/manifest_file.cpp
+index ca212d34357ce..166381c05faaa 100644
+--- a/third_party/openxr/src_overrides/src/loader/manifest_file.cpp
++++ b/third_party/openxr/src_overrides/src/loader/manifest_file.cpp
+@@ -680,14 +680,14 @@ XrResult RuntimeManifestFile::FindManifestFiles(const std::string &openxr_comman
+         }
+ #else  // !defined(XR_OS_WINDOWS) && !defined(XR_OS_LINUX)
+ 
+-#if defined(XR_KHR_LOADER_INIT_SUPPORT) && defined(XR_USE_PLATFORM_ANDROID)
++#if defined(XR_KHR_LOADER_INIT_SUPPORT) && defined(XR_USE_PLATFORM_ANDROID) && !defined(XRLOADER_DISABLE_CONTENT_PROVIDERS)
+         Json::Value virtualManifest;
+         result = GetPlatformRuntimeVirtualManifest(virtualManifest);
+         if (XR_SUCCESS == result) {
+             RuntimeManifestFile::CreateIfValid(virtualManifest, "", manifest_files);
+             return result;
+         }
+-#endif  // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_KHR_LOADER_INIT_SUPPORT)
++#endif  // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_KHR_LOADER_INIT_SUPPORT) && !defined(XRLOADER_DISABLE_CONTENT_PROVIDERS)
+         if (!PlatformGetGlobalRuntimeFileName(XR_VERSION_MAJOR(XR_CURRENT_API_VERSION), filename)) {
+             LoaderLogger::LogErrorMessage(
+                 openxr_command,
+-- 
+2.47.0.338.g60cca15819-goog
+
diff --git a/third_party/opus/src/doc/opus_update.patch b/third_party/opus/src/doc/opus_update.patch
new file mode 100644
index 0000000000000..11f066c7022ff
--- /dev/null
+++ b/third_party/opus/src/doc/opus_update.patch
@@ -0,0 +1,244 @@
+diff --git a/celt/bands.c b/celt/bands.c
+index 6962587..32e1de6 100644
+--- a/celt/bands.c
++++ b/celt/bands.c
+@@ -1234,9 +1234,23 @@ void quant_all_bands(int encode, const CELTMode *m, int start, int end,
+          b = 0;
+       }
+ 
+-      if (resynth && M*eBands[i]-N >= M*eBands[start] && (update_lowband || lowband_offset==0))
++      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
+             lowband_offset = i;
+ 
++      if (i == start+1)
++      {
++         int n1, n2;
++         int offset;
++         n1 = M*(eBands[start+1]-eBands[start]);
++         n2 = M*(eBands[start+2]-eBands[start+1]);
++         offset = M*eBands[start];
++         /* Duplicate enough of the first band folding data to be able to fold the second band.
++            Copies no data for CELT-only mode. */
++         OPUS_COPY(&norm[offset+n1], &norm[offset+2*n1 - n2], n2-n1);
++         if (C==2)
++            OPUS_COPY(&norm2[offset+n1], &norm2[offset+2*n1 - n2], n2-n1);
++      }
++
+       tf_change = tf_res[i];
+       if (i>=m->effEBands)
+       {
+@@ -1257,7 +1271,7 @@ void quant_all_bands(int encode, const CELTMode *m, int start, int end,
+          fold_start = lowband_offset;
+          while(M*eBands[--fold_start] > effective_lowband);
+          fold_end = lowband_offset-1;
+-         while(M*eBands[++fold_end] < effective_lowband+N);
++         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+N);
+          x_cm = y_cm = 0;
+          fold_i = fold_start; do {
+            x_cm |= collapse_masks[fold_i*C+0];
+diff --git a/celt/quant_bands.c b/celt/quant_bands.c
+index e5ed9ef..82fb823 100644
+--- a/celt/quant_bands.c
++++ b/celt/quant_bands.c
+@@ -552,6 +552,7 @@ void log2Amp(const CELTMode *m, int start, int end,
+       {
+          opus_val16 lg = ADD16(oldEBands[i+c*m->nbEBands],
+                          SHL16((opus_val16)eMeans[i],6));
++         lg = MIN32(QCONST32(32.f, 16), lg);
+          eBands[i+c*m->nbEBands] = PSHR32(celt_exp2(lg),4);
+       }
+       for (;i<m->nbEBands;i++)
+diff --git a/silk/LPC_inv_pred_gain.c b/silk/LPC_inv_pred_gain.c
+index 60c439b..6c301da 100644
+--- a/silk/LPC_inv_pred_gain.c
++++ b/silk/LPC_inv_pred_gain.c
+@@ -84,8 +84,13 @@ static opus_int32 LPC_inverse_pred_gain_QA(                 /* O   Returns inver
+ 
+         /* Update AR coefficient */
+         for( n = 0; n < k; n++ ) {
+-            tmp_QA = Aold_QA[ n ] - MUL32_FRAC_Q( Aold_QA[ k - n - 1 ], rc_Q31, 31 );
+-            Anew_QA[ n ] = MUL32_FRAC_Q( tmp_QA, rc_mult2 , mult2Q );
++            opus_int64 tmp64;
++            tmp_QA = silk_SUB_SAT32( Aold_QA[ n ], MUL32_FRAC_Q( Aold_QA[ k - n - 1 ], rc_Q31, 31 ) );
++            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( tmp_QA, rc_mult2 ), mult2Q);
++            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
++               return 0;
++            }
++            Anew_QA[ n ] = ( opus_int32 )tmp64;
+         }
+     }
+ 
+diff --git a/silk/NLSF_stabilize.c b/silk/NLSF_stabilize.c
+index 979aaba..2ef2398 100644
+--- a/silk/NLSF_stabilize.c
++++ b/silk/NLSF_stabilize.c
+@@ -134,7 +134,7 @@ void silk_NLSF_stabilize(
+ 
+         /* Keep delta_min distance between the NLSFs */
+         for( i = 1; i < L; i++ )
+-            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], NLSF_Q15[i-1] + NDeltaMin_Q15[i] );
++            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
+ 
+         /* Last NLSF should be no higher than 1 - NDeltaMin[L] */
+         NLSF_Q15[L-1] = silk_min_int( NLSF_Q15[L-1], (1<<15) - NDeltaMin_Q15[L] );
+diff --git a/silk/dec_API.c b/silk/dec_API.c
+index efd7918..21bb7e0 100644
+--- a/silk/dec_API.c
++++ b/silk/dec_API.c
+@@ -72,6 +72,9 @@ opus_int silk_InitDecoder(                              /* O    Returns error co
+     for( n = 0; n < DECODER_NUM_CHANNELS; n++ ) {
+         ret  = silk_init_decoder( &channel_state[ n ] );
+     }
++    silk_memset(&((silk_decoder *)decState)->sStereo, 0, sizeof(((silk_decoder *)decState)->sStereo));
++    /* Not strictly needed, but it's cleaner that way */
++    ((silk_decoder *)decState)->prev_decode_only_middle = 0;
+ 
+     return ret;
+ }
+diff --git a/silk/resampler_private_IIR_FIR.c b/silk/resampler_private_IIR_FIR.c
+index dbd6d9a..91a43aa 100644
+--- a/silk/resampler_private_IIR_FIR.c
++++ b/silk/resampler_private_IIR_FIR.c
+@@ -75,10 +75,10 @@ void silk_resampler_private_IIR_FIR(
+     silk_resampler_state_struct *S = (silk_resampler_state_struct *)SS;
+     opus_int32 nSamplesIn;
+     opus_int32 max_index_Q16, index_increment_Q16;
+-    opus_int16 buf[ RESAMPLER_MAX_BATCH_SIZE_IN + RESAMPLER_ORDER_FIR_12 ];
++    opus_int16 buf[ 2*RESAMPLER_MAX_BATCH_SIZE_IN + RESAMPLER_ORDER_FIR_12 ];
+ 
+     /* Copy buffered samples to start of buffer */
+-    silk_memcpy( buf, S->sFIR, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int32 ) );
++    silk_memcpy( buf, S->sFIR, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
+ 
+     /* Iterate over blocks of frameSizeIn input samples */
+     index_increment_Q16 = S->invRatio_Q16;
+@@ -95,13 +95,13 @@ void silk_resampler_private_IIR_FIR(
+ 
+         if( inLen > 0 ) {
+             /* More iterations to do; copy last part of filtered signal to beginning of buffer */
+-            silk_memcpy( buf, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int32 ) );
++            silk_memmove( buf, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
+         } else {
+             break;
+         }
+     }
+ 
+     /* Copy last part of filtered signal to the state for the next call */
+-    silk_memcpy( S->sFIR, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int32 ) );
++    silk_memcpy( S->sFIR, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
+ }
+ 
+diff --git a/src/opus_decoder.c b/src/opus_decoder.c
+index 0cc56f8..8a30fbc 100644
+--- a/src/opus_decoder.c
++++ b/src/opus_decoder.c
+@@ -595,16 +595,14 @@ static int opus_packet_parse_impl(const unsigned char *data, int len,
+       /* Padding flag is bit 6 */
+       if (ch&0x40)
+       {
+-         int padding=0;
+          int p;
+          do {
+             if (len<=0)
+                return OPUS_INVALID_PACKET;
+             p = *data++;
+             len--;
+-            padding += p==255 ? 254: p;
++            len -= p==255 ? 254: p;
+          } while (p==255);
+-         len -= padding;
+       }
+       if (len<0)
+          return OPUS_INVALID_PACKET;
+diff --git a/run_vectors.sh b/run_vectors.sh
+index 7cd23ed..4841b0a 100755
+--- a/run_vectors.sh
++++ b/run_vectors.sh
+@@ -1,3 +1,5 @@
++#!/bin/sh
++#
+ # Copyright (c) 2011-2012 IETF Trust, Jean-Marc Valin. All rights reserved.
+ #
+ #  This file is extracted from RFC6716. Please see that RFC for additional
+@@ -31,10 +33,8 @@
+ #  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ #  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ 
+-#!/bin/sh
+-
+-rm logs_mono.txt
+-rm logs_stereo.txt
++rm -f logs_mono.txt logs_mono2.txt
++rm -f logs_stereo.txt logs_stereo2.txt
+ 
+ if [ "$#" -ne "3" ]; then
+     echo "usage: run_vectors.sh <exec path> <vector path> <rate>"
+@@ -45,18 +45,23 @@ CMD_PATH=$1
+ VECTOR_PATH=$2
+ RATE=$3
+ 
+-OPUS_DEMO=$CMD_PATH/opus_demo
+-OPUS_COMPARE=$CMD_PATH/opus_compare
++: ${OPUS_DEMO:=$CMD_PATH/opus_demo}
++: ${OPUS_COMPARE:=$CMD_PATH/opus_compare}
+ 
+ if [ -d $VECTOR_PATH ]; then
+     echo Test vectors found in $VECTOR_PATH
+ else
+     echo No test vectors found
+-    #Don't make the test fail here because the test vectors will be
+-    #distributed separately
++    #Don't make the test fail here because the test vectors
++    #will be distributed separately
+     exit 0
+ fi
+ 
++if [ ! -x $OPUS_COMPARE ]; then
++    echo ERROR: Compare program not found: $OPUS_COMPARE
++    exit 1
++fi
++
+ if [ -x $OPUS_DEMO ]; then
+     echo Decoding with $OPUS_DEMO
+ else
+@@ -82,9 +87,11 @@ do
+         echo ERROR: decoding failed
+         exit 1
+     fi
+-    $OPUS_COMPARE -r $RATE $VECTOR_PATH/testvector$file.dec tmp.out >> logs_mono.txt 2>&1
++    $OPUS_COMPARE -r $RATE $VECTOR_PATH/testvector${file}.dec tmp.out >> logs_mono.txt 2>&1
+     float_ret=$?
+-    if [ "$float_ret" -eq "0" ]; then
++    $OPUS_COMPARE -r $RATE $VECTOR_PATH/testvector${file}m.dec tmp.out >> logs_mono2.txt 2>&1
++    float_ret2=$?
++    if [ "$float_ret" -eq "0" ] || [ "$float_ret2" -eq "0" ]; then
+         echo output matches reference
+     else
+         echo ERROR: output does not match reference
+@@ -111,9 +118,11 @@ do
+         echo ERROR: decoding failed
+         exit 1
+     fi
+-    $OPUS_COMPARE -s -r $RATE $VECTOR_PATH/testvector$file.dec tmp.out >> logs_stereo.txt 2>&1
++    $OPUS_COMPARE -s -r $RATE $VECTOR_PATH/testvector${file}.dec tmp.out >> logs_stereo.txt 2>&1
+     float_ret=$?
+-    if [ "$float_ret" -eq "0" ]; then
++    $OPUS_COMPARE -s -r $RATE $VECTOR_PATH/testvector${file}m.dec tmp.out >> logs_stereo2.txt 2>&1
++    float_ret2=$?
++    if [ "$float_ret" -eq "0" ] || [ "$float_ret2" -eq "0" ]; then
+         echo output matches reference
+     else
+         echo ERROR: output does not match reference
+@@ -125,5 +134,10 @@ done
+ 
+ 
+ echo All tests have passed successfully
+-grep quality logs_mono.txt | awk '{sum+=$4}END{print "Average mono quality is", sum/NR, "%"}'
+-grep quality logs_stereo.txt | awk '{sum+=$4}END{print "Average stereo quality is", sum/NR, "%"}'
++mono1=`grep quality logs_mono.txt | awk '{sum+=$4}END{if (NR == 12) sum /= 12; else sum = 0; print sum}'`
++mono2=`grep quality logs_mono2.txt | awk '{sum+=$4}END{if (NR == 12) sum /= 12; else sum = 0; print sum}'`
++echo $mono1 $mono2 | awk '{if ($2 > $1) $1 = $2; print "Average mono quality is", $1, "%"}'
++
++stereo1=`grep quality logs_stereo.txt | awk '{sum+=$4}END{if (NR == 12) sum /= 12; else sum = 0; print sum}'`
++stereo2=`grep quality logs_stereo2.txt | awk '{sum+=$4}END{if (NR == 12) sum /= 12; else sum = 0; print sum}'`
++echo $stereo1 $stereo2 | awk '{if ($2 > $1) $1 = $2; print "Average stereo quality is", $1, "%"}'
diff --git a/third_party/ply/license.patch b/third_party/ply/license.patch
new file mode 100644
index 0000000000000..b6cdff196c4b5
--- /dev/null
+++ b/third_party/ply/license.patch
@@ -0,0 +1,42 @@
+diff --git a/third_party/ply/__init__.py b/third_party/ply/__init__.py
+index 853a985..f3da03e 100644
+--- a/third_party/ply/__init__.py
++++ b/third_party/ply/__init__.py
+@@ -1,4 +1,36 @@
+ # PLY package
+ # Author: David Beazley (dave@dabeaz.com)
++# -----------------------------------------------------------------------------
++# ply: __init__.py
++#
++# Copyright (C) 2001-2018
++# David M. Beazley (Dabeaz LLC)
++# All rights reserved.
++#
++# Redistribution and use in source and binary forms, with or without
++# modification, are permitted provided that the following conditions are
++# met:
++#
++# * Redistributions of source code must retain the above copyright notice,
++#   this list of conditions and the following disclaimer.
++# * Redistributions in binary form must reproduce the above copyright notice,
++#   this list of conditions and the following disclaimer in the documentation
++#   and/or other materials provided with the distribution.
++# * Neither the name of the David Beazley or Dabeaz LLC may be used to
++#   endorse or promote products derived from this software without
++#  specific prior written permission.
++#
++# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
++# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
++# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
++# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
++# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
++# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
++# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
++# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
++# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
++# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++# -----------------------------------------------------------------------------
+ 
+ __version__ = '3.11'
+ __all__ = ['lex','yacc']
diff --git a/third_party/polymer/v3_0/chromium.patch b/third_party/polymer/v3_0/chromium.patch
new file mode 100644
index 0000000000000..77684789f2ea7
--- /dev/null
+++ b/third_party/polymer/v3_0/chromium.patch
@@ -0,0 +1,13 @@
+diff --git a/components-chromium/iron-overlay-behavior/iron-overlay-manager.js b/components-chromium/iron-overlay-behavior/iron-overlay-manager.js
+index 99768f419688..7dd55b8077b7 100644
+--- a/components-chromium/iron-overlay-behavior/iron-overlay-manager.js
++++ b/components-chromium/iron-overlay-behavior/iron-overlay-manager.js
+@@ -13,7 +13,7 @@ import './iron-overlay-backdrop.js';
+ 
+ import {IronA11yKeysBehavior} from '../iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';
+ import {dom} from '../polymer/lib/legacy/polymer.dom.js';
+-import * as gestures from '../polymer/lib/utils/gestures.js';
++import {gestures} from '../polymer/lib/utils/gestures.js';
+ 
+ /**
+  * @struct
diff --git a/third_party/polymer/v3_0/chromium_dts.patch b/third_party/polymer/v3_0/chromium_dts.patch
new file mode 100644
index 0000000000000..fc3ba19fb983e
--- /dev/null
+++ b/third_party/polymer/v3_0/chromium_dts.patch
@@ -0,0 +1,136 @@
+diff --git a/components-chromium/iron-collapse/iron-collapse.d.ts b/components-chromium/iron-collapse/iron-collapse.d.ts
+index ba7cf2165f095..fb091bd6c5520 100644
+--- a/components-chromium/iron-collapse/iron-collapse.d.ts
++++ b/components-chromium/iron-collapse/iron-collapse.d.ts
+@@ -69,7 +69,7 @@ interface IronCollapseElement extends IronResizableBehavior, LegacyElementMixin,
+   /**
+    * Set opened to true to show the collapse element and to false to hide it.
+    */
+-  opened: boolean|null|undefined;
++  opened: boolean;
+ 
+   /**
+    * When true, the element is transitioning its opened state. When false,
+diff --git a/components-chromium/iron-iconset-svg/iron-iconset-svg.d.ts b/components-chromium/iron-iconset-svg/iron-iconset-svg.d.ts
+index 8dc9834e50cc9..3f76923548e7f 100644
+--- a/components-chromium/iron-iconset-svg/iron-iconset-svg.d.ts
++++ b/components-chromium/iron-iconset-svg/iron-iconset-svg.d.ts
+@@ -104,6 +104,15 @@ interface IronIconsetSvgElement extends LegacyElementMixin, HTMLElement {
+    */
+   applyIcon(element: Element|null, iconName: string): Element|null;
+ 
++  /**
++   * Produce installable clone of the SVG element matching `id` in this
++   * iconset, or `undefined` if there is no matching element.
++   * @param iconName Name of the icon to apply.
++   * @param targetIsRTL Whether the target element is RTL.
++   * @return Returns an installable clone of the SVG element matching `id`.
++   */
++  createIcon(iconName: string, targetIsRTL: boolean): Element|null;
++
+   /**
+    * Remove an icon from the given element by undoing the changes effected
+    * by `applyIcon`.
+diff --git a/components-chromium/iron-list/iron-list.d.ts b/components-chromium/iron-list/iron-list.d.ts
+index e469a76eccfbf..06629b5b15945 100644
+--- a/components-chromium/iron-list/iron-list.d.ts
++++ b/components-chromium/iron-list/iron-list.d.ts
+@@ -574,6 +574,7 @@ interface IronListElement extends Templatizer, IronResizableBehavior, IronScroll
+   readonly _estRowsInView: any;
+   readonly _physicalRows: any;
+   readonly _scrollOffset: any;
++  preserveFocus: boolean;
+   attached(): void;
+   detached(): void;
+ 
+diff --git a/components-chromium/iron-overlay-behavior/iron-overlay-behavior.d.ts b/components-chromium/iron-overlay-behavior/iron-overlay-behavior.d.ts
+index a1a4c1fdc485c..67634c9abb81c 100644
+--- a/components-chromium/iron-overlay-behavior/iron-overlay-behavior.d.ts
++++ b/components-chromium/iron-overlay-behavior/iron-overlay-behavior.d.ts
+@@ -23,7 +23,7 @@ interface IronOverlayBehaviorImpl {
+   /**
+    * True if the overlay is currently displayed.
+    */
+-  opened: boolean|null|undefined;
++  opened: boolean;
+ 
+   /**
+    * True if the overlay was canceled when it was last closed.
+diff --git a/components-chromium/paper-spinner/paper-spinner-behavior.d.ts b/components-chromium/paper-spinner/paper-spinner-behavior.d.ts
+index e6b510ce1ffda..da0718c12503f 100644
+--- a/components-chromium/paper-spinner/paper-spinner-behavior.d.ts
++++ b/components-chromium/paper-spinner/paper-spinner-behavior.d.ts
+@@ -15,7 +15,7 @@ interface PaperSpinnerBehavior {
+   /**
+    * Displays the spinner.
+    */
+-  active: boolean|null|undefined;
++  active: boolean;
+ 
+   /**
+    * Alternative text content for accessibility support.
+diff --git a/components-chromium/paper-tooltip/paper-tooltip.d.ts b/components-chromium/paper-tooltip/paper-tooltip.d.ts
+index ed159e50ca1dd..7ef18f0bc7cc8 100644
+--- a/components-chromium/paper-tooltip/paper-tooltip.d.ts
++++ b/components-chromium/paper-tooltip/paper-tooltip.d.ts
+@@ -118,7 +118,7 @@ interface PaperTooltipElement extends LegacyElementMixin, HTMLElement {
+    * that your animationConfig has the exact format below.
+    */
+   animationConfig: object|null|undefined;
+-  _showing: boolean|null|undefined;
++  _showing: boolean;
+   hostAttributes: object|null;
+ 
+   /**
+@@ -126,7 +126,7 @@ interface PaperTooltipElement extends LegacyElementMixin, HTMLElement {
+    * either the element given by the `for` attribute, or the immediate parent
+    * of the tooltip.
+    */
+-  readonly target: any;
++  target: any;
+   attached(): void;
+   detached(): void;
+ 
+diff --git a/components-chromium/polymer/lib/elements/dom-repeat.d.ts b/components-chromium/polymer/lib/elements/dom-repeat.d.ts
+index 3941f763e1271..8caf1e381d759 100644
+--- a/components-chromium/polymer/lib/elements/dom-repeat.d.ts
++++ b/components-chromium/polymer/lib/elements/dom-repeat.d.ts
+@@ -287,6 +287,16 @@ declare class DomRepeat extends
+   modelForElement(el: HTMLElement): TemplateInstanceBase|null;
+ }
+ 
++interface DomRepeatItem<M> {
++  model: {
++    item: M,
++    index: number,
++  }
++}
++
++/** Event interface for dom-repeat events. */
++export type DomRepeatEvent<M, E extends Event = Event> = DomRepeatItem<M>&E;
++
+ declare global {
+ 
+   interface HTMLElementTagNameMap {
+diff --git a/components-chromium/polymer/polymer.d.ts b/components-chromium/polymer/polymer.d.ts
+index 588b7ee0df247..83213a66d8239 100644
+--- a/components-chromium/polymer/polymer.d.ts
++++ b/components-chromium/polymer/polymer.d.ts
+@@ -11,7 +11,7 @@ subject to an additional IP rights grant found at http://polymer.github.io/PATEN
+ import * as gestures from './lib/utils/gestures.js';
+ 
+ export {DomIf} from './lib/elements/dom-if.js';
+-export {DomRepeat} from './lib/elements/dom-repeat.js';
++export {DomRepeat, DomRepeatEvent} from './lib/elements/dom-repeat.js';
+ export {mixinBehaviors} from './lib/legacy/class.js';
+ export {OptionalMutableDataBehavior} from './lib/legacy/mutable-data-behavior.js';
+ export {Polymer} from './lib/legacy/polymer-fn.js';
+@@ -26,8 +26,6 @@ export {html} from './lib/utils/html-tag.js';
+ export {dedupingMixin} from './lib/utils/mixin.js';
+ export {get, matches, translate} from './lib/utils/path.js';
+ export {afterNextRender, beforeNextRender} from './lib/utils/render-status.js';
+-export {useShadow} from './lib/utils/settings.js';
+ export {TemplateInstanceBase, templatize} from './lib/utils/templatize.js';
+ export {PolymerElement} from './polymer-element.js';
+-export {Base} from './polymer-legacy.js';
+ export {gestures};
diff --git a/third_party/polymer/v3_0/iron_icon.patch b/third_party/polymer/v3_0/iron_icon.patch
new file mode 100644
index 0000000000000..f24f98b0812e4
--- /dev/null
+++ b/third_party/polymer/v3_0/iron_icon.patch
@@ -0,0 +1,33 @@
+diff --git a/components-chromium/iron-icon/iron-icon.js b/components-chromium/iron-icon/iron-icon.js
+index 35835d2b5c484..2a647f13b3e55 100644
+--- a/components-chromium/iron-icon/iron-icon.js
++++ b/components-chromium/iron-icon/iron-icon.js
+@@ -8,8 +8,6 @@ found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
+ part of the polymer project is also subject to an additional IP rights grant
+ found at http://polymer.github.io/PATENTS.txt
+ */
+-import '../iron-flex-layout/iron-flex-layout.js';
+-
+ import {IronMeta} from '../iron-meta/iron-meta.js';
+ import {Polymer} from '../polymer/polymer_bundled.min.js';
+ import {dom} from '../polymer/polymer_bundled.min.js';
+@@ -89,8 +87,9 @@ Polymer({
+   _template: html`
+     <style>
+       :host {
+-        @apply --layout-inline;
+-        @apply --layout-center-center;
++        align-items: center;
++        display: inline-flex;
++        justify-content: center;
+         position: relative;
+ 
+         vertical-align: middle;
+@@ -100,7 +99,6 @@ Polymer({
+ 
+         width: var(--iron-icon-width, 24px);
+         height: var(--iron-icon-height, 24px);
+-        @apply --iron-icon;
+       }
+ 
+       :host([hidden]) {
diff --git a/third_party/polymer/v3_0/iron_iconset_svg.patch b/third_party/polymer/v3_0/iron_iconset_svg.patch
new file mode 100644
index 0000000000000..0cc257a0747e8
--- /dev/null
+++ b/third_party/polymer/v3_0/iron_iconset_svg.patch
@@ -0,0 +1,54 @@
+diff --git b/components-chromium/iron-iconset-svg/iron-iconset-svg.js a/components-chromium/iron-iconset-svg/iron-iconset-svg.js
+index 9bd6935fa7a9f..603f83c270ca6 100644
+--- b/components-chromium/iron-iconset-svg/iron-iconset-svg.js
++++ a/components-chromium/iron-iconset-svg/iron-iconset-svg.js
+@@ -127,13 +127,26 @@ Polymer({
+         iconName, this.rtlMirroring && this._targetIsRTL(element));
+     if (svg) {
+       // insert svg element into shadow root, if it exists
+-      var pde = dom(element.root || element);
++      var pde = element.shadowRoot ?
++          element.shadowRoot : dom(element.root || element);
+       pde.insertBefore(svg, pde.childNodes[0]);
+       return element._svgIcon = svg;
+     }
+     return null;
+   },
+ 
++  /**
++   * Produce installable clone of the SVG element matching `id` in this
++   * iconset, or `undefined` if there is no matching element.
++   * @param {string} iconName Name of the icon to apply.
++   * @param {boolean} targetIsRTL Whether the target element is RTL.
++   * @return {Element} Returns an installable clone of the SVG element
++   *     matching `id`.
++   */
++  createIcon: function(iconName, targetIsRTL) {
++    return this._cloneIcon(iconName, this.rtlMirroring && targetIsRTL);
++  },
++
+   /**
+    * Remove an icon from the given element by undoing the changes effected
+    * by `applyIcon`.
+@@ -143,7 +156,9 @@ Polymer({
+   removeIcon: function(element) {
+     // Remove old svg element
+     if (element._svgIcon) {
+-      dom(element.root || element).removeChild(element._svgIcon);
++      var root = element.shadowRoot ?
++          element.shadowRoot : dom(element.root || element);
++      root.removeChild(element._svgIcon);
+       element._svgIcon = null;
+     }
+   },
+@@ -185,9 +200,7 @@ Polymer({
+     this._meta.key = this.name;
+     this._meta.value = this;
+ 
+-    this.async(function() {
+-      this.fire('iron-iconset-added', this, {node: window});
+-    });
++    this.fire('iron-iconset-added', this, {node: window});
+   },
+ 
+   /**
diff --git a/third_party/polymer/v3_0/iron_list.patch b/third_party/polymer/v3_0/iron_list.patch
new file mode 100644
index 0000000000000..888311d41e912
--- /dev/null
+++ b/third_party/polymer/v3_0/iron_list.patch
@@ -0,0 +1,145 @@
+diff --git a/components-chromium/iron-list/iron-list.js b/components-chromium/iron-list/iron-list.js
+index 67ec9a735773d..ad8e118645b56 100644
+--- a/components-chromium/iron-list/iron-list.js
++++ b/components-chromium/iron-list/iron-list.js
+@@ -207,19 +207,6 @@ to previous and next items in the list:
+ </iron-list>
+ ```
+ 
+-### Styling
+-
+-You can use the `--iron-list-items-container` mixin to style the container of
+-items:
+-
+-```css
+-iron-list {
+- --iron-list-items-container: {
+-    margin: auto;
+-  };
+-}
+-```
+-
+ ### Resizing
+ 
+ `iron-list` lays out the items when it receives a notification via the
+@@ -267,7 +254,6 @@ Polymer({
+       }
+ 
+       #items {
+-        @apply --iron-list-items-container;
+         position: relative;
+       }
+ 
+@@ -376,7 +362,15 @@ Polymer({
+      * there's some offset between the scrolling element and the list. For
+      * example: a header is placed above the list.
+      */
+-    scrollOffset: {type: Number, value: 0}
++    scrollOffset: {type: Number, value: 0},
++
++    /**
++     * If set to true, focus on an element will be preserved after rerender.
++     */
++    preserveFocus: {
++      type: Boolean,
++      value: false
++    }
+   },
+ 
+   observers: [
+@@ -1066,11 +1060,53 @@ Polymer({
+     newGrid && this._updateGridMetrics();
+   },
+ 
++  /**
++   * Finds and returns the focused element (both within self and children's
++   * Shadow DOM).
++   * @return {?HTMLElement}
++   */
++  _getFocusedElement: function() {
++    function doSearch(node, query) {
++      let result = null;
++      let type = node.nodeType;
++      if (type == Node.ELEMENT_NODE || type == Node.DOCUMENT_FRAGMENT_NODE)
++        result = node.querySelector(query);
++      if (result)
++        return result;
++
++      let child = node.firstChild;
++      while (child !== null && result === null) {
++        result = doSearch(child, query);
++        child = child.nextSibling;
++      }
++      if (result)
++        return result;
++
++      const shadowRoot = node.shadowRoot;
++      return shadowRoot ? doSearch(shadowRoot, query) : null;
++    }
++
++    // Find out if any of the items are focused first, and only search
++    // recursively in the item that contains focus, to avoid a slow
++    // search of the entire list.
++    const focusWithin = doSearch(this, ':focus-within');
++    return focusWithin ? doSearch(focusWithin, ':focus') : null;
++  },
++
+   /**
+    * Called when the items have changed. That is, reassignments
+    * to `items`, splices or updates to a single item.
+    */
+   _itemsChanged: function(change) {
++    var rendering = /^items(\.splices){0,1}$/.test(change.path);
++    var lastFocusedIndex, focusedElement;
++    if (rendering && this.preserveFocus) {
++      lastFocusedIndex = this._focusedVirtualIndex;
++      focusedElement = this._getFocusedElement();
++    }
++
++    var preservingFocus = rendering && this.preserveFocus && focusedElement;
++
+     if (change.path === 'items') {
+       this._virtualStart = 0;
+       this._physicalTop = 0;
+@@ -1082,7 +1118,7 @@ Polymer({
+       this._physicalItems = this._physicalItems || [];
+       this._physicalSizes = this._physicalSizes || [];
+       this._physicalStart = 0;
+-      if (this._scrollTop > this._scrollOffset) {
++      if (this._scrollTop > this._scrollOffset && !preservingFocus) {
+         this._resetScrollPosition(0);
+       }
+       this._removeFocusedItem();
+@@ -1114,6 +1150,17 @@ Polymer({
+     } else if (change.path !== 'items.length') {
+       this._forwardItemPath(change.path, change.value);
+     }
++
++    // If the list was in focus when updated, preserve the focus on item.
++    if (preservingFocus) {
++      flush();
++      focusedElement.blur();  // paper- elements breaks when focused twice.
++      this._focusPhysicalItem(
++          Math.min(this.items.length - 1, lastFocusedIndex));
++      if (!this._isIndexVisible(this._focusedVirtualIndex)) {
++        this.scrollToIndex(this._focusedVirtualIndex);
++      }
++    }
+   },
+ 
+   _forwardItemPath: function(path, value) {
+@@ -1851,13 +1898,7 @@ Polymer({
+     if (!targetModel) {
+       return;
+     }
+-    if (focusedModel === targetModel) {
+-      // If the user focused the same item, then bring it into view if it's not
+-      // visible.
+-      if (!this._isIndexVisible(fidx)) {
+-        this.scrollToIndex(fidx);
+-      }
+-    } else {
++    if (focusedModel !== targetModel) {
+       this._restoreFocusedItem();
+       // Restore tabIndex for the currently focused item.
+       if (focusedModel) {
diff --git a/third_party/polymer/v3_0/iron_overlay_backdrop.patch b/third_party/polymer/v3_0/iron_overlay_backdrop.patch
new file mode 100644
index 0000000000000..b1101d792e6de
--- /dev/null
+++ b/third_party/polymer/v3_0/iron_overlay_backdrop.patch
@@ -0,0 +1,27 @@
+diff --git a/components-chromium/iron-overlay-behavior/iron-overlay-backdrop.js b/components-chromium/iron-overlay-behavior/iron-overlay-backdrop.js
+index fca79f0d2cd25..d32f1cc38325f 100644
+--- a/components-chromium/iron-overlay-behavior/iron-overlay-backdrop.js
++++ b/components-chromium/iron-overlay-behavior/iron-overlay-backdrop.js
+@@ -26,8 +26,6 @@ Custom property | Description | Default
+ -------------------------------------------|------------------------|---------
+ `--iron-overlay-backdrop-background-color` | Backdrop background color | #000
+ `--iron-overlay-backdrop-opacity`          | Backdrop opacity | 0.6
+-`--iron-overlay-backdrop`                  | Mixin applied to `iron-overlay-backdrop`.                      | {}
+-`--iron-overlay-backdrop-opened`           | Mixin applied to `iron-overlay-backdrop` when it is displayed | {}
+ */
+ Polymer({
+   _template: html`
+@@ -42,13 +40,11 @@ Polymer({
+         opacity: 0;
+         transition: opacity 0.2s;
+         pointer-events: none;
+-        @apply --iron-overlay-backdrop;
+       }
+ 
+       :host(.opened) {
+         opacity: var(--iron-overlay-backdrop-opacity, 0.6);
+         pointer-events: auto;
+-        @apply --iron-overlay-backdrop-opened;
+       }
+     </style>
+ 
diff --git a/third_party/polymer/v3_0/paper_progress.patch b/third_party/polymer/v3_0/paper_progress.patch
new file mode 100644
index 0000000000000..18995c76657a4
--- /dev/null
+++ b/third_party/polymer/v3_0/paper_progress.patch
@@ -0,0 +1,60 @@
+diff --git a/components-chromium/paper-progress/paper-progress.js b/components-chromium/paper-progress/paper-progress.js
+index fdb26f773b1e3..51b5a814601ac 100644
+--- a/components-chromium/paper-progress/paper-progress.js
++++ b/components-chromium/paper-progress/paper-progress.js
+@@ -9,7 +9,5 @@ part of the polymer project is also subject to an additional IP rights grant
+ found at http://polymer.github.io/PATENTS.txt
+ */
+ import '../polymer/polymer-legacy.js';
+-import '../iron-flex-layout/iron-flex-layout.js';
+-import '../paper-styles/color.js';
+ 
+ import {IronRangeBehavior} from '../iron-range-behavior/iron-range-behavior.js';
+@@ -74,7 +72,6 @@ The following mixins are available for styling:
+ 
+ Custom property | Description | Default
+ ----------------|-------------|---------
+-`--paper-progress-container` | Mixin applied to container | `{}`
+ `--paper-progress-transition-duration` | Duration of the transition | `0.08s`
+ `--paper-progress-transition-timing-function` | The timing function for the transition | `ease`
+ `--paper-progress-transition-delay` | delay for the transition | `0s`
+@@ -98,6 +95,10 @@ Polymer({
+         width: 200px;
+         position: relative;
+         overflow: hidden;
++        --google-green-100: #b7e1cd;
++        --google-green-500: #0f9d58;
++        --google-grey-300: #e0e0e0;
++        --google-grey-500: #9e9e9e;
+       }
+ 
+       :host([hidden]), [hidden] {
+@@ -105,7 +106,6 @@ Polymer({
+       }
+ 
+       #progressContainer {
+-        @apply --paper-progress-container;
+         position: relative;
+       }
+ 
+@@ -118,7 +118,11 @@ Polymer({
+       #primaryProgress,
+       #secondaryProgress,
+       .indeterminate::after {
+-        @apply --layout-fit;
++        position: absolute;
++        top: 0;
++        right: 0;
++        bottom: 0;
++        left: 0;
+       }
+ 
+       #progressContainer,
+@@ -146,7 +150,6 @@ Polymer({
+ 
+       #primaryProgress,
+       #secondaryProgress {
+-        @apply --layout-fit;
+         -webkit-transform-origin: left center;
+         transform-origin: left center;
+         -webkit-transform: scaleX(0);
diff --git a/third_party/polymer/v3_0/paper_spinner.patch b/third_party/polymer/v3_0/paper_spinner.patch
new file mode 100644
index 0000000000000..85c8c7a0d5cd9
--- /dev/null
+++ b/third_party/polymer/v3_0/paper_spinner.patch
@@ -0,0 +1,50 @@
+diff --git a/components-chromium/paper-spinner/paper-spinner-lite.js b/components-chromium/paper-spinner/paper-spinner-lite.js
+index 2577e3a37ed52..c6d5e4bd0865e 100644
+--- a/components-chromium/paper-spinner/paper-spinner-lite.js
++++ b/components-chromium/paper-spinner/paper-spinner-lite.js
+@@ -9,7 +9,6 @@ part of the polymer project is also subject to an additional IP rights grant
+ found at http://polymer.github.io/PATENTS.txt
+ */
+ import '../polymer/polymer-legacy.js';
+-import '../paper-styles/color.js';
+ import './paper-spinner-styles.js';
+ 
+ import {Polymer} from '../polymer/polymer_bundled.min.js';
+diff --git a/components-chromium/paper-spinner/paper-spinner-styles.js b/components-chromium/paper-spinner/paper-spinner-styles.js
+index 1fe43d0e8e6ed..832d6037d2a00 100644
+--- a/components-chromium/paper-spinner/paper-spinner-styles.js
++++ b/components-chromium/paper-spinner/paper-spinner-styles.js
+@@ -8,10 +8,9 @@ found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
+ part of the polymer project is also subject to an additional IP rights grant
+ found at http://polymer.github.io/PATENTS.txt
+ */
+-const $_documentContainer = document.createElement('template');
+-$_documentContainer.setAttribute('style', 'display: none;');
++import {html} from '../polymer/lib/utils/html-tag.js';
+ 
+-$_documentContainer.innerHTML = `<dom-module id="paper-spinner-styles">
++const template = html`<dom-module id="paper-spinner-styles">
+   <template>
+     <style>
+       /*
+@@ -47,6 +46,12 @@ const template = html`<dom-module id="paper-spinner-styles">
+ 
+         /* SHRINK_TIME */
+         --paper-spinner-cooldown-duration: 400ms;
++
++        /* Colors */
++        --google-red-500: #db4437;
++        --google-blue-500: #4285f4;
++        --google-green-500: #0f9d58;
++        --google-yellow-500: #f4b400;
+       }
+ 
+       #spinnerContainer {
+@@ -324,6 +329,6 @@ $_documentContainer.innerHTML = `<dom-module id="paper-spinner-styles">
+   </template>
+ </dom-module>`;
+ 
+-document.head.appendChild($_documentContainer.content);
++document.head.appendChild(template.content);
+ 
+ export {};
diff --git a/third_party/polymer/v3_0/paper_tooltip.patch b/third_party/polymer/v3_0/paper_tooltip.patch
new file mode 100644
index 0000000000000..03934acd18cc2
--- /dev/null
+++ b/third_party/polymer/v3_0/paper_tooltip.patch
@@ -0,0 +1,204 @@
+diff --git a/components-chromium/paper-tooltip/paper-tooltip.js b/components-chromium/paper-tooltip/paper-tooltip.js
+index 853eee1990258..1b36aa4c38b3f 100644
+--- a/components-chromium/paper-tooltip/paper-tooltip.js
++++ b/components-chromium/paper-tooltip/paper-tooltip.js
+@@ -42,12 +42,14 @@ Custom property | Description | Default
+ `--paper-tooltip-background` | The background color of the tooltip | `#616161`
+ `--paper-tooltip-opacity` | The opacity of the tooltip | `0.9`
+ `--paper-tooltip-text-color` | The text color of the tooltip | `white`
+-`--paper-tooltip` | Mixin applied to the tooltip | `{}`
+ `--paper-tooltip-delay-in` | Delay before tooltip starts to fade in | `500`
+ `--paper-tooltip-delay-out` | Delay before tooltip starts to fade out | `0`
+ `--paper-tooltip-duration-in` | Timing for animation when showing tooltip | `500`
+ `--paper-tooltip-duration-out` | Timing for animation when hiding tooltip | `0`
+-`--paper-tooltip-animation` | Mixin applied to the tooltip animation | `{}`
++
++Also prefer using the exposed CSS part as follows where possible
++paper-tooltip::part(tooltip) {...}
++
+ @group Paper Elements
+ @element paper-tooltip
+ @demo demo/index.html
+@@ -67,14 +69,12 @@ Polymer({
+       #tooltip {
+         display: block;
+         outline: none;
+-        @apply --paper-font-common-base;
+         font-size: 10px;
+         line-height: 1;
+         background-color: var(--paper-tooltip-background, #616161);
+         color: var(--paper-tooltip-text-color, white);
+         padding: 8px;
+         border-radius: 2px;
+-        @apply --paper-tooltip;
+       }
+ 
+       @keyframes keyFrameScaleUp {
+@@ -149,7 +149,6 @@ Polymer({
+         animation-timing-function: ease-in;
+         animation-duration: var(--paper-tooltip-duration-in, 500ms);
+         animation-fill-mode: forwards;
+-        @apply --paper-tooltip-animation;
+       }
+ 
+       .fade-out-animation {
+@@ -160,7 +159,6 @@ Polymer({
+         animation-timing-function: ease-in;
+         animation-duration: var(--paper-tooltip-duration-out, 500ms);
+         animation-fill-mode: forwards;
+-        @apply --paper-tooltip-animation;
+       }
+ 
+       .scale-up-animation {
+@@ -172,7 +170,6 @@ Polymer({
+         animation-timing-function: ease-in;
+         animation-duration: var(--paper-tooltip-duration-in, 500ms);
+         animation-fill-mode: forwards;
+-        @apply --paper-tooltip-animation;
+       }
+ 
+       .scale-down-animation {
+@@ -184,7 +181,6 @@ Polymer({
+         animation-timing-function: ease-in;
+         animation-duration: var(--paper-tooltip-duration-out, 500ms);
+         animation-fill-mode: forwards;
+-        @apply --paper-tooltip-animation;
+       }
+ 
+       .slide-down-animation {
+@@ -196,7 +192,6 @@ Polymer({
+         animation-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
+         animation-duration: var(--paper-tooltip-duration-out, 500ms);
+         animation-fill-mode: forwards;
+-        @apply --paper-tooltip-animation;
+       }
+ 
+       .slide-down-animation-out {
+@@ -208,7 +203,6 @@ Polymer({
+         animation-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
+         animation-duration: var(--paper-tooltip-duration-out, 500ms);
+         animation-fill-mode: forwards;
+-        @apply --paper-tooltip-animation;
+       }
+ 
+       .cancel-animation {
+@@ -222,7 +216,7 @@ Polymer({
+       }
+     </style>
+ 
+-    <div id="tooltip" class="hidden">
++    <div id="tooltip" class="hidden" part="tooltip">
+       <slot></slot>
+     </div>
+ `,
+@@ -282,8 +276,8 @@ Polymer({
+      */
+     animationExit: {type: String, value: ''},
+     /**
+-     * This property is deprecated.  Use --paper-tooltip-animation to change the
+-     * animation. The entry and exit animations that will be played when showing
++     * This property is deprecated.
++     * The entry and exit animations that will be played when showing
+      * and hiding the tooltip. If you want to override this, you must ensure
+      * that your animationConfig has the exact format below.
+      * @deprecated since version
+@@ -311,12 +305,16 @@ Polymer({
+ 
+   /**
+    * Returns the target element that this tooltip is anchored to. It is
+-   * either the element given by the `for` attribute, or the immediate parent
+-   * of the tooltip.
++   * either the element given by the `for` attribute, the element manually
++   * specified through the `target` attribute, or the immediate parent of
++   * the tooltip.
+    *
+    * @type {Node}
+    */
+   get target() {
++    if (this._manualTarget)
++      return this._manualTarget;
++
+     var parentNode = dom(this).parentNode;
+     // If the parentNode is a document fragment, then we need to use the host.
+     var ownerRoot = dom(this).getOwnerRoot();
+@@ -331,6 +329,15 @@ Polymer({
+     return target;
+   },
+ 
++  /**
++   * Sets the target element that this tooltip will be anchored to.
++   * @param {Node} target
++   */
++  set target(target) {
++    this._manualTarget = target;
++    this._findTarget();
++  },
++
+   /**
+    * @return {void}
+    */
+@@ -429,13 +436,16 @@ Polymer({
+    * @return {void}
+    */
+   updatePosition: function() {
+-    if (!this._target || !this.offsetParent)
++    if (!this._target)
++      return;
++    var offsetParent = this._composedOffsetParent();
++    if (!offsetParent)
+       return;
+     var offset = this.offset;
+     // If a marginTop has been provided by the user (pre 1.0.3), use it.
+     if (this.marginTop != 14 && this.offset == 14)
+       offset = this.marginTop;
+-    var parentRect = this.offsetParent.getBoundingClientRect();
++    var parentRect = offsetParent.getBoundingClientRect();
+     var targetRect = this._target.getBoundingClientRect();
+     var thisRect = this.getBoundingClientRect();
+     var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;
+@@ -581,5 +591,45 @@ Polymer({
+     }
+     this.unlisten(this.$.tooltip, 'animationend', '_onAnimationEnd');
+     this.unlisten(this, 'mouseenter', 'hide');
++  },
++
++  /**
++   * Polyfills the old offsetParent behavior from before the spec was changed:
++   * https://github.com/w3c/csswg-drafts/issues/159
++   */
++  _composedOffsetParent: function() {
++    // Do an initial walk to check for display:none ancestors.
++    for (let ancestor = this; ancestor; ancestor = flatTreeParent(ancestor)) {
++      if (!(ancestor instanceof Element))
++        continue;
++      if (getComputedStyle(ancestor).display === 'none')
++        return null;
++    }
++
++    for (let ancestor = flatTreeParent(this); ancestor; ancestor = flatTreeParent(ancestor)) {
++      if (!(ancestor instanceof Element))
++        continue;
++      const style = getComputedStyle(ancestor);
++      if (style.display === 'contents') {
++        // display:contents nodes aren't in the layout tree so they should be skipped.
++        continue;
++      }
++      if (style.position !== 'static') {
++        return ancestor;
++      }
++      if (ancestor.tagName === 'BODY')
++        return ancestor;
++    }
++    return null;
++
++    function flatTreeParent(element) {
++      if (element.assignedSlot) {
++        return element.assignedSlot;
++      }
++      if (element.parentNode instanceof ShadowRoot) {
++        return element.parentNode.host;
++      }
++      return element.parentNode;
++    }
+   }
+ });
diff --git a/third_party/polymer/v3_0/polymer.patch b/third_party/polymer/v3_0/polymer.patch
new file mode 100644
index 0000000000000..662fc65515dae
--- /dev/null
+++ b/third_party/polymer/v3_0/polymer.patch
@@ -0,0 +1,205 @@
+diff --git a/components-chromium/polymer/lib/elements/custom-style.js b/components-chromium/polymer/lib/elements/custom-style.js
+index e0d2021372554..c667b6ee83a03 100644
+--- a/components-chromium/polymer/lib/elements/custom-style.js
++++ b/components-chromium/polymer/lib/elements/custom-style.js
+@@ -7,14 +7,11 @@ The complete set of contributors may be found at http://polymer.github.io/CONTRI
+ Code distributed by Google as part of the polymer project is also
+ subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
+ */
+-import '../../../shadycss/entrypoints/custom-style-interface.js';
+ 
+ import { cssFromModules } from '../utils/style-gather.js';
+ 
+ const attr = 'include';
+ 
+-const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;
+-
+ /**
+  * Custom element for defining styles in the main document that can take
+  * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
+@@ -65,7 +62,6 @@ export class CustomStyle extends HTMLElement {
+   constructor() {
+     super();
+     this._style = null;
+-    CustomStyleInterface.addCustomStyle(this);
+   }
+   /**
+    * Returns the light-DOM `<style>` child this element wraps.  Upon first
+diff --git a/components-chromium/polymer/lib/legacy/legacy-element-mixin.js b/components-chromium/polymer/lib/legacy/legacy-element-mixin.js
+index de150da342ee9..8815c83a70cca 100644
+--- a/components-chromium/polymer/lib/legacy/legacy-element-mixin.js
++++ b/components-chromium/polymer/lib/legacy/legacy-element-mixin.js
+@@ -7,10 +7,8 @@ The complete set of contributors may be found at http://polymer.github.io/CONTRI
+ Code distributed by Google as part of the polymer project is also
+ subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
+ */
+-import '../../../shadycss/entrypoints/apply-shim.js';
+ import { ElementMixin, builtCSS } from '../mixins/element-mixin.js';
+ import { GestureEventListeners } from '../mixins/gesture-event-listeners.js';
+-import { DirMixin } from '../mixins/dir-mixin.js';
+ import { dedupingMixin } from '../utils/mixin.js';
+ import '../utils/render-status.js';
+ import '../utils/unresolved.js';
+@@ -39,7 +37,6 @@ let styleInterface = window.ShadyCSS;
+  * @polymer
+  * @appliesMixin ElementMixin
+  * @appliesMixin GestureEventListeners
+- * @appliesMixin DirMixin
+  * @property isAttached {boolean} Set to `true` in this element's
+  *   `connectedCallback` and `false` in `disconnectedCallback`
+  * @summary Element class mixin that provides Polymer's "legacy" API
+@@ -52,7 +49,6 @@ export const LegacyElementMixin = dedupingMixin((base) => {
+    * @constructor
+    * @implements {Polymer_ElementMixin}
+    * @implements {Polymer_GestureEventListeners}
+-   * @implements {Polymer_DirMixin}
+    * @extends {HTMLElement}
+    * @private
+    */
+@@ -66,8 +62,7 @@ export const LegacyElementMixin = dedupingMixin((base) => {
+    * @extends {GesturesElement}
+    * @private
+    */
+-  const legacyElementBase = builtCSS ? GesturesElement :
+-    DirMixin(GesturesElement);
++  const legacyElementBase = GesturesElement;
+ 
+   const observedAttributesGetter = findObservedAttributesGetter(legacyElementBase);
+ 
+diff --git a/components-chromium/polymer/lib/mixins/element-mixin.js b/components-chromium/polymer/lib/mixins/element-mixin.js
+index cba8953ab51bb..76b86681be72a 100644
+--- a/components-chromium/polymer/lib/mixins/element-mixin.js
++++ b/components-chromium/polymer/lib/mixins/element-mixin.js
+@@ -739,13 +739,13 @@ export const ElementMixin = dedupingMixin(base => {
+         if (dom) {
+           if (!n.shadowRoot) {
+             n.attachShadow({mode: 'open', shadyUpgradeFragment: dom});
+-            n.shadowRoot.appendChild(dom);
+             // When `adoptedStyleSheets` is supported a stylesheet is made
+             // available on the element constructor.
+             if (this.constructor._styleSheet) {
+               n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];
+             }
+           }
++          n.shadowRoot.appendChild(dom);
+           if (syncInitialRender && window.ShadyDOM) {
+             window.ShadyDOM.flushInitial(n.shadowRoot);
+           }
+@@ -783,8 +783,9 @@ export const ElementMixin = dedupingMixin(base => {
+      * @suppress {invalidCasts}
+      */
+     updateStyles(properties) {
+-      if (window.ShadyCSS) {
+-        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);
++      // Chromium modification to use native API instead of relying on ShadyCSS.
++      for (const [name, value] of Object.entries(properties)) {
++        this.style.setProperty(name, value);
+       }
+     }
+ 
+diff --git a/components-chromium/polymer/lib/mixins/template-stamp.js b/components-chromium/polymer/lib/mixins/template-stamp.js
+index 19938efe0b622..0537e0b3b9884 100644
+--- a/components-chromium/polymer/lib/mixins/template-stamp.js
++++ b/components-chromium/polymer/lib/mixins/template-stamp.js
+@@ -299,9 +299,7 @@ export const TemplateStamp = dedupingMixin(
+         let /** ? */ templateInfo = template._templateInfo = {};
+         templateInfo.nodeInfoList = [];
+         templateInfo.nestedTemplate = Boolean(outerTemplateInfo);
+-        templateInfo.stripWhiteSpace =
+-          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||
+-          (template.hasAttribute && template.hasAttribute('strip-whitespace'));
++        templateInfo.stripWhiteSpace = true
+          // TODO(rictic): fix typing
+          this._parseTemplateContent(
+              template, templateInfo, /** @type {?} */ ({parent: null}));
+diff --git a/components-chromium/polymer/lib/utils/settings.js b/components-chromium/polymer/lib/utils/settings.js
+index ee70d3c14b0c2..265940bf4c6c8 100644
+--- a/components-chromium/polymer/lib/utils/settings.js
++++ b/components-chromium/polymer/lib/utils/settings.js
+@@ -173,8 +173,8 @@ export const setLegacyOptimizations = function(useLegacyOptimizations) {
+ /**
+  * Setting to add warnings useful when migrating from Polymer 1.x to 2.x.
+  */
+-export let legacyWarnings =
+-  window.Polymer && window.Polymer.legacyWarnings || false;
++// Turn off option for Chromium.
++export const legacyWarnings = false;
+ 
+ /**
+  * Sets `legacyWarnings` globally for all elements to migration warnings.
+@@ -190,8 +190,8 @@ export const setLegacyWarnings = function(useLegacyWarnings) {
+  * Setting to perform initial rendering synchronously when running under ShadyDOM.
+  * This matches the behavior of Polymer 1.
+  */
+-export let syncInitialRender =
+-  window.Polymer && window.Polymer.syncInitialRender || false;
++// Turn off option for Chromium.
++export const syncInitialRender = false;
+ 
+ /**
+  * Sets `syncInitialRender` globally for all elements to enable synchronous
+@@ -210,8 +210,8 @@ export const setSyncInitialRender = function(useSyncInitialRender) {
+  * observers around undefined values. Observers and computed property methods
+  * are not called until no argument is undefined.
+  */
+-export let legacyUndefined =
+-  window.Polymer && window.Polymer.legacyUndefined || false;
++// Turn off option for Chromium.
++export const legacyUndefined = false;
+ 
+ /**
+  * Sets `legacyUndefined` globally for all elements to enable legacy
+@@ -267,8 +267,8 @@ export const setCancelSyntheticClickEvents = function(useCancelSyntheticClickEve
+  * eliminates most of the tax of needing two elements due to the loss of
+  * type-extended templates as a result of the V1 specification changes.
+  */
+-export let removeNestedTemplates =
+-  window.Polymer && window.Polymer.removeNestedTemplates || false;
++// Turn off option for Chromium.
++export const removeNestedTemplates = false;
+ 
+ /**
+  * Sets `removeNestedTemplates` globally, to eliminate nested templates
+@@ -290,7 +290,8 @@ export const setRemoveNestedTemplates = function(useRemoveNestedTemplates) {
+  * such as `modelForElement` will not be available for nodes stamped by
+  * `dom-if`.
+  */
+-export let fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;
++// Turn off option for Chromium.
++export const fastDomIf = false;
+ 
+ /**
+  * Sets `fastDomIf` globally, to put `dom-if` in a performance-optimized mode.
+@@ -308,8 +309,8 @@ export const setFastDomIf = function(useFastDomIf) {
+  * setting the `notify-dom-change` attribute (`notifyDomChange: true` property)
+  * to `dom-if`/`don-repeat` instances.
+  */
+-export let suppressTemplateNotifications =
+-  window.Polymer && window.Polymer.suppressTemplateNotifications || false;
++// Turn off option for Chromium.
++export const suppressTemplateNotifications = false;
+ 
+ /**
+  * Sets `suppressTemplateNotifications` globally, to disable `dom-change` and
+@@ -327,8 +328,8 @@ export const setSuppressTemplateNotifications = function(suppress) {
+  * to avoid setting `observedAttributes`. Instead attributes are read
+  * once at create time and set/removeAttribute are patched.
+  */
+-export let legacyNoObservedAttributes =
+-  window.Polymer && window.Polymer.legacyNoObservedAttributes || false;
++// Turn off option for Chromium.
++export const legacyNoObservedAttributes = false;
+ 
+ /**
+  * Sets `legacyNoObservedAttributes` globally, to disable `observedAttributes`.
+@@ -345,8 +346,8 @@ export const setLegacyNoObservedAttributes = function(noObservedAttributes) {
+  * between component instances' shadow roots, if the app uses built Shady CSS
+  * styles.
+  */
+-export let useAdoptedStyleSheetsWithBuiltCSS =
+-  window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;
++// Turn off option for Chromium.
++export const useAdoptedStyleSheetsWithBuiltCSS = false;
+ 
+ /**
+  * Sets `useAdoptedStyleSheetsWithBuiltCSS` globally.
diff --git a/third_party/private_membership/patches/0001-Chromium-fixes-for-PSM-client-library.patch b/third_party/private_membership/patches/0001-Chromium-fixes-for-PSM-client-library.patch
new file mode 100644
index 0000000000000..fa505d38bda7f
--- /dev/null
+++ b/third_party/private_membership/patches/0001-Chromium-fixes-for-PSM-client-library.patch
@@ -0,0 +1,1200 @@
+diff --git a/third_party/private_membership/src/internal/BUILD b/third_party/private_membership/src/internal/BUILD
+deleted file mode 100644
+index b6e49dade5d6e..0000000000000
+--- a/third_party/private_membership/src/internal/BUILD
++++ /dev/null
+@@ -1,281 +0,0 @@
+-package(default_visibility = ["//:__subpackages__"])
+-
+-cc_library(
+-    name = "aes_ctr_256_with_fixed_iv",
+-    srcs = [
+-        "aes_ctr_256_with_fixed_iv.cc",
+-    ],
+-    hdrs = [
+-        "aes_ctr_256_with_fixed_iv.h",
+-    ],
+-    deps = [
+-        "@boringssl//:ssl",
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-        "@com_google_absl//absl/strings",
+-    ],
+-)
+-
+-cc_test(
+-    name = "aes_ctr_256_with_fixed_iv_test",
+-    srcs = [
+-        "aes_ctr_256_with_fixed_iv_test.cc",
+-    ],
+-    deps = [
+-        ":aes_ctr_256_with_fixed_iv",
+-        "@boringssl//:ssl",
+-        "@com_github_google_googletest//:gtest_main",
+-        "@com_github_google_shell//shell_encryption/testing:status_is_fork",
+-        "@com_github_google_shell//shell_encryption/testing:status_testing",
+-        "@com_google_absl//absl/memory",
+-    ],
+-)
+-
+-cc_library(
+-    name = "crypto_utils",
+-    srcs = [
+-        "crypto_utils.cc",
+-    ],
+-    hdrs = [
+-        "crypto_utils.h",
+-    ],
+-    deps = [
+-        ":aes_ctr_256_with_fixed_iv",
+-        ":id_utils",
+-        "//private_membership/rlwe/client/proto:private_membership_cc_proto",
+-        "@com_github_google_private_join_and_compute//private_join_and_compute/crypto:bn_util",
+-        "@com_github_google_private_join_and_compute//private_join_and_compute/crypto:ec_commutative_cipher",
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-        "@com_google_absl//absl/strings",
+-    ],
+-)
+-
+-cc_test(
+-    name = "crypto_utils_test",
+-    srcs = ["crypto_utils_test.cc"],
+-    deps = [
+-        ":aes_ctr_256_with_fixed_iv",
+-        ":crypto_utils",
+-        "//private_membership/rlwe/client/proto:private_membership_cc_proto",
+-        "@com_github_google_googletest//:gtest_main",
+-        "@com_github_google_shell//shell_encryption/testing:status_is_fork",
+-        "@com_github_google_shell//shell_encryption/testing:status_testing",
+-    ],
+-)
+-
+-cc_library(
+-    name = "id_utils",
+-    srcs = [
+-        "id_utils.cc",
+-    ],
+-    hdrs = [
+-        "id_utils.h",
+-    ],
+-    deps = [
+-        "@com_google_absl//absl/strings",
+-    ],
+-)
+-
+-cc_test(
+-    name = "id_utils_test",
+-    srcs = [
+-        "id_utils_test.cc",
+-    ],
+-    deps = [
+-        ":id_utils",
+-        "@com_github_google_googletest//:gtest_main",
+-    ],
+-)
+-
+-cc_library(
+-    name = "oprf_utils",
+-    srcs = [
+-        "oprf_utils.cc",
+-    ],
+-    hdrs = [
+-        "oprf_utils.h",
+-    ],
+-    deps = [
+-        "//private_membership/rlwe/client/proto:private_membership_cc_proto",
+-        "@com_github_google_private_join_and_compute//private_join_and_compute/crypto:ec_commutative_cipher",
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-    ],
+-)
+-
+-cc_test(
+-    name = "oprf_utils_test",
+-    srcs = [
+-        "oprf_utils_test.cc",
+-    ],
+-    deps = [
+-        ":oprf_utils",
+-        "@com_github_google_googletest//:gtest_main",
+-        "@com_github_google_private_join_and_compute//private_join_and_compute/crypto:ec_commutative_cipher",
+-        "@com_github_google_shell//shell_encryption/testing:status_is_fork",
+-        "@com_github_google_shell//shell_encryption/testing:status_testing",
+-    ],
+-)
+-
+-cc_library(
+-    name = "constants",
+-    hdrs = [
+-        "constants.h",
+-    ],
+-    deps = [
+-        "@boringssl//:ssl",
+-        "@com_github_google_shell//shell_encryption:montgomery",
+-        "@com_github_google_shell//shell_encryption/prng:chacha_prng",
+-        "@com_github_google_shell//shell_encryption/prng:single_thread_chacha_prng",
+-    ],
+-)
+-
+-cc_library(
+-    name = "encrypted_bucket_id",
+-    srcs = [
+-        "encrypted_bucket_id.cc",
+-    ],
+-    hdrs = [
+-        "encrypted_bucket_id.h",
+-    ],
+-    deps = [
+-        ":rlwe_id_utils",
+-        ":utils",
+-        "//private_membership/rlwe/client/cpp/internal:crypto_utils",
+-        "//private_membership/rlwe/client/proto:private_membership_rlwe_cc_proto",
+-        "@com_github_google_private_join_and_compute//private_join_and_compute/crypto:ec_commutative_cipher",
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-        "@com_google_absl//absl/hash",
+-        "@com_google_absl//absl/strings",
+-    ],
+-)
+-
+-cc_test(
+-    name = "encrypted_bucket_id_test",
+-    srcs = [
+-        "encrypted_bucket_id_test.cc",
+-    ],
+-    deps = [
+-        ":encrypted_bucket_id",
+-        ":rlwe_id_utils",
+-        "//private_membership/rlwe/client/cpp/internal/testing:constants",
+-        "//private_membership/rlwe/client/proto:private_membership_rlwe_cc_proto",
+-        "@com_github_google_googletest//:gtest_main",
+-        "@com_github_google_shell//shell_encryption/testing:status_is_fork",
+-        "@com_github_google_shell//shell_encryption/testing:status_testing",
+-    ],
+-)
+-
+-cc_library(
+-    name = "hashed_bucket_id",
+-    srcs = [
+-        "hashed_bucket_id.cc",
+-    ],
+-    hdrs = [
+-        "hashed_bucket_id.h",
+-    ],
+-    deps = [
+-        ":rlwe_id_utils",
+-        ":utils",
+-        "//private_membership/rlwe/client/proto:private_membership_cc_proto",
+-        "//private_membership/rlwe/client/proto:private_membership_rlwe_cc_proto",
+-        "@com_github_google_private_join_and_compute//private_join_and_compute/crypto:ec_commutative_cipher",
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-        "@com_google_absl//absl/hash",
+-        "@com_google_absl//absl/strings",
+-    ],
+-)
+-
+-cc_test(
+-    name = "hashed_bucket_id_test",
+-    srcs = [
+-        "hashed_bucket_id_test.cc",
+-    ],
+-    deps = [
+-        ":hashed_bucket_id",
+-        "//private_membership/rlwe/client/proto:private_membership_cc_proto",
+-        "//private_membership/rlwe/client/proto:private_membership_rlwe_cc_proto",
+-        "@com_github_google_googletest//:gtest_main",
+-        "@com_github_google_shell//shell_encryption/testing:status_is_fork",
+-        "@com_github_google_shell//shell_encryption/testing:status_testing",
+-    ],
+-)
+-
+-cc_library(
+-    name = "rlwe_id_utils",
+-    srcs = [
+-        "rlwe_id_utils.cc",
+-    ],
+-    hdrs = [
+-        "rlwe_id_utils.h",
+-    ],
+-    deps = [
+-        ":constants",
+-        "//private_membership/rlwe/client/cpp/internal:crypto_utils",
+-        "//private_membership/rlwe/client/proto:private_membership_cc_proto",
+-        "//private_membership/rlwe/client/proto:private_membership_rlwe_cc_proto",
+-        "@com_github_google_private_join_and_compute//private_join_and_compute/crypto:ec_commutative_cipher",
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-        "@com_google_absl//absl/status",
+-        "@com_google_absl//absl/strings",
+-    ],
+-)
+-
+-cc_test(
+-    name = "rlwe_id_utils_test",
+-    srcs = ["rlwe_id_utils_test.cc"],
+-    deps = [
+-        ":constants",
+-        ":rlwe_id_utils",
+-        "//private_membership/rlwe/client/cpp/internal/testing:constants",
+-        "//private_membership/rlwe/client/proto:private_membership_cc_proto",
+-        "@com_github_google_googletest//:gtest_main",
+-        "@com_github_google_shell//shell_encryption/testing:status_is_fork",
+-        "@com_github_google_shell//shell_encryption/testing:status_testing",
+-        "@com_google_absl//absl/status",
+-    ],
+-)
+-
+-cc_library(
+-    name = "rlwe_params",
+-    srcs = [
+-        "rlwe_params.cc",
+-    ],
+-    hdrs = [
+-        "rlwe_params.h",
+-    ],
+-    deps = [
+-        ":constants",
+-        "//private_membership/rlwe/client/proto:private_membership_rlwe_cc_proto",
+-        "@com_github_google_shell//shell_encryption:context",
+-        "@com_github_google_shell//shell_encryption:error_params",
+-        "@com_github_google_shell//shell_encryption:montgomery",
+-        "@com_github_google_shell//shell_encryption:ntt_parameters",
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-    ],
+-)
+-
+-cc_library(
+-    name = "utils",
+-    srcs = [
+-        "utils.cc",
+-    ],
+-    hdrs = [
+-        "utils.h",
+-    ],
+-    deps = [
+-        "@com_github_google_shell//shell_encryption:statusor_fork",
+-        "@com_google_absl//absl/strings",
+-    ],
+-)
+-
+-cc_test(
+-    name = "utils_test",
+-    srcs = [
+-        "utils_test.cc",
+-    ],
+-    deps = [
+-        ":utils",
+-        "@com_github_google_googletest//:gtest_main",
+-        "@com_github_google_shell//shell_encryption/testing:status_is_fork",
+-        "@com_github_google_shell//shell_encryption/testing:status_testing",
+-    ],
+-)
+diff --git a/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.cc b/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.cc
+index 20ff7fa4c24ea..ebd721107c30f 100644
+--- a/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.cc
++++ b/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.cc
+@@ -12,7 +12,7 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/aes_ctr_256_with_fixed_iv.h"
++#include "third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h"
+ 
+ #include <memory>
+ #include <string>
+diff --git a/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h b/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h
+index 536bb09cc86c1..a108f06844269 100644
+--- a/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h
++++ b/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h
+@@ -12,16 +12,16 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_AES_CTR_256_WITH_FIXED_IV_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_AES_CTR_256_WITH_FIXED_IV_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_AES_CTR_256_WITH_FIXED_IV_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_AES_CTR_256_WITH_FIXED_IV_H_
+ 
+ #include <memory>
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
++#include "third_party/private_membership/base/private_membership_export.h"
+ #include "absl/strings/string_view.h"
+ #include <openssl/evp.h>
+-#include "shell_encryption/statusor.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ 
+@@ -64,4 +64,4 @@ class PRIVATE_MEMBERSHIP_EXPORT AesCtr256WithFixedIV {
+ 
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_AES_CTR_256_WITH_FIXED_IV_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_AES_CTR_256_WITH_FIXED_IV_H_
+diff --git a/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv_test.cc b/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv_test.cc
+index f954ba2323f1d..44911f8e1376b 100644
+--- a/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv_test.cc
++++ b/third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv_test.cc
+@@ -12,7 +12,7 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/aes_ctr_256_with_fixed_iv.h"
++#include "third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h"
+ 
+ #include <memory>
+ #include <string>
+@@ -21,8 +21,8 @@
+ #include <gtest/gtest.h>
+ #include "absl/memory/memory.h"
+ #include <openssl/rand.h>
+-#include "shell_encryption/testing/status_matchers.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/status_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ namespace private_membership {
+ namespace {
+diff --git a/third_party/private_membership/src/internal/constants.h b/third_party/private_membership/src/internal/constants.h
+index a445d553ec924..d5cfcf9216cc2 100644
+--- a/third_party/private_membership/src/internal/constants.h
++++ b/third_party/private_membership/src/internal/constants.h
+@@ -12,15 +12,15 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_CONSTANTS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_CONSTANTS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_CONSTANTS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_CONSTANTS_H_
+ 
+ #include <cstdint>
+ 
+ #include <openssl/obj_mac.h>
+-#include "shell_encryption/montgomery.h"
+-#include "shell_encryption/prng/chacha_prng.h"
+-#include "shell_encryption/prng/single_thread_chacha_prng.h"
++#include "third_party/shell-encryption/src/montgomery.h"
++#include "third_party/shell-encryption/src/prng/chacha_prng.h"
++#include "third_party/shell-encryption/src/prng/single_thread_chacha_prng.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+@@ -46,4 +46,4 @@ typedef ::rlwe::MontgomeryInt<absl::uint128> ModularInt128;
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_CONSTANTS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_CONSTANTS_H_
+diff --git a/third_party/private_membership/src/internal/crypto_utils.cc b/third_party/private_membership/src/internal/crypto_utils.cc
+index 8132e66a2b048..48590d7070890 100644
+--- a/third_party/private_membership/src/internal/crypto_utils.cc
++++ b/third_party/private_membership/src/internal/crypto_utils.cc
+@@ -12,13 +12,13 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/crypto_utils.h"
++#include "third_party/private_membership/src/internal/crypto_utils.h"
+ 
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/cpp/internal/aes_ctr_256_with_fixed_iv.h"
+-#include "private_membership/rlwe/client/cpp/internal/id_utils.h"
+-#include "shell_encryption/status_macros.h"
++#include "third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h"
++#include "third_party/private_membership/src/internal/id_utils.h"
++#include "third_party/shell-encryption/src/status_macros.h"
+ 
+ namespace private_membership {
+ namespace {
+diff --git a/third_party/private_membership/src/internal/crypto_utils.h b/third_party/private_membership/src/internal/crypto_utils.h
+index 1d65ae3929649..772d38ba0571d 100644
+--- a/third_party/private_membership/src/internal/crypto_utils.h
++++ b/third_party/private_membership/src/internal/crypto_utils.h
+@@ -12,17 +12,17 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_CRYPTO_UTILS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_CRYPTO_UTILS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_CRYPTO_UTILS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_CRYPTO_UTILS_H_
+ 
+ #include <string>
+ 
+-#include "private_join_and_compute/crypto/context.h"
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
++#include "third_party/private-join-and-compute/src/crypto/context.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/base/private_membership_export.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/statusor.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ 
+@@ -67,4 +67,4 @@ PRIVATE_MEMBERSHIP_EXPORT ::rlwe::StatusOr<std::string> DecryptValueWithKey(
+ 
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_CRYPTO_UTILS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_CRYPTO_UTILS_H_
+diff --git a/third_party/private_membership/src/internal/crypto_utils_test.cc b/third_party/private_membership/src/internal/crypto_utils_test.cc
+index f43c9ef8b6116..a6b78c9455569 100644
+--- a/third_party/private_membership/src/internal/crypto_utils_test.cc
++++ b/third_party/private_membership/src/internal/crypto_utils_test.cc
+@@ -12,16 +12,16 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/crypto_utils.h"
++#include "third_party/private_membership/src/internal/crypto_utils.h"
+ 
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/cpp/internal/aes_ctr_256_with_fixed_iv.h"
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
++#include "third_party/private_membership/src/internal/aes_ctr_256_with_fixed_iv.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+-#include "shell_encryption/testing/status_matchers.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/status_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ namespace private_membership {
+ namespace {
+diff --git a/third_party/private_membership/src/internal/encrypted_bucket_id.cc b/third_party/private_membership/src/internal/encrypted_bucket_id.cc
+index 3f840f7295951..e48fa7dafca5a 100644
+--- a/third_party/private_membership/src/internal/encrypted_bucket_id.cc
++++ b/third_party/private_membership/src/internal/encrypted_bucket_id.cc
+@@ -12,16 +12,16 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/encrypted_bucket_id.h"
++#include "third_party/private_membership/src/internal/encrypted_bucket_id.h"
+ 
+ #include <string>
+ #include <utility>
+ 
+-#include "private_membership/rlwe/client/cpp/internal/crypto_utils.h"
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_id_utils.h"
+-#include "private_membership/rlwe/client/cpp/internal/utils.h"
++#include "third_party/private_membership/src/internal/crypto_utils.h"
++#include "third_party/private_membership/src/internal/rlwe_id_utils.h"
++#include "third_party/private_membership/src/internal/utils.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/status_macros.h"
++#include "third_party/shell-encryption/src/status_macros.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/encrypted_bucket_id.h b/third_party/private_membership/src/internal/encrypted_bucket_id.h
+index 5502b99c0d4dc..6543210e3d347 100644
+--- a/third_party/private_membership/src/internal/encrypted_bucket_id.h
++++ b/third_party/private_membership/src/internal/encrypted_bucket_id.h
+@@ -12,17 +12,17 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_ENCRYPTED_BUCKET_ID_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_ENCRYPTED_BUCKET_ID_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_ENCRYPTED_BUCKET_ID_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_ENCRYPTED_BUCKET_ID_H_
+ 
+ #include <string>
+ 
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
++#include "third_party/private_membership/base/private_membership_export.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
+ #include "absl/hash/hash.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/statusor.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+@@ -92,4 +92,4 @@ class PRIVATE_MEMBERSHIP_EXPORT EncryptedBucketId {
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_ENCRYPTED_BUCKET_ID_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_ENCRYPTED_BUCKET_ID_H_
+diff --git a/third_party/private_membership/src/internal/encrypted_bucket_id_test.cc b/third_party/private_membership/src/internal/encrypted_bucket_id_test.cc
+index 525657774f35b..1972c0509494e 100644
+--- a/third_party/private_membership/src/internal/encrypted_bucket_id_test.cc
++++ b/third_party/private_membership/src/internal/encrypted_bucket_id_test.cc
+@@ -12,19 +12,19 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/encrypted_bucket_id.h"
++#include "third_party/private_membership/src/internal/encrypted_bucket_id.h"
+ 
+ #include <cstdint>
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_id_utils.h"
+-#include "private_membership/rlwe/client/cpp/internal/testing/constants.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
++#include "third_party/private_membership/src/internal/rlwe_id_utils.h"
++#include "third_party/private_membership/src/internal/testing/constants.h"
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+-#include "shell_encryption/testing/protobuf_matchers.h"
+-#include "shell_encryption/testing/status_matchers.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/protobuf_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/hashed_bucket_id.cc b/third_party/private_membership/src/internal/hashed_bucket_id.cc
+index 1e584d6618565..66a65674fb7ed 100644
+--- a/third_party/private_membership/src/internal/hashed_bucket_id.cc
++++ b/third_party/private_membership/src/internal/hashed_bucket_id.cc
+@@ -12,16 +12,16 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/hashed_bucket_id.h"
++#include "third_party/private_membership/src/internal/hashed_bucket_id.h"
+ 
+ #include <string>
+ #include <utility>
+ 
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_id_utils.h"
+-#include "private_membership/rlwe/client/cpp/internal/utils.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/src/internal/rlwe_id_utils.h"
++#include "third_party/private_membership/src/internal/utils.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/status_macros.h"
++#include "third_party/shell-encryption/src/status_macros.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/hashed_bucket_id.h b/third_party/private_membership/src/internal/hashed_bucket_id.h
+index 75b70f98eac83..db1805c7a0676 100644
+--- a/third_party/private_membership/src/internal/hashed_bucket_id.h
++++ b/third_party/private_membership/src/internal/hashed_bucket_id.h
+@@ -12,16 +12,16 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_HASHED_BUCKET_ID_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_HASHED_BUCKET_ID_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_HASHED_BUCKET_ID_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_HASHED_BUCKET_ID_H_
+ 
+ #include <string>
+ 
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
+ #include "absl/hash/hash.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/statusor.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+@@ -97,4 +97,4 @@ class HashedBucketId {
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_HASHED_BUCKET_ID_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_HASHED_BUCKET_ID_H_
+diff --git a/third_party/private_membership/src/internal/hashed_bucket_id_test.cc b/third_party/private_membership/src/internal/hashed_bucket_id_test.cc
+index 41e36f79d5823..be8c24112db59 100644
+--- a/third_party/private_membership/src/internal/hashed_bucket_id_test.cc
++++ b/third_party/private_membership/src/internal/hashed_bucket_id_test.cc
+@@ -12,17 +12,17 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/hashed_bucket_id.h"
++#include "third_party/private_membership/src/internal/hashed_bucket_id.h"
+ 
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+-#include "shell_encryption/testing/protobuf_matchers.h"
+-#include "shell_encryption/testing/status_matchers.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/protobuf_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/id_utils.cc b/third_party/private_membership/src/internal/id_utils.cc
+index 472e7197fe0fd..a01bf2a98ef98 100644
+--- a/third_party/private_membership/src/internal/id_utils.cc
++++ b/third_party/private_membership/src/internal/id_utils.cc
+@@ -12,7 +12,7 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/id_utils.h"
++#include "third_party/private_membership/src/internal/id_utils.h"
+ 
+ #include <string>
+ 
+diff --git a/third_party/private_membership/src/internal/id_utils.h b/third_party/private_membership/src/internal/id_utils.h
+index 40a9dad54f247..2f4110f826ffd 100644
+--- a/third_party/private_membership/src/internal/id_utils.h
++++ b/third_party/private_membership/src/internal/id_utils.h
+@@ -12,12 +12,12 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_ID_UTILS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_ID_UTILS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_ID_UTILS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_ID_UTILS_H_
+ 
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
++#include "third_party/private_membership/base/private_membership_export.h"
+ #include "absl/strings/string_view.h"
+ 
+ namespace private_membership {
+@@ -29,4 +29,4 @@ PRIVATE_MEMBERSHIP_EXPORT std::string PadOrTruncate(absl::string_view in,
+ 
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_ID_UTILS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_ID_UTILS_H_
+diff --git a/third_party/private_membership/src/internal/id_utils_test.cc b/third_party/private_membership/src/internal/id_utils_test.cc
+index c61fc1ed7edd3..dbace147c370e 100644
+--- a/third_party/private_membership/src/internal/id_utils_test.cc
++++ b/third_party/private_membership/src/internal/id_utils_test.cc
+@@ -12,7 +12,7 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/id_utils.h"
++#include "third_party/private_membership/src/internal/id_utils.h"
+ 
+ #include <string>
+ 
+diff --git a/third_party/private_membership/src/internal/oprf_utils.cc b/third_party/private_membership/src/internal/oprf_utils.cc
+index a377c878ded45..008510c34e7ea 100644
+--- a/third_party/private_membership/src/internal/oprf_utils.cc
++++ b/third_party/private_membership/src/internal/oprf_utils.cc
+@@ -12,12 +12,12 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/oprf_utils.h"
++#include "third_party/private_membership/src/internal/oprf_utils.h"
+ 
+ #include <string>
+ #include <utility>
+ 
+-#include "shell_encryption/status_macros.h"
++#include "third_party/shell-encryption/src/status_macros.h"
+ 
+ namespace private_membership {
+ 
+diff --git a/third_party/private_membership/src/internal/oprf_utils.h b/third_party/private_membership/src/internal/oprf_utils.h
+index 98c3c3c36b2b3..9998acade6b25 100644
+--- a/third_party/private_membership/src/internal/oprf_utils.h
++++ b/third_party/private_membership/src/internal/oprf_utils.h
+@@ -12,13 +12,13 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_OPRF_UTILS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_OPRF_UTILS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_OPRF_UTILS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_OPRF_UTILS_H_
+ 
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
+-#include "shell_encryption/statusor.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/base/private_membership_export.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ 
+@@ -33,4 +33,4 @@ PRIVATE_MEMBERSHIP_EXPORT ::rlwe::StatusOr<DoublyEncryptedId> ReEncryptId(
+ 
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_OPRF_UTILS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_OPRF_UTILS_H_
+diff --git a/third_party/private_membership/src/internal/oprf_utils_test.cc b/third_party/private_membership/src/internal/oprf_utils_test.cc
+index a1c0cd7d6aeb5..695444d8e96d1 100644
+--- a/third_party/private_membership/src/internal/oprf_utils_test.cc
++++ b/third_party/private_membership/src/internal/oprf_utils_test.cc
+@@ -12,13 +12,13 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/oprf_utils.h"
++#include "third_party/private_membership/src/internal/oprf_utils.h"
+ 
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+-#include "shell_encryption/testing/status_matchers.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/status_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ namespace private_membership {
+ namespace {
+diff --git a/third_party/private_membership/src/internal/rlwe_id_utils.cc b/third_party/private_membership/src/internal/rlwe_id_utils.cc
+index 2c59cab0f83c6..551e637972dc3 100644
+--- a/third_party/private_membership/src/internal/rlwe_id_utils.cc
++++ b/third_party/private_membership/src/internal/rlwe_id_utils.cc
+@@ -12,18 +12,18 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_id_utils.h"
++#include "third_party/private_membership/src/internal/rlwe_id_utils.h"
+ 
+ #include <string>
+ #include <utility>
+ 
+-#include "private_membership/rlwe/client/cpp/internal/crypto_utils.h"
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/cpp/internal/constants.h"
++#include "third_party/private_membership/src/internal/crypto_utils.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/src/internal/constants.h"
+ #include "absl/status/status.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/status_macros.h"
++#include "third_party/shell-encryption/src/status_macros.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/rlwe_id_utils.h b/third_party/private_membership/src/internal/rlwe_id_utils.h
+index 6e519e72b4ead..6edf07555d1f8 100644
+--- a/third_party/private_membership/src/internal/rlwe_id_utils.h
++++ b/third_party/private_membership/src/internal/rlwe_id_utils.h
+@@ -12,16 +12,16 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_RLWE_ID_UTILS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_RLWE_ID_UTILS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_RLWE_ID_UTILS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_RLWE_ID_UTILS_H_
+ 
+ #include <string>
+ 
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
+-#include "shell_encryption/statusor.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/base/private_membership_export.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+@@ -61,4 +61,4 @@ HashNonsensitiveIdWithSalt(absl::string_view nsid, HashType hash_type,
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_RLWE_ID_UTILS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_RLWE_ID_UTILS_H_
+diff --git a/third_party/private_membership/src/internal/rlwe_id_utils_test.cc b/third_party/private_membership/src/internal/rlwe_id_utils_test.cc
+index 029ca5d77172b..c73def66869a5 100644
+--- a/third_party/private_membership/src/internal/rlwe_id_utils_test.cc
++++ b/third_party/private_membership/src/internal/rlwe_id_utils_test.cc
+@@ -12,19 +12,19 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_id_utils.h"
++#include "third_party/private_membership/src/internal/rlwe_id_utils.h"
+ 
+ #include <string>
+ #include <vector>
+ 
+-#include "private_membership/rlwe/client/cpp/internal/constants.h"
+-#include "private_membership/rlwe/client/cpp/internal/testing/constants.h"
++#include "third_party/private_membership/src/internal/constants.h"
++#include "third_party/private_membership/src/internal/testing/constants.h"
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+ #include "absl/status/status.h"
+-#include "shell_encryption/testing/protobuf_matchers.h"
+-#include "shell_encryption/testing/status_matchers.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/protobuf_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/rlwe_params.cc b/third_party/private_membership/src/internal/rlwe_params.cc
+index 11a36986357c3..c8904d1984a7e 100644
+--- a/third_party/private_membership/src/internal/rlwe_params.cc
++++ b/third_party/private_membership/src/internal/rlwe_params.cc
+@@ -12,16 +12,16 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_params.h"
++#include "third_party/private_membership/src/internal/rlwe_params.h"
+ 
+ #include <memory>
+ #include <utility>
+ #include <vector>
+ 
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
+-#include "private_membership/rlwe/client/cpp/internal/constants.h"
+-#include "shell_encryption/montgomery.h"
+-#include "shell_encryption/status_macros.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
++#include "third_party/private_membership/src/internal/constants.h"
++#include "third_party/shell-encryption/src/montgomery.h"
++#include "third_party/shell-encryption/src/status_macros.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/rlwe_params.h b/third_party/private_membership/src/internal/rlwe_params.h
+index c769b9b5d4ef7..84e4bafbf8b63 100644
+--- a/third_party/private_membership/src/internal/rlwe_params.h
++++ b/third_party/private_membership/src/internal/rlwe_params.h
+@@ -12,15 +12,15 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_RLWE_PARAMS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_RLWE_PARAMS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_RLWE_PARAMS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_RLWE_PARAMS_H_
+ 
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
+-#include "shell_encryption/context.h"
+-#include "shell_encryption/error_params.h"
+-#include "shell_encryption/montgomery.h"
+-#include "shell_encryption/ntt_parameters.h"
+-#include "shell_encryption/statusor.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
++#include "third_party/shell-encryption/src/context.h"
++#include "third_party/shell-encryption/src/error_params.h"
++#include "third_party/shell-encryption/src/montgomery.h"
++#include "third_party/shell-encryption/src/ntt_parameters.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+@@ -48,4 +48,4 @@ CreateErrorParams(const RlweParameters& rlwe_params,
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_RLWE_PARAMS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_RLWE_PARAMS_H_
+diff --git a/third_party/private_membership/src/internal/testing/BUILD b/third_party/private_membership/src/internal/testing/BUILD
+deleted file mode 100644
+index 5b1d0ad6689be..0000000000000
+--- a/third_party/private_membership/src/internal/testing/BUILD
++++ /dev/null
+@@ -1,11 +0,0 @@
+-package(default_visibility = ["//:__subpackages__"])
+-
+-cc_library(
+-    name = "constants",
+-    hdrs = [
+-        "constants.h",
+-    ],
+-    deps = [
+-        "@boringssl//:ssl",
+-    ],
+-)
+diff --git a/third_party/private_membership/src/internal/testing/constants.h b/third_party/private_membership/src/internal/testing/constants.h
+index a98cb67d4d011..8e679f36020ce 100644
+--- a/third_party/private_membership/src/internal/testing/constants.h
++++ b/third_party/private_membership/src/internal/testing/constants.h
+@@ -1,5 +1,5 @@
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_TESTING_CONSTANTS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_TESTING_CONSTANTS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_TESTING_CONSTANTS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_TESTING_CONSTANTS_H_
+ 
+ #include <openssl/obj_mac.h>
+ 
+@@ -12,4 +12,4 @@ constexpr int kTestCurveId = NID_X9_62_prime256v1;
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_TESTING_CONSTANTS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_TESTING_CONSTANTS_H_
+diff --git a/third_party/private_membership/src/internal/testing/regression_test_data/BUILD b/third_party/private_membership/src/internal/testing/regression_test_data/BUILD
+deleted file mode 100644
+index df3be365735da..0000000000000
+--- a/third_party/private_membership/src/internal/testing/regression_test_data/BUILD
++++ /dev/null
+@@ -1,25 +0,0 @@
+-load("@rules_cc//cc:defs.bzl", "cc_library")
+-load("@rules_proto//proto:defs.bzl", "proto_library")
+-
+-package(default_visibility = ["//:__subpackages__"])
+-
+-proto_library(
+-    name = "regression_test_data_proto",
+-    srcs = ["regression_test_data.proto"],
+-    deps = [
+-        "//private_membership/rlwe/client/proto:private_membership_rlwe_proto",
+-    ],
+-)
+-
+-cc_proto_library(
+-    name = "regression_test_data_cc_proto",
+-    deps = [":regression_test_data_proto"],
+-)
+-
+-filegroup(
+-    name = "regression_test_data",
+-    testonly = 1,
+-    srcs = [
+-        "test_data.binarypb",
+-    ],
+-)
+diff --git a/third_party/private_membership/src/internal/testing/regression_test_data/regression_test_data.proto b/third_party/private_membership/src/internal/testing/regression_test_data/regression_test_data.proto
+index f43c87a91a1f5..023e6e7abde96 100644
+--- a/third_party/private_membership/src/internal/testing/regression_test_data/regression_test_data.proto
++++ b/third_party/private_membership/src/internal/testing/regression_test_data/regression_test_data.proto
+@@ -4,7 +4,7 @@ option optimize_for = LITE_RUNTIME;
+ 
+ package private_membership.rlwe;
+ 
+-import "private_membership/rlwe/client/proto/private_membership_rlwe.proto";
++import "private_membership_rlwe.proto";
+ 
+ // The regression test data consists of multiple test cases.
+ message PrivateMembershipRlweClientRegressionTestData {
+diff --git a/third_party/private_membership/src/internal/utils.cc b/third_party/private_membership/src/internal/utils.cc
+index b7878380c969b..f2120f2fc6a5e 100644
+--- a/third_party/private_membership/src/internal/utils.cc
++++ b/third_party/private_membership/src/internal/utils.cc
+@@ -12,11 +12,11 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/utils.h"
++#include "third_party/private_membership/src/internal/utils.h"
+ 
+ #include <string>
+ 
+-#include "shell_encryption/status_macros.h"
++#include "third_party/shell-encryption/src/status_macros.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/internal/utils.h b/third_party/private_membership/src/internal/utils.h
+index 3c41b8a9a9eb4..e4f426e83fa52 100644
+--- a/third_party/private_membership/src/internal/utils.h
++++ b/third_party/private_membership/src/internal/utils.h
+@@ -12,14 +12,14 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_UTILS_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_UTILS_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_UTILS_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_UTILS_H_
+ 
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
++#include "third_party/private_membership/base/private_membership_export.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/statusor.h"
++#include "third_party/shell-encryption/src/statusor.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+@@ -62,4 +62,4 @@ PRIVATE_MEMBERSHIP_EXPORT bool IsValid(absl::string_view in, int bit_length);
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_INTERNAL_UTILS_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_INTERNAL_UTILS_H_
+diff --git a/third_party/private_membership/src/internal/utils_test.cc b/third_party/private_membership/src/internal/utils_test.cc
+index 9e7473cf1f623..c4c3812e9c25c 100644
+--- a/third_party/private_membership/src/internal/utils_test.cc
++++ b/third_party/private_membership/src/internal/utils_test.cc
+@@ -12,12 +12,12 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/internal/utils.h"
++#include "third_party/private_membership/src/internal/utils.h"
+ 
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+-#include "shell_encryption/testing/status_matchers.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/status_matchers.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ using ::rlwe::testing::StatusIs;
+ using ::testing::HasSubstr;
+diff --git a/third_party/private_membership/src/private_membership_rlwe.proto b/third_party/private_membership/src/private_membership_rlwe.proto
+index 165096c32cd82..402dad1b5ba1f 100644
+--- a/third_party/private_membership/src/private_membership_rlwe.proto
++++ b/third_party/private_membership/src/private_membership_rlwe.proto
+@@ -20,8 +20,8 @@ package private_membership.rlwe;
+ 
+ option go_package = "github.com/google/private-membership";
+ 
+-import "private_membership/rlwe/client/proto/private_membership.proto";
+-import "shell_encryption/serialization.proto";
++import "private_membership.proto";
++import "serialization.proto";
+ 
+ // Request and Response protos
+ //
+diff --git a/third_party/private_membership/src/private_membership_rlwe_client.cc b/third_party/private_membership/src/private_membership_rlwe_client.cc
+index ca04abc7fb070..39bc87ad8d02a 100644
+--- a/third_party/private_membership/src/private_membership_rlwe_client.cc
++++ b/third_party/private_membership/src/private_membership_rlwe_client.cc
+@@ -12,7 +12,7 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#include "private_membership/rlwe/client/cpp/private_membership_rlwe_client.h"
++#include "third_party/private_membership/src/private_membership_rlwe_client.h"
+ 
+ #include <algorithm>
+ #include <iterator>
+@@ -22,24 +22,24 @@
+ #include <utility>
+ #include <vector>
+ 
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
+-#include "private_membership/rlwe/client/cpp/internal/crypto_utils.h"
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
+-#include "private_membership/rlwe/client/cpp/internal/constants.h"
+-#include "private_membership/rlwe/client/cpp/internal/encrypted_bucket_id.h"
+-#include "private_membership/rlwe/client/cpp/internal/hashed_bucket_id.h"
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_id_utils.h"
+-#include "private_membership/rlwe/client/cpp/internal/rlwe_params.h"
+-#include "private_membership/rlwe/client/cpp/internal/utils.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
++#include "third_party/private_membership/src/internal/crypto_utils.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
++#include "third_party/private_membership/src/internal/constants.h"
++#include "third_party/private_membership/src/internal/encrypted_bucket_id.h"
++#include "third_party/private_membership/src/internal/hashed_bucket_id.h"
++#include "third_party/private_membership/src/internal/rlwe_id_utils.h"
++#include "third_party/private_membership/src/internal/rlwe_params.h"
++#include "third_party/private_membership/src/internal/utils.h"
+ #include "absl/container/flat_hash_map.h"
+ #include "absl/container/flat_hash_set.h"
+ #include "absl/status/statusor.h"
+ #include "absl/strings/string_view.h"
+-#include "shell_encryption/polynomial.h"
+-#include "shell_encryption/status_macros.h"
+-#include "shell_encryption/symmetric_encryption_with_prng.h"
+-#include "shell_encryption/transcription.h"
++#include "third_party/shell-encryption/src/polynomial.h"
++#include "third_party/shell-encryption/src/status_macros.h"
++#include "third_party/shell-encryption/src/symmetric_encryption_with_prng.h"
++#include "third_party/shell-encryption/src/transcription.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+diff --git a/third_party/private_membership/src/private_membership_rlwe_client.h b/third_party/private_membership/src/private_membership_rlwe_client.h
+index a47ae95a4b273..d04b8086911c7 100644
+--- a/third_party/private_membership/src/private_membership_rlwe_client.h
++++ b/third_party/private_membership/src/private_membership_rlwe_client.h
+@@ -12,24 +12,24 @@
+ // See the License for the specific language governing permissions and
+ // limitations under the License.
+ 
+-#ifndef PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_PRIVATE_MEMBERSHIP_RLWE_CLIENT_H_
+-#define PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_PRIVATE_MEMBERSHIP_RLWE_CLIENT_H_
++#ifndef THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_PRIVATE_MEMBERSHIP_RLWE_CLIENT_H_
++#define THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_PRIVATE_MEMBERSHIP_RLWE_CLIENT_H_
+ 
+ #include <memory>
+ #include <optional>
+ #include <string>
+ #include <vector>
+ 
+-#include "private_join_and_compute/crypto/ec_commutative_cipher.h"
+-#include "private_membership/rlwe/client/proto/private_membership.pb.h"
+-#include "private_membership/rlwe/client/cpp/open_source/chromium/private_membership_export.h"
+-#include "private_membership/rlwe/client/proto/private_membership_rlwe.pb.h"
+-#include "private_membership/rlwe/client/cpp/internal/constants.h"
++#include "third_party/private-join-and-compute/src/crypto/ec_commutative_cipher.h"
++#include "third_party/private_membership/src/private_membership.pb.h"
++#include "third_party/private_membership/base/private_membership_export.h"
++#include "third_party/private_membership/src/private_membership_rlwe.pb.h"
++#include "third_party/private_membership/src/internal/constants.h"
+ #include "absl/container/flat_hash_map.h"
+-#include "shell_encryption/montgomery.h"
+-#include "shell_encryption/prng/prng.h"
+-#include "shell_encryption/statusor.h"
+-#include "shell_encryption/symmetric_encryption.h"
++#include "third_party/shell-encryption/src/montgomery.h"
++#include "third_party/shell-encryption/src/prng/prng.h"
++#include "third_party/shell-encryption/src/statusor.h"
++#include "third_party/shell-encryption/src/symmetric_encryption.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
+@@ -300,4 +300,4 @@ class PRIVATE_MEMBERSHIP_EXPORT PrivateMembershipRlweClient {
+ }  // namespace rlwe
+ }  // namespace private_membership
+ 
+-#endif  // PRIVATE_MEMBERSHIP_RLWE_CLIENT_CPP_PRIVATE_MEMBERSHIP_RLWE_CLIENT_H_
++#endif  // THIRD_PARTY_PRIVATE_MEMBERSHIP_SRC_PRIVATE_MEMBERSHIP_RLWE_CLIENT_H_
+diff --git a/third_party/private_membership/src/private_membership_rlwe_client_regression_test.cc b/third_party/private_membership/src/private_membership_rlwe_client_regression_test.cc
+index 6ced941a41f3a..a102c471539fa 100644
+--- a/third_party/private_membership/src/private_membership_rlwe_client_regression_test.cc
++++ b/third_party/private_membership/src/private_membership_rlwe_client_regression_test.cc
+@@ -2,12 +2,12 @@
+ #include <sstream>
+ #include <string>
+ 
+-#include "private_membership/rlwe/client/cpp/private_membership_rlwe_client.h"
+-#include "private_membership/rlwe/client/cpp/internal/testing/regression_test_data/regression_test_data.pb.h"
++#include "third_party/private_membership/src/private_membership_rlwe_client.h"
++#include "third_party/private_membership/src/internal/testing/regression_test_data/regression_test_data.pb.h"
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+ #include "absl/status/status.h"
+-#include "shell_encryption/testing/status_testing.h"
++#include "third_party/shell-encryption/src/testing/status_testing.h"
+ 
+ namespace private_membership {
+ namespace rlwe {
diff --git a/third_party/protobuf/patches/0004-fix-shared-library-exports.patch b/third_party/protobuf/patches/0004-fix-shared-library-exports.patch
new file mode 100644
index 0000000000000..d8e31d9a2f527
--- /dev/null
+++ b/third_party/protobuf/patches/0004-fix-shared-library-exports.patch
@@ -0,0 +1,45 @@
+--- a/src/google/protobuf/stubs/port.h
++++ b/src/google/protobuf/stubs/port.h
+@@ -90,18 +90,31 @@
+ 
+ // Legacy: some users reference these (internal-only) macros even though we
+ // don't need them any more.
+-#if defined(_MSC_VER) && defined(PROTOBUF_USE_DLLS)
+-  #ifdef LIBPROTOBUF_EXPORTS
+-    #define LIBPROTOBUF_EXPORT __declspec(dllexport)
+-  #else
+-    #define LIBPROTOBUF_EXPORT __declspec(dllimport)
++#if defined(COMPONENT_BUILD) && defined(PROTOBUF_USE_DLLS)
++  #if defined(_MSC_VER)
++    #ifdef LIBPROTOBUF_EXPORTS
++      #define LIBPROTOBUF_EXPORT __declspec(dllexport)
++    #else
++      #define LIBPROTOBUF_EXPORT __declspec(dllimport)
++    #endif
++    #ifdef LIBPROTOC_EXPORTS
++      #define LIBPROTOC_EXPORT   __declspec(dllexport)
++    #else
++      #define LIBPROTOC_EXPORT   __declspec(dllimport)
++    #endif
++  #else  // defined(_MSC_VER)
++    #ifdef LIBPROTOBUF_EXPORTS
++      #define LIBPROTOBUF_EXPORT __attribute__((visibility("default")))
++    #else
++      #define LIBPROTOBUF_EXPORT
++    #endif
++    #ifdef LIBPROTOC_EXPORTS
++      #define LIBPROTOC_EXPORT   __attribute__((visibility("default")))
++    #else
++      #define LIBPROTOC_EXPORT
++    #endif
+   #endif
+-  #ifdef LIBPROTOC_EXPORTS
+-    #define LIBPROTOC_EXPORT   __declspec(dllexport)
+-  #else
+-    #define LIBPROTOC_EXPORT   __declspec(dllimport)
+-  #endif
+-#else
++#else  // defined(COMPONENT_BUILD) && defined(PROTOBUF_USE_DLLS)
+   #define LIBPROTOBUF_EXPORT
+   #define LIBPROTOC_EXPORT
+ #endif
diff --git a/third_party/protobuf/patches/0008-uninline_get_empty_string.patch b/third_party/protobuf/patches/0008-uninline_get_empty_string.patch
new file mode 100644
index 0000000000000..b3a9de75147ea
--- /dev/null
+++ b/third_party/protobuf/patches/0008-uninline_get_empty_string.patch
@@ -0,0 +1,32 @@
+diff --git a/src/google/protobuf/generated_message_util.cc b/src/google/protobuf/generated_message_util.cc
+index 887f97cc28639..bdfc5518d8d50 100644
+--- a/src/google/protobuf/generated_message_util.cc
++++ b/src/google/protobuf/generated_message_util.cc
+@@ -99,6 +99,11 @@ void InitProtobufDefaultsSlow() {
+ PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 static std::true_type init_empty_string =
+     (InitProtobufDefaults(), std::true_type{});
+ 
++const std::string& GetEmptyString() {
++  InitProtobufDefaults();
++  return GetEmptyStringAlreadyInited();
++}
++
+ size_t StringSpaceUsedExcludingSelfLong(const std::string& str) {
+   const void* start = &str;
+   const void* end = &str + 1;
+diff --git a/src/google/protobuf/generated_message_util.h b/src/google/protobuf/generated_message_util.h
+index 99bb53ef7c5cb..74a0ef6b5b0b5 100644
+--- a/src/google/protobuf/generated_message_util.h
++++ b/src/google/protobuf/generated_message_util.h
+@@ -79,10 +79,7 @@ PROTOBUF_EXPORT inline void InitProtobufDefaults() {
+ }
+ 
+ // This used by proto1
+-PROTOBUF_EXPORT inline const std::string& GetEmptyString() {
+-  InitProtobufDefaults();
+-  return GetEmptyStringAlreadyInited();
+-}
++PROTOBUF_EXPORT const ::std::string& GetEmptyString();
+ 
+ // Default empty Cord object. Don't use directly. Instead, call
+ // GetEmptyCordAlreadyInited() to get the reference.
diff --git a/third_party/protobuf/patches/0010-uninline-generated-code.patch b/third_party/protobuf/patches/0010-uninline-generated-code.patch
new file mode 100644
index 0000000000000..e144b4b0ba589
--- /dev/null
+++ b/third_party/protobuf/patches/0010-uninline-generated-code.patch
@@ -0,0 +1,13 @@
+diff --git a/src/google/protobuf/compiler/cpp/message.cc b/src/google/protobuf/compiler/cpp/message.cc
+index 0c9632cd0899d..77ac10ff35d0b 100644
+--- a/src/google/protobuf/compiler/cpp/message.cc
++++ b/src/google/protobuf/compiler/cpp/message.cc
+@@ -2122,7 +2122,7 @@ void MessageGenerator::GenerateClassDefinition(io::Printer* p) {
+           static constexpr int kIndexInFileMessages = $index_in_file_messages$;
+           $decl_any_methods$;
+           friend void swap($classname$& a, $classname$& b) { a.Swap(&b); }
+-          inline void Swap($classname$* other) {
++          PROTOBUF_NOINLINE void Swap($classname$* other) {
+             if (other == this) return;
+             if ($pbi$::CanUseInternalSwap(GetArena(), other->GetArena())) {
+               InternalSwap(other);
diff --git a/third_party/protobuf/patches/0022-Allow-deprecated-fields.patch b/third_party/protobuf/patches/0022-Allow-deprecated-fields.patch
new file mode 100644
index 0000000000000..16fc9df674475
--- /dev/null
+++ b/third_party/protobuf/patches/0022-Allow-deprecated-fields.patch
@@ -0,0 +1,41 @@
+diff --git a/src/google/protobuf/compiler/cpp/enum.cc b/src/google/protobuf/compiler/cpp/enum.cc
+index ba56b4bb5af42..61d8cfe0b20e3 100644
+--- a/src/google/protobuf/compiler/cpp/enum.cc
++++ b/src/google/protobuf/compiler/cpp/enum.cc
+@@ -131,7 +131,7 @@ void EnumGenerator::GenerateDefinition(io::Printer* p) {
+                            .AnnotatedAs(value),
+                        {"kNumber", Int32ToString(value->number())},
+                        {"DEPRECATED",
+-                        value->options().deprecated() ? "[[deprecated]]" : ""},
++                        /*value->options().deprecated() ? "[[deprecated]]" : */""},
+                    },
+                    R"cc(
+                      $Msg_Enum_VALUE$$ DEPRECATED$ = $kNumber$,
+@@ -287,7 +287,7 @@ void EnumGenerator::GenerateSymbolImports(io::Printer* p) const {
+         {
+             Sub("VALUE", EnumValueName(enum_->value(j))).AnnotatedAs(value),
+             {"DEPRECATED",
+-             value->options().deprecated() ? "[[deprecated]]" : ""},
++             /*value->options().deprecated() ? "[[deprecated]]" : */""},
+         },
+         R"cc(
+           $DEPRECATED $static constexpr $Enum_$ $VALUE$ = $Msg_Enum$_$VALUE$;
+diff --git a/src/google/protobuf/compiler/cpp/helpers.h b/src/google/protobuf/compiler/cpp/helpers.h
+index dbcc9245068b9..761c0adcb9a26 100644
+--- a/src/google/protobuf/compiler/cpp/helpers.h
++++ b/src/google/protobuf/compiler/cpp/helpers.h
+@@ -54,12 +54,12 @@ inline absl::string_view ProtobufNamespace(const Options& opts) {
+ 
+ inline std::string DeprecatedAttribute(const Options&,
+                                        const FieldDescriptor* d) {
+-  return d->options().deprecated() ? "[[deprecated]] " : "";
++  return /*d->options().deprecated() ? "[[deprecated]] " : */"";
+ }
+ 
+ inline std::string DeprecatedAttribute(const Options&,
+                                        const EnumValueDescriptor* d) {
+-  return d->options().deprecated() ? "[[deprecated]] " : "";
++  return /*d->options().deprecated() ? "[[deprecated]] " : */"";
+ }
+ 
+ // Commonly-used separator comments.  Thick is a line of '=', thin is a line
diff --git a/third_party/protobuf/patches/0029-make-initializers-optimizable.patch b/third_party/protobuf/patches/0029-make-initializers-optimizable.patch
new file mode 100644
index 0000000000000..b03b6e9f8662b
--- /dev/null
+++ b/third_party/protobuf/patches/0029-make-initializers-optimizable.patch
@@ -0,0 +1,76 @@
+diff --git a/src/google/protobuf/generated_message_util.cc b/src/google/protobuf/generated_message_util.cc
+index 09b7db5d66226..887f97cc28639 100644
+--- a/src/google/protobuf/generated_message_util.cc
++++ b/src/google/protobuf/generated_message_util.cc
+@@ -87,26 +87,17 @@ static void InitWeakDefaults() {
+ void InitWeakDefaults() {}
+ #endif
+ 
+-PROTOBUF_CONSTINIT std::atomic<bool> init_protobuf_defaults_state{false};
+-static bool InitProtobufDefaultsImpl() {
++PROTOBUF_CONSTINIT bool init_protobuf_defaults_state{false};
++void InitProtobufDefaultsSlow() {
+   fixed_address_empty_string.DefaultConstruct();
+-  OnShutdownDestroyString(fixed_address_empty_string.get_mutable());
++  init_protobuf_defaults_state = true;
+   InitWeakDefaults();
+-
+-
+-  init_protobuf_defaults_state.store(true, std::memory_order_release);
+-  return true;
+-}
+-
+-void InitProtobufDefaultsSlow() {
+-  static bool is_inited = InitProtobufDefaultsImpl();
+-  (void)is_inited;
+ }
+ // Force the initialization of the empty string.
+ // Normally, registration would do it, but we don't have any guarantee that
+ // there is any object with reflection.
+ PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 static std::true_type init_empty_string =
+-    (InitProtobufDefaultsSlow(), std::true_type{});
++    (InitProtobufDefaults(), std::true_type{});
+ 
+ size_t StringSpaceUsedExcludingSelfLong(const std::string& str) {
+   const void* start = &str;
+diff --git a/src/google/protobuf/generated_message_util.h b/src/google/protobuf/generated_message_util.h
+index ab676e406be78..99bb53ef7c5cb 100644
+--- a/src/google/protobuf/generated_message_util.h
++++ b/src/google/protobuf/generated_message_util.h
+@@ -66,11 +66,14 @@ namespace internal {
+ // This fastpath inlines a single branch instead of having to make the
+ // InitProtobufDefaults function call.
+ // It also generates less inlined code than a function-scope static initializer.
+-PROTOBUF_EXPORT extern std::atomic<bool> init_protobuf_defaults_state;
++PROTOBUF_EXPORT extern bool init_protobuf_defaults_state;
+ PROTOBUF_EXPORT void InitProtobufDefaultsSlow();
+ PROTOBUF_EXPORT inline void InitProtobufDefaults() {
+-  if (PROTOBUF_PREDICT_FALSE(
+-          !init_protobuf_defaults_state.load(std::memory_order_acquire))) {
++  // This is not thread-safe, but is called within a static initializer. As long
++  // as there are no calls to this function from off the main thread, before
++  // main() starts, this is safe. After main() starts,
++  // init_protobuf_defaults_state will always be true.
++  if (PROTOBUF_PREDICT_FALSE(!init_protobuf_defaults_state)) {
+     InitProtobufDefaultsSlow();
+   }
+ }
+diff --git a/src/google/protobuf/port_def.inc b/src/google/protobuf/port_def.inc
+index 8200a61ba8ad9..33ff5fd1d3219 100644
+--- a/src/google/protobuf/port_def.inc
++++ b/src/google/protobuf/port_def.inc
+@@ -657,14 +657,6 @@ static_assert(PROTOBUF_ABSL_MIN(20230125, 3),
+ #define PROTOBUF_FINAL final
+ #endif
+ 
+-// Determines the platforms where descriptor weak messages can be used.
+-#ifdef PROTOBUF_DESCRIPTOR_WEAK_MESSAGES_ALLOWED
+-#error PROTOBUF_DESCRIPTOR_WEAK_MESSAGES_ALLOWED was previously defined
+-#endif
+-#if defined(__GNUC__) && defined(__clang__) && !defined(__APPLE__) && \
+-    !defined(_MSC_VER)
+-#define PROTOBUF_DESCRIPTOR_WEAK_MESSAGES_ALLOWED
+-#endif
+ 
+ 
+ // TODO: Enable the feature by default and remove this flag.
diff --git a/third_party/protobuf/patches/0030-workaround-windows-constinit.patch b/third_party/protobuf/patches/0030-workaround-windows-constinit.patch
new file mode 100644
index 0000000000000..d0c406db1d7d7
--- /dev/null
+++ b/third_party/protobuf/patches/0030-workaround-windows-constinit.patch
@@ -0,0 +1,141 @@
+diff --git a/src/google/protobuf/compiler/cpp/file.cc b/src/google/protobuf/compiler/cpp/file.cc
+index 460ff6c0244ec..8672b34a76967 100644
+--- a/src/google/protobuf/compiler/cpp/file.cc
++++ b/src/google/protobuf/compiler/cpp/file.cc
+@@ -588,7 +588,7 @@ void FileGenerator::GenerateSourceDefaultInstance(int idx, io::Printer* p) {
+             };
+           };
+ 
+-          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT$ dllexport_decl$
++          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR$ dllexport_decl$
+               PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const $type$ $name$;
+         )cc");
+   }
+@@ -616,7 +616,7 @@ void FileGenerator::GenerateSourceDefaultInstance(int idx, io::Printer* p) {
+             };
+           };
+ 
+-          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT$ dllexport_decl$
++          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR$ dllexport_decl$
+               PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 $type$ $name$;
+         )cc");
+   } else if (UsingImplicitWeakDescriptor(file_, options_)) {
+@@ -642,7 +642,7 @@ void FileGenerator::GenerateSourceDefaultInstance(int idx, io::Printer* p) {
+                 file_default_instances + $index$, sizeof($type$)};
+           };
+ 
+-          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT$ dllexport_decl$
++          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR$ dllexport_decl$
+               PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 $type$ $name$
+               __attribute__((section("$section$")));
+         )cc");
+@@ -662,7 +662,7 @@ void FileGenerator::GenerateSourceDefaultInstance(int idx, io::Printer* p) {
+             };
+           };
+ 
+-          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT$ dllexport_decl$
++          PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR$ dllexport_decl$
+               PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 $type$ $name$;
+         )cc");
+   }
+diff --git a/src/google/protobuf/compiler/cpp/message.cc b/src/google/protobuf/compiler/cpp/message.cc
+index bca954732d122..bd5b8cc3818ec 100644
+--- a/src/google/protobuf/compiler/cpp/message.cc
++++ b/src/google/protobuf/compiler/cpp/message.cc
+@@ -4052,7 +4052,7 @@ void MessageGenerator::GenerateClassData(io::Printer* p) {
+              }},
+         },
+         R"cc(
+-          PROTOBUF_CONSTINIT
++          PROTOBUF_CONSTINIT_WITH_PTR
+           PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
+           const $pbi$::ClassDataFull $classname$::_class_data_ = {
+               $pbi$::ClassData{
+diff --git a/src/google/protobuf/compiler/cpp/parse_function_generator.cc b/src/google/protobuf/compiler/cpp/parse_function_generator.cc
+index d0a1731ddf7d5..283e9cc3b2d5b 100644
+--- a/src/google/protobuf/compiler/cpp/parse_function_generator.cc
++++ b/src/google/protobuf/compiler/cpp/parse_function_generator.cc
+@@ -269,7 +269,7 @@ void ParseFunctionGenerator::GenerateTailCallTable(io::Printer* printer) {
+       // FileDescriptorProto is safe from this.
+       IsFileDescriptorProto(descriptor_->file(), options_)
+           ? "constexpr"
+-          : "PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1\nconst",
++          : "PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1\nconst",
+       tc_table_info_->table_size_log2, ordered_fields_.size(),
+       tc_table_info_->aux_entries.size(),
+       FieldNameDataSize(tc_table_info_->field_name_data),
+diff --git a/src/google/protobuf/extension_set.cc b/src/google/protobuf/extension_set.cc
+index bad7d59e2bcdd..94229c6491476 100644
+--- a/src/google/protobuf/extension_set.cc
++++ b/src/google/protobuf/extension_set.cc
+@@ -171,7 +171,8 @@ void ExtensionSet::RegisterMessageExtension(const MessageLite* extendee,
+   ExtensionInfo info(extendee, number, type, is_repeated, is_packed,
+                      verify_func, is_lazy);
+   info.message_info = {prototype,
+-#if defined(PROTOBUF_CONSTINIT_DEFAULT_INSTANCES)
++#if defined(PROTOBUF_CONSTINIT_DEFAULT_INSTANCES) && \
++    !defined(PROTOBUF_DEFAULT_INSTANCES_MAY_NOT_BE_CONSTINIT)
+                        prototype->GetTcParseTable()
+ #else
+                        nullptr
+diff --git a/src/google/protobuf/map_field.h b/src/google/protobuf/map_field.h
+index 0e37a16d7bc53..656a99fdc04e1 100644
+--- a/src/google/protobuf/map_field.h
++++ b/src/google/protobuf/map_field.h
+@@ -680,7 +680,7 @@ class MapField final : public TypeDefinedMapFieldBase<Key, T> {
+ template <typename Derived, typename Key, typename T,
+           WireFormatLite::FieldType kKeyFieldType_,
+           WireFormatLite::FieldType kValueFieldType_>
+-PROTOBUF_CONSTINIT const MapFieldBase::VTable
++PROTOBUF_CONSTINIT_WITH_PTR const MapFieldBase::VTable
+     MapField<Derived, Key, T, kKeyFieldType_, kValueFieldType_>::kVTable =
+         MapField::template MakeVTable<MapField>();
+ 
+diff --git a/src/google/protobuf/port_def.inc b/src/google/protobuf/port_def.inc
+index 075e10e925efa..999032346b18a 100644
+--- a/src/google/protobuf/port_def.inc
++++ b/src/google/protobuf/port_def.inc
+@@ -326,19 +326,31 @@ static_assert(PROTOBUF_ABSL_MIN(20230125, 3),
+ #  define PROTOBUF_EXPORT __declspec(dllexport)
+ #  define PROTOBUF_EXPORT_TEMPLATE_DECLARE
+ #  define PROTOBUF_EXPORT_TEMPLATE_DEFINE __declspec(dllexport)
++#  define PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_CONSTINIT
++// See PROTOBUF_CONSTINIT_WITH_PTR below. This define is used by code inside the
++// protobuf library that needs to know whether it can assume a default instance,
++// which may be initialized inside the same binary or in another library, is
++// constinit.
++#  define PROTOBUF_DEFAULT_INSTANCES_MAY_NOT_BE_CONSTINIT
+ # else
+ #  define PROTOBUF_EXPORT __declspec(dllimport)
+ #  define PROTOBUF_EXPORT_TEMPLATE_DECLARE
+ #  define PROTOBUF_EXPORT_TEMPLATE_DEFINE __declspec(dllimport)
++// Pointers to dllimport extern variables on Windows require a static
++// initialization and cannot be constant-initialized. This macro disables
++// constinit in files where we cannot support it.
++#  define PROTOBUF_CONSTINIT_WITH_PTR
+ # endif  // defined(LIBPROTOBUF_EXPORTS)
+ #elif defined(PROTOBUF_USE_DLLS) && defined(LIBPROTOBUF_EXPORTS)
+ # define PROTOBUF_EXPORT __attribute__((visibility("default")))
+ # define PROTOBUF_EXPORT_TEMPLATE_DECLARE __attribute__((visibility("default")))
+ # define PROTOBUF_EXPORT_TEMPLATE_DEFINE
++# define PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_CONSTINIT
+ #else
+ # define PROTOBUF_EXPORT
+ # define PROTOBUF_EXPORT_TEMPLATE_DECLARE
+ # define PROTOBUF_EXPORT_TEMPLATE_DEFINE
++# define PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_CONSTINIT
+ #endif
+ 
+ #ifdef PROTOC_EXPORT
+diff --git a/src/google/protobuf/port_undef.inc b/src/google/protobuf/port_undef.inc
+index 784b102d4c633..fa6de4dccd008 100644
+--- a/src/google/protobuf/port_undef.inc
++++ b/src/google/protobuf/port_undef.inc
+@@ -47,6 +47,7 @@
+ #undef PROTOBUF_ALIGNAS
+ #undef PROTOBUF_THREAD_LOCAL
+ #undef PROTOBUF_CONSTINIT
++#undef PROTOBUF_CONSTINIT_WITH_PTR
+ #undef PROTOBUF_CONSTEXPR
+ #undef PROTOBUF_CONSTINIT_DEFAULT_INSTANCES
+ #undef PROTOBUF_ATTRIBUTE_WEAK
diff --git a/third_party/protobuf/patches/0031-workaround-cfi-unrelated-cast.patch b/third_party/protobuf/patches/0031-workaround-cfi-unrelated-cast.patch
new file mode 100644
index 0000000000000..8d9aaa474616b
--- /dev/null
+++ b/third_party/protobuf/patches/0031-workaround-cfi-unrelated-cast.patch
@@ -0,0 +1,48 @@
+diff --git a/src/google/protobuf/descriptor.cc b/src/google/protobuf/descriptor.cc
+index 0524fd46226e6..082e5124a023f 100644
+--- a/src/google/protobuf/descriptor.cc
++++ b/src/google/protobuf/descriptor.cc
+@@ -301,22 +301,16 @@ class FlatAllocation {
+     return ends_.template Get<U>();
+   }
+ 
+-  // Avoid the reinterpret_cast if the array is empty.
+-  // Clang's Control Flow Integrity does not like the cast pointing to memory
+-  // that is not yet initialized to be of that type.
+-  // (from -fsanitize=cfi-unrelated-cast)
+   template <typename U>
++  PROTOBUF_NO_SANITIZE("cfi-unrelated-cast", "vptr")
+   U* Begin() const {
+-    int begin = BeginOffset<U>(), end = EndOffset<U>();
+-    if (begin == end) return nullptr;
+-    return reinterpret_cast<U*>(data() + begin);
++    return reinterpret_cast<U*>(data() + BeginOffset<U>());
+   }
+ 
+   template <typename U>
++  PROTOBUF_NO_SANITIZE("cfi-unrelated-cast", "vptr")
+   U* End() const {
+-    int begin = BeginOffset<U>(), end = EndOffset<U>();
+-    if (begin == end) return nullptr;
+-    return reinterpret_cast<U*>(data() + end);
++    return reinterpret_cast<U*>(data() + EndOffset<U>());
+   }
+ 
+   template <typename U>
+diff --git a/src/google/protobuf/port_def.inc b/src/google/protobuf/port_def.inc
+index cae9ebe01ec2c..b84b55e4d8762 100644
+--- a/src/google/protobuf/port_def.inc
++++ b/src/google/protobuf/port_def.inc
+@@ -764,6 +764,12 @@
+ #define PROTOBUF_UNUSED
+ #endif
+ 
++#if __has_attribute(no_sanitize)
++#define PROTOBUF_NO_SANITIZE(...) __attribute__((no_sanitize(__VA_ARGS__)))
++#else
++#define PROTOBUF_NO_SANITIZE(...)
++#endif
++
+ // ThreadSafeArenaz is turned off completely in opensource builds.
+ 
+ // Windows declares several inconvenient macro names.  We #undef them and then
diff --git a/third_party/protobuf/patches/0039-generate-mediapipe-anylite.patch b/third_party/protobuf/patches/0039-generate-mediapipe-anylite.patch
new file mode 100644
index 0000000000000..5699273942336
--- /dev/null
+++ b/third_party/protobuf/patches/0039-generate-mediapipe-anylite.patch
@@ -0,0 +1,93 @@
+diff --git a/src/google/protobuf/compiler/cpp/helpers.cc b/src/google/protobuf/compiler/cpp/helpers.cc
+index e6a89222c432f..f515316381b81 100644
+--- a/src/google/protobuf/compiler/cpp/helpers.cc
++++ b/src/google/protobuf/compiler/cpp/helpers.cc
+@@ -73,6 +73,14 @@ namespace {
+ constexpr absl::string_view kAnyMessageName = "Any";
+ constexpr absl::string_view kAnyProtoFile = "google/protobuf/any.proto";
+ 
++// TODO(crbug.com/332939935): This is used to allow generating an AnyLite proto
++// compatible with /third_party/medialite instead of checking in compiled
++// protobufs that complicate rolling.
++// Upstream should be fixed so that we don't need to generate a separate
++// AnyLite, then this patch/change should be dropped.
++constexpr absl::string_view kAnyLiteMessageName = "AnyLite";
++constexpr absl::string_view kAnyLiteProtoFile = "google/protobuf/any_lite.proto";
++
+ static const char* const kKeywordList[] = {
+     // clang-format off
+     "NULL",
+@@ -1217,11 +1225,13 @@ bool IsStringOrMessage(const FieldDescriptor* field) {
+ }
+ 
+ bool IsAnyMessage(const FileDescriptor* descriptor) {
+-  return descriptor->name() == kAnyProtoFile;
++  return descriptor->name() == kAnyProtoFile ||
++         descriptor->name() == kAnyLiteProtoFile;
+ }
+ 
+ bool IsAnyMessage(const Descriptor* descriptor) {
+-  return descriptor->name() == kAnyMessageName &&
++  return (descriptor->name() == kAnyMessageName ||
++          descriptor->name() == kAnyLiteMessageName) &&
+          IsAnyMessage(descriptor->file());
+ }
+ 
+diff --git a/src/google/protobuf/compiler/cpp/message.cc b/src/google/protobuf/compiler/cpp/message.cc
+index 7bd9e9f7d0668..0c9632cd0899d 100644
+--- a/src/google/protobuf/compiler/cpp/message.cc
++++ b/src/google/protobuf/compiler/cpp/message.cc
+@@ -2303,28 +2303,32 @@ void MessageGenerator::GenerateClassMethods(io::Printer* p) {
+     return;
+   }
+   if (IsAnyMessage(descriptor_)) {
+-    p->Emit({{"any_field_descriptor",
+-              [&] {
+-                if (!HasDescriptorMethods(descriptor_->file(), options_)) {
+-                  return;
++    // TODO(crbug.com/332939935): Remove this workaround when the AnyLite patch
++    // can go away.
++    if (descriptor_->name() != "AnyLite") {
++      p->Emit({{"any_field_descriptor",
++                [&] {
++                  if (!HasDescriptorMethods(descriptor_->file(), options_)) {
++                    return;
++                  }
++                  p->Emit(
++                      R"cc(
++                        bool $classname$::GetAnyFieldDescriptors(
++                            const ::$proto_ns$::Message& message,
++                            const ::$proto_ns$::FieldDescriptor** type_url_field,
++                            const ::$proto_ns$::FieldDescriptor** value_field) {
++                          return ::_pbi::GetAnyFieldDescriptors(message, type_url_field, value_field);
++                        }
++                      )cc");
++                }}},
++              R"cc(
++                $any_field_descriptor$;
++                bool $classname$::ParseAnyTypeUrl(::absl::string_view type_url,
++                                                  std::string* full_type_name) {
++                  return ::_pbi::ParseAnyTypeUrl(type_url, full_type_name);
+                 }
+-                p->Emit(
+-                    R"cc(
+-                      bool $classname$::GetAnyFieldDescriptors(
+-                          const ::$proto_ns$::Message& message,
+-                          const ::$proto_ns$::FieldDescriptor** type_url_field,
+-                          const ::$proto_ns$::FieldDescriptor** value_field) {
+-                        return ::_pbi::GetAnyFieldDescriptors(message, type_url_field, value_field);
+-                      }
+-                    )cc");
+-              }}},
+-            R"cc(
+-              $any_field_descriptor$;
+-              bool $classname$::ParseAnyTypeUrl(::absl::string_view type_url,
+-                                                std::string* full_type_name) {
+-                return ::_pbi::ParseAnyTypeUrl(type_url, full_type_name);
+-              }
+-            )cc");
++              )cc");
++    }
+   }
+   p->Emit(
+       {{"has_bit",
diff --git a/third_party/protobuf/patches/0042-fix-undefined-protobuf-custom-vtable.patch b/third_party/protobuf/patches/0042-fix-undefined-protobuf-custom-vtable.patch
new file mode 100644
index 0000000000000..fd5a75a6220b6
--- /dev/null
+++ b/third_party/protobuf/patches/0042-fix-undefined-protobuf-custom-vtable.patch
@@ -0,0 +1,42 @@
+diff --git a/src/google/protobuf/dynamic_message.cc b/src/google/protobuf/dynamic_message.cc
+index b7a7482729a75..0fd0d1a40ddcb 100644
+--- a/src/google/protobuf/dynamic_message.cc
++++ b/src/google/protobuf/dynamic_message.cc
+@@ -274,7 +274,9 @@ struct DynamicMessageFactory::TypeInfo {
+           &DynamicMessage::MergeImpl,
+           internal::MessageCreator(),  // to be filled later
+           &DynamicMessage::DestroyImpl,
++#if defined(PROTOBUF_CUSTOM_VTABLE)
+           static_cast<void (MessageLite::*)()>(&DynamicMessage::ClearImpl),
++#endif  // PROTOBUF_CUSTOM_VTABLE
+           DynamicMessage::ByteSizeLongImpl,
+           DynamicMessage::_InternalSerializeImpl,
+           PROTOBUF_FIELD_OFFSET(DynamicMessage, cached_byte_size_),
+diff --git a/src/google/protobuf/implicit_weak_message.cc b/src/google/protobuf/implicit_weak_message.cc
+index d53daf64780e6..9d74777043389 100644
+--- a/src/google/protobuf/implicit_weak_message.cc
++++ b/src/google/protobuf/implicit_weak_message.cc
+@@ -73,7 +73,9 @@ constexpr ClassDataLite<1> ImplicitWeakMessage::class_data_ = {
+                                  sizeof(ImplicitWeakMessage),
+                                  alignof(ImplicitWeakMessage)),
+         &DestroyImpl,
++#if defined(PROTOBUF_CUSTOM_VTABLE)
+         GetClearImpl<ImplicitWeakMessage>(),
++#endif  // PROTOBUF_CUSTOM_VTABLE
+         &ByteSizeLongImpl,
+         &_InternalSerializeImpl,
+         PROTOBUF_FIELD_OFFSET(ImplicitWeakMessage, cached_size_),
+diff --git a/src/google/protobuf/message_lite.h b/src/google/protobuf/message_lite.h
+index be759007a11d3..99bb9fe038aa5 100644
+--- a/src/google/protobuf/message_lite.h
++++ b/src/google/protobuf/message_lite.h
+@@ -382,7 +382,9 @@ struct PROTOBUF_EXPORT ClassData {
+       void (*merge_to_from)(MessageLite& to, const MessageLite& from_msg),
+       internal::MessageCreator message_creator,
+       void (*destroy_message)(MessageLite& msg),  //
++#if defined(PROTOBUF_CUSTOM_VTABLE)
+       void (MessageLite::*clear)(),
++#endif  // PROTOBUF_CUSTOM_VTABLE
+       size_t (*byte_size_long)(const MessageLite&),
+       uint8_t* (*serialize)(const MessageLite& msg, uint8_t* ptr,
+                             io::EpsCopyOutputStream* stream),
diff --git a/third_party/protobuf/patches/0043-unreachable-code-return.patch b/third_party/protobuf/patches/0043-unreachable-code-return.patch
new file mode 100644
index 0000000000000..f71d3b20d8e4d
--- /dev/null
+++ b/third_party/protobuf/patches/0043-unreachable-code-return.patch
@@ -0,0 +1,13 @@
+diff --git a/src/google/protobuf/compiler/cpp/message.cc b/src/google/protobuf/compiler/cpp/message.cc
+index bd58a134cbe20..bd5b8cc3818ec 100644
+--- a/src/google/protobuf/compiler/cpp/message.cc
++++ b/src/google/protobuf/compiler/cpp/message.cc
+@@ -3943,7 +3943,7 @@ void MessageGenerator::GenerateClassData(io::Printer* p) {
+                 constexpr auto arena_bits = $pbi$::EncodePlacementArenaOffsets({
+                     $arena_offsets$,
+                 });
+-                if (arena_bits.has_value()) {
++                if constexpr (arena_bits.has_value()) {
+                   return $pbi$::MessageCreator::$copy_type$(
+                       sizeof($classname$), alignof($classname$), *arena_bits);
+                 } else {
diff --git a/third_party/protobuf/patches/0044-trim-protoc-main.patch b/third_party/protobuf/patches/0044-trim-protoc-main.patch
new file mode 100644
index 0000000000000..9ab22d3f53e96
--- /dev/null
+++ b/third_party/protobuf/patches/0044-trim-protoc-main.patch
@@ -0,0 +1,63 @@
+diff --git a/third_party/protobuf/src/google/protobuf/compiler/main.cc b/third_party/protobuf/src/google/protobuf/compiler/main.cc
+index babede8faa8c4..02085bb887478 100644
+--- a/third_party/protobuf/src/google/protobuf/compiler/main.cc
++++ b/third_party/protobuf/src/google/protobuf/compiler/main.cc
+@@ -8,15 +8,9 @@
+ #include "absl/log/initialize.h"
+ #include "google/protobuf/compiler/command_line_interface.h"
+ #include "google/protobuf/compiler/cpp/generator.h"
+-#include "google/protobuf/compiler/csharp/csharp_generator.h"
+ #include "google/protobuf/compiler/java/generator.h"
+-#include "google/protobuf/compiler/kotlin/generator.h"
+-#include "google/protobuf/compiler/objectivec/generator.h"
+-#include "google/protobuf/compiler/php/php_generator.h"
+ #include "google/protobuf/compiler/python/generator.h"
+ #include "google/protobuf/compiler/python/pyi_generator.h"
+-#include "google/protobuf/compiler/ruby/ruby_generator.h"
+-#include "google/protobuf/compiler/rust/generator.h"
+ 
+ #ifdef DISABLE_PROTOC_CONFIG
+ #include "google/protobuf/compiler/allowlists/allowlist.h"
+@@ -62,11 +56,6 @@ int ProtobufMain(int argc, char* argv[]) {
+   java_generator.set_opensource_runtime(true);
+ #endif
+ 
+-  // Proto2 Kotlin
+-  kotlin::KotlinGenerator kt_generator;
+-  cli.RegisterGenerator("--kotlin_out", "--kotlin_opt", &kt_generator,
+-                        "Generate Kotlin file.");
+-
+ 
+   // Proto2 Python
+   python::Generator py_generator;
+@@ -82,30 +71,6 @@ int ProtobufMain(int argc, char* argv[]) {
+   cli.RegisterGenerator("--pyi_out", &pyi_generator,
+                         "Generate python pyi stub.");
+ 
+-  // PHP
+-  php::Generator php_generator;
+-  cli.RegisterGenerator("--php_out", "--php_opt", &php_generator,
+-                        "Generate PHP source file.");
+-
+-  // Ruby
+-  ruby::Generator rb_generator;
+-  cli.RegisterGenerator("--ruby_out", "--ruby_opt", &rb_generator,
+-                        "Generate Ruby source file.");
+-
+-  // CSharp
+-  csharp::Generator csharp_generator;
+-  cli.RegisterGenerator("--csharp_out", "--csharp_opt", &csharp_generator,
+-                        "Generate C# source file.");
+-
+-  // Objective-C
+-  objectivec::ObjectiveCGenerator objc_generator;
+-  cli.RegisterGenerator("--objc_out", "--objc_opt", &objc_generator,
+-                        "Generate Objective-C header and source.");
+-
+-  // Rust
+-  rust::RustGenerator rust_generator;
+-  cli.RegisterGenerator("--rust_out", "--rust_opt", &rust_generator,
+-                        "Generate Rust sources.");
+ #ifdef DISABLE_PROTOC_CONFIG
+   auto cleanup = internal::DisableAllowlistInternalOnly();
+ #endif  // DISABLE_PROTOC_CONFIG
diff --git a/third_party/protobuf/patches/0045-string-resize.patch b/third_party/protobuf/patches/0045-string-resize.patch
new file mode 100644
index 0000000000000..562b256462e82
--- /dev/null
+++ b/third_party/protobuf/patches/0045-string-resize.patch
@@ -0,0 +1,119 @@
+diff --git a/src/google/protobuf/inlined_string_field.cc b/src/google/protobuf/inlined_string_field.cc
+index a17f922b6cba9..69ba4743987ba 100644
+--- a/src/google/protobuf/inlined_string_field.cc
++++ b/src/google/protobuf/inlined_string_field.cc
+@@ -15,7 +15,6 @@
+ 
+ #include "absl/base/optimization.h"
+ #include "absl/log/absl_check.h"
+-#include "absl/strings/internal/resize_uninitialized.h"
+ #include "absl/strings/string_view.h"
+ #include "google/protobuf/arena.h"
+ #include "google/protobuf/arena_align.h"
+diff --git a/src/google/protobuf/io/coded_stream.cc b/src/google/protobuf/io/coded_stream.cc
+index f8d7b71a156f9..104e4307e6de5 100644
+--- a/src/google/protobuf/io/coded_stream.cc
++++ b/src/google/protobuf/io/coded_stream.cc
+@@ -32,7 +32,6 @@
+ #include "absl/log/absl_check.h"
+ #include "absl/log/absl_log.h"
+ #include "absl/strings/cord.h"
+-#include "absl/strings/internal/resize_uninitialized.h"
+ #include "absl/strings/string_view.h"
+ #include "google/protobuf/arena.h"
+ #include "google/protobuf/io/zero_copy_stream.h"
+@@ -255,7 +254,7 @@ bool CodedInputStream::ReadString(std::string* buffer, int size) {
+   if (size < 0) return false;  // security: size is often user-supplied
+ 
+   if (BufferSize() >= size) {
+-    absl::strings_internal::STLStringResizeUninitialized(buffer, size);
++    buffer->resize(size);
+     std::pair<char*, bool> z = as_string_data(buffer);
+     if (z.second) {
+       // Oddly enough, memcpy() requires its first two args to be non-NULL even
+diff --git a/src/google/protobuf/io/zero_copy_stream_impl_lite.cc b/src/google/protobuf/io/zero_copy_stream_impl_lite.cc
+index 15baebe3fa15b..81e14cbc74502 100644
+--- a/src/google/protobuf/io/zero_copy_stream_impl_lite.cc
++++ b/src/google/protobuf/io/zero_copy_stream_impl_lite.cc
+@@ -19,7 +19,6 @@
+ #include "absl/base/casts.h"
+ #include "absl/log/absl_check.h"
+ #include "absl/strings/cord.h"
+-#include "absl/strings/internal/resize_uninitialized.h"
+ 
+ // Must be included last
+ #include "google/protobuf/port_def.inc"
+@@ -136,8 +135,7 @@ bool StringOutputStream::Next(void** data, int* size) {
+   // Avoid integer overflow in returned '*size'.
+   new_size = std::min(new_size, old_size + std::numeric_limits<int>::max());
+   // Increase the size, also make sure that it is at least kMinimumSize.
+-  absl::strings_internal::STLStringResizeUninitialized(
+-      target_,
++  target_->resize(
+       std::max(new_size,
+                kMinimumSize + 0));  // "+ 0" works around GCC4 weirdness.
+ 
+diff --git a/src/google/protobuf/message_lite.cc b/src/google/protobuf/message_lite.cc
+index 1a2c6bd88bdf0..9652028e07bdb 100644
+--- a/src/google/protobuf/message_lite.cc
++++ b/src/google/protobuf/message_lite.cc
+@@ -26,7 +26,6 @@
+ #include "absl/log/log.h"
+ #include "absl/strings/cord.h"
+ #include "absl/strings/cord_buffer.h"
+-#include "absl/strings/internal/resize_uninitialized.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/string_view.h"
+ #include "absl/types/optional.h"
+@@ -584,8 +583,7 @@ bool MessageLite::AppendPartialToString(std::string* output) const {
+     return false;
+   }
+ 
+-  absl::strings_internal::STLStringResizeUninitializedAmortized(
+-      output, old_size + byte_size);
++  output->resize(old_size + byte_size);
+   uint8_t* start =
+       reinterpret_cast<uint8_t*>(io::mutable_string_data(output) + old_size);
+   SerializeToArrayImpl(*this, start, byte_size);
+diff --git a/src/google/protobuf/parse_context.h b/src/google/protobuf/parse_context.h
+index 22ed8212dfa6d..1f6f72629720a 100644
+--- a/src/google/protobuf/parse_context.h
++++ b/src/google/protobuf/parse_context.h
+@@ -18,7 +18,6 @@
+ #include "absl/log/absl_check.h"
+ #include "absl/log/absl_log.h"
+ #include "absl/strings/cord.h"
+-#include "absl/strings/internal/resize_uninitialized.h"
+ #include "absl/strings/string_view.h"
+ #include "absl/types/optional.h"
+ #include "google/protobuf/arena.h"
+@@ -182,7 +181,7 @@ class PROTOBUF_EXPORT EpsCopyInputStream {
+       // However micro-benchmarks regress on string reading cases. So we copy
+       // the same logic from the old CodedInputStream ReadString. Note: as of
+       // Apr 2021, this is still a significant win over `assign()`.
+-      absl::strings_internal::STLStringResizeUninitialized(s, size);
++      s->resize(size);
+       char* z = &(*s)[0];
+       memcpy(z, ptr, size);
+       return ptr + size;
+diff --git a/src/google/protobuf/unknown_field_set.cc b/src/google/protobuf/unknown_field_set.cc
+index 2f33555a16847..05c0c93a47bb2 100644
+--- a/src/google/protobuf/unknown_field_set.cc
++++ b/src/google/protobuf/unknown_field_set.cc
+@@ -17,7 +17,6 @@
+ 
+ #include "absl/log/absl_check.h"
+ #include "absl/strings/cord.h"
+-#include "absl/strings/internal/resize_uninitialized.h"
+ #include "absl/strings/string_view.h"
+ #include "google/protobuf/extension_set.h"
+ #include "google/protobuf/generated_message_tctable_impl.h"
+@@ -213,7 +212,7 @@ bool UnknownFieldSet::ParseFromArray(const void* data, int size) {
+ bool UnknownFieldSet::SerializeToString(std::string* output) const {
+   const size_t size =
+       google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(*this);
+-  absl::strings_internal::STLStringResizeUninitializedAmortized(output, size);
++  output->resize(size);
+   google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+       *this, reinterpret_cast<uint8_t*>(const_cast<char*>(output->data())));
+   return true;
diff --git a/third_party/protobuf/patches/0046-absl-log.patch b/third_party/protobuf/patches/0046-absl-log.patch
new file mode 100644
index 0000000000000..d6b4b71214357
--- /dev/null
+++ b/third_party/protobuf/patches/0046-absl-log.patch
@@ -0,0 +1,24 @@
+diff --git a/src/google/protobuf/message_lite.cc b/src/google/protobuf/message_lite.cc
+index 9652028e07bdb..6bb2f434db2c1 100644
+--- a/src/google/protobuf/message_lite.cc
++++ b/src/google/protobuf/message_lite.cc
+@@ -23,7 +23,6 @@
+ 
+ #include "absl/log/absl_check.h"
+ #include "absl/log/absl_log.h"
+-#include "absl/log/log.h"
+ #include "absl/strings/cord.h"
+ #include "absl/strings/cord_buffer.h"
+ #include "absl/strings/str_cat.h"
+diff --git a/src/google/protobuf/wire_format_lite.cc b/src/google/protobuf/wire_format_lite.cc
+index 989a3372624d1..cbe6f3adfe143 100644
+--- a/src/google/protobuf/wire_format_lite.cc
++++ b/src/google/protobuf/wire_format_lite.cc
+@@ -20,7 +20,6 @@
+ 
+ #include "absl/log/absl_check.h"
+ #include "absl/log/absl_log.h"
+-#include "absl/log/log.h"
+ #include "absl/strings/cord.h"
+ #include "absl/strings/str_cat.h"
+ #include "absl/strings/str_format.h"
diff --git a/third_party/protobuf/patches/0047-perfetto-backcompat.patch b/third_party/protobuf/patches/0047-perfetto-backcompat.patch
new file mode 100644
index 0000000000000..46b2596cedbf0
--- /dev/null
+++ b/third_party/protobuf/patches/0047-perfetto-backcompat.patch
@@ -0,0 +1,77 @@
+diff --git a/src/google/protobuf/compiler/importer.h b/src/google/protobuf/compiler/importer.h
+index e63a7b7b30a79..b9b6cd8c00766 100644
+--- a/src/google/protobuf/compiler/importer.h
++++ b/src/google/protobuf/compiler/importer.h
+@@ -191,12 +191,30 @@ class PROTOBUF_EXPORT MultiFileErrorCollector {
+   // Line and column numbers are zero-based.  A line number of -1 indicates
+   // an error with the entire file (e.g. "not found").
+   virtual void RecordError(absl::string_view filename, int line, int column,
+-                           absl::string_view message)
+-      = 0;
++                           absl::string_view message) {
++    PROTOBUF_IGNORE_DEPRECATION_START
++    AddError(std::string(filename), line, column, std::string(message));
++    PROTOBUF_IGNORE_DEPRECATION_STOP
++  }
+   virtual void RecordWarning(absl::string_view filename, int line, int column,
+                              absl::string_view message) {
++    PROTOBUF_IGNORE_DEPRECATION_START
++    AddWarning(std::string(filename), line, column, std::string(message));
++    PROTOBUF_IGNORE_DEPRECATION_STOP
++  }
++
++ private:
++  // These should never be called directly, but if a legacy class overrides
++  // them they'll get routed to by the Record* methods.
++  [[deprecated("Use RecordError")]]
++  virtual void AddError(const std::string& filename, int line, int column,
++                        const std::string& message) {
++    ABSL_LOG(FATAL) << "AddError or RecordError must be implemented.";
+   }
+ 
++  [[deprecated("Use RecordWarning")]]
++  virtual void AddWarning(const std::string& filename, int line, int column,
++                          const std::string& message) {}
+ };
+ 
+ // Abstract interface which represents a directory tree containing proto files.
+diff --git a/src/google/protobuf/io/tokenizer.h b/src/google/protobuf/io/tokenizer.h
+index 007d09016eb35..0855a17db5b3a 100644
+--- a/src/google/protobuf/io/tokenizer.h
++++ b/src/google/protobuf/io/tokenizer.h
+@@ -55,16 +55,33 @@ class PROTOBUF_EXPORT ErrorCollector {
+   // column numbers.  The numbers are zero-based, so you may want to add
+   // 1 to each before printing them.
+   virtual void RecordError(int line, ColumnNumber column,
+-                           absl::string_view message)
+-      = 0;
++                           absl::string_view message) {
++    PROTOBUF_IGNORE_DEPRECATION_START
++    AddError(line, column, std::string(message));
++    PROTOBUF_IGNORE_DEPRECATION_STOP
++  }
+ 
+   // Indicates that there was a warning in the input at the given line and
+   // column numbers.  The numbers are zero-based, so you may want to add
+   // 1 to each before printing them.
+   virtual void RecordWarning(int line, ColumnNumber column,
+                              absl::string_view message) {
++    PROTOBUF_IGNORE_DEPRECATION_START
++    AddWarning(line, column, std::string(message));
++    PROTOBUF_IGNORE_DEPRECATION_STOP
+   }
+ 
++ private:
++  // These should never be called directly, but if a legacy class overrides
++  // them they'll get routed to by the Record* methods.
++  ABSL_DEPRECATED("Use RecordError")
++  virtual void AddError(int line, ColumnNumber column,
++                        const std::string& message) {
++    ABSL_LOG(FATAL) << "AddError or RecordError must be implemented.";
++  }
++  ABSL_DEPRECATED("Use RecordWarning")
++  virtual void AddWarning(int line, ColumnNumber column,
++                          const std::string& message) {}
+ };
+ 
+ // This class converts a stream of raw text into a stream of tokens for
diff --git a/third_party/protobuf/patches/0048-csharp-names-redirect.patch b/third_party/protobuf/patches/0048-csharp-names-redirect.patch
new file mode 100644
index 0000000000000..19f0b831f06f0
--- /dev/null
+++ b/third_party/protobuf/patches/0048-csharp-names-redirect.patch
@@ -0,0 +1,12 @@
+diff --git a/src/google/protobuf/compiler/csharp/csharp_names.h b/src/google/protobuf/compiler/csharp/csharp_names.h
+new file mode 100644
+index 0000000000000..6d55b01a2c2d5
+--- /dev/null
++++ b/src/google/protobuf/compiler/csharp/csharp_names.h
+@@ -0,0 +1,6 @@
++// Copyright 2025 The Chromium Authors
++// Use of this source code is governed by a BSD-style license that can be
++// found in the LICENSE file.
++
++// Redirect for GRPC's sake. See README.chromium
++#include "google/protobuf/compiler/csharp/names.h"
diff --git a/third_party/protobuf/patches/0049-deprecated-declarations-pragma.patch b/third_party/protobuf/patches/0049-deprecated-declarations-pragma.patch
new file mode 100644
index 0000000000000..6d22662b9f988
--- /dev/null
+++ b/third_party/protobuf/patches/0049-deprecated-declarations-pragma.patch
@@ -0,0 +1,19 @@
+diff --git a/src/google/protobuf/descriptor.cc b/src/google/protobuf/descriptor.cc
+index e6092b2344b9e..3bda7aef78e53 100644
+--- a/src/google/protobuf/descriptor.cc
++++ b/src/google/protobuf/descriptor.cc
+@@ -138,12 +138,12 @@ std::string ToJsonName(const absl::string_view input) {
+ 
+ template <typename OptionsT>
+ bool IsLegacyJsonFieldConflictEnabled(const OptionsT& options) {
+-#ifdef __GNUC__
++#if defined(__GNUC__) || defined(__clang__)
+ #pragma GCC diagnostic push
+ #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+ #endif
+   return options.deprecated_legacy_json_field_conflicts();
+-#ifdef __GNUC__
++#if defined(__GNUC__) || defined(__clang__)
+ #pragma GCC diagnostic pop
+ #endif
+ }
diff --git a/third_party/protobuf/patches/0050-remove-unreachable-code.patch b/third_party/protobuf/patches/0050-remove-unreachable-code.patch
new file mode 100644
index 0000000000000..dce36ca82d189
--- /dev/null
+++ b/third_party/protobuf/patches/0050-remove-unreachable-code.patch
@@ -0,0 +1,20 @@
+diff --git a/src/google/protobuf/generated_message_tctable_lite.cc b/src/google/protobuf/generated_message_tctable_lite.cc
+index 6ed1157ce2cea..58612936a9477 100644
+--- a/src/google/protobuf/generated_message_tctable_lite.cc
++++ b/src/google/protobuf/generated_message_tctable_lite.cc
+@@ -56,15 +56,9 @@ using FieldEntry = TcParseTableBase::FieldEntry;
+ #ifndef NDEBUG
+ void AlignFail(std::integral_constant<size_t, 4>, std::uintptr_t address) {
+   ABSL_LOG(FATAL) << "Unaligned (4) access at " << address;
+-
+-  // Explicit abort to let compilers know this function does not return
+-  abort();
+ }
+ void AlignFail(std::integral_constant<size_t, 8>, std::uintptr_t address) {
+   ABSL_LOG(FATAL) << "Unaligned (8) access at " << address;
+-
+-  // Explicit abort to let compilers know this function does not return
+-  abort();
+ }
+ #endif
+ 
diff --git a/third_party/protobuf/patches/0051-export-template-define.patch b/third_party/protobuf/patches/0051-export-template-define.patch
new file mode 100644
index 0000000000000..f3203b34a0d93
--- /dev/null
+++ b/third_party/protobuf/patches/0051-export-template-define.patch
@@ -0,0 +1,24 @@
+diff --git a/src/google/protobuf/repeated_ptr_field.cc b/src/google/protobuf/repeated_ptr_field.cc
+index 517230563ca88..f923dfd45e4e7 100644
+--- a/src/google/protobuf/repeated_ptr_field.cc
++++ b/src/google/protobuf/repeated_ptr_field.cc
+@@ -131,7 +131,8 @@ memswap<ArenaOffsetHelper<RepeatedPtrFieldBase>::value>(
+     char* PROTOBUF_RESTRICT, char* PROTOBUF_RESTRICT);
+ 
+ template <>
+-void RepeatedPtrFieldBase::MergeFrom<std::string>(
++PROTOBUF_EXPORT_TEMPLATE_DEFINE void
++RepeatedPtrFieldBase::MergeFrom<std::string>(
+     const RepeatedPtrFieldBase& from) {
+   Prefetch5LinesFrom1Line(&from);
+   ABSL_DCHECK_NE(&from, this);
+@@ -198,7 +199,8 @@ void RepeatedPtrFieldBase::MergeFromConcreteMessage(
+ }
+ 
+ template <>
+-void RepeatedPtrFieldBase::MergeFrom<MessageLite>(
++PROTOBUF_EXPORT_TEMPLATE_DEFINE void
++RepeatedPtrFieldBase::MergeFrom<MessageLite>(
+     const RepeatedPtrFieldBase& from) {
+   Prefetch5LinesFrom1Line(&from);
+   ABSL_DCHECK_NE(&from, this);
diff --git a/third_party/protobuf/patches/0052-remove-dynamic-annotations.patch b/third_party/protobuf/patches/0052-remove-dynamic-annotations.patch
new file mode 100644
index 0000000000000..e734317767e0f
--- /dev/null
+++ b/third_party/protobuf/patches/0052-remove-dynamic-annotations.patch
@@ -0,0 +1,35 @@
+diff --git a/src/google/protobuf/descriptor.cc b/src/google/protobuf/descriptor.cc
+index bbbeb343b7cf7..d2a631b4d465e 100644
+--- a/src/google/protobuf/descriptor.cc
++++ b/src/google/protobuf/descriptor.cc
+@@ -37,7 +37,6 @@
+ #include "absl/base/call_once.h"
+ #include "absl/base/casts.h"
+ #include "absl/base/const_init.h"
+-#include "absl/base/dynamic_annotations.h"
+ #include "absl/base/thread_annotations.h"
+ #include "absl/cleanup/cleanup.h"
+ #include "absl/container/btree_map.h"
+diff --git a/src/google/protobuf/repeated_field.h b/src/google/protobuf/repeated_field.h
+index cacad88b13735..e428811d27169 100644
+--- a/src/google/protobuf/repeated_field.h
++++ b/src/google/protobuf/repeated_field.h
+@@ -32,7 +32,6 @@
+ #include <utility>
+ 
+ #include "absl/base/attributes.h"
+-#include "absl/base/dynamic_annotations.h"
+ #include "absl/base/optimization.h"
+ #include "absl/log/absl_check.h"
+ #include "absl/meta/type_traits.h"
+@@ -544,8 +543,8 @@ class RepeatedField final
+     if (old_size != new_size) {
+       ABSL_ATTRIBUTE_UNUSED const bool is_soo = this->is_soo();
+       ABSL_ATTRIBUTE_UNUSED const Element* elem = unsafe_elements(is_soo);
+-      ABSL_ANNOTATE_CONTIGUOUS_CONTAINER(elem, elem + Capacity(is_soo),
+-                                         elem + old_size, elem + new_size);
++      // ABSL_ANNOTATE_CONTIGUOUS_CONTAINER(elem, elem + Capacity(is_soo),
++      //                                   elem + old_size, elem + new_size);
+       if (new_size < old_size) {
+         ABSL_ANNOTATE_MEMORY_IS_UNINITIALIZED(
+             elem + new_size, (old_size - new_size) * sizeof(Element));
diff --git a/third_party/protobuf/patches/0053-ignore-compatibility-dir.patch b/third_party/protobuf/patches/0053-ignore-compatibility-dir.patch
new file mode 100644
index 0000000000000..fefa25e855077
--- /dev/null
+++ b/third_party/protobuf/patches/0053-ignore-compatibility-dir.patch
@@ -0,0 +1,11 @@
+diff --git a/.gitignore b/.gitignore
+index 5daf9c20e7903..5766401460e4c 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -216,3 +216,6 @@ compile_commands.json
+ 
+ # Ignore Bzlmod lock file until it is more stable
+ MODULE.bazel.lock
++
++# Chromium: this directory contains some large files that we don't use.
++compatibility/
diff --git a/third_party/protobuf/patches/0054-remove-usage-if-absl-internal-if_constexpr.patch b/third_party/protobuf/patches/0054-remove-usage-if-absl-internal-if_constexpr.patch
new file mode 100644
index 0000000000000..ef1be7eae6b40
--- /dev/null
+++ b/third_party/protobuf/patches/0054-remove-usage-if-absl-internal-if_constexpr.patch
@@ -0,0 +1,91 @@
+From 1de8261ac45cbd24ad473847be04d4d1a1a50536 Mon Sep 17 00:00:00 2001
+From: Sophie Chang <sophiechang@chromium.org>
+Date: Tue, 25 Feb 2025 17:51:22 +0000
+Subject: [PATCH] Remove usage if absl internal if_constexpr
+
+---
+ .../protobuf/src/google/protobuf/arena.h      | 61 ++++++++-----------
+ 1 file changed, 25 insertions(+), 36 deletions(-)
+
+diff --git a/third_party/protobuf/src/google/protobuf/arena.h b/third_party/protobuf/src/google/protobuf/arena.h
+index 545fd5126a478..55b1ec83bd06f 100644
+--- a/third_party/protobuf/src/google/protobuf/arena.h
++++ b/third_party/protobuf/src/google/protobuf/arena.h
+@@ -32,7 +32,6 @@ using type_info = ::type_info;
+ #include "absl/base/optimization.h"
+ #include "absl/base/prefetch.h"
+ #include "absl/log/absl_check.h"
+-#include "absl/utility/internal/if_constexpr.h"
+ #include "google/protobuf/arena_align.h"
+ #include "google/protobuf/arena_allocation_policy.h"
+ #include "google/protobuf/port.h"
+@@ -214,41 +213,31 @@ class PROTOBUF_EXPORT PROTOBUF_ALIGNAS(8) Arena final {
+   // otherwise, returns a heap-allocated object.
+   template <typename T, typename... Args>
+   PROTOBUF_NDEBUG_INLINE static T* Create(Arena* arena, Args&&... args) {
+-    return absl::utility_internal::IfConstexprElse<
+-        is_arena_constructable<T>::value>(
+-        // Arena-constructable
+-        [arena](auto&&... args) {
+-          using Type = std::remove_const_t<T>;
+-#ifdef __cpp_if_constexpr
+-          // DefaultConstruct/CopyConstruct are optimized for messages, which
+-          // are both arena constructible and destructor skippable and they
+-          // assume much. Don't use these functions unless the invariants
+-          // hold.
+-          if constexpr (is_destructor_skippable<T>::value) {
+-            constexpr auto construct_type = GetConstructType<T, Args&&...>();
+-            // We delegate to DefaultConstruct/CopyConstruct where appropriate
+-            // because protobuf generated classes have external templates for
+-            // these functions for code size reasons. When `if constexpr` is not
+-            // available always use the fallback.
+-            if constexpr (construct_type == ConstructType::kDefault) {
+-              return static_cast<Type*>(DefaultConstruct<Type>(arena));
+-            } else if constexpr (construct_type == ConstructType::kCopy) {
+-              return static_cast<Type*>(CopyConstruct<Type>(arena, &args...));
+-            }
+-          }
+-#endif
+-          return CreateArenaCompatible<Type>(arena,
+-                                             std::forward<Args>(args)...);
+-        },
+-        // Non arena-constructable
+-        [arena](auto&&... args) {
+-          if (PROTOBUF_PREDICT_FALSE(arena == nullptr)) {
+-            return new T(std::forward<Args>(args)...);
+-          }
+-          return new (arena->AllocateInternal<T>())
+-              T(std::forward<Args>(args)...);
+-        },
+-        std::forward<Args>(args)...);
++    if constexpr (is_arena_constructable<T>::value) {
++      using Type = std::remove_const_t<T>;
++      // DefaultConstruct/CopyConstruct are optimized for messages, which
++      // are both arena constructible and destructor skippable and they
++      // assume much. Don't use these functions unless the invariants
++      // hold.
++      if constexpr (is_destructor_skippable<T>::value) {
++        constexpr auto construct_type = GetConstructType<T, Args&&...>();
++        // We delegate to DefaultConstruct/CopyConstruct where appropriate
++        // because protobuf generated classes have external templates for
++        // these functions for code size reasons. When `if constexpr` is not
++        // available always use the fallback.
++        if constexpr (construct_type == ConstructType::kDefault) {
++          return static_cast<Type*>(DefaultConstruct<Type>(arena));
++        } else if constexpr (construct_type == ConstructType::kCopy) {
++          return static_cast<Type*>(CopyConstruct<Type>(arena, &args...));
++        }
++      }
++      return CreateArenaCompatible<Type>(arena, std::forward<Args>(args)...);
++    } else {
++      if (ABSL_PREDICT_FALSE(arena == nullptr)) {
++        return new T(std::forward<Args>(args)...);
++      }
++      return new (arena->AllocateInternal<T>()) T(std::forward<Args>(args)...);
++    }
+   }
+ 
+   // API to delete any objects not on an arena.  This can be used to safely
+-- 
+2.48.1.711.g2feabab25a-goog
+
diff --git a/third_party/protobuf/third_party/rules_fuzzing.patch b/third_party/protobuf/third_party/rules_fuzzing.patch
new file mode 100644
index 0000000000000..5e5965ad8033c
--- /dev/null
+++ b/third_party/protobuf/third_party/rules_fuzzing.patch
@@ -0,0 +1,13 @@
+diff --git a/fuzzing/private/binary.bzl b/fuzzing/private/binary.bzl
+index 4c85aed..8ff9723 100644
+--- a/fuzzing/private/binary.bzl
++++ b/fuzzing/private/binary.bzl
+@@ -114,7 +114,7 @@ def _fuzzing_binary_impl(ctx):
+     else:
+         default_info = ctx.attr.binary[DefaultInfo]
+     binary_runfiles = default_info.default_runfiles
+-    binary_repo_mapping_manifest = getattr(default_info.files_to_run, "repo_mapping_manifest")
++    binary_repo_mapping_manifest = getattr(default_info.files_to_run, "repo_mapping_manifest", None)
+     other_runfiles = []
+     if ctx.file.corpus:
+         other_runfiles.append(ctx.file.corpus)
\ No newline at end of file
diff --git a/third_party/rapidhash/patches/0001-clang-format.patch b/third_party/rapidhash/patches/0001-clang-format.patch
new file mode 100644
index 0000000000000..361472922b97a
--- /dev/null
+++ b/third_party/rapidhash/patches/0001-clang-format.patch
@@ -0,0 +1,733 @@
+1,323c1,408
+< /*
+<  * rapidhash - Very fast, high quality, platform-independent hashing algorithm.
+<  * Copyright (C) 2024 Nicolas De Carli
+<  *
+<  * Based on 'wyhash', by Wang Yi <godspeed_china@yeah.net>
+<  *
+<  * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+<  *
+<  * Redistribution and use in source and binary forms, with or without
+<  * modification, are permitted provided that the following conditions are
+<  * met:
+<  *
+<  *    * Redistributions of source code must retain the above copyright
+<  *      notice, this list of conditions and the following disclaimer.
+<  *    * Redistributions in binary form must reproduce the above
+<  *      copyright notice, this list of conditions and the following disclaimer
+<  *      in the documentation and/or other materials provided with the
+<  *      distribution.
+<  *
+<  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+<  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+<  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+<  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+<  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+<  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+<  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+<  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+<  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+<  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+<  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+<  *
+<  * You can contact the author at:
+<  *   - rapidhash source repository: https://github.com/Nicoshev/rapidhash
+<  */
+< 
+< /*
+<  *  Includes.
+<  */
+< #include <stdint.h>
+< #include <string.h>
+< #if defined(_MSC_VER)
+<   #include <intrin.h>
+<   #if defined(_M_X64) && !defined(_M_ARM64EC)
+<     #pragma intrinsic(_umul128)
+<   #endif
+< #endif
+< 
+< /*
+<  *  C++ macros.
+<  *
+<  *  RAPIDHASH_INLINE can be overriden to be stronger than a hint, i.e. by adding __attribute__((always_inline)).
+<  */
+< #ifdef __cplusplus
+<   #define RAPIDHASH_NOEXCEPT noexcept
+<   #define RAPIDHASH_CONSTEXPR constexpr
+<   #ifndef RAPIDHASH_INLINE
+<     #define RAPIDHASH_INLINE inline
+<   #endif
+< #else
+<   #define RAPIDHASH_NOEXCEPT 
+<   #define RAPIDHASH_CONSTEXPR const
+<   #ifndef RAPIDHASH_INLINE
+<     #define RAPIDHASH_INLINE static inline
+<   #endif
+< #endif
+< 
+< /*
+<  *  Protection macro, alters behaviour of rapid_mum multiplication function.
+<  *  
+<  *  RAPIDHASH_FAST: Normal behavior, max speed.
+<  *  RAPIDHASH_PROTECTED: Extra protection against entropy loss.
+<  */
+< #ifndef RAPIDHASH_PROTECTED
+<   #define RAPIDHASH_FAST
+< #elif defined(RAPIDHASH_FAST)
+<   #error "cannot define RAPIDHASH_PROTECTED and RAPIDHASH_FAST simultaneously."
+< #endif
+< 
+< /*
+<  *  Unrolling macros, changes code definition for main hash function.
+<  *  
+<  *  RAPIDHASH_COMPACT: Legacy variant, each loop process 48 bytes.
+<  *  RAPIDHASH_UNROLLED: Unrolled variant, each loop process 96 bytes.
+<  *
+<  *  Most modern CPUs should benefit from having RAPIDHASH_UNROLLED.
+<  *
+<  *  These macros do not alter the output hash.
+<  */
+< #ifndef RAPIDHASH_COMPACT
+<   #define RAPIDHASH_UNROLLED
+< #elif defined(RAPIDHASH_UNROLLED)
+<   #error "cannot define RAPIDHASH_COMPACT and RAPIDHASH_UNROLLED simultaneously."
+< #endif
+< 
+< /*
+<  *  Likely and unlikely macros.
+<  */
+< #if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
+<   #define _likely_(x)  __builtin_expect(x,1)
+<   #define _unlikely_(x)  __builtin_expect(x,0)
+< #else
+<   #define _likely_(x) (x)
+<   #define _unlikely_(x) (x)
+< #endif
+< 
+< /*
+<  *  Endianness macros.
+<  */
+< #ifndef RAPIDHASH_LITTLE_ENDIAN
+<   #if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+<     #define RAPIDHASH_LITTLE_ENDIAN
+<   #elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+<     #define RAPIDHASH_BIG_ENDIAN
+<   #else
+<     #warning "could not determine endianness! Falling back to little endian."
+<     #define RAPIDHASH_LITTLE_ENDIAN
+<   #endif
+< #endif
+< 
+< /*
+<  *  Default seed.
+<  */
+< #define RAPID_SEED (0xbdd89aa982704029ull)
+< 
+< /*
+<  *  Default secret parameters.
+<  */
+< RAPIDHASH_CONSTEXPR uint64_t rapid_secret[3] = {0x2d358dccaa6c78a5ull, 0x8bb84b93962eacc9ull, 0x4b33a62ed433d4a3ull};
+< 
+< /*
+<  *  64*64 -> 128bit multiply function.
+<  *  
+<  *  @param A  Address of 64-bit number.
+<  *  @param B  Address of 64-bit number.
+<  *
+<  *  Calculates 128-bit C = *A * *B.
+<  *
+<  *  When RAPIDHASH_FAST is defined:
+<  *  Overwrites A contents with C's low 64 bits.
+<  *  Overwrites B contents with C's high 64 bits.
+<  *
+<  *  When RAPIDHASH_PROTECTED is defined:
+<  *  Xors and overwrites A contents with C's low 64 bits.
+<  *  Xors and overwrites B contents with C's high 64 bits.
+<  */
+< RAPIDHASH_INLINE void rapid_mum(uint64_t *A, uint64_t *B) RAPIDHASH_NOEXCEPT {
+< #if defined(__SIZEOF_INT128__)
+<   __uint128_t r=*A; r*=*B; 
+<   #ifdef RAPIDHASH_PROTECTED
+<   *A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
+<   #else
+<   *A=(uint64_t)r; *B=(uint64_t)(r>>64);
+<   #endif
+< #elif defined(_MSC_VER) && (defined(_WIN64) || defined(_M_HYBRID_CHPE_ARM64))
+<   #if defined(_M_X64)
+<     #ifdef RAPIDHASH_PROTECTED
+<     uint64_t a, b;
+<     a=_umul128(*A,*B,&b);
+<     *A^=a;  *B^=b;
+<     #else
+<     *A=_umul128(*A,*B,B);
+<     #endif
+<   #else
+<     #ifdef RAPIDHASH_PROTECTED
+<     uint64_t a, b;
+<     b = __umulh(*A, *B);
+<     a = *A * *B;
+<     *A^=a;  *B^=b;
+<     #else
+<     uint64_t c = __umulh(*A, *B);
+<     *A = *A * *B;
+<     *B = c;
+<     #endif
+<   #endif
+< #else
+<   uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
+<   uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
+<   lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
+<   #ifdef RAPIDHASH_PROTECTED
+<   *A^=lo;  *B^=hi;
+<   #else
+<   *A=lo;  *B=hi;
+<   #endif
+< #endif
+< }
+< 
+< /*
+<  *  Multiply and xor mix function.
+<  *  
+<  *  @param A  64-bit number.
+<  *  @param B  64-bit number.
+<  *
+<  *  Calculates 128-bit C = A * B.
+<  *  Returns 64-bit xor between high and low 64 bits of C.
+<  */
+< RAPIDHASH_INLINE uint64_t rapid_mix(uint64_t A, uint64_t B) RAPIDHASH_NOEXCEPT { rapid_mum(&A,&B); return A^B; }
+< 
+< /*
+<  *  Read functions.
+<  */
+< #ifdef RAPIDHASH_LITTLE_ENDIAN
+< RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t *p) RAPIDHASH_NOEXCEPT { uint64_t v; memcpy(&v, p, sizeof(uint64_t)); return v;}
+< RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t *p) RAPIDHASH_NOEXCEPT { uint32_t v; memcpy(&v, p, sizeof(uint32_t)); return v;}
+< #elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
+< RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t *p) RAPIDHASH_NOEXCEPT { uint64_t v; memcpy(&v, p, sizeof(uint64_t)); return __builtin_bswap64(v);}
+< RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t *p) RAPIDHASH_NOEXCEPT { uint32_t v; memcpy(&v, p, sizeof(uint32_t)); return __builtin_bswap32(v);}
+< #elif defined(_MSC_VER)
+< RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t *p) RAPIDHASH_NOEXCEPT { uint64_t v; memcpy(&v, p, sizeof(uint64_t)); return _byteswap_uint64(v);}
+< RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t *p) RAPIDHASH_NOEXCEPT { uint32_t v; memcpy(&v, p, sizeof(uint32_t)); return _byteswap_ulong(v);}
+< #else
+< RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t *p) RAPIDHASH_NOEXCEPT {
+<   uint64_t v; memcpy(&v, p, 8);
+<   return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
+< }
+< RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t *p) RAPIDHASH_NOEXCEPT {
+<   uint32_t v; memcpy(&v, p, 4);
+<   return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
+< }
+< #endif
+< 
+< /*
+<  *  Reads and combines 3 bytes of input.
+<  *
+<  *  @param p  Buffer to read from.
+<  *  @param k  Length of @p, in bytes.
+<  *
+<  *  Always reads and combines 3 bytes from memory.
+<  *  Guarantees to read each buffer position at least once.
+<  *  
+<  *  Returns a 64-bit value containing all three bytes read. 
+<  */
+< RAPIDHASH_INLINE uint64_t rapid_readSmall(const uint8_t *p, size_t k) RAPIDHASH_NOEXCEPT { return (((uint64_t)p[0])<<56)|(((uint64_t)p[k>>1])<<32)|p[k-1];}
+< 
+< /*
+<  *  rapidhash main function.
+<  *
+<  *  @param key     Buffer to be hashed.
+<  *  @param len     @key length, in bytes.
+<  *  @param seed    64-bit seed used to alter the hash result predictably.
+<  *  @param secret  Triplet of 64-bit secrets used to alter hash result predictably.
+<  *
+<  *  Returns a 64-bit hash.
+<  */
+< RAPIDHASH_INLINE uint64_t rapidhash_internal(const void *key, size_t len, uint64_t seed, const uint64_t* secret) RAPIDHASH_NOEXCEPT {
+<   const uint8_t *p=(const uint8_t *)key; seed^=rapid_mix(seed^secret[0],secret[1])^len;  uint64_t  a,  b;
+<   if(_likely_(len<=16)){
+<     if(_likely_(len>=4)){ 
+<       const uint8_t * plast = p + len - 4;
+<       a = (rapid_read32(p) << 32) | rapid_read32(plast);
+<       const uint64_t delta = ((len&24)>>(len>>3));
+<       b = ((rapid_read32(p + delta) << 32) | rapid_read32(plast - delta)); }
+<     else if(_likely_(len>0)){ a=rapid_readSmall(p,len); b=0;}
+<     else a=b=0;
+<   }
+<   else{
+<     size_t i=len; 
+<     if(_unlikely_(i>48)){
+<       uint64_t see1=seed, see2=seed;
+< #ifdef RAPIDHASH_UNROLLED
+<       while(_likely_(i>=96)){
+<         seed=rapid_mix(rapid_read64(p)^secret[0],rapid_read64(p+8)^seed);
+<         see1=rapid_mix(rapid_read64(p+16)^secret[1],rapid_read64(p+24)^see1);
+<         see2=rapid_mix(rapid_read64(p+32)^secret[2],rapid_read64(p+40)^see2);
+<         seed=rapid_mix(rapid_read64(p+48)^secret[0],rapid_read64(p+56)^seed);
+<         see1=rapid_mix(rapid_read64(p+64)^secret[1],rapid_read64(p+72)^see1);
+<         see2=rapid_mix(rapid_read64(p+80)^secret[2],rapid_read64(p+88)^see2);
+<         p+=96; i-=96;
+<       }
+<       if(_unlikely_(i>=48)){
+<         seed=rapid_mix(rapid_read64(p)^secret[0],rapid_read64(p+8)^seed);
+<         see1=rapid_mix(rapid_read64(p+16)^secret[1],rapid_read64(p+24)^see1);
+<         see2=rapid_mix(rapid_read64(p+32)^secret[2],rapid_read64(p+40)^see2);
+<         p+=48; i-=48;
+<       }
+< #else
+<       do {
+<         seed=rapid_mix(rapid_read64(p)^secret[0],rapid_read64(p+8)^seed);
+<         see1=rapid_mix(rapid_read64(p+16)^secret[1],rapid_read64(p+24)^see1);
+<         see2=rapid_mix(rapid_read64(p+32)^secret[2],rapid_read64(p+40)^see2);
+<         p+=48; i-=48;
+<       } while (_likely_(i>=48));
+< #endif
+<       seed^=see1^see2;
+<     }
+<     if(i>16){
+<       seed=rapid_mix(rapid_read64(p)^secret[2],rapid_read64(p+8)^seed^secret[1]);
+<       if(i>32)
+<         seed=rapid_mix(rapid_read64(p+16)^secret[2],rapid_read64(p+24)^seed);
+<     }
+<     a=rapid_read64(p+i-16);  b=rapid_read64(p+i-8);
+<   }
+<   a^=secret[1]; b^=seed;  rapid_mum(&a,&b);
+<   return  rapid_mix(a^secret[0]^len,b^secret[1]);
+< }
+< 
+< /*
+<  *  rapidhash default seeded hash function.
+<  *
+<  *  @param key     Buffer to be hashed.
+<  *  @param len     @key length, in bytes.
+<  *  @param seed    64-bit seed used to alter the hash result predictably.
+<  *
+<  *  Calls rapidhash_internal using provided parameters and default secrets.
+<  *
+<  *  Returns a 64-bit hash.
+<  */
+< RAPIDHASH_INLINE uint64_t rapidhash_withSeed(const void *key, size_t len, uint64_t seed) RAPIDHASH_NOEXCEPT {
+<   return rapidhash_internal(key, len, seed, rapid_secret);
+< }
+< 
+< /*
+<  *  rapidhash default hash function.
+<  *
+<  *  @param key     Buffer to be hashed.
+<  *  @param len     @key length, in bytes.
+<  *
+<  *  Calls rapidhash_withSeed using provided parameters and the default seed.
+<  *
+<  *  Returns a 64-bit hash.
+<  */
+< RAPIDHASH_INLINE uint64_t rapidhash(const void *key, size_t len) RAPIDHASH_NOEXCEPT {
+<   return rapidhash_withSeed(key, len, RAPID_SEED);
+< }
+---
+> /*
+>  * rapidhash - Very fast, high quality, platform-independent hashing algorithm.
+>  * Copyright (C) 2024 Nicolas De Carli
+>  *
+>  * Based on 'wyhash', by Wang Yi <godspeed_china@yeah.net>
+>  *
+>  * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+>  *
+>  * Redistribution and use in source and binary forms, with or without
+>  * modification, are permitted provided that the following conditions are
+>  * met:
+>  *
+>  *    * Redistributions of source code must retain the above copyright
+>  *      notice, this list of conditions and the following disclaimer.
+>  *    * Redistributions in binary form must reproduce the above
+>  *      copyright notice, this list of conditions and the following disclaimer
+>  *      in the documentation and/or other materials provided with the
+>  *      distribution.
+>  *
+>  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+>  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+>  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+>  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+>  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+>  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+>  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+>  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+>  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+>  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+>  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+>  *
+>  * You can contact the author at:
+>  *   - rapidhash source repository: https://github.com/Nicoshev/rapidhash
+>  */
+> 
+> /*
+>  *  Includes.
+>  */
+> #include <stdint.h>
+> #include <string.h>
+> #if defined(_MSC_VER)
+> #include <intrin.h>
+> #if defined(_M_X64) && !defined(_M_ARM64EC)
+> #pragma intrinsic(_umul128)
+> #endif
+> #endif
+> 
+> /*
+>  *  C++ macros.
+>  *
+>  *  RAPIDHASH_INLINE can be overriden to be stronger than a hint, i.e. by adding
+>  * __attribute__((always_inline)).
+>  */
+> #ifdef __cplusplus
+> #define RAPIDHASH_NOEXCEPT noexcept
+> #define RAPIDHASH_CONSTEXPR constexpr
+> #ifndef RAPIDHASH_INLINE
+> #define RAPIDHASH_INLINE inline
+> #endif
+> #else
+> #define RAPIDHASH_NOEXCEPT
+> #define RAPIDHASH_CONSTEXPR const
+> #ifndef RAPIDHASH_INLINE
+> #define RAPIDHASH_INLINE static inline
+> #endif
+> #endif
+> 
+> /*
+>  *  Protection macro, alters behaviour of rapid_mum multiplication function.
+>  *
+>  *  RAPIDHASH_FAST: Normal behavior, max speed.
+>  *  RAPIDHASH_PROTECTED: Extra protection against entropy loss.
+>  */
+> #ifndef RAPIDHASH_PROTECTED
+> #define RAPIDHASH_FAST
+> #elif defined(RAPIDHASH_FAST)
+> #error "cannot define RAPIDHASH_PROTECTED and RAPIDHASH_FAST simultaneously."
+> #endif
+> 
+> /*
+>  *  Unrolling macros, changes code definition for main hash function.
+>  *
+>  *  RAPIDHASH_COMPACT: Legacy variant, each loop process 48 bytes.
+>  *  RAPIDHASH_UNROLLED: Unrolled variant, each loop process 96 bytes.
+>  *
+>  *  Most modern CPUs should benefit from having RAPIDHASH_UNROLLED.
+>  *
+>  *  These macros do not alter the output hash.
+>  */
+> #ifndef RAPIDHASH_COMPACT
+> #define RAPIDHASH_UNROLLED
+> #elif defined(RAPIDHASH_UNROLLED)
+> #error "cannot define RAPIDHASH_COMPACT and RAPIDHASH_UNROLLED simultaneously."
+> #endif
+> 
+> /*
+>  *  Likely and unlikely macros.
+>  */
+> #if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
+> #define _likely_(x) __builtin_expect(x, 1)
+> #define _unlikely_(x) __builtin_expect(x, 0)
+> #else
+> #define _likely_(x) (x)
+> #define _unlikely_(x) (x)
+> #endif
+> 
+> /*
+>  *  Endianness macros.
+>  */
+> #ifndef RAPIDHASH_LITTLE_ENDIAN
+> #if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || \
+>     (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+> #define RAPIDHASH_LITTLE_ENDIAN
+> #elif defined(__BIG_ENDIAN__) || \
+>     (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+> #define RAPIDHASH_BIG_ENDIAN
+> #else
+> #warning "could not determine endianness! Falling back to little endian."
+> #define RAPIDHASH_LITTLE_ENDIAN
+> #endif
+> #endif
+> 
+> /*
+>  *  Default seed.
+>  */
+> #define RAPID_SEED (0xbdd89aa982704029ull)
+> 
+> /*
+>  *  Default secret parameters.
+>  */
+> RAPIDHASH_CONSTEXPR uint64_t rapid_secret[3] = {
+>     0x2d358dccaa6c78a5ull, 0x8bb84b93962eacc9ull, 0x4b33a62ed433d4a3ull};
+> 
+> /*
+>  *  64*64 -> 128bit multiply function.
+>  *
+>  *  @param A  Address of 64-bit number.
+>  *  @param B  Address of 64-bit number.
+>  *
+>  *  Calculates 128-bit C = *A * *B.
+>  *
+>  *  When RAPIDHASH_FAST is defined:
+>  *  Overwrites A contents with C's low 64 bits.
+>  *  Overwrites B contents with C's high 64 bits.
+>  *
+>  *  When RAPIDHASH_PROTECTED is defined:
+>  *  Xors and overwrites A contents with C's low 64 bits.
+>  *  Xors and overwrites B contents with C's high 64 bits.
+>  */
+> RAPIDHASH_INLINE void rapid_mum(uint64_t* A, uint64_t* B) RAPIDHASH_NOEXCEPT {
+> #if defined(__SIZEOF_INT128__)
+>   __uint128_t r = *A;
+>   r *= *B;
+> #ifdef RAPIDHASH_PROTECTED
+>   *A ^= (uint64_t)r;
+>   *B ^= (uint64_t)(r >> 64);
+> #else
+>   *A = (uint64_t)r;
+>   *B = (uint64_t)(r >> 64);
+> #endif
+> #elif defined(_MSC_VER) && (defined(_WIN64) || defined(_M_HYBRID_CHPE_ARM64))
+> #if defined(_M_X64)
+> #ifdef RAPIDHASH_PROTECTED
+>   uint64_t a, b;
+>   a = _umul128(*A, *B, &b);
+>   *A ^= a;
+>   *B ^= b;
+> #else
+>   *A = _umul128(*A, *B, B);
+> #endif
+> #else
+> #ifdef RAPIDHASH_PROTECTED
+>   uint64_t a, b;
+>   b = __umulh(*A, *B);
+>   a = *A * *B;
+>   *A ^= a;
+>   *B ^= b;
+> #else
+>   uint64_t c = __umulh(*A, *B);
+>   *A = *A * *B;
+>   *B = c;
+> #endif
+> #endif
+> #else
+>   uint64_t ha = *A >> 32, hb = *B >> 32, la = (uint32_t)*A, lb = (uint32_t)*B,
+>            hi, lo;
+>   uint64_t rh = ha * hb, rm0 = ha * lb, rm1 = hb * la, rl = la * lb,
+>            t = rl + (rm0 << 32), c = t < rl;
+>   lo = t + (rm1 << 32);
+>   c += lo < t;
+>   hi = rh + (rm0 >> 32) + (rm1 >> 32) + c;
+> #ifdef RAPIDHASH_PROTECTED
+>   *A ^= lo;
+>   *B ^= hi;
+> #else
+>   *A = lo;
+>   *B = hi;
+> #endif
+> #endif
+> }
+> 
+> /*
+>  *  Multiply and xor mix function.
+>  *
+>  *  @param A  64-bit number.
+>  *  @param B  64-bit number.
+>  *
+>  *  Calculates 128-bit C = A * B.
+>  *  Returns 64-bit xor between high and low 64 bits of C.
+>  */
+> RAPIDHASH_INLINE uint64_t rapid_mix(uint64_t A, uint64_t B) RAPIDHASH_NOEXCEPT {
+>   rapid_mum(&A, &B);
+>   return A ^ B;
+> }
+> 
+> /*
+>  *  Read functions.
+>  */
+> #ifdef RAPIDHASH_LITTLE_ENDIAN
+> RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint64_t v;
+>   memcpy(&v, p, sizeof(uint64_t));
+>   return v;
+> }
+> RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint32_t v;
+>   memcpy(&v, p, sizeof(uint32_t));
+>   return v;
+> }
+> #elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
+> RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint64_t v;
+>   memcpy(&v, p, sizeof(uint64_t));
+>   return __builtin_bswap64(v);
+> }
+> RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint32_t v;
+>   memcpy(&v, p, sizeof(uint32_t));
+>   return __builtin_bswap32(v);
+> }
+> #elif defined(_MSC_VER)
+> RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint64_t v;
+>   memcpy(&v, p, sizeof(uint64_t));
+>   return _byteswap_uint64(v);
+> }
+> RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint32_t v;
+>   memcpy(&v, p, sizeof(uint32_t));
+>   return _byteswap_ulong(v);
+> }
+> #else
+> RAPIDHASH_INLINE uint64_t rapid_read64(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint64_t v;
+>   memcpy(&v, p, 8);
+>   return (((v >> 56) & 0xff) | ((v >> 40) & 0xff00) | ((v >> 24) & 0xff0000) |
+>           ((v >> 8) & 0xff000000) | ((v << 8) & 0xff00000000) |
+>           ((v << 24) & 0xff0000000000) | ((v << 40) & 0xff000000000000) |
+>           ((v << 56) & 0xff00000000000000));
+> }
+> RAPIDHASH_INLINE uint64_t rapid_read32(const uint8_t* p) RAPIDHASH_NOEXCEPT {
+>   uint32_t v;
+>   memcpy(&v, p, 4);
+>   return (((v >> 24) & 0xff) | ((v >> 8) & 0xff00) | ((v << 8) & 0xff0000) |
+>           ((v << 24) & 0xff000000));
+> }
+> #endif
+> 
+> /*
+>  *  Reads and combines 3 bytes of input.
+>  *
+>  *  @param p  Buffer to read from.
+>  *  @param k  Length of @p, in bytes.
+>  *
+>  *  Always reads and combines 3 bytes from memory.
+>  *  Guarantees to read each buffer position at least once.
+>  *
+>  *  Returns a 64-bit value containing all three bytes read.
+>  */
+> RAPIDHASH_INLINE uint64_t rapid_readSmall(const uint8_t* p,
+>                                           size_t k) RAPIDHASH_NOEXCEPT {
+>   return (((uint64_t)p[0]) << 56) | (((uint64_t)p[k >> 1]) << 32) | p[k - 1];
+> }
+> 
+> /*
+>  *  rapidhash main function.
+>  *
+>  *  @param key     Buffer to be hashed.
+>  *  @param len     @key length, in bytes.
+>  *  @param seed    64-bit seed used to alter the hash result predictably.
+>  *  @param secret  Triplet of 64-bit secrets used to alter hash result
+>  * predictably.
+>  *
+>  *  Returns a 64-bit hash.
+>  */
+> RAPIDHASH_INLINE uint64_t rapidhash_internal(const void* key,
+>                                              size_t len,
+>                                              uint64_t seed,
+>                                              const uint64_t* secret)
+>     RAPIDHASH_NOEXCEPT {
+>   const uint8_t* p = (const uint8_t*)key;
+>   seed ^= rapid_mix(seed ^ secret[0], secret[1]) ^ len;
+>   uint64_t a, b;
+>   if (_likely_(len <= 16)) {
+>     if (_likely_(len >= 4)) {
+>       const uint8_t* plast = p + len - 4;
+>       a = (rapid_read32(p) << 32) | rapid_read32(plast);
+>       const uint64_t delta = ((len & 24) >> (len >> 3));
+>       b = ((rapid_read32(p + delta) << 32) | rapid_read32(plast - delta));
+>     } else if (_likely_(len > 0)) {
+>       a = rapid_readSmall(p, len);
+>       b = 0;
+>     } else {
+>       a = b = 0;
+>     }
+>   } else {
+>     size_t i = len;
+>     if (_unlikely_(i > 48)) {
+>       uint64_t see1 = seed, see2 = seed;
+> #ifdef RAPIDHASH_UNROLLED
+>       while (_likely_(i >= 96)) {
+>         seed =
+>             rapid_mix(rapid_read64(p) ^ secret[0], rapid_read64(p + 8) ^ seed);
+>         see1 = rapid_mix(rapid_read64(p + 16) ^ secret[1],
+>                          rapid_read64(p + 24) ^ see1);
+>         see2 = rapid_mix(rapid_read64(p + 32) ^ secret[2],
+>                          rapid_read64(p + 40) ^ see2);
+>         seed = rapid_mix(rapid_read64(p + 48) ^ secret[0],
+>                          rapid_read64(p + 56) ^ seed);
+>         see1 = rapid_mix(rapid_read64(p + 64) ^ secret[1],
+>                          rapid_read64(p + 72) ^ see1);
+>         see2 = rapid_mix(rapid_read64(p + 80) ^ secret[2],
+>                          rapid_read64(p + 88) ^ see2);
+>         p += 96;
+>         i -= 96;
+>       }
+>       if (_unlikely_(i >= 48)) {
+>         seed =
+>             rapid_mix(rapid_read64(p) ^ secret[0], rapid_read64(p + 8) ^ seed);
+>         see1 = rapid_mix(rapid_read64(p + 16) ^ secret[1],
+>                          rapid_read64(p + 24) ^ see1);
+>         see2 = rapid_mix(rapid_read64(p + 32) ^ secret[2],
+>                          rapid_read64(p + 40) ^ see2);
+>         p += 48;
+>         i -= 48;
+>       }
+> #else
+>       do {
+>         seed =
+>             rapid_mix(rapid_read64(p) ^ secret[0], rapid_read64(p + 8) ^ seed);
+>         see1 = rapid_mix(rapid_read64(p + 16) ^ secret[1],
+>                          rapid_read64(p + 24) ^ see1);
+>         see2 = rapid_mix(rapid_read64(p + 32) ^ secret[2],
+>                          rapid_read64(p + 40) ^ see2);
+>         p += 48;
+>         i -= 48;
+>       } while (_likely_(i >= 48));
+> #endif
+>       seed ^= see1 ^ see2;
+>     }
+>     if (i > 16) {
+>       seed = rapid_mix(rapid_read64(p) ^ secret[2],
+>                        rapid_read64(p + 8) ^ seed ^ secret[1]);
+>       if (i > 32) {
+>         seed = rapid_mix(rapid_read64(p + 16) ^ secret[2],
+>                          rapid_read64(p + 24) ^ seed);
+>       }
+>     }
+>     a = rapid_read64(p + i - 16);
+>     b = rapid_read64(p + i - 8);
+>   }
+>   a ^= secret[1];
+>   b ^= seed;
+>   rapid_mum(&a, &b);
+>   return rapid_mix(a ^ secret[0] ^ len, b ^ secret[1]);
+> }
+> 
+> /*
+>  *  rapidhash default seeded hash function.
+>  *
+>  *  @param key     Buffer to be hashed.
+>  *  @param len     @key length, in bytes.
+>  *  @param seed    64-bit seed used to alter the hash result predictably.
+>  *
+>  *  Calls rapidhash_internal using provided parameters and default secrets.
+>  *
+>  *  Returns a 64-bit hash.
+>  */
+> RAPIDHASH_INLINE uint64_t rapidhash_withSeed(const void* key,
+>                                              size_t len,
+>                                              uint64_t seed) RAPIDHASH_NOEXCEPT {
+>   return rapidhash_internal(key, len, seed, rapid_secret);
+> }
+> 
+> /*
+>  *  rapidhash default hash function.
+>  *
+>  *  @param key     Buffer to be hashed.
+>  *  @param len     @key length, in bytes.
+>  *
+>  *  Calls rapidhash_withSeed using provided parameters and the default seed.
+>  *
+>  *  Returns a 64-bit hash.
+>  */
+> RAPIDHASH_INLINE uint64_t rapidhash(const void* key,
+>                                     size_t len) RAPIDHASH_NOEXCEPT {
+>   return rapidhash_withSeed(key, len, RAPID_SEED);
+> }
diff --git a/third_party/rust/chromium_crates_io/patches/cxx/0002-Remove-executable-bit-from-build.js.patch b/third_party/rust/chromium_crates_io/patches/cxx/0002-Remove-executable-bit-from-build.js.patch
new file mode 100644
index 0000000000000..35a4ad0a02d93
--- /dev/null
+++ b/third_party/rust/chromium_crates_io/patches/cxx/0002-Remove-executable-bit-from-build.js.patch
@@ -0,0 +1,17 @@
+From 0b3dd0c355b0be484f87b64b305415e4131e5a3f Mon Sep 17 00:00:00 2001
+From: Adrian Taylor <adetaylor@chromium.org>
+Date: Wed, 8 Nov 2023 16:59:08 +0000
+Subject: [PATCH 2/4] Remove executable bit from JS file
+
+Change-Id: I3665b8a18fea653c61e0f9663ded100d5482921e
+---
+ third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/book/build.js | 0
+ 1 file changed, 0 insertions(+), 0 deletions(-)
+ mode change 100755 => 100644 third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/book/build.js
+
+diff --git a/third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/book/build.js b/third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/book/build.js
+old mode 100755
+new mode 100644
+-- 
+2.42.0.869.gea05f2083d-goog
+
diff --git a/third_party/rust/chromium_crates_io/patches/cxx/0003-Change-cxx-header-include-to-be-an-absolute-path.patch b/third_party/rust/chromium_crates_io/patches/cxx/0003-Change-cxx-header-include-to-be-an-absolute-path.patch
new file mode 100644
index 0000000000000..9d9e0eee7c2f3
--- /dev/null
+++ b/third_party/rust/chromium_crates_io/patches/cxx/0003-Change-cxx-header-include-to-be-an-absolute-path.patch
@@ -0,0 +1,23 @@
+From 608e9f748a6327620f04735ff8eae279c42cd4c9 Mon Sep 17 00:00:00 2001
+From: Adrian Taylor <adetaylor@chromium.org>
+Date: Wed, 8 Nov 2023 17:08:01 +0000
+Subject: [PATCH 3/4] Absolute path for cxx header
+
+Change-Id: Iaaa5965443bd3446ac8cd645936614a24e8bb500
+---
+ third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/src/cxx.cc | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/src/cxx.cc b/third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/src/cxx.cc
+index 2522d61aa33dc..a1cdc44ea1ba9 100644
+--- a/third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/src/cxx.cc
++++ b/third_party/rust/chromium_crates_io/vendor/cxx-1.0.110/src/cxx.cc
+@@ -1,4 +1,4 @@
+-#include "../include/cxx.h"
++#include "third_party/rust/cxx/v1/cxx.h"
+ #include <cstdio>
+ #include <cstring>
+ #include <iostream>
+-- 
+2.42.0.869.gea05f2083d-goog
+
diff --git a/third_party/rust/chromium_crates_io/patches/cxx/0004-Define-exported-cxx-symbols.patch b/third_party/rust/chromium_crates_io/patches/cxx/0004-Define-exported-cxx-symbols.patch
new file mode 100644
index 0000000000000..da5618d344f1a
--- /dev/null
+++ b/third_party/rust/chromium_crates_io/patches/cxx/0004-Define-exported-cxx-symbols.patch
@@ -0,0 +1,867 @@
+From 73844b580d37a74ce57f32eee3087b251e1505ad Mon Sep 17 00:00:00 2001
+From: "Dustin J. Mitchell" <djmitche@chromium.org>
+Date: Mon, 10 Feb 2025 19:54:42 +0000
+Subject: [PATCH] patch 4
+
+---
+ .../vendor/cxx-1.0.140/src/cxx.cc             | 327 ++++++++++--------
+ 1 file changed, 176 insertions(+), 151 deletions(-)
+
+diff --git a/third_party/rust/chromium_crates_io/vendor/cxx-1.0.140/src/cxx.cc b/third_party/rust/chromium_crates_io/vendor/cxx-1.0.140/src/cxx.cc
+index 5741afa229129..1d75716d2cba6 100644
+--- a/third_party/rust/chromium_crates_io/vendor/cxx-1.0.140/src/cxx.cc
++++ b/third_party/rust/chromium_crates_io/vendor/cxx-1.0.140/src/cxx.cc
+@@ -1,79 +1,101 @@
+ #include "third_party/rust/cxx/v1/cxx.h"
+ #include <cstdio>
+ #include <cstring>
+ #include <iostream>
+ #include <memory>
+ 
++#ifndef CXX_RS_EXPORT
++#define CXX_RS_EXPORT
++#endif
++#ifndef CXX_CPP_EXPORT
++#define CXX_CPP_EXPORT
++#endif
++
+ extern "C" {
+-void cxxbridge1$cxx_string$init(std::string *s, const std::uint8_t *ptr,
+-                                std::size_t len) noexcept {
++CXX_RS_EXPORT void cxxbridge1$cxx_string$init(std::string *s,
++                                              const std::uint8_t *ptr,
++                                              std::size_t len) noexcept {
+   new (s) std::string(reinterpret_cast<const char *>(ptr), len);
+ }
+ 
+-void cxxbridge1$cxx_string$destroy(std::string *s) noexcept {
++CXX_RS_EXPORT void cxxbridge1$cxx_string$destroy(std::string *s) noexcept {
+   using std::string;
+   s->~string();
+ }
+ 
+-const char *cxxbridge1$cxx_string$data(const std::string &s) noexcept {
++CXX_RS_EXPORT const char *
++cxxbridge1$cxx_string$data(const std::string &s) noexcept {
+   return s.data();
+ }
+ 
+-std::size_t cxxbridge1$cxx_string$length(const std::string &s) noexcept {
++CXX_RS_EXPORT std::size_t
++cxxbridge1$cxx_string$length(const std::string &s) noexcept {
+   return s.length();
+ }
+ 
+-void cxxbridge1$cxx_string$clear(std::string &s) noexcept { s.clear(); }
++CXX_RS_EXPORT void cxxbridge1$cxx_string$clear(std::string &s) noexcept {
++  s.clear();
++}
+ 
+-void cxxbridge1$cxx_string$reserve_total(std::string &s,
+-                                         size_t new_cap) noexcept {
++CXX_RS_EXPORT void
++cxxbridge1$cxx_string$reserve_total(std::string &s, size_t new_cap) noexcept {
+   s.reserve(new_cap);
+ }
+ 
+-void cxxbridge1$cxx_string$push(std::string &s, const std::uint8_t *ptr,
+-                                std::size_t len) noexcept {
++CXX_RS_EXPORT void cxxbridge1$cxx_string$push(std::string &s,
++                                              const std::uint8_t *ptr,
++                                              std::size_t len) noexcept {
+   s.append(reinterpret_cast<const char *>(ptr), len);
+ }
+ 
+ // rust::String
+-void cxxbridge1$string$new(rust::String *self) noexcept;
+-void cxxbridge1$string$clone(rust::String *self,
+-                             const rust::String &other) noexcept;
+-bool cxxbridge1$string$from_utf8(rust::String *self, const char *ptr,
+-                                 std::size_t len) noexcept;
+-void cxxbridge1$string$from_utf8_lossy(rust::String *self, const char *ptr,
+-                                       std::size_t len) noexcept;
+-bool cxxbridge1$string$from_utf16(rust::String *self, const char16_t *ptr,
+-                                  std::size_t len) noexcept;
+-void cxxbridge1$string$from_utf16_lossy(rust::String *self, const char16_t *ptr,
+-                                        std::size_t len) noexcept;
+-void cxxbridge1$string$drop(rust::String *self) noexcept;
+-const char *cxxbridge1$string$ptr(const rust::String *self) noexcept;
+-std::size_t cxxbridge1$string$len(const rust::String *self) noexcept;
+-std::size_t cxxbridge1$string$capacity(const rust::String *self) noexcept;
+-void cxxbridge1$string$reserve_additional(rust::String *self,
+-                                          size_t additional) noexcept;
+-void cxxbridge1$string$reserve_total(rust::String *self,
+-                                     size_t new_cap) noexcept;
++CXX_RS_EXPORT void cxxbridge1$string$new(rust::String *self) noexcept;
++CXX_RS_EXPORT void cxxbridge1$string$clone(rust::String *self,
++                                           const rust::String &other) noexcept;
++CXX_RS_EXPORT bool cxxbridge1$string$from_utf8(rust::String *self,
++                                               const char *ptr,
++                                               std::size_t len) noexcept;
++CXX_RS_EXPORT void cxxbridge1$string$from_utf8_lossy(rust::String *self,
++                                                     const char *ptr,
++                                                     std::size_t len) noexcept;
++CXX_RS_EXPORT bool cxxbridge1$string$from_utf16(rust::String *self,
++                                                const char16_t *ptr,
++                                                std::size_t len) noexcept;
++CXX_RS_EXPORT void cxxbridge1$string$from_utf16_lossy(rust::String *self,
++                                                      const char16_t *ptr,
++                                                      std::size_t len) noexcept;
++CXX_RS_EXPORT void cxxbridge1$string$drop(rust::String *self) noexcept;
++CXX_RS_EXPORT const char *
++cxxbridge1$string$ptr(const rust::String *self) noexcept;
++CXX_RS_EXPORT std::size_t
++cxxbridge1$string$len(const rust::String *self) noexcept;
++CXX_RS_EXPORT std::size_t
++cxxbridge1$string$capacity(const rust::String *self) noexcept;
++CXX_RS_EXPORT void
++cxxbridge1$string$reserve_additional(rust::String *self,
++                                     size_t additional) noexcept;
++CXX_RS_EXPORT void cxxbridge1$string$reserve_total(rust::String *self,
++                                                   size_t new_cap) noexcept;
+ 
+ // rust::Str
+-void cxxbridge1$str$new(rust::Str *self) noexcept;
+-void cxxbridge1$str$ref(rust::Str *self, const rust::String *string) noexcept;
+-bool cxxbridge1$str$from(rust::Str *self, const char *ptr,
+-                         std::size_t len) noexcept;
+-const char *cxxbridge1$str$ptr(const rust::Str *self) noexcept;
+-std::size_t cxxbridge1$str$len(const rust::Str *self) noexcept;
++CXX_RS_EXPORT void cxxbridge1$str$new(rust::Str *self) noexcept;
++CXX_RS_EXPORT void cxxbridge1$str$ref(rust::Str *self,
++                                      const rust::String *string) noexcept;
++CXX_RS_EXPORT bool cxxbridge1$str$from(rust::Str *self, const char *ptr,
++                                       std::size_t len) noexcept;
++CXX_RS_EXPORT const char *cxxbridge1$str$ptr(const rust::Str *self) noexcept;
++CXX_RS_EXPORT std::size_t cxxbridge1$str$len(const rust::Str *self) noexcept;
+ 
+ // rust::Slice
+-void cxxbridge1$slice$new(void *self, const void *ptr,
+-                          std::size_t len) noexcept;
+-void *cxxbridge1$slice$ptr(const void *self) noexcept;
+-std::size_t cxxbridge1$slice$len(const void *self) noexcept;
++CXX_RS_EXPORT void cxxbridge1$slice$new(void *self, const void *ptr,
++                                        std::size_t len) noexcept;
++CXX_RS_EXPORT void *cxxbridge1$slice$ptr(const void *self) noexcept;
++CXX_RS_EXPORT std::size_t cxxbridge1$slice$len(const void *self) noexcept;
+ } // extern "C"
+ 
+ namespace rust {
+ inline namespace cxxbridge1 {
+ 
+ template <typename Exception>
+ void panic [[noreturn]] (const char *msg) {
+ #if defined(RUST_CXX_NO_EXCEPTIONS)
+@@ -81,323 +103,324 @@ void panic [[noreturn]] (const char *msg) {
+   std::abort();
+ #else
+   throw Exception(msg);
+ #endif
+ }
+ 
+ template void panic<std::out_of_range> [[noreturn]] (const char *msg);
+ 
++
+ template <typename T>
+ static bool is_aligned(const void *ptr) noexcept {
+   auto iptr = reinterpret_cast<std::uintptr_t>(ptr);
+   return !(iptr % alignof(T));
+ }
+ 
+-String::String() noexcept { cxxbridge1$string$new(this); }
++CXX_CPP_EXPORT String::String() noexcept { cxxbridge1$string$new(this); }
+ 
+-String::String(const String &other) noexcept {
++CXX_CPP_EXPORT String::String(const String &other) noexcept {
+   cxxbridge1$string$clone(this, other);
+ }
+ 
+-String::String(String &&other) noexcept : repr(other.repr) {
++CXX_CPP_EXPORT String::String(String &&other) noexcept : repr(other.repr) {
+   cxxbridge1$string$new(&other);
+ }
+ 
+-String::~String() noexcept { cxxbridge1$string$drop(this); }
++CXX_CPP_EXPORT String::~String() noexcept { cxxbridge1$string$drop(this); }
+ 
+ static void initString(String *self, const char *s, std::size_t len) {
+   if (!cxxbridge1$string$from_utf8(self, s, len)) {
+     panic<std::invalid_argument>("data for rust::String is not utf-8");
+   }
+ }
+ 
+ static void initString(String *self, const char16_t *s, std::size_t len) {
+   if (!cxxbridge1$string$from_utf16(self, s, len)) {
+     panic<std::invalid_argument>("data for rust::String is not utf-16");
+   }
+ }
+ 
+-String::String(const std::string &s) { initString(this, s.data(), s.length()); }
++CXX_CPP_EXPORT String::String(const std::string &s) { initString(this, s.data(), s.length()); }
+ 
+-String::String(const char *s) {
++CXX_CPP_EXPORT String::String(const char *s) {
+   assert(s != nullptr);
+   initString(this, s, std::strlen(s));
+ }
+ 
+-String::String(const char *s, std::size_t len) {
++CXX_CPP_EXPORT String::String(const char *s, std::size_t len) {
+   assert(s != nullptr || len == 0);
+   initString(this,
+              s == nullptr && len == 0 ? reinterpret_cast<const char *>(1) : s,
+              len);
+ }
+ 
+ #if __cplusplus >= 202002L
+-String::String(const char8_t *s) : String(reinterpret_cast<const char *>(s)) {}
++CXX_CPP_EXPORT String::String(const char8_t *s) : String(reinterpret_cast<const char *>(s)) {}
+ 
+-String::String(const char8_t *s, std::size_t len)
++CXX_CPP_EXPORT String::String(const char8_t *s, std::size_t len)
+     : String(reinterpret_cast<const char *>(s), len) {}
+ #endif
+ 
+-String::String(const char16_t *s) {
++CXX_CPP_EXPORT String::String(const char16_t *s) {
+   assert(s != nullptr);
+   assert(is_aligned<char16_t>(s));
+   initString(this, s, std::char_traits<char16_t>::length(s));
+ }
+ 
+-String::String(const char16_t *s, std::size_t len) {
++CXX_CPP_EXPORT String::String(const char16_t *s, std::size_t len) {
+   assert(s != nullptr || len == 0);
+   assert(is_aligned<char16_t>(s));
+   initString(this,
+              s == nullptr && len == 0 ? reinterpret_cast<const char16_t *>(2)
+                                       : s,
+              len);
+ }
+ 
+ struct String::lossy_t {};
+ 
+-String::String(lossy_t, const char *s, std::size_t len) noexcept {
++CXX_CPP_EXPORT String::String(lossy_t, const char *s, std::size_t len) noexcept {
+   cxxbridge1$string$from_utf8_lossy(
+       this, s == nullptr && len == 0 ? reinterpret_cast<const char *>(1) : s,
+       len);
+ }
+ 
+-String::String(lossy_t, const char16_t *s, std::size_t len) noexcept {
++CXX_CPP_EXPORT String::String(lossy_t, const char16_t *s, std::size_t len) noexcept {
+   cxxbridge1$string$from_utf16_lossy(
+       this,
+       s == nullptr && len == 0 ? reinterpret_cast<const char16_t *>(2) : s,
+       len);
+ }
+ 
+-String String::lossy(const std::string &s) noexcept {
++CXX_CPP_EXPORT String String::lossy(const std::string &s) noexcept {
+   return String::lossy(s.data(), s.length());
+ }
+ 
+-String String::lossy(const char *s) noexcept {
++CXX_CPP_EXPORT String String::lossy(const char *s) noexcept {
+   assert(s != nullptr);
+   return String::lossy(s, std::strlen(s));
+ }
+ 
+-String String::lossy(const char *s, std::size_t len) noexcept {
++CXX_CPP_EXPORT String String::lossy(const char *s, std::size_t len) noexcept {
+   assert(s != nullptr || len == 0);
+   return String(lossy_t{}, s, len);
+ }
+ 
+-String String::lossy(const char16_t *s) noexcept {
++CXX_CPP_EXPORT String String::lossy(const char16_t *s) noexcept {
+   assert(s != nullptr);
+   assert(is_aligned<char16_t>(s));
+   return String(lossy_t{}, s, std::char_traits<char16_t>::length(s));
+ }
+ 
+-String String::lossy(const char16_t *s, std::size_t len) noexcept {
++CXX_CPP_EXPORT String String::lossy(const char16_t *s, std::size_t len) noexcept {
+   assert(s != nullptr || len == 0);
+   assert(is_aligned<char16_t>(s));
+   return String(lossy_t{}, s, len);
+ }
+ 
+-String &String::operator=(const String &other) & noexcept {
++CXX_CPP_EXPORT String &String::operator=(const String &other) & noexcept {
+   if (this != &other) {
+     cxxbridge1$string$drop(this);
+     cxxbridge1$string$clone(this, other);
+   }
+   return *this;
+ }
+ 
+-String &String::operator=(String &&other) & noexcept {
++CXX_CPP_EXPORT String &String::operator=(String &&other) & noexcept {
+   cxxbridge1$string$drop(this);
+   this->repr = other.repr;
+   cxxbridge1$string$new(&other);
+   return *this;
+ }
+ 
+-String::operator std::string() const {
++CXX_CPP_EXPORT String::operator std::string() const {
+   return std::string(this->data(), this->size());
+ }
+ 
+-const char *String::data() const noexcept {
++CXX_CPP_EXPORT const char *String::data() const noexcept {
+   return cxxbridge1$string$ptr(this);
+ }
+ 
+-std::size_t String::size() const noexcept {
++CXX_CPP_EXPORT std::size_t String::size() const noexcept {
+   return cxxbridge1$string$len(this);
+ }
+ 
+-std::size_t String::length() const noexcept {
++CXX_CPP_EXPORT std::size_t String::length() const noexcept {
+   return cxxbridge1$string$len(this);
+ }
+ 
+-bool String::empty() const noexcept { return this->size() == 0; }
++CXX_CPP_EXPORT bool String::empty() const noexcept { return this->size() == 0; }
+ 
+-const char *String::c_str() noexcept {
++CXX_CPP_EXPORT const char *String::c_str() noexcept {
+   auto len = this->length();
+   cxxbridge1$string$reserve_additional(this, 1);
+   auto ptr = this->data();
+   const_cast<char *>(ptr)[len] = '\0';
+   return ptr;
+ }
+ 
+-std::size_t String::capacity() const noexcept {
++CXX_CPP_EXPORT std::size_t String::capacity() const noexcept {
+   return cxxbridge1$string$capacity(this);
+ }
+ 
+-void String::reserve(std::size_t new_cap) noexcept {
++CXX_CPP_EXPORT void String::reserve(std::size_t new_cap) noexcept {
+   cxxbridge1$string$reserve_total(this, new_cap);
+ }
+ 
+-String::iterator String::begin() noexcept {
++CXX_CPP_EXPORT String::iterator String::begin() noexcept {
+   return const_cast<char *>(this->data());
+ }
+ 
+-String::iterator String::end() noexcept {
++CXX_CPP_EXPORT String::iterator String::end() noexcept {
+   return const_cast<char *>(this->data()) + this->size();
+ }
+ 
+-String::const_iterator String::begin() const noexcept { return this->cbegin(); }
++CXX_CPP_EXPORT String::const_iterator String::begin() const noexcept { return this->cbegin(); }
+ 
+-String::const_iterator String::end() const noexcept { return this->cend(); }
++CXX_CPP_EXPORT String::const_iterator String::end() const noexcept { return this->cend(); }
+ 
+-String::const_iterator String::cbegin() const noexcept { return this->data(); }
++CXX_CPP_EXPORT String::const_iterator String::cbegin() const noexcept { return this->data(); }
+ 
+-String::const_iterator String::cend() const noexcept {
++CXX_CPP_EXPORT String::const_iterator String::cend() const noexcept {
+   return this->data() + this->size();
+ }
+ 
+-bool String::operator==(const String &rhs) const noexcept {
++CXX_CPP_EXPORT bool String::operator==(const String &rhs) const noexcept {
+   return rust::Str(*this) == rust::Str(rhs);
+ }
+ 
+-bool String::operator!=(const String &rhs) const noexcept {
++CXX_CPP_EXPORT bool String::operator!=(const String &rhs) const noexcept {
+   return rust::Str(*this) != rust::Str(rhs);
+ }
+ 
+-bool String::operator<(const String &rhs) const noexcept {
++CXX_CPP_EXPORT bool String::operator<(const String &rhs) const noexcept {
+   return rust::Str(*this) < rust::Str(rhs);
+ }
+ 
+-bool String::operator<=(const String &rhs) const noexcept {
++CXX_CPP_EXPORT bool String::operator<=(const String &rhs) const noexcept {
+   return rust::Str(*this) <= rust::Str(rhs);
+ }
+ 
+-bool String::operator>(const String &rhs) const noexcept {
++CXX_CPP_EXPORT bool String::operator>(const String &rhs) const noexcept {
+   return rust::Str(*this) > rust::Str(rhs);
+ }
+ 
+-bool String::operator>=(const String &rhs) const noexcept {
++CXX_CPP_EXPORT bool String::operator>=(const String &rhs) const noexcept {
+   return rust::Str(*this) >= rust::Str(rhs);
+ }
+ 
+-void String::swap(String &rhs) noexcept {
++CXX_CPP_EXPORT void String::swap(String &rhs) noexcept {
+   using std::swap;
+   swap(this->repr, rhs.repr);
+ }
+ 
+-String::String(unsafe_bitcopy_t, const String &bits) noexcept
++CXX_CPP_EXPORT String::String(unsafe_bitcopy_t, const String &bits) noexcept
+     : repr(bits.repr) {}
+ 
+-std::ostream &operator<<(std::ostream &os, const String &s) {
++CXX_CPP_EXPORT std::ostream &operator<<(std::ostream &os, const String &s) {
+   os.write(s.data(), static_cast<std::streamsize>(s.size()));
+   return os;
+ }
+ 
+-Str::Str() noexcept { cxxbridge1$str$new(this); }
++CXX_CPP_EXPORT Str::Str() noexcept { cxxbridge1$str$new(this); }
+ 
+-Str::Str(const String &s) noexcept { cxxbridge1$str$ref(this, &s); }
++CXX_CPP_EXPORT Str::Str(const String &s) noexcept { cxxbridge1$str$ref(this, &s); }
+ 
+ static void initStr(Str *self, const char *ptr, std::size_t len) {
+   if (!cxxbridge1$str$from(self, ptr, len)) {
+     panic<std::invalid_argument>("data for rust::Str is not utf-8");
+   }
+ }
+ 
+-Str::Str(const std::string &s) { initStr(this, s.data(), s.length()); }
++CXX_CPP_EXPORT Str::Str(const std::string &s) { initStr(this, s.data(), s.length()); }
+ 
+-Str::Str(const char *s) {
++CXX_CPP_EXPORT Str::Str(const char *s) {
+   assert(s != nullptr);
+   initStr(this, s, std::strlen(s));
+ }
+ 
+-Str::Str(const char *s, std::size_t len) {
++CXX_CPP_EXPORT Str::Str(const char *s, std::size_t len) {
+   assert(s != nullptr || len == 0);
+   initStr(this,
+           s == nullptr && len == 0 ? reinterpret_cast<const char *>(1) : s,
+           len);
+ }
+ 
+-Str::operator std::string() const {
++CXX_CPP_EXPORT Str::operator std::string() const {
+   return std::string(this->data(), this->size());
+ }
+ 
+-const char *Str::data() const noexcept { return cxxbridge1$str$ptr(this); }
++CXX_CPP_EXPORT const char *Str::data() const noexcept { return cxxbridge1$str$ptr(this); }
+ 
+-std::size_t Str::size() const noexcept { return cxxbridge1$str$len(this); }
++CXX_CPP_EXPORT std::size_t Str::size() const noexcept { return cxxbridge1$str$len(this); }
+ 
+-std::size_t Str::length() const noexcept { return this->size(); }
++CXX_CPP_EXPORT std::size_t Str::length() const noexcept { return this->size(); }
+ 
+-bool Str::empty() const noexcept { return this->size() == 0; }
++CXX_CPP_EXPORT bool Str::empty() const noexcept { return this->size() == 0; }
+ 
+-Str::const_iterator Str::begin() const noexcept { return this->cbegin(); }
++CXX_CPP_EXPORT Str::const_iterator Str::begin() const noexcept { return this->cbegin(); }
+ 
+-Str::const_iterator Str::end() const noexcept { return this->cend(); }
++CXX_CPP_EXPORT Str::const_iterator Str::end() const noexcept { return this->cend(); }
+ 
+-Str::const_iterator Str::cbegin() const noexcept { return this->data(); }
++CXX_CPP_EXPORT Str::const_iterator Str::cbegin() const noexcept { return this->data(); }
+ 
+-Str::const_iterator Str::cend() const noexcept {
++CXX_CPP_EXPORT Str::const_iterator Str::cend() const noexcept {
+   return this->data() + this->size();
+ }
+ 
+-bool Str::operator==(const Str &rhs) const noexcept {
++CXX_CPP_EXPORT bool Str::operator==(const Str &rhs) const noexcept {
+   return this->size() == rhs.size() &&
+          std::equal(this->begin(), this->end(), rhs.begin());
+ }
+ 
+-bool Str::operator!=(const Str &rhs) const noexcept { return !(*this == rhs); }
++CXX_CPP_EXPORT bool Str::operator!=(const Str &rhs) const noexcept { return !(*this == rhs); }
+ 
+-bool Str::operator<(const Str &rhs) const noexcept {
++CXX_CPP_EXPORT bool Str::operator<(const Str &rhs) const noexcept {
+   return std::lexicographical_compare(this->begin(), this->end(), rhs.begin(),
+                                       rhs.end());
+ }
+ 
+-bool Str::operator<=(const Str &rhs) const noexcept {
++CXX_CPP_EXPORT bool Str::operator<=(const Str &rhs) const noexcept {
+   // std::mismatch(this->begin(), this->end(), rhs.begin(), rhs.end()), except
+   // without Undefined Behavior on C++11 if rhs is shorter than *this.
+   const_iterator liter = this->begin(), lend = this->end(), riter = rhs.begin(),
+                  rend = rhs.end();
+   while (liter != lend && riter != rend && *liter == *riter) {
+     ++liter, ++riter;
+   }
+   if (liter == lend) {
+     return true; // equal or *this is a prefix of rhs
+   } else if (riter == rend) {
+     return false; // rhs is a prefix of *this
+   } else {
+     return *liter <= *riter;
+   }
+ }
+ 
+-bool Str::operator>(const Str &rhs) const noexcept { return rhs < *this; }
++CXX_CPP_EXPORT bool Str::operator>(const Str &rhs) const noexcept { return rhs < *this; }
+ 
+-bool Str::operator>=(const Str &rhs) const noexcept { return rhs <= *this; }
++CXX_CPP_EXPORT bool Str::operator>=(const Str &rhs) const noexcept { return rhs <= *this; }
+ 
+-void Str::swap(Str &rhs) noexcept {
++CXX_CPP_EXPORT void Str::swap(Str &rhs) noexcept {
+   using std::swap;
+   swap(this->repr, rhs.repr);
+ }
+ 
+-std::ostream &operator<<(std::ostream &os, const Str &s) {
++CXX_CPP_EXPORT std::ostream &operator<<(std::ostream &os, const Str &s) {
+   os.write(s.data(), static_cast<std::streamsize>(s.size()));
+   return os;
+ }
+ 
+-void sliceInit(void *self, const void *ptr, std::size_t len) noexcept {
++CXX_CPP_EXPORT void sliceInit(void *self, const void *ptr, std::size_t len) noexcept {
+   cxxbridge1$slice$new(self, ptr, len);
+ }
+ 
+-void *slicePtr(const void *self) noexcept { return cxxbridge1$slice$ptr(self); }
++CXX_CPP_EXPORT void *slicePtr(const void *self) noexcept { return cxxbridge1$slice$ptr(self); }
+ 
+-std::size_t sliceLen(const void *self) noexcept {
++CXX_CPP_EXPORT std::size_t sliceLen(const void *self) noexcept {
+   return cxxbridge1$slice$len(self);
+ }
+ 
+ // Rust specifies that usize is ABI compatible with C's uintptr_t.
+ // https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html#isize-and-usize
+ // However there is no direct Rust equivalent for size_t. C does not guarantee
+ // that size_t and uintptr_t are compatible. In practice though, on all
+ // platforms supported by Rust, they are identical for ABI purposes. See the
+@@ -458,58 +481,59 @@ static_assert(!std::is_same<Vec<std::uint8_t>::const_iterator,
+ 
+ static const char *errorCopy(const char *ptr, std::size_t len) {
+   char *copy = new char[len];
+   std::memcpy(copy, ptr, len);
+   return copy;
+ }
+ 
+ extern "C" {
+-const char *cxxbridge1$error(const char *ptr, std::size_t len) noexcept {
++CXX_RS_EXPORT const char *cxxbridge1$error(const char *ptr,
++                                           std::size_t len) noexcept {
+   return errorCopy(ptr, len);
+ }
+ } // extern "C"
+ 
+-Error::Error(const Error &other)
++CXX_CPP_EXPORT Error::Error(const Error &other)
+     : std::exception(other),
+       msg(other.msg ? errorCopy(other.msg, other.len) : nullptr),
+       len(other.len) {}
+ 
+-Error::Error(Error &&other) noexcept
++CXX_CPP_EXPORT Error::Error(Error &&other) noexcept
+     : std::exception(std::move(other)), msg(other.msg), len(other.len) {
+   other.msg = nullptr;
+   other.len = 0;
+ }
+ 
+-Error::~Error() noexcept { delete[] this->msg; }
++CXX_CPP_EXPORT Error::~Error() noexcept { delete[] this->msg; }
+ 
+-Error &Error::operator=(const Error &other) & {
++CXX_CPP_EXPORT Error &Error::operator=(const Error &other) & {
+   if (this != &other) {
+     std::exception::operator=(other);
+     delete[] this->msg;
+     this->msg = nullptr;
+     if (other.msg) {
+       this->msg = errorCopy(other.msg, other.len);
+       this->len = other.len;
+     }
+   }
+   return *this;
+ }
+ 
+-Error &Error::operator=(Error &&other) & noexcept {
++CXX_CPP_EXPORT Error &Error::operator=(Error &&other) & noexcept {
+   std::exception::operator=(std::move(other));
+   delete[] this->msg;
+   this->msg = other.msg;
+   this->len = other.len;
+   other.msg = nullptr;
+   other.len = 0;
+   return *this;
+ }
+ 
+-const char *Error::what() const noexcept { return this->msg; }
++CXX_CPP_EXPORT const char *Error::what() const noexcept { return this->msg; }
+ 
+ namespace {
+ template <typename T>
+ union MaybeUninit {
+   T value;
+   MaybeUninit() {}
+   ~MaybeUninit() {}
+ };
+@@ -518,17 +542,17 @@ union MaybeUninit {
+ namespace repr {
+ struct PtrLen final {
+   void *ptr;
+   std::size_t len;
+ };
+ } // namespace repr
+ 
+ extern "C" {
+-repr::PtrLen cxxbridge1$exception(const char *, std::size_t len) noexcept;
++CXX_RS_EXPORT repr::PtrLen cxxbridge1$exception(const char *, std::size_t len) noexcept;
+ }
+ 
+ namespace detail {
+ // On some platforms size_t is the same C++ type as one of the sized integer
+ // types; on others it is a distinct type. Only in the latter case do we need to
+ // define a specialized impl of rust::Vec<size_t>, because in the former case it
+ // would collide with one of the other specializations.
+ using usize_if_unique =
+@@ -549,130 +573,131 @@ class Fail final {
+   repr::PtrLen &throw$;
+ 
+ public:
+   Fail(repr::PtrLen &throw$) noexcept : throw$(throw$) {}
+   void operator()(const char *) noexcept;
+   void operator()(const std::string &) noexcept;
+ };
+ 
+-void Fail::operator()(const char *catch$) noexcept {
++CXX_CPP_EXPORT void Fail::operator()(const char *catch$) noexcept {
+   throw$ = cxxbridge1$exception(catch$, std::strlen(catch$));
+ }
+ 
+-void Fail::operator()(const std::string &catch$) noexcept {
++CXX_CPP_EXPORT void Fail::operator()(const std::string &catch$) noexcept {
+   throw$ = cxxbridge1$exception(catch$.data(), catch$.length());
+ }
+ } // namespace detail
+ 
+ } // namespace cxxbridge1
+ } // namespace rust
+ 
+ namespace {
+ template <typename T>
+ void destroy(T *ptr) {
+   ptr->~T();
+ }
+ } // namespace
+ 
+ extern "C" {
+-void cxxbridge1$unique_ptr$std$string$null(
++CXX_RS_EXPORT void cxxbridge1$unique_ptr$std$string$null(
+     std::unique_ptr<std::string> *ptr) noexcept {
+   new (ptr) std::unique_ptr<std::string>();
+ }
+-void cxxbridge1$unique_ptr$std$string$raw(std::unique_ptr<std::string> *ptr,
+-                                          std::string *raw) noexcept {
++CXX_RS_EXPORT void
++cxxbridge1$unique_ptr$std$string$raw(std::unique_ptr<std::string> *ptr,
++                                     std::string *raw) noexcept {
+   new (ptr) std::unique_ptr<std::string>(raw);
+ }
+-const std::string *cxxbridge1$unique_ptr$std$string$get(
++CXX_RS_EXPORT const std::string *cxxbridge1$unique_ptr$std$string$get(
+     const std::unique_ptr<std::string> &ptr) noexcept {
+   return ptr.get();
+ }
+-std::string *cxxbridge1$unique_ptr$std$string$release(
++CXX_RS_EXPORT std::string *cxxbridge1$unique_ptr$std$string$release(
+     std::unique_ptr<std::string> &ptr) noexcept {
+   return ptr.release();
+ }
+-void cxxbridge1$unique_ptr$std$string$drop(
++CXX_RS_EXPORT void cxxbridge1$unique_ptr$std$string$drop(
+     std::unique_ptr<std::string> *ptr) noexcept {
+   ptr->~unique_ptr();
+ }
+ } // extern "C"
+ 
+ namespace {
+ const std::size_t kMaxExpectedWordsInString = 8;
+ static_assert(alignof(std::string) <= alignof(void *),
+               "unexpectedly large std::string alignment");
+ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),
+               "unexpectedly large std::string size");
+ } // namespace
+ 
+ #define STD_VECTOR_OPS(RUST_TYPE, CXX_TYPE)                                    \
+-  std::vector<CXX_TYPE> *cxxbridge1$std$vector$##RUST_TYPE##$new() noexcept {  \
++  CXX_RS_EXPORT std::vector<CXX_TYPE> *cxxbridge1$std$vector$##RUST_TYPE##$new() noexcept {  \
+     return new std::vector<CXX_TYPE>();                                        \
+   }                                                                            \
+-  std::size_t cxxbridge1$std$vector$##RUST_TYPE##$size(                        \
++  CXX_RS_EXPORT std::size_t cxxbridge1$std$vector$##RUST_TYPE##$size(                        \
+       const std::vector<CXX_TYPE> &s) noexcept {                               \
+     return s.size();                                                           \
+   }                                                                            \
+-  CXX_TYPE *cxxbridge1$std$vector$##RUST_TYPE##$get_unchecked(                 \
++  CXX_RS_EXPORT CXX_TYPE *cxxbridge1$std$vector$##RUST_TYPE##$get_unchecked(                 \
+       std::vector<CXX_TYPE> *s, std::size_t pos) noexcept {                    \
+     return &(*s)[pos];                                                         \
+   }                                                                            \
+-  void cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$null(                    \
++  CXX_RS_EXPORT void cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$null(                    \
+       std::unique_ptr<std::vector<CXX_TYPE>> *ptr) noexcept {                  \
+     new (ptr) std::unique_ptr<std::vector<CXX_TYPE>>();                        \
+   }                                                                            \
+-  void cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$raw(                     \
++  CXX_RS_EXPORT void cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$raw(                     \
+       std::unique_ptr<std::vector<CXX_TYPE>> *ptr,                             \
+       std::vector<CXX_TYPE> *raw) noexcept {                                   \
+     new (ptr) std::unique_ptr<std::vector<CXX_TYPE>>(raw);                     \
+   }                                                                            \
+-  const std::vector<CXX_TYPE>                                                  \
++  CXX_RS_EXPORT const std::vector<CXX_TYPE>                                                  \
+       *cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$get(                     \
+           const std::unique_ptr<std::vector<CXX_TYPE>> &ptr) noexcept {        \
+     return ptr.get();                                                          \
+   }                                                                            \
+-  std::vector<CXX_TYPE>                                                        \
++  CXX_RS_EXPORT std::vector<CXX_TYPE>                                                        \
+       *cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$release(                 \
+           std::unique_ptr<std::vector<CXX_TYPE>> &ptr) noexcept {              \
+     return ptr.release();                                                      \
+   }                                                                            \
+-  void cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$drop(                    \
++  CXX_RS_EXPORT void cxxbridge1$unique_ptr$std$vector$##RUST_TYPE##$drop(                    \
+       std::unique_ptr<std::vector<CXX_TYPE>> *ptr) noexcept {                  \
+     ptr->~unique_ptr();                                                        \
+   }
+ 
+ #define STD_VECTOR_TRIVIAL_OPS(RUST_TYPE, CXX_TYPE)                            \
+-  void cxxbridge1$std$vector$##RUST_TYPE##$push_back(                          \
++  CXX_RS_EXPORT void cxxbridge1$std$vector$##RUST_TYPE##$push_back(                          \
+       std::vector<CXX_TYPE> *v, CXX_TYPE *value) noexcept {                    \
+     v->push_back(std::move(*value));                                           \
+     destroy(value);                                                            \
+   }                                                                            \
+-  void cxxbridge1$std$vector$##RUST_TYPE##$pop_back(std::vector<CXX_TYPE> *v,  \
++  CXX_RS_EXPORT void cxxbridge1$std$vector$##RUST_TYPE##$pop_back(std::vector<CXX_TYPE> *v,  \
+                                                     CXX_TYPE *out) noexcept {  \
+     new (out) CXX_TYPE(std::move(v->back()));                                  \
+     v->pop_back();                                                             \
+   }
+ 
+ #define RUST_VEC_EXTERNS(RUST_TYPE, CXX_TYPE)                                  \
+-  void cxxbridge1$rust_vec$##RUST_TYPE##$new(                                  \
++  CXX_RS_EXPORT void cxxbridge1$rust_vec$##RUST_TYPE##$new(                                  \
+       rust::Vec<CXX_TYPE> *ptr) noexcept;                                      \
+-  void cxxbridge1$rust_vec$##RUST_TYPE##$drop(                                 \
++  CXX_RS_EXPORT void cxxbridge1$rust_vec$##RUST_TYPE##$drop(                                 \
+       rust::Vec<CXX_TYPE> *ptr) noexcept;                                      \
+-  std::size_t cxxbridge1$rust_vec$##RUST_TYPE##$len(                           \
++  CXX_RS_EXPORT std::size_t cxxbridge1$rust_vec$##RUST_TYPE##$len(                           \
+       const rust::Vec<CXX_TYPE> *ptr) noexcept;                                \
+-  std::size_t cxxbridge1$rust_vec$##RUST_TYPE##$capacity(                      \
++  CXX_RS_EXPORT std::size_t cxxbridge1$rust_vec$##RUST_TYPE##$capacity(                      \
+       const rust::Vec<CXX_TYPE> *ptr) noexcept;                                \
+-  const CXX_TYPE *cxxbridge1$rust_vec$##RUST_TYPE##$data(                      \
++  CXX_RS_EXPORT const CXX_TYPE *cxxbridge1$rust_vec$##RUST_TYPE##$data(                      \
+       const rust::Vec<CXX_TYPE> *ptr) noexcept;                                \
+-  void cxxbridge1$rust_vec$##RUST_TYPE##$reserve_total(                        \
++  CXX_RS_EXPORT void cxxbridge1$rust_vec$##RUST_TYPE##$reserve_total(                        \
+       rust::Vec<CXX_TYPE> *ptr, std::size_t new_cap) noexcept;                 \
+-  void cxxbridge1$rust_vec$##RUST_TYPE##$set_len(rust::Vec<CXX_TYPE> *ptr,     \
++  CXX_RS_EXPORT void cxxbridge1$rust_vec$##RUST_TYPE##$set_len(rust::Vec<CXX_TYPE> *ptr,     \
+                                                  std::size_t len) noexcept;    \
+-  void cxxbridge1$rust_vec$##RUST_TYPE##$truncate(rust::Vec<CXX_TYPE> *ptr,    \
++  CXX_RS_EXPORT void cxxbridge1$rust_vec$##RUST_TYPE##$truncate(rust::Vec<CXX_TYPE> *ptr,    \
+                                                   std::size_t len) noexcept;
+ 
+ #define RUST_VEC_OPS(RUST_TYPE, CXX_TYPE)                                      \
+   template <>                                                                  \
+   Vec<CXX_TYPE>::Vec() noexcept {                                              \
+     cxxbridge1$rust_vec$##RUST_TYPE##$new(this);                               \
+   }                                                                            \
+   template <>                                                                  \
+@@ -702,62 +727,62 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),
+   template <>                                                                  \
+   void Vec<CXX_TYPE>::truncate(std::size_t len) {                              \
+     cxxbridge1$rust_vec$##RUST_TYPE##$truncate(this, len);                     \
+   }
+ 
+ #define SHARED_PTR_OPS(RUST_TYPE, CXX_TYPE)                                    \
+   static_assert(sizeof(std::shared_ptr<CXX_TYPE>) == 2 * sizeof(void *), "");  \
+   static_assert(alignof(std::shared_ptr<CXX_TYPE>) == alignof(void *), "");    \
+-  void cxxbridge1$std$shared_ptr$##RUST_TYPE##$null(                           \
++  CXX_RS_EXPORT void cxxbridge1$std$shared_ptr$##RUST_TYPE##$null(             \
+       std::shared_ptr<CXX_TYPE> *ptr) noexcept {                               \
+     new (ptr) std::shared_ptr<CXX_TYPE>();                                     \
+   }                                                                            \
+-  CXX_TYPE *cxxbridge1$std$shared_ptr$##RUST_TYPE##$uninit(                    \
++  CXX_RS_EXPORT CXX_TYPE *cxxbridge1$std$shared_ptr$##RUST_TYPE##$uninit(      \
+       std::shared_ptr<CXX_TYPE> *ptr) noexcept {                               \
+     CXX_TYPE *uninit =                                                         \
+         reinterpret_cast<CXX_TYPE *>(new rust::MaybeUninit<CXX_TYPE>);         \
+     new (ptr) std::shared_ptr<CXX_TYPE>(uninit);                               \
+     return uninit;                                                             \
+   }                                                                            \
+-  void cxxbridge1$std$shared_ptr$##RUST_TYPE##$clone(                          \
++  CXX_RS_EXPORT void cxxbridge1$std$shared_ptr$##RUST_TYPE##$clone(            \
+       const std::shared_ptr<CXX_TYPE> &self,                                   \
+       std::shared_ptr<CXX_TYPE> *ptr) noexcept {                               \
+     new (ptr) std::shared_ptr<CXX_TYPE>(self);                                 \
+   }                                                                            \
+-  const CXX_TYPE *cxxbridge1$std$shared_ptr$##RUST_TYPE##$get(                 \
++  CXX_RS_EXPORT const CXX_TYPE *cxxbridge1$std$shared_ptr$##RUST_TYPE##$get(   \
+       const std::shared_ptr<CXX_TYPE> &self) noexcept {                        \
+     return self.get();                                                         \
+   }                                                                            \
+-  void cxxbridge1$std$shared_ptr$##RUST_TYPE##$drop(                           \
++  CXX_RS_EXPORT void cxxbridge1$std$shared_ptr$##RUST_TYPE##$drop(             \
+       const std::shared_ptr<CXX_TYPE> *self) noexcept {                        \
+     self->~shared_ptr();                                                       \
+   }                                                                            \
+   static_assert(sizeof(std::weak_ptr<CXX_TYPE>) == 2 * sizeof(void *), "");    \
+   static_assert(alignof(std::weak_ptr<CXX_TYPE>) == alignof(void *), "");      \
+-  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$null(                             \
++  CXX_RS_EXPORT void cxxbridge1$std$weak_ptr$##RUST_TYPE##$null(               \
+       std::weak_ptr<CXX_TYPE> *ptr) noexcept {                                 \
+     new (ptr) std::weak_ptr<CXX_TYPE>();                                       \
+   }                                                                            \
+-  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$clone(                            \
++  CXX_RS_EXPORT void cxxbridge1$std$weak_ptr$##RUST_TYPE##$clone(              \
+       const std::weak_ptr<CXX_TYPE> &self,                                     \
+       std::weak_ptr<CXX_TYPE> *ptr) noexcept {                                 \
+     new (ptr) std::weak_ptr<CXX_TYPE>(self);                                   \
+   }                                                                            \
+-  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$downgrade(                        \
++  CXX_RS_EXPORT void cxxbridge1$std$weak_ptr$##RUST_TYPE##$downgrade(          \
+       const std::shared_ptr<CXX_TYPE> &shared,                                 \
+       std::weak_ptr<CXX_TYPE> *weak) noexcept {                                \
+     new (weak) std::weak_ptr<CXX_TYPE>(shared);                                \
+   }                                                                            \
+-  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$upgrade(                          \
++  CXX_RS_EXPORT void cxxbridge1$std$weak_ptr$##RUST_TYPE##$upgrade(            \
+       const std::weak_ptr<CXX_TYPE> &weak,                                     \
+       std::shared_ptr<CXX_TYPE> *shared) noexcept {                            \
+     new (shared) std::shared_ptr<CXX_TYPE>(weak.lock());                       \
+   }                                                                            \
+-  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$drop(                             \
++  CXX_RS_EXPORT void cxxbridge1$std$weak_ptr$##RUST_TYPE##$drop(               \
+       const std::weak_ptr<CXX_TYPE> *self) noexcept {                          \
+     self->~weak_ptr();                                                         \
+   }
+ 
+ // Usize and isize are the same type as one of the below.
+ #define FOR_EACH_NUMERIC(MACRO)                                                \
+   MACRO(u8, std::uint8_t)                                                      \
+   MACRO(u16, std::uint16_t)                                                    \
+-- 
+2.48.1.502.g6dc24dfdaf-goog
+
diff --git a/third_party/rust/chromium_crates_io/patches/memoffset/0001-Remove-executable-bit-from-miri.sh.patch b/third_party/rust/chromium_crates_io/patches/memoffset/0001-Remove-executable-bit-from-miri.sh.patch
new file mode 100644
index 0000000000000..49f014f58a680
--- /dev/null
+++ b/third_party/rust/chromium_crates_io/patches/memoffset/0001-Remove-executable-bit-from-miri.sh.patch
@@ -0,0 +1,17 @@
+From 8b4c46ae7310ca0872566d73238891388e30317e Mon Sep 17 00:00:00 2001
+From: danakj <danakj@chromium.org>
+Date: Tue, 14 Nov 2023 15:58:45 -0500
+Subject: [PATCH] Remove executable bit from miri.sh
+
+Presubmit error: Has executable bit but not shebang or ELF or Mach-O header
+---
+ .../rust/chromium_crates_io/vendor/memoffset-0.6.5/ci/miri.sh     | 0
+ 1 file changed, 0 insertions(+), 0 deletions(-)
+ mode change 100755 => 100644 third_party/rust/chromium_crates_io/vendor/memoffset-0.6.5/ci/miri.sh
+
+diff --git a/third_party/rust/chromium_crates_io/vendor/memoffset-0.6.5/ci/miri.sh b/third_party/rust/chromium_crates_io/vendor/memoffset-0.6.5/ci/miri.sh
+old mode 100755
+new mode 100644
+-- 
+2.43.0.rc0.421.g78406f8d94-goog
+
diff --git a/third_party/rust/chromium_crates_io/patches/png/0201-trimmed-down-Treat-most-auxiliary-chunk-errors-as-be.patch b/third_party/rust/chromium_crates_io/patches/png/0201-trimmed-down-Treat-most-auxiliary-chunk-errors-as-be.patch
new file mode 100644
index 0000000000000..2e434ad68ca5a
--- /dev/null
+++ b/third_party/rust/chromium_crates_io/patches/png/0201-trimmed-down-Treat-most-auxiliary-chunk-errors-as-be.patch
@@ -0,0 +1,79 @@
+From aabd523b3cedec16f67802102f25ebf2a053e1d3 Mon Sep 17 00:00:00 2001
+From: Lukasz Anforowicz <lukasza@chromium.org>
+Date: Mon, 3 Mar 2025 18:24:25 +0000
+Subject: [PATCH] [trimmed down] Treat most auxiliary chunk errors as benign.
+
+This commit is a trimmed down version of
+https://github.com/image-rs/image-png/pull/569.
+The original PR has been trimmed down to reduce the risk
+of conflicts when applying the patch to 0.17.16.
+See also http://crbug.com/400455848
+---
+ src/decoder/stream.rs | 37 +++++++++++++++++++++++++++++++++----
+ 1 file changed, 33 insertions(+), 4 deletions(-)
+
+diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.16/src/decoder/stream.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.16/src/decoder/stream.rs
+index 0e65ef2..46a5e6f 100644
+--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.16/src/decoder/stream.rs
++++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.16/src/decoder/stream.rs
+@@ -975,7 +975,7 @@ impl StreamingDecoder {
+ 
+     fn parse_chunk(&mut self, type_str: ChunkType) -> Result<Decoded, DecodingError> {
+         self.state = Some(State::new_u32(U32ValueKind::Crc(type_str)));
+-        let parse_result = match type_str {
++        let mut parse_result = match type_str {
+             IHDR => self.parse_ihdr(),
+             chunk::sBIT => self.parse_sbit(),
+             chunk::PLTE => self.parse_plte(),
+@@ -998,8 +998,7 @@ impl StreamingDecoder {
+             _ => Ok(Decoded::PartialChunk(type_str)),
+         };
+ 
+-        parse_result.map_err(|e| {
+-            self.state = None;
++        parse_result = parse_result.map_err(|e| {
+             match e {
+                 // `parse_chunk` is invoked after gathering **all** bytes of a chunk, so
+                 // `UnexpectedEof` from something like `read_be` is permanent and indicates an
+@@ -1012,7 +1011,37 @@ impl StreamingDecoder {
+                 }
+                 e => e,
+             }
+-        })
++        });
++
++        // Ignore benign errors in some auxiliary chunks.  `LimitsExceeded`, `Parameter`
++        // and other error kinds are *not* treated as benign.  We only ignore errors in *some*
++        // auxiliary chunks (i.e. we don't use `chunk::is_critical`), because for chunks like
++        // `fcTL` or `fdAT` the fallback to the static/non-animated image has to be implemented
++        // *on top* of the `StreamingDecoder` API.
++        //
++        // TODO: Consider supporting a strict mode where even benign errors are reported up.
++        // See https://github.com/image-rs/image-png/pull/569#issuecomment-2642062285
++        if matches!(parse_result.as_ref(), Err(DecodingError::Format(_)))
++            && matches!(
++                type_str,
++                chunk::cHRM
++                    | chunk::gAMA
++                    | chunk::iCCP
++                    | chunk::pHYs
++                    | chunk::sBIT
++                    | chunk::sRGB
++                    | chunk::tRNS
++            )
++        {
++            parse_result = Ok(Decoded::Nothing);
++        }
++
++        // Clear the parsing state to enforce that parsing can't continue after an error.
++        if parse_result.is_err() {
++            self.state = None;
++        }
++
++        parse_result
+     }
+ 
+     fn parse_fctl(&mut self) -> Result<Decoded, DecodingError> {
+-- 
+2.48.1.711.g2feabab25a-goog
+
diff --git a/third_party/sentencepiece/patches/0001-Remove-config-include.patch b/third_party/sentencepiece/patches/0001-Remove-config-include.patch
new file mode 100644
index 0000000000000..cdb13726abedd
--- /dev/null
+++ b/third_party/sentencepiece/patches/0001-Remove-config-include.patch
@@ -0,0 +1,24 @@
+From 161f5e23e7b860b90630057df3379400bf68e95f Mon Sep 17 00:00:00 2001
+From: Clark DuVall <cduvall@chromium.org>
+Date: Wed, 16 Aug 2023 16:02:16 -0700
+Subject: [PATCH 1/4] Remove config include
+
+---
+ third_party/sentencepiece/src/src/common.h | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/third_party/sentencepiece/src/src/common.h b/third_party/sentencepiece/src/src/common.h
+index b38b3f7b6615f..9bfb3884b068f 100644
+--- a/third_party/sentencepiece/src/src/common.h
++++ b/third_party/sentencepiece/src/src/common.h
+@@ -25,7 +25,6 @@
+ #include <utility>
+ #include <vector>
+ 
+-#include "config.h"
+ #include "third_party/absl/strings/string_view.h"
+ 
+ #if defined(_WIN32) && !defined(__CYGWIN__)
+-- 
+2.42.0.rc1.204.g551eb34607-goog
+
diff --git a/third_party/sentencepiece/patches/0002-Fix-absl-includes.patch b/third_party/sentencepiece/patches/0002-Fix-absl-includes.patch
new file mode 100644
index 0000000000000..4fff2245402ab
--- /dev/null
+++ b/third_party/sentencepiece/patches/0002-Fix-absl-includes.patch
@@ -0,0 +1,861 @@
+From 187a01a68fa8adbb99552c227bb531c68276287b Mon Sep 17 00:00:00 2001
+From: Clark DuVall <cduvall@chromium.org>
+Date: Wed, 16 Aug 2023 16:02:45 -0700
+Subject: [PATCH 2/4] Fix absl includes
+
+---
+ third_party/sentencepiece/src/src/bpe_model.cc |  2 +-
+ .../sentencepiece/src/src/bpe_model_trainer.cc |  6 +++---
+ .../sentencepiece/src/src/bpe_model_trainer.h  |  2 +-
+ .../src/src/bpe_model_trainer_test.cc          |  4 ++--
+ third_party/sentencepiece/src/src/builder.cc   |  8 ++++----
+ third_party/sentencepiece/src/src/builder.h    |  2 +-
+ .../sentencepiece/src/src/builder_test.cc      |  2 +-
+ .../src/src/char_model_trainer_test.cc         |  4 ++--
+ third_party/sentencepiece/src/src/common.h     |  2 +-
+ .../src/src/compile_charsmap_main.cc           |  4 ++--
+ third_party/sentencepiece/src/src/error.cc     |  4 ++--
+ .../sentencepiece/src/src/filesystem.cc        |  2 +-
+ third_party/sentencepiece/src/src/filesystem.h |  2 +-
+ .../sentencepiece/src/src/filesystem_test.cc   |  2 +-
+ third_party/sentencepiece/src/src/init.h       |  4 ++--
+ .../sentencepiece/src/src/model_factory.cc     |  2 +-
+ .../sentencepiece/src/src/model_interface.cc   |  4 ++--
+ .../sentencepiece/src/src/model_interface.h    |  4 ++--
+ .../src/src/model_interface_test.cc            |  2 +-
+ .../sentencepiece/src/src/normalizer.cc        |  8 ++++----
+ third_party/sentencepiece/src/src/normalizer.h |  2 +-
+ .../src/src/pretokenizer_for_training.cc       |  2 +-
+ .../src/src/pretokenizer_for_training.h        |  2 +-
+ .../src/src/pretokenizer_for_training_test.cc  |  6 +++---
+ .../src/src/sentencepiece_processor.cc         | 16 ++++++++--------
+ .../src/src/sentencepiece_processor_test.cc    |  8 ++++----
+ .../src/src/sentencepiece_trainer.cc           | 12 ++++++------
+ .../src/src/sentencepiece_trainer_test.cc      |  2 +-
+ .../sentencepiece/src/src/spec_parser.h        |  4 ++--
+ .../sentencepiece/src/src/spm_decode_main.cc   |  4 ++--
+ .../sentencepiece/src/src/spm_encode_main.cc   |  8 ++++----
+ .../src/src/spm_export_vocab_main.cc           |  2 +-
+ .../src/src/spm_normalize_main.cc              |  2 +-
+ .../sentencepiece/src/src/spm_train_main.cc    |  8 ++++----
+ .../sentencepiece/src/src/testharness.cc       |  2 +-
+ .../sentencepiece/src/src/testharness.h        |  6 +++---
+ .../sentencepiece/src/src/trainer_factory.cc   |  2 +-
+ .../sentencepiece/src/src/trainer_interface.cc | 18 +++++++++---------
+ .../sentencepiece/src/src/trainer_interface.h  |  2 +-
+ .../src/src/trainer_interface_test.cc          |  4 ++--
+ .../sentencepiece/src/src/unicode_script.cc    |  2 +-
+ .../sentencepiece/src/src/unicode_script_map.h |  2 +-
+ .../src/src/unicode_script_test.cc             |  2 +-
+ .../sentencepiece/src/src/unigram_model.cc     |  8 ++++----
+ .../src/src/unigram_model_test.cc              |  4 ++--
+ .../src/src/unigram_model_trainer.cc           |  8 ++++----
+ .../src/src/unigram_model_trainer.h            |  2 +-
+ .../src/src/unigram_model_trainer_test.cc      |  4 ++--
+ third_party/sentencepiece/src/src/util.h       |  2 +-
+ third_party/sentencepiece/src/src/util_test.cc |  2 +-
+ .../src/src/word_model_trainer.cc              |  4 ++--
+ .../src/src/word_model_trainer_test.cc         |  4 ++--
+ 52 files changed, 113 insertions(+), 113 deletions(-)
+
+diff --git a/third_party/sentencepiece/src/src/bpe_model.cc b/third_party/sentencepiece/src/src/bpe_model.cc
+index bc7ada13a7848..bc9124dd7c44c 100644
+--- a/third_party/sentencepiece/src/src/bpe_model.cc
++++ b/third_party/sentencepiece/src/src/bpe_model.cc
+@@ -22,7 +22,7 @@
+ #include <vector>
+ 
+ #include "freelist.h"
+-#include "third_party/absl/container/flat_hash_map.h"
++#include "absl/container/flat_hash_map.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/bpe_model_trainer.cc b/third_party/sentencepiece/src/src/bpe_model_trainer.cc
+index de86f14a2db0d..60d03745e8a39 100644
+--- a/third_party/sentencepiece/src/src/bpe_model_trainer.cc
++++ b/third_party/sentencepiece/src/src/bpe_model_trainer.cc
+@@ -20,9 +20,9 @@
+ #include <vector>
+ 
+ #include "pretokenizer_for_training.h"
+-#include "third_party/absl/container/flat_hash_set.h"
+-#include "third_party/absl/strings/str_join.h"
+-#include "third_party/absl/strings/str_replace.h"
++#include "absl/container/flat_hash_set.h"
++#include "absl/strings/str_join.h"
++#include "absl/strings/str_replace.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/bpe_model_trainer.h b/third_party/sentencepiece/src/src/bpe_model_trainer.h
+index 2879d29e2d4b3..4a37ac291b627 100644
+--- a/third_party/sentencepiece/src/src/bpe_model_trainer.h
++++ b/third_party/sentencepiece/src/src/bpe_model_trainer.h
+@@ -22,7 +22,7 @@
+ #include <vector>
+ 
+ #include "sentencepiece_model.pb.h"
+-#include "third_party/absl/container/flat_hash_map.h"
++#include "absl/container/flat_hash_map.h"
+ #include "trainer_interface.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/bpe_model_trainer_test.cc b/third_party/sentencepiece/src/src/bpe_model_trainer_test.cc
+index 173eb9cf53137..2a43c3acca6bb 100644
+--- a/third_party/sentencepiece/src/src/bpe_model_trainer_test.cc
++++ b/third_party/sentencepiece/src/src/bpe_model_trainer_test.cc
+@@ -20,8 +20,8 @@
+ #include "sentencepiece_processor.h"
+ #include "sentencepiece_trainer.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/builder.cc b/third_party/sentencepiece/src/src/builder.cc
+index 822f6fcbf1940..45c5ebaa31059 100644
+--- a/third_party/sentencepiece/src/src/builder.cc
++++ b/third_party/sentencepiece/src/src/builder.cc
+@@ -19,10 +19,10 @@
+ #include <utility>
+ 
+ #include "filesystem.h"
+-#include "third_party/absl/strings/str_join.h"
+-#include "third_party/absl/strings/str_replace.h"
+-#include "third_party/absl/strings/str_split.h"
+-#include "third_party/absl/strings/strip.h"
++#include "absl/strings/str_join.h"
++#include "absl/strings/str_replace.h"
++#include "absl/strings/str_split.h"
++#include "absl/strings/strip.h"
+ 
+ #ifdef ENABLE_NFKC_COMPILE
+ #include <unicode/errorcode.h>
+diff --git a/third_party/sentencepiece/src/src/builder.h b/third_party/sentencepiece/src/src/builder.h
+index 094da7266fd72..ea5171e564f8c 100644
+--- a/third_party/sentencepiece/src/src/builder.h
++++ b/third_party/sentencepiece/src/src/builder.h
+@@ -22,7 +22,7 @@
+ #include "common.h"
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ 
+ namespace sentencepiece {
+ namespace normalizer {
+diff --git a/third_party/sentencepiece/src/src/builder_test.cc b/third_party/sentencepiece/src/src/builder_test.cc
+index 4acb7b3bddf62..1dee5c7df77d7 100644
+--- a/third_party/sentencepiece/src/src/builder_test.cc
++++ b/third_party/sentencepiece/src/src/builder_test.cc
+@@ -18,7 +18,7 @@
+ #include "normalizer.h"
+ #include "sentencepiece_trainer.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
++#include "absl/strings/str_cat.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/char_model_trainer_test.cc b/third_party/sentencepiece/src/src/char_model_trainer_test.cc
+index 8c2e4b7a2f385..e8b4979673bfd 100644
+--- a/third_party/sentencepiece/src/src/char_model_trainer_test.cc
++++ b/third_party/sentencepiece/src/src/char_model_trainer_test.cc
+@@ -19,8 +19,8 @@
+ #include "filesystem.h"
+ #include "sentencepiece_processor.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/common.h b/third_party/sentencepiece/src/src/common.h
+index 9bfb3884b068f..7347ff44362c6 100644
+--- a/third_party/sentencepiece/src/src/common.h
++++ b/third_party/sentencepiece/src/src/common.h
+@@ -25,7 +25,7 @@
+ #include <utility>
+ #include <vector>
+ 
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ 
+ #if defined(_WIN32) && !defined(__CYGWIN__)
+ #define OS_WIN
+diff --git a/third_party/sentencepiece/src/src/compile_charsmap_main.cc b/third_party/sentencepiece/src/src/compile_charsmap_main.cc
+index da15328ddbf17..b806319c45bcb 100644
+--- a/third_party/sentencepiece/src/src/compile_charsmap_main.cc
++++ b/third_party/sentencepiece/src/src/compile_charsmap_main.cc
+@@ -22,8 +22,8 @@
+ #include "filesystem.h"
+ #include "init.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/flags/flag.h"
++#include "absl/strings/string_view.h"
+ 
+ using sentencepiece::normalizer::Builder;
+ 
+diff --git a/third_party/sentencepiece/src/src/error.cc b/third_party/sentencepiece/src/src/error.cc
+index d3792dc3d6a37..19ef6f35b822e 100644
+--- a/third_party/sentencepiece/src/src/error.cc
++++ b/third_party/sentencepiece/src/src/error.cc
+@@ -21,8 +21,8 @@
+ #ifdef _USE_EXTERNAL_ABSL
+ // Naive workaround to define minloglevel on external absl package.
+ // We want to define them in other cc file.
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/flags/parse.h"
++#include "absl/flags/flag.h"
++#include "absl/flags/parse.h"
+ ABSL_FLAG(int32, minloglevel, 0,
+           "Messages logged at a lower level than this don't actually.");
+ #endif
+diff --git a/third_party/sentencepiece/src/src/filesystem.cc b/third_party/sentencepiece/src/src/filesystem.cc
+index 833c8f78c4a24..6a169d90b87ac 100644
+--- a/third_party/sentencepiece/src/src/filesystem.cc
++++ b/third_party/sentencepiece/src/src/filesystem.cc
+@@ -15,7 +15,7 @@
+ #include <iostream>
+ 
+ #include "filesystem.h"
+-#include "third_party/absl/memory/memory.h"
++#include "absl/memory/memory.h"
+ #include "util.h"
+ 
+ #if defined(OS_WIN) && defined(UNICODE) && defined(_UNICODE)
+diff --git a/third_party/sentencepiece/src/src/filesystem.h b/third_party/sentencepiece/src/src/filesystem.h
+index e572b4b694d3a..dbcce4810f037 100644
+--- a/third_party/sentencepiece/src/src/filesystem.h
++++ b/third_party/sentencepiece/src/src/filesystem.h
+@@ -23,7 +23,7 @@
+ 
+ #include "common.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ 
+ namespace sentencepiece {
+ namespace filesystem {
+diff --git a/third_party/sentencepiece/src/src/filesystem_test.cc b/third_party/sentencepiece/src/src/filesystem_test.cc
+index 790e756aacd18..39ece9952f362 100644
+--- a/third_party/sentencepiece/src/src/filesystem_test.cc
++++ b/third_party/sentencepiece/src/src/filesystem_test.cc
+@@ -14,7 +14,7 @@
+ 
+ #include "filesystem.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
++#include "absl/strings/str_cat.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/init.h b/third_party/sentencepiece/src/src/init.h
+index 6ae047e8a4cd6..14edb8c75f431 100644
+--- a/third_party/sentencepiece/src/src/init.h
++++ b/third_party/sentencepiece/src/src/init.h
+@@ -16,8 +16,8 @@
+ #define INIT_H_
+ 
+ #include "common.h"
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/flags/parse.h"
++#include "absl/flags/flag.h"
++#include "absl/flags/parse.h"
+ 
+ #ifdef _USE_EXTERNAL_PROTOBUF
+ #include "google/protobuf/message_lite.h"
+diff --git a/third_party/sentencepiece/src/src/model_factory.cc b/third_party/sentencepiece/src/src/model_factory.cc
+index be995010a5d9b..040c00c7ea6fe 100644
+--- a/third_party/sentencepiece/src/src/model_factory.cc
++++ b/third_party/sentencepiece/src/src/model_factory.cc
+@@ -15,7 +15,7 @@
+ #include "bpe_model.h"
+ #include "char_model.h"
+ #include "model_factory.h"
+-#include "third_party/absl/memory/memory.h"
++#include "absl/memory/memory.h"
+ #include "unigram_model.h"
+ #include "word_model.h"
+ 
+diff --git a/third_party/sentencepiece/src/src/model_interface.cc b/third_party/sentencepiece/src/src/model_interface.cc
+index c49be1ebf9ab9..22c6378e700a7 100644
+--- a/third_party/sentencepiece/src/src/model_interface.cc
++++ b/third_party/sentencepiece/src/src/model_interface.cc
+@@ -16,8 +16,8 @@
+ 
+ #include "model_interface.h"
+ #include "sentencepiece_model.pb.h"
+-#include "third_party/absl/memory/memory.h"
+-#include "third_party/absl/strings/str_format.h"
++#include "absl/memory/memory.h"
++#include "absl/strings/str_format.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/model_interface.h b/third_party/sentencepiece/src/src/model_interface.h
+index 06e924302dd89..1365c64503845 100644
+--- a/third_party/sentencepiece/src/src/model_interface.h
++++ b/third_party/sentencepiece/src/src/model_interface.h
+@@ -25,8 +25,8 @@
+ #include "normalizer.h"
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/container/flat_hash_map.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/container/flat_hash_map.h"
++#include "absl/strings/string_view.h"
+ #include "third_party/darts_clone/darts.h"
+ #include "util.h"
+ 
+diff --git a/third_party/sentencepiece/src/src/model_interface_test.cc b/third_party/sentencepiece/src/src/model_interface_test.cc
+index 09e41d34812d9..725bfa4d7798f 100644
+--- a/third_party/sentencepiece/src/src/model_interface_test.cc
++++ b/third_party/sentencepiece/src/src/model_interface_test.cc
+@@ -16,7 +16,7 @@
+ 
+ #include "model_factory.h"
+ #include "testharness.h"
+-#include "third_party/absl/container/flat_hash_map.h"
++#include "absl/container/flat_hash_map.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/normalizer.cc b/third_party/sentencepiece/src/src/normalizer.cc
+index 53e43c4d2927f..a6152bfb0ad82 100644
+--- a/third_party/sentencepiece/src/src/normalizer.cc
++++ b/third_party/sentencepiece/src/src/normalizer.cc
+@@ -18,10 +18,10 @@
+ #include <vector>
+ 
+ #include "common.h"
+-#include "third_party/absl/memory/memory.h"
+-#include "third_party/absl/strings/match.h"
+-#include "third_party/absl/strings/string_view.h"
+-#include "third_party/absl/strings/strip.h"
++#include "absl/memory/memory.h"
++#include "absl/strings/match.h"
++#include "absl/strings/string_view.h"
++#include "absl/strings/strip.h"
+ #include "third_party/darts_clone/darts.h"
+ #include "util.h"
+ 
+diff --git a/third_party/sentencepiece/src/src/normalizer.h b/third_party/sentencepiece/src/src/normalizer.h
+index c79813c76ceea..5a60ef760147a 100644
+--- a/third_party/sentencepiece/src/src/normalizer.h
++++ b/third_party/sentencepiece/src/src/normalizer.h
+@@ -24,7 +24,7 @@
+ #include "common.h"
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ #include "third_party/darts_clone/darts.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/pretokenizer_for_training.cc b/third_party/sentencepiece/src/src/pretokenizer_for_training.cc
+index d4f492c5627f7..54bdff117eba5 100644
+--- a/third_party/sentencepiece/src/src/pretokenizer_for_training.cc
++++ b/third_party/sentencepiece/src/src/pretokenizer_for_training.cc
+@@ -15,7 +15,7 @@
+ 
+ #include <string>
+ 
+-#include "third_party/absl/strings/str_replace.h"
++#include "absl/strings/str_replace.h"
+ 
+ namespace sentencepiece {
+ namespace pretokenizer {
+diff --git a/third_party/sentencepiece/src/src/pretokenizer_for_training.h b/third_party/sentencepiece/src/src/pretokenizer_for_training.h
+index fa54f95c70926..b5f9ae964bdf8 100644
+--- a/third_party/sentencepiece/src/src/pretokenizer_for_training.h
++++ b/third_party/sentencepiece/src/src/pretokenizer_for_training.h
+@@ -21,7 +21,7 @@
+ #include "common.h"
+ #include "sentencepiece.pb.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ 
+ namespace sentencepiece {
+ namespace pretokenizer {
+diff --git a/third_party/sentencepiece/src/src/pretokenizer_for_training_test.cc b/third_party/sentencepiece/src/src/pretokenizer_for_training_test.cc
+index 99db0c51025cc..25e8aef5983fd 100644
+--- a/third_party/sentencepiece/src/src/pretokenizer_for_training_test.cc
++++ b/third_party/sentencepiece/src/src/pretokenizer_for_training_test.cc
+@@ -14,9 +14,9 @@
+ #include "pretokenizer_for_training.h"
+ 
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
+-#include "third_party/absl/strings/str_split.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
++#include "absl/strings/str_split.h"
+ #include "trainer_interface.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/sentencepiece_processor.cc b/third_party/sentencepiece/src/src/sentencepiece_processor.cc
+index f0df2f601a2d4..9b9157181281e 100644
+--- a/third_party/sentencepiece/src/src/sentencepiece_processor.cc
++++ b/third_party/sentencepiece/src/src/sentencepiece_processor.cc
+@@ -24,14 +24,14 @@
+ #include "model_interface.h"
+ #include "normalizer.h"
+ #include "sentencepiece.pb.h"
+-#include "third_party/absl/memory/memory.h"
+-#include "third_party/absl/strings/numbers.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
+-#include "third_party/absl/strings/str_replace.h"
+-#include "third_party/absl/strings/str_split.h"
+-#include "third_party/absl/strings/string_view.h"
+-#include "third_party/absl/strings/strip.h"
++#include "absl/memory/memory.h"
++#include "absl/strings/numbers.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
++#include "absl/strings/str_replace.h"
++#include "absl/strings/str_split.h"
++#include "absl/strings/string_view.h"
++#include "absl/strings/strip.h"
+ #include "unigram_model.h"
+ #include "util.h"
+ 
+diff --git a/third_party/sentencepiece/src/src/sentencepiece_processor_test.cc b/third_party/sentencepiece/src/src/sentencepiece_processor_test.cc
+index f05dc5d183237..4f2f33befc074 100644
+--- a/third_party/sentencepiece/src/src/sentencepiece_processor_test.cc
++++ b/third_party/sentencepiece/src/src/sentencepiece_processor_test.cc
+@@ -24,10 +24,10 @@
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_trainer.h"
+ #include "testharness.h"
+-#include "third_party/absl/container/flat_hash_map.h"
+-#include "third_party/absl/memory/memory.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/container/flat_hash_map.h"
++#include "absl/memory/memory.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/string_view.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/sentencepiece_trainer.cc b/third_party/sentencepiece/src/src/sentencepiece_trainer.cc
+index b9fe64f2bb859..47ef33c0f5384 100644
+--- a/third_party/sentencepiece/src/src/sentencepiece_trainer.cc
++++ b/third_party/sentencepiece/src/src/sentencepiece_trainer.cc
+@@ -22,12 +22,12 @@
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_trainer.h"
+ #include "spec_parser.h"
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/strings/numbers.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_split.h"
+-#include "third_party/absl/strings/string_view.h"
+-#include "third_party/absl/strings/strip.h"
++#include "absl/flags/flag.h"
++#include "absl/strings/numbers.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_split.h"
++#include "absl/strings/string_view.h"
++#include "absl/strings/strip.h"
+ #include "trainer_factory.h"
+ #include "util.h"
+ 
+diff --git a/third_party/sentencepiece/src/src/sentencepiece_trainer_test.cc b/third_party/sentencepiece/src/src/sentencepiece_trainer_test.cc
+index e44e66ba5ce54..fc73b1d422d3b 100644
+--- a/third_party/sentencepiece/src/src/sentencepiece_trainer_test.cc
++++ b/third_party/sentencepiece/src/src/sentencepiece_trainer_test.cc
+@@ -16,7 +16,7 @@
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_trainer.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
++#include "absl/strings/str_cat.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/spec_parser.h b/third_party/sentencepiece/src/src/spec_parser.h
+index c5f05829beb70..c7684ed9fc752 100644
+--- a/third_party/sentencepiece/src/src/spec_parser.h
++++ b/third_party/sentencepiece/src/src/spec_parser.h
+@@ -19,8 +19,8 @@
+ #include <vector>
+ 
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/strings/ascii.h"
+-#include "third_party/absl/strings/str_split.h"
++#include "absl/strings/ascii.h"
++#include "absl/strings/str_split.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/spm_decode_main.cc b/third_party/sentencepiece/src/src/spm_decode_main.cc
+index bc49bd3829da3..ed80939f02e67 100644
+--- a/third_party/sentencepiece/src/src/spm_decode_main.cc
++++ b/third_party/sentencepiece/src/src/spm_decode_main.cc
+@@ -21,8 +21,8 @@
+ #include "init.h"
+ #include "sentencepiece.pb.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/strings/str_split.h"
++#include "absl/flags/flag.h"
++#include "absl/strings/str_split.h"
+ #include "util.h"
+ 
+ ABSL_FLAG(std::string, model, "", "model file name");
+diff --git a/third_party/sentencepiece/src/src/spm_encode_main.cc b/third_party/sentencepiece/src/src/spm_encode_main.cc
+index 2fbb850fa145d..7f93be0d27285 100644
+--- a/third_party/sentencepiece/src/src/spm_encode_main.cc
++++ b/third_party/sentencepiece/src/src/spm_encode_main.cc
+@@ -21,10 +21,10 @@
+ #include "init.h"
+ #include "sentencepiece.pb.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/container/flat_hash_map.h"
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
++#include "absl/container/flat_hash_map.h"
++#include "absl/flags/flag.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
+ #include "trainer_interface.h"
+ 
+ ABSL_FLAG(std::string, model, "", "model file name");
+diff --git a/third_party/sentencepiece/src/src/spm_export_vocab_main.cc b/third_party/sentencepiece/src/src/spm_export_vocab_main.cc
+index e5b97dfe4e631..480c6397db39b 100644
+--- a/third_party/sentencepiece/src/src/spm_export_vocab_main.cc
++++ b/third_party/sentencepiece/src/src/spm_export_vocab_main.cc
+@@ -19,7 +19,7 @@
+ #include "init.h"
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/flags/flag.h"
++#include "absl/flags/flag.h"
+ 
+ ABSL_FLAG(std::string, output, "", "Output filename");
+ ABSL_FLAG(std::string, model, "", "input model file name");
+diff --git a/third_party/sentencepiece/src/src/spm_normalize_main.cc b/third_party/sentencepiece/src/src/spm_normalize_main.cc
+index 39f3ef904d72c..b2b7562003a86 100644
+--- a/third_party/sentencepiece/src/src/spm_normalize_main.cc
++++ b/third_party/sentencepiece/src/src/spm_normalize_main.cc
+@@ -21,7 +21,7 @@
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_processor.h"
+ #include "sentencepiece_trainer.h"
+-#include "third_party/absl/flags/flag.h"
++#include "absl/flags/flag.h"
+ 
+ ABSL_FLAG(std::string, model, "", "Model file name");
+ ABSL_FLAG(bool, use_internal_normalization, false,
+diff --git a/third_party/sentencepiece/src/src/spm_train_main.cc b/third_party/sentencepiece/src/src/spm_train_main.cc
+index 34369cdfc730b..d8ffeb6dfb335 100644
+--- a/third_party/sentencepiece/src/src/spm_train_main.cc
++++ b/third_party/sentencepiece/src/src/spm_train_main.cc
+@@ -18,10 +18,10 @@
+ #include "init.h"
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_trainer.h"
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/strings/ascii.h"
+-#include "third_party/absl/strings/str_join.h"
+-#include "third_party/absl/strings/str_split.h"
++#include "absl/flags/flag.h"
++#include "absl/strings/ascii.h"
++#include "absl/strings/str_join.h"
++#include "absl/strings/str_split.h"
+ #include "util.h"
+ 
+ using sentencepiece::NormalizerSpec;
+diff --git a/third_party/sentencepiece/src/src/testharness.cc b/third_party/sentencepiece/src/src/testharness.cc
+index f6b1efee5c8c6..daf2d141b8e5d 100644
+--- a/third_party/sentencepiece/src/src/testharness.cc
++++ b/third_party/sentencepiece/src/src/testharness.cc
+@@ -26,7 +26,7 @@
+ #include <vector>
+ 
+ #include "common.h"
+-#include "third_party/absl/strings/str_cat.h"
++#include "absl/strings/str_cat.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/testharness.h b/third_party/sentencepiece/src/src/testharness.h
+index 9879b06ec575e..98317add65bb7 100644
+--- a/third_party/sentencepiece/src/src/testharness.h
++++ b/third_party/sentencepiece/src/src/testharness.h
+@@ -21,9 +21,9 @@
+ #include <string>
+ 
+ #include "common.h"
+-#include "third_party/absl/flags/flag.h"
+-#include "third_party/absl/flags/parse.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/flags/flag.h"
++#include "absl/flags/parse.h"
++#include "absl/strings/string_view.h"
+ 
+ ABSL_DECLARE_FLAG(std::string, test_tmpdir);
+ ABSL_DECLARE_FLAG(std::string, test_srcdir);
+diff --git a/third_party/sentencepiece/src/src/trainer_factory.cc b/third_party/sentencepiece/src/src/trainer_factory.cc
+index d1d25412a1b2f..ff594d0590e99 100644
+--- a/third_party/sentencepiece/src/src/trainer_factory.cc
++++ b/third_party/sentencepiece/src/src/trainer_factory.cc
+@@ -14,7 +14,7 @@
+ 
+ #include "bpe_model_trainer.h"
+ #include "char_model_trainer.h"
+-#include "third_party/absl/memory/memory.h"
++#include "absl/memory/memory.h"
+ #include "trainer_factory.h"
+ #include "unigram_model_trainer.h"
+ #include "word_model_trainer.h"
+diff --git a/third_party/sentencepiece/src/src/trainer_interface.cc b/third_party/sentencepiece/src/src/trainer_interface.cc
+index 968f7b9ce8f39..47b9c2be5f409 100644
+--- a/third_party/sentencepiece/src/src/trainer_interface.cc
++++ b/third_party/sentencepiece/src/src/trainer_interface.cc
+@@ -28,15 +28,15 @@
+ #include "normalizer.h"
+ #include "sentencepiece_processor.h"
+ #include "sentencepiece_trainer.h"
+-#include "third_party/absl/container/flat_hash_map.h"
+-#include "third_party/absl/memory/memory.h"
+-#include "third_party/absl/random/distributions.h"
+-#include "third_party/absl/random/random.h"
+-#include "third_party/absl/strings/numbers.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_format.h"
+-#include "third_party/absl/strings/str_join.h"
+-#include "third_party/absl/strings/str_split.h"
++#include "absl/container/flat_hash_map.h"
++#include "absl/memory/memory.h"
++#include "absl/random/distributions.h"
++#include "absl/random/random.h"
++#include "absl/strings/numbers.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_format.h"
++#include "absl/strings/str_join.h"
++#include "absl/strings/str_split.h"
+ #include "unicode_script.h"
+ #include "util.h"
+ 
+diff --git a/third_party/sentencepiece/src/src/trainer_interface.h b/third_party/sentencepiece/src/src/trainer_interface.h
+index 8d625a953985f..0c003b655b1bb 100644
+--- a/third_party/sentencepiece/src/src/trainer_interface.h
++++ b/third_party/sentencepiece/src/src/trainer_interface.h
+@@ -27,7 +27,7 @@
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_processor.h"
+ #include "sentencepiece_trainer.h"
+-#include "third_party/absl/container/flat_hash_map.h"
++#include "absl/container/flat_hash_map.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/trainer_interface_test.cc b/third_party/sentencepiece/src/src/trainer_interface_test.cc
+index feb970f2b5098..ce22bac19b21c 100644
+--- a/third_party/sentencepiece/src/src/trainer_interface_test.cc
++++ b/third_party/sentencepiece/src/src/trainer_interface_test.cc
+@@ -18,8 +18,8 @@
+ 
+ #include "filesystem.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_format.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_format.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/unicode_script.cc b/third_party/sentencepiece/src/src/unicode_script.cc
+index 583dc30020004..11b24dc4fb128 100644
+--- a/third_party/sentencepiece/src/src/unicode_script.cc
++++ b/third_party/sentencepiece/src/src/unicode_script.cc
+@@ -14,7 +14,7 @@
+ 
+ #include <unordered_map>
+ 
+-#include "third_party/absl/container/flat_hash_map.h"
++#include "absl/container/flat_hash_map.h"
+ #include "unicode_script.h"
+ #include "unicode_script_map.h"
+ #include "util.h"
+diff --git a/third_party/sentencepiece/src/src/unicode_script_map.h b/third_party/sentencepiece/src/src/unicode_script_map.h
+index f2e67e9e54be8..f1b8299f8692f 100644
+--- a/third_party/sentencepiece/src/src/unicode_script_map.h
++++ b/third_party/sentencepiece/src/src/unicode_script_map.h
+@@ -14,7 +14,7 @@
+ 
+ #ifndef UNICODE_SCRIPT_DATA_H_
+ #define UNICODE_SCRIPT_DATA_H_
+-#include "third_party/absl/container/flat_hash_map.h"
++#include "absl/container/flat_hash_map.h"
+ namespace sentencepiece {
+ namespace unicode_script {
+ namespace {
+diff --git a/third_party/sentencepiece/src/src/unicode_script_test.cc b/third_party/sentencepiece/src/src/unicode_script_test.cc
+index ab33565a88eb6..e0b1c4d4d50df 100644
+--- a/third_party/sentencepiece/src/src/unicode_script_test.cc
++++ b/third_party/sentencepiece/src/src/unicode_script_test.cc
+@@ -14,7 +14,7 @@
+ 
+ #include "common.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ #include "unicode_script.h"
+ #include "util.h"
+ 
+diff --git a/third_party/sentencepiece/src/src/unigram_model.cc b/third_party/sentencepiece/src/src/unigram_model.cc
+index d9f1ce9d521fc..bb559587f93e9 100644
+--- a/third_party/sentencepiece/src/src/unigram_model.cc
++++ b/third_party/sentencepiece/src/src/unigram_model.cc
+@@ -24,10 +24,10 @@
+ #include <utility>
+ #include <vector>
+ 
+-#include "third_party/absl/container/flat_hash_map.h"
+-#include "third_party/absl/memory/memory.h"
+-#include "third_party/absl/strings/str_split.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/container/flat_hash_map.h"
++#include "absl/memory/memory.h"
++#include "absl/strings/str_split.h"
++#include "absl/strings/string_view.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/unigram_model_test.cc b/third_party/sentencepiece/src/src/unigram_model_test.cc
+index bf22da30b83ea..21cbec34a350f 100644
+--- a/third_party/sentencepiece/src/src/unigram_model_test.cc
++++ b/third_party/sentencepiece/src/src/unigram_model_test.cc
+@@ -22,8 +22,8 @@
+ #include "sentencepiece_model.pb.h"
+ #include "sentencepiece_processor.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/unigram_model_trainer.cc b/third_party/sentencepiece/src/src/unigram_model_trainer.cc
+index d58c408066aea..7fd081d77991c 100644
+--- a/third_party/sentencepiece/src/src/unigram_model_trainer.cc
++++ b/third_party/sentencepiece/src/src/unigram_model_trainer.cc
+@@ -27,10 +27,10 @@
+ #include "normalizer.h"
+ #include "pretokenizer_for_training.h"
+ #include "sentencepiece_trainer.h"
+-#include "third_party/absl/container/flat_hash_map.h"
+-#include "third_party/absl/memory/memory.h"
+-#include "third_party/absl/strings/str_replace.h"
+-#include "third_party/absl/strings/str_split.h"
++#include "absl/container/flat_hash_map.h"
++#include "absl/memory/memory.h"
++#include "absl/strings/str_replace.h"
++#include "absl/strings/str_split.h"
+ #include "third_party/esaxx/esa.hxx"  // Suffix array library.
+ #include "unicode_script.h"
+ #include "util.h"
+diff --git a/third_party/sentencepiece/src/src/unigram_model_trainer.h b/third_party/sentencepiece/src/src/unigram_model_trainer.h
+index c6562e65e8190..2d24eebc73c3c 100644
+--- a/third_party/sentencepiece/src/src/unigram_model_trainer.h
++++ b/third_party/sentencepiece/src/src/unigram_model_trainer.h
+@@ -21,7 +21,7 @@
+ #include <vector>
+ 
+ #include "sentencepiece_model.pb.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ #include "trainer_interface.h"
+ #include "unigram_model.h"
+ #include "util.h"
+diff --git a/third_party/sentencepiece/src/src/unigram_model_trainer_test.cc b/third_party/sentencepiece/src/src/unigram_model_trainer_test.cc
+index 31da90ba5b879..d7198da475955 100644
+--- a/third_party/sentencepiece/src/src/unigram_model_trainer_test.cc
++++ b/third_party/sentencepiece/src/src/unigram_model_trainer_test.cc
+@@ -22,8 +22,8 @@
+ #include "sentencepiece_processor.h"
+ #include "sentencepiece_trainer.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/util.h b/third_party/sentencepiece/src/src/util.h
+index 5110291925180..fc09e12f2d529 100644
+--- a/third_party/sentencepiece/src/src/util.h
++++ b/third_party/sentencepiece/src/src/util.h
+@@ -30,7 +30,7 @@
+ 
+ #include "common.h"
+ #include "sentencepiece_processor.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/strings/string_view.h"
+ 
+ #ifdef SPM_NO_THREADLOCAL
+ #include <pthread.h>
+diff --git a/third_party/sentencepiece/src/src/util_test.cc b/third_party/sentencepiece/src/src/util_test.cc
+index 71d006f81ec55..231fc96992e2f 100644
+--- a/third_party/sentencepiece/src/src/util_test.cc
++++ b/third_party/sentencepiece/src/src/util_test.cc
+@@ -16,7 +16,7 @@
+ 
+ #include "filesystem.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
++#include "absl/strings/str_cat.h"
+ #include "util.h"
+ 
+ namespace sentencepiece {
+diff --git a/third_party/sentencepiece/src/src/word_model_trainer.cc b/third_party/sentencepiece/src/src/word_model_trainer.cc
+index 0b8b0622f009b..b057843d45261 100644
+--- a/third_party/sentencepiece/src/src/word_model_trainer.cc
++++ b/third_party/sentencepiece/src/src/word_model_trainer.cc
+@@ -15,8 +15,8 @@
+ #include <cmath>
+ #include <string>
+ 
+-#include "third_party/absl/container/flat_hash_map.h"
+-#include "third_party/absl/strings/string_view.h"
++#include "absl/container/flat_hash_map.h"
++#include "absl/strings/string_view.h"
+ #include "util.h"
+ #include "word_model.h"
+ #include "word_model_trainer.h"
+diff --git a/third_party/sentencepiece/src/src/word_model_trainer_test.cc b/third_party/sentencepiece/src/src/word_model_trainer_test.cc
+index c4a8bc6798a3e..366810f4e8469 100644
+--- a/third_party/sentencepiece/src/src/word_model_trainer_test.cc
++++ b/third_party/sentencepiece/src/src/word_model_trainer_test.cc
+@@ -18,8 +18,8 @@
+ #include "filesystem.h"
+ #include "sentencepiece_processor.h"
+ #include "testharness.h"
+-#include "third_party/absl/strings/str_cat.h"
+-#include "third_party/absl/strings/str_join.h"
++#include "absl/strings/str_cat.h"
++#include "absl/strings/str_join.h"
+ #include "util.h"
+ #include "word_model_trainer.h"
+ 
+-- 
+2.42.0.rc1.204.g551eb34607-goog
+
diff --git a/third_party/sentencepiece/patches/0003-Remove-absl-flags.patch b/third_party/sentencepiece/patches/0003-Remove-absl-flags.patch
new file mode 100644
index 0000000000000..c5cc065de9b5c
--- /dev/null
+++ b/third_party/sentencepiece/patches/0003-Remove-absl-flags.patch
@@ -0,0 +1,49 @@
+From f3351c5574d5bcd8b4f49baea9d8d654f27dfd3a Mon Sep 17 00:00:00 2001
+From: Clark DuVall <cduvall@chromium.org>
+Date: Wed, 16 Aug 2023 16:05:14 -0700
+Subject: [PATCH 3/4] Remove absl flags
+
+---
+ third_party/sentencepiece/src/src/init.h | 18 +-----------------
+ 1 file changed, 1 insertion(+), 17 deletions(-)
+
+diff --git a/third_party/sentencepiece/src/src/init.h b/third_party/sentencepiece/src/src/init.h
+index 14edb8c75f431..c5f6d9cc52472 100644
+--- a/third_party/sentencepiece/src/src/init.h
++++ b/third_party/sentencepiece/src/src/init.h
+@@ -16,31 +16,15 @@
+ #define INIT_H_
+ 
+ #include "common.h"
+-#include "absl/flags/flag.h"
+-#include "absl/flags/parse.h"
+ 
+ #ifdef _USE_EXTERNAL_PROTOBUF
+ #include "google/protobuf/message_lite.h"
+ #else
+-#include "third_party/protobuf-lite/google/protobuf/message_lite.h"
++#include "third_party/protobuf/src/google/protobuf/message_lite.h"
+ #endif
+ 
+-ABSL_DECLARE_FLAG(int32, minloglevel);
+ 
+ namespace sentencepiece {
+-inline void ParseCommandLineFlags(const char *usage, int *argc, char ***argv,
+-                                  bool remove_arg = true) {
+-  const auto unused_args = absl::ParseCommandLine(*argc, *argv);
+-
+-  if (remove_arg) {
+-    char **argv_val = *argv;
+-    *argv = argv_val = argv_val + *argc - unused_args.size();
+-    std::copy(unused_args.begin(), unused_args.end(), argv_val);
+-    *argc = static_cast<int>(unused_args.size());
+-  }
+-
+-  logging::SetMinLogLevel(absl::GetFlag(FLAGS_minloglevel));
+-}
+ 
+ inline void ShutdownLibrary() {
+   google::protobuf::ShutdownProtobufLibrary();
+-- 
+2.42.0.rc1.204.g551eb34607-goog
+
diff --git a/third_party/sentencepiece/patches/0004-Remove-util-Status.patch b/third_party/sentencepiece/patches/0004-Remove-util-Status.patch
new file mode 100644
index 0000000000000..40a039c50595a
--- /dev/null
+++ b/third_party/sentencepiece/patches/0004-Remove-util-Status.patch
@@ -0,0 +1,190 @@
+From c9502627a134b4ec78548a86d2795b07f4b0a0f6 Mon Sep 17 00:00:00 2001
+From: Clark DuVall <cduvall@chromium.org>
+Date: Wed, 16 Aug 2023 16:07:15 -0700
+Subject: [PATCH 4/4] Remove util::Status
+
+---
+ third_party/sentencepiece/src/src/error.cc    | 103 ------------------
+ .../src/src/sentencepiece_processor.h         |  47 +-------
+ 2 files changed, 4 insertions(+), 146 deletions(-)
+
+diff --git a/third_party/sentencepiece/src/src/error.cc b/third_party/sentencepiece/src/src/error.cc
+index 19ef6f35b822e..6e327f1779af9 100644
+--- a/third_party/sentencepiece/src/src/error.cc
++++ b/third_party/sentencepiece/src/src/error.cc
+@@ -54,107 +54,4 @@ void SetTestCounter(int c) { gTestCounter = c; }
+ bool GetTestCounter() { return gTestCounter; }
+ }  // namespace error
+ 
+-namespace util {
+-
+-Status::Status() {}
+-Status::~Status() {}
+-
+-struct Status::Rep {
+-  StatusCode code;
+-  std::string error_message;
+-};
+-
+-Status::Status(StatusCode code, absl::string_view error_message)
+-    : rep_(new Rep) {
+-  rep_->code = code;
+-  rep_->error_message = std::string(error_message);
+-}
+-
+-Status::Status(const Status& s)
+-    : rep_((s.rep_ == nullptr) ? nullptr : new Rep(*s.rep_)) {}
+-
+-void Status::operator=(const Status& s) {
+-  if (rep_ != s.rep_)
+-    rep_.reset((s.rep_ == nullptr) ? nullptr : new Rep(*s.rep_));
+-}
+-
+-bool Status::operator==(const Status& s) const { return (rep_ == s.rep_); }
+-
+-bool Status::operator!=(const Status& s) const { return (rep_ != s.rep_); }
+-
+-const char* Status::error_message() const {
+-  return ok() ? "" : rep_->error_message.c_str();
+-}
+-
+-void Status::set_error_message(const char* str) {
+-  if (rep_ == nullptr) rep_.reset(new Rep);
+-  rep_->error_message = str;
+-}
+-
+-StatusCode Status::code() const { return ok() ? StatusCode::kOk : rep_->code; }
+-
+-std::string Status::ToString() const {
+-  if (rep_ == nullptr) return "OK";
+-
+-  std::string result;
+-  switch (code()) {
+-    case StatusCode::kCancelled:
+-      result = "Cancelled";
+-      break;
+-    case StatusCode::kUnknown:
+-      result = "Unknown";
+-      break;
+-    case StatusCode::kInvalidArgument:
+-      result = "Invalid argument";
+-      break;
+-    case StatusCode::kDeadlineExceeded:
+-      result = "Deadline exceeded";
+-      break;
+-    case StatusCode::kNotFound:
+-      result = "Not found";
+-      break;
+-    case StatusCode::kAlreadyExists:
+-      result = "Already exists";
+-      break;
+-    case StatusCode::kPermissionDenied:
+-      result = "Permission denied";
+-      break;
+-    case StatusCode::kResourceExhausted:
+-      result = "Unauthenticated";
+-      break;
+-    case StatusCode::kFailedPrecondition:
+-      result = "Failed precondition";
+-      break;
+-    case StatusCode::kAborted:
+-      result = "Aborted";
+-      break;
+-    case StatusCode::kOutOfRange:
+-      result = "Out of range";
+-      break;
+-    case StatusCode::kUnimplemented:
+-      result = "Unimplemented";
+-      break;
+-    case StatusCode::kInternal:
+-      result = "Internal";
+-      break;
+-    case StatusCode::kUnavailable:
+-      result = "Unavailable";
+-      break;
+-    case StatusCode::kDataLoss:
+-      result = "Data loss";
+-      break;
+-    case StatusCode::kUnauthenticated:
+-      result = "Unauthenticated";
+-    default:
+-      break;
+-  }
+-
+-  result += ": ";
+-  result += rep_->error_message;
+-  return result;
+-}
+-
+-void Status::IgnoreError() {}
+-
+-}  // namespace util
+ }  // namespace sentencepiece
+diff --git a/third_party/sentencepiece/src/src/sentencepiece_processor.h b/third_party/sentencepiece/src/src/sentencepiece_processor.h
+index 14b1e8cd830c7..d6c7da32d05b1 100644
+--- a/third_party/sentencepiece/src/src/sentencepiece_processor.h
++++ b/third_party/sentencepiece/src/src/sentencepiece_processor.h
+@@ -22,6 +22,8 @@
+ #include <utility>
+ #include <vector>
+ 
++#include "absl/status/status.h"
++
+ #ifndef SWIG
+ namespace absl {
+ using std::string_view;
+@@ -31,49 +33,8 @@ using std::string_view;
+ namespace sentencepiece {
+ namespace util {
+ 
+-enum class StatusCode : int {
+-  kOk = 0,
+-  kCancelled = 1,
+-  kUnknown = 2,
+-  kInvalidArgument = 3,
+-  kDeadlineExceeded = 4,
+-  kNotFound = 5,
+-  kAlreadyExists = 6,
+-  kPermissionDenied = 7,
+-  kResourceExhausted = 8,
+-  kFailedPrecondition = 9,
+-  kAborted = 10,
+-  kOutOfRange = 11,
+-  kUnimplemented = 12,
+-  kInternal = 13,
+-  kUnavailable = 14,
+-  kDataLoss = 15,
+-  kUnauthenticated = 16,
+-};
+-
+-class Status {
+- public:
+-  Status();
+-  ~Status();
+-  Status(StatusCode code, absl::string_view error_message);
+-  Status(const Status &s);
+-  void operator=(const Status &s);
+-  bool operator==(const Status &s) const;
+-  bool operator!=(const Status &s) const;
+-  inline bool ok() const { return rep_ == nullptr; }
+-
+-  void set_error_message(const char *str);
+-  const char *error_message() const;
+-  const char *message() const { return error_message(); }
+-  StatusCode code() const;
+-  std::string ToString() const;
+-
+-  void IgnoreError();
+-
+- private:
+-  struct Rep;
+-  std::unique_ptr<Rep> rep_;
+-};
++using StatusCode = absl::StatusCode;
++using Status = absl::Status;
+ }  // namespace util
+ 
+ // SentencePieceProcessor:
+-- 
+2.42.0.rc1.204.g551eb34607-goog
+
diff --git a/third_party/sentencepiece/patches/0005-Fix-utf8towide.patch b/third_party/sentencepiece/patches/0005-Fix-utf8towide.patch
new file mode 100644
index 0000000000000..9047d7382ad1e
--- /dev/null
+++ b/third_party/sentencepiece/patches/0005-Fix-utf8towide.patch
@@ -0,0 +1,115 @@
+diff --git a/third_party/sentencepiece/src/src/common.h b/third_party/sentencepiece/src/src/common.h
+index f38625ea60e0f..4cdc28d127ff7 100644
+--- a/third_party/sentencepiece/src/src/common.h
++++ b/third_party/sentencepiece/src/src/common.h
+@@ -52,12 +52,6 @@ typedef uint64_t uint64;
+ 
+ static constexpr uint32 kUnicodeError = 0xFFFD;
+ 
+-#if defined(OS_WIN) && defined(UNICODE) && defined(_UNICODE)
+-#define WPATH(path) (::sentencepiece::win32::Utf8ToWide(path).c_str())
+-#else
+-#define WPATH(path) (path)
+-#endif
+-
+ template <typename T, size_t N>
+ char (&ArraySizeHelper(T (&array)[N]))[N];
+ 
+@@ -79,11 +73,6 @@ char (&ArraySizeHelper(const T (&array)[N]))[N];
+ #endif
+ 
+ namespace sentencepiece {
+-#ifdef OS_WIN
+-namespace win32 {
+-std::wstring Utf8ToWide(const absl::string_view input);
+-}  // namespace win32
+-#endif
+ 
+ #ifdef IS_BIG_ENDIAN
+ namespace util {
+diff --git a/third_party/sentencepiece/src/src/filesystem.cc b/third_party/sentencepiece/src/src/filesystem.cc
+index 36deb3fdfa750..6f294df0b2c52 100644
+--- a/third_party/sentencepiece/src/src/filesystem.cc
++++ b/third_party/sentencepiece/src/src/filesystem.cc
+@@ -19,9 +19,9 @@
+ #include "util.h"
+ 
+ #if defined(OS_WIN) && defined(UNICODE) && defined(_UNICODE)
+-#define WPATH(path) (::sentencepiece::win32::Utf8ToWide(path).c_str())
++#define WPATH(path) (::sentencepiece::util::Utf8ToWide(path).c_str())
+ #else
+-#define WPATH(path) (path)
++#define WPATH(path) (path.data())
+ #endif
+ 
+ namespace sentencepiece {
+@@ -32,7 +32,7 @@ class PosixReadableFile : public ReadableFile {
+   PosixReadableFile(absl::string_view filename, bool is_binary = false)
+       : is_(filename.empty()
+                 ? &std::cin
+-                : new std::ifstream(WPATH(filename.data()),
++                : new std::ifstream(WPATH(filename),
+                                     is_binary ? std::ios::binary | std::ios::in
+                                               : std::ios::in)) {
+     if (!*is_)
+@@ -70,7 +70,7 @@ class PosixWritableFile : public WritableFile {
+   PosixWritableFile(absl::string_view filename, bool is_binary = false)
+       : os_(filename.empty()
+                 ? &std::cout
+-                : new std::ofstream(WPATH(filename.data()),
++                : new std::ofstream(WPATH(filename),
+                                     is_binary ? std::ios::binary | std::ios::out
+                                               : std::ios::out)) {
+     if (!*os_)
+diff --git a/third_party/sentencepiece/src/src/util.cc b/third_party/sentencepiece/src/src/util.cc
+index a6d28b2cac263..322406cbc2782 100644
+--- a/third_party/sentencepiece/src/src/util.cc
++++ b/third_party/sentencepiece/src/src/util.cc
+@@ -252,28 +252,20 @@ std::vector<std::string> StrSplitAsCSV(absl::string_view text) {
+ 
+   return result;
+ }
+-}  // namespace util
+ 
+ #ifdef OS_WIN
+-namespace win32 {
+ std::wstring Utf8ToWide(absl::string_view input) {
+   int output_length = ::MultiByteToWideChar(
+       CP_UTF8, 0, input.data(), static_cast<int>(input.size()), nullptr, 0);
+-  output_length = output_length <= 0 ? 0 : output_length - 1;
+   if (output_length == 0) {
+     return L"";
+   }
+-  std::unique_ptr<wchar_t[]> input_wide(new wchar_t[output_length + 1]);
+-  std::fill(input_wide.get(), input_wide.get() + output_length + 1, L'\0');
++  std::wstring output(output_length, 0);
+   const int result = ::MultiByteToWideChar(CP_UTF8, 0, input.data(),
+                                            static_cast<int>(input.size()),
+-                                           input_wide.get(), output_length + 1);
+-  std::wstring output;
+-  if (result > 0) {
+-    output.assign(input_wide.get());
+-  }
+-  return output;
++                                           output.data(), output.size());
++  return result == output_length ? output : L"";
+ }
+-}  // namespace win32
+ #endif
++}  // namespace util
+ }  // namespace sentencepiece
+diff --git a/third_party/sentencepiece/src/src/util.h b/third_party/sentencepiece/src/src/util.h
+index 1451306618b95..656ed77f81539 100644
+--- a/third_party/sentencepiece/src/src/util.h
++++ b/third_party/sentencepiece/src/src/util.h
+@@ -340,6 +340,10 @@ std::string StrError(int errnum);
+ 
+ std::vector<std::string> StrSplitAsCSV(absl::string_view text);
+ 
++#ifdef OS_WIN
++std::wstring Utf8ToWide(const absl::string_view input);
++#endif
++
+ inline Status OkStatus() {
+   return Status();
+ }
diff --git a/third_party/sentencepiece/patches/0006-Fix-gn-check-in-sentencepiece.patch b/third_party/sentencepiece/patches/0006-Fix-gn-check-in-sentencepiece.patch
new file mode 100644
index 0000000000000..193eed8a1f0bb
--- /dev/null
+++ b/third_party/sentencepiece/patches/0006-Fix-gn-check-in-sentencepiece.patch
@@ -0,0 +1,34 @@
+From 20635c0907ff1b75481855a7328393287e22d3ba Mon Sep 17 00:00:00 2001
+From: John Abd-El-Malek <jam@chromium.org>
+Date: Mon, 21 Aug 2023 14:15:30 -0700
+Subject: [PATCH] Fix gn check in sentencepiece.
+
+---
+ third_party/sentencepiece/src/src/error.cc | 11 -----------
+ 1 file changed, 11 deletions(-)
+
+diff --git a/third_party/sentencepiece/src/src/error.cc b/third_party/sentencepiece/src/src/error.cc
+index a23c462698922..91282df7c0438 100644
+--- a/third_party/sentencepiece/src/src/error.cc
++++ b/third_party/sentencepiece/src/src/error.cc
+@@ -18,17 +18,6 @@
+ #include "init.h"
+ #include "sentencepiece_processor.h"
+ 
+-#ifdef _USE_EXTERNAL_ABSL
+-// Naive workaround to define minloglevel on external absl package.
+-// We want to define them in other cc file.
+-#include "absl/flags/flag.h"
+-#include "absl/flags/parse.h"
+-ABSL_FLAG(int32,
+-          minloglevel,
+-          0,
+-          "Messages logged at a lower level than this don't actually.");
+-#endif
+-
+ namespace sentencepiece {
+ namespace error {
+ int gTestCounter = 0;
+-- 
+2.39.1.windows.1
+
diff --git a/third_party/sentencepiece/patches/0007-SentencePiece-introduce-no-exceptions-mode.patch b/third_party/sentencepiece/patches/0007-SentencePiece-introduce-no-exceptions-mode.patch
new file mode 100644
index 0000000000000..ec59155855f80
--- /dev/null
+++ b/third_party/sentencepiece/patches/0007-SentencePiece-introduce-no-exceptions-mode.patch
@@ -0,0 +1,124 @@
+From f056d5f4cc818a6b9da93e93b5d47cdd7cfb5ca5 Mon Sep 17 00:00:00 2001
+From: Piotr Bialecki <bialpio@chromium.org>
+Date: Tue, 10 Oct 2023 11:26:05 -0700
+Subject: [PATCH] SentencePiece: introduce no-exceptions mode
+
+---
+ third_party/sentencepiece/src/src/util.cc     |  4 +++
+ .../src/third_party/darts_clone/darts.h       | 35 +++++++++----------
+ 2 files changed, 20 insertions(+), 19 deletions(-)
+
+diff --git a/third_party/sentencepiece/src/src/util.cc b/third_party/sentencepiece/src/src/util.cc
+index 322406cbc2782..c5e5289807a0c 100644
+--- a/third_party/sentencepiece/src/src/util.cc
++++ b/third_party/sentencepiece/src/src/util.cc
+@@ -32,11 +32,15 @@ void SetRandomGeneratorSeed(unsigned int seed) {
+ }
+ 
+ uint32 GetRandomGeneratorSeed() {
++#if !SENTENCEPIECE_DISABLE_EXCEPTIONS
+   try {
++#endif
+     return g_seed == kDefaultSeed ? std::random_device{}() : g_seed.load();
++#if !SENTENCEPIECE_DISABLE_EXCEPTIONS
+   } catch (...) {
+     return g_seed.load();
+   }
++#endif
+ }
+ 
+ namespace logging {
+diff --git a/third_party/sentencepiece/src/third_party/darts_clone/darts.h b/third_party/sentencepiece/src/third_party/darts_clone/darts.h
+index f9b32b1ec615b..9b975545aece1 100644
+--- a/third_party/sentencepiece/src/third_party/darts_clone/darts.h
++++ b/third_party/sentencepiece/src/third_party/darts_clone/darts.h
+@@ -5,6 +5,10 @@
+ #include <exception>
+ #include <new>
+ 
++#if DARTS_DISABLE_EXCEPTIONS
++#include "absl/log/absl_check.h"
++#endif
++
+ #define DARTS_VERSION "0.32"
+ 
+ // DARTS_THROW() throws a <Darts::Exception> whose message starts with the
+@@ -15,9 +19,14 @@
+ #define DARTS_INT_TO_STR(value) #value
+ #define DARTS_LINE_TO_STR(line) DARTS_INT_TO_STR(line)
+ #define DARTS_LINE_STR DARTS_LINE_TO_STR(__LINE__)
++
++#if DARTS_DISABLE_EXCEPTIONS
++#define DARTS_THROW(msg) ABSL_CHECK(false) << msg
++#else
+ #define DARTS_THROW(msg)                                      \
+   throw Darts::Details::Exception(__FILE__ ":" DARTS_LINE_STR \
+                                            ": exception: " msg)
++#endif
+ 
+ namespace Darts {
+ 
+@@ -74,6 +83,7 @@ class DoubleArrayUnit {
+   // Copyable.
+ };
+ 
++#if !DARTS_DISABLE_EXCEPTIONS
+ // Darts-clone throws an <Exception> for memory allocation failure, invalid
+ // arguments or a too large offset. The last case means that there are too many
+ // keys in the given set of keys. Note that the `msg' of <Exception> must be a
+@@ -96,6 +106,7 @@ class Exception : public std::exception {
+   // Disallows operator=.
+   Exception& operator=(const Exception&);
+ };
++#endif  // !DARTS_DISABLE_EXCEPTIONS
+ 
+ }  // namespace Details
+ 
+@@ -373,15 +384,9 @@ int DoubleArrayImpl<A, B, T, C>::open(const char* file_name,
+     }
+   }
+ 
+-  unit_type* buf;
+-  try {
+-    buf = new unit_type[size];
+-    for (id_type i = 0; i < 256; ++i) {
+-      buf[i] = units[i];
+-    }
+-  } catch (const std::bad_alloc&) {
+-    std::fclose(file);
+-    DARTS_THROW("failed to open double-array: std::bad_alloc");
++  unit_type* buf = new unit_type[size];
++  for (id_type i = 0; i < 256; ++i) {
++    buf[i] = units[i];
+   }
+ 
+   if (size > 256) {
+@@ -688,11 +693,7 @@ void AutoPool<T>::resize_buf(std::size_t size) {
+   }
+ 
+   AutoArray<char> buf;
+-  try {
+-    buf.reset(new char[sizeof(T) * capacity]);
+-  } catch (const std::bad_alloc&) {
+-    DARTS_THROW("failed to resize pool: std::bad_alloc");
+-  }
++  buf.reset(new char[sizeof(T) * capacity]);
+ 
+   if (size_ > 0) {
+     T* src = reinterpret_cast<T*>(&buf_[0]);
+@@ -804,11 +805,7 @@ class BitVector {
+ };
+ 
+ inline void BitVector::build() {
+-  try {
+-    ranks_.reset(new id_type[units_.size()]);
+-  } catch (const std::bad_alloc&) {
+-    DARTS_THROW("failed to build rank index: std::bad_alloc");
+-  }
++  ranks_.reset(new id_type[units_.size()]);
+ 
+   num_ones_ = 0;
+   for (std::size_t i = 0; i < units_.size(); ++i) {
+-- 
+2.42.0.609.gbb76f46606-goog
+
diff --git a/third_party/shell-encryption/patches/0001-Support-SHELL-in-chromium.patch b/third_party/shell-encryption/patches/0001-Support-SHELL-in-chromium.patch
new file mode 100644
index 0000000000000..841932cd25b43
--- /dev/null
+++ b/third_party/shell-encryption/patches/0001-Support-SHELL-in-chromium.patch
@@ -0,0 +1,115 @@
+diff --git a/montgomery.cc b/montgomery.cc
+index d5221f4..9fbc5da 100644
+--- a/montgomery.cc
++++ b/montgomery.cc
+@@ -22,8 +22,8 @@ template <typename T>
+ rlwe::StatusOr<std::unique_ptr<const MontgomeryIntParams<T>>>
+ MontgomeryIntParams<T>::Create(Int modulus) {
+   // Check that the modulus is smaller than max(Int) / 4.
+-  if (Int most_significant_bit = modulus >> (bitsize_int - 2);
+-      most_significant_bit != 0) {
++  Int most_significant_bit = modulus >> (bitsize_int - 2);
++  if (most_significant_bit != 0) {
+     return absl::InvalidArgumentError(absl::StrCat(
+         "The modulus should be less than 2^", (bitsize_int - 2), "."));
+   }
+diff --git a/ntt_parameters.h b/ntt_parameters.h
+index 56e1871..c3da197 100644
+--- a/ntt_parameters.h
++++ b/ntt_parameters.h
+@@ -103,7 +103,8 @@ static void BitrevHelper(const std::vector<unsigned int>& bitrevs,
+   using std::swap;
+   for (int i = 0; i < item_to_reverse->size(); i++) {
+     // Only swap in one direction - don't accidentally swap twice.
+-    if (unsigned int r = bitrevs[i]; i < r) {
++    unsigned int r = bitrevs[i];
++    if (static_cast<unsigned int>(i) < r) {
+       swap((*item_to_reverse)[i], (*item_to_reverse)[r]);
+     }
+   }
+diff --git a/polynomial.h b/polynomial.h
+index 07843b2..3cf0c77 100644
+--- a/polynomial.h
++++ b/polynomial.h
+@@ -80,7 +80,8 @@ class Polynomial {
+                                  const NttParameters<ModularInt>* ntt_params,
+                                  const ModularIntParams* modular_params) {
+     // Check to ensure that the coefficient vector is of the correct length.
+-    if (int len = poly_coeffs.size(); len <= 0 || (len & (len - 1)) != 0) {
++    int len = poly_coeffs.size();
++    if (len <= 0 || (len & (len - 1)) != 0) {
+       // An error value.
+       return Polynomial();
+     }
+diff --git a/prng/chacha_prng_util.cc b/prng/chacha_prng_util.cc
+index dfab1d9..c49c82d 100644
+--- a/prng/chacha_prng_util.cc
++++ b/prng/chacha_prng_util.cc
+@@ -24,7 +24,8 @@
+ #include <openssl/rand.h>
+ #include "status_macros.h"
+ 
+-namespace rlwe::internal {
++namespace rlwe {
++namespace internal {
+ 
+ absl::Status ChaChaPrngResalt(absl::string_view key, int buffer_size,
+                               int* salt_counter, int* position_in_buffer,
+@@ -85,4 +86,5 @@ rlwe::StatusOr<Uint64> ChaChaPrngRand64(absl::string_view key,
+   return rand64;
+ }
+ 
+-}  // namespace rlwe::internal
++}  // namespace internal
++}  // namespace rlwe
+diff --git a/prng/chacha_prng_util.h b/prng/chacha_prng_util.h
+index 32cac5b..8eb8118 100644
+--- a/prng/chacha_prng_util.h
++++ b/prng/chacha_prng_util.h
+@@ -28,7 +28,8 @@
+ #include "integral_types.h"
+ #include "statusor.h"
+ 
+-namespace rlwe::internal {
++namespace rlwe {
++namespace internal {
+ 
+ const int kChaChaKeyBytesSize = 32;
+ const int kChaChaNonceSize = 12;
+@@ -59,6 +60,7 @@ rlwe::StatusOr<Uint64> ChaChaPrngRand64(absl::string_view key,
+                                         int* salt_counter,
+                                         std::vector<Uint8>* buffer);
+ 
+-}  // namespace rlwe::internal
++}  // namespace internal
++}  // namespace rlwe
+ 
+ #endif  // RLWE_CHACHA_PRNG_UTIL_H_
+diff --git a/statusor.h b/statusor.h
+index d8addb5..200f62d 100644
+--- a/statusor.h
++++ b/statusor.h
+@@ -96,7 +96,7 @@ class StatusOr {
+ 
+   operator absl::Status() const { return status(); }
+ 
+-  template <template <typename> typename OtherStatusOrType>
++  template <template <typename> class OtherStatusOrType>
+   operator OtherStatusOrType<T>() {
+     if (value_) {
+       return OtherStatusOrType<T>(std::move(value_.value()));
+diff --git a/symmetric_encryption.h b/symmetric_encryption.h
+index e120b18..987e86f 100644
+--- a/symmetric_encryption.h
++++ b/symmetric_encryption.h
+@@ -571,8 +571,8 @@ class SymmetricRlweKey {
+       const typename ModularIntQ::Params* modulus_params_q,
+       const NttParameters<ModularIntQ>* ntt_params_q) const {
+     // Configuration failure.
+-    if (Int t = (modulus_params_q->One() << log_t_) + modulus_params_q->One();
+-        modulus_params_->modulus % t != modulus_params_q->modulus % t) {
++    Int t = (modulus_params_q->One() << log_t_) + modulus_params_q->One();
++    if (modulus_params_->modulus % t != modulus_params_q->modulus % t) {
+       return absl::InvalidArgumentError("p % t != q % t");
+     }
+ 
diff --git a/third_party/shell-encryption/patches/0003-Support-SHELL-tests-in-chromium.patch b/third_party/shell-encryption/patches/0003-Support-SHELL-tests-in-chromium.patch
new file mode 100644
index 0000000000000..0b470515e5dbe
--- /dev/null
+++ b/third_party/shell-encryption/patches/0003-Support-SHELL-tests-in-chromium.patch
@@ -0,0 +1,1243 @@
+diff --git a/context_test.cc b/context_test.cc
+index 73436a9..9f35334 100644
+--- a/context_test.cc
++++ b/context_test.cc
+@@ -33,7 +33,7 @@ TYPED_TEST_SUITE(ContextTest, rlwe::testing::ModularIntTypes);
+ 
+ TYPED_TEST(ContextTest, CreateWorks) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+   }
+@@ -41,7 +41,7 @@ TYPED_TEST(ContextTest, CreateWorks) {
+ 
+ TYPED_TEST(ContextTest, ParametersMatch) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+ 
+diff --git a/error_params_test.cc b/error_params_test.cc
+index fe1fd55..7cc3c8b 100644
+--- a/error_params_test.cc
++++ b/error_params_test.cc
+@@ -120,7 +120,7 @@ TYPED_TEST_SUITE(ErrorParamsTest, rlwe::testing::ModularIntTypes);
+ 
+ TYPED_TEST(ErrorParamsTest, CreateError) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+ 
+@@ -140,7 +140,7 @@ TYPED_TEST(ErrorParamsTest, CreateError) {
+ 
+ TYPED_TEST(ErrorParamsTest, PlaintextError) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+ 
+@@ -161,7 +161,7 @@ TYPED_TEST(ErrorParamsTest, PlaintextError) {
+ 
+ TYPED_TEST(ErrorParamsTest, EncryptionError) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key, this->SampleKey(context.get()));
+@@ -186,7 +186,7 @@ TYPED_TEST(ErrorParamsTest, EncryptionError) {
+ 
+ TYPED_TEST(ErrorParamsTest, RelinearizationErrorScalesWithT) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     // Error scales by (T / logT) when all other constants are fixed.
+diff --git a/galois_key_test.cc b/galois_key_test.cc
+index 022ddd5..b73a4d4 100644
+--- a/galois_key_test.cc
++++ b/galois_key_test.cc
+@@ -17,6 +17,7 @@
+ 
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
++#include <google/protobuf/util/message_differencer.h>
+ #include "constants.h"
+ #include "montgomery.h"
+ #include "ntt_parameters.h"
+@@ -408,7 +409,7 @@ TEST_F(GaloisKeyTest, SerializationsOfIdentialKeysEqual) {
+   ASSERT_OK_AND_ASSIGN(auto serialized_copy, galois_key_copy.Serialize());
+ 
+   // Check that two serializations of the same matrix are equal.
+-  EXPECT_THAT(serialized_copy, EqualsProto(serialized));
++  EXPECT_EQ(serialized_copy.SerializeAsString(), serialized.SerializeAsString());
+ }
+ 
+ }  //  namespace
+diff --git a/int256.cc b/int256.cc
+index 1096c98..f9a40fc 100644
+--- a/int256.cc
++++ b/int256.cc
+@@ -40,7 +40,7 @@ const uint256_pod kuint256max = {absl::kuint128max, absl::kuint128max};
+     }                                         \
+   } while (0)
+ static inline int Fls64(Uint64 n) {
+-  DCHECK_NE(0, n);
++  //DCHECK_NE(0, n);
+   int pos = 0;
+   STEP(Uint64, n, pos, 0x20);
+   Uint32 n32 = n;
+diff --git a/montgomery_test.cc b/montgomery_test.cc
+index 7fe438f..7caf459 100644
+--- a/montgomery_test.cc
++++ b/montgomery_test.cc
+@@ -102,7 +102,7 @@ TYPED_TEST(MontgomeryTest, ParamsInvModulus) {
+   using Int = typename TypeParam::Int;
+   using BigInt = typename internal::BigInt<Int>::value_type;
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     EXPECT_EQ(modulus_params->r * modulus_params->inv_r -
+@@ -118,7 +118,7 @@ TYPED_TEST(MontgomeryTest, ImportExportInt) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -140,7 +140,7 @@ TYPED_TEST(MontgomeryTest, AddSub) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -173,7 +173,7 @@ TYPED_TEST(MontgomeryTest, InlineAddSub) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -209,7 +209,7 @@ TYPED_TEST(MontgomeryTest, Equality) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -251,7 +251,7 @@ TYPED_TEST(MontgomeryTest, Negate) {
+   using Int = typename TypeParam::Int;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (Int i = 0; i < 4 * kNewhopeModulus; i++) {
+@@ -271,7 +271,7 @@ TYPED_TEST(MontgomeryTest, AddRepeatedly) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -307,7 +307,7 @@ TYPED_TEST(MontgomeryTest, Multiply) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     // Test over many random values.
+@@ -346,7 +346,7 @@ TYPED_TEST(MontgomeryTest, MulInPlace) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     // Test over many random values.
+@@ -375,7 +375,7 @@ TYPED_TEST(MontgomeryTest, MulConstantInPlace) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     // Test over many random values.
+@@ -387,7 +387,9 @@ TYPED_TEST(MontgomeryTest, MulConstantInPlace) {
+       auto ma_clone = ma;
+       ASSERT_OK_AND_ASSIGN(auto mb,
+                            TypeParam::ImportInt(b, modulus_params.get()));
+-      auto [constant, constant_barrett] = mb.GetConstant(modulus_params.get());
++      auto constants_tuple = mb.GetConstant(modulus_params.get());
++      auto constant = std::get<0>(constants_tuple);
++      auto constant_barrett = std::get<1>(constants_tuple);
+       ma.MulInPlace(mb, modulus_params.get());
+       ma_clone.MulConstantInPlace(constant, constant_barrett,
+                                   modulus_params.get());
+@@ -407,7 +409,7 @@ TYPED_TEST(MontgomeryTest, MultiplyRepeatedly) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -436,7 +438,7 @@ TYPED_TEST(MontgomeryTest, SmallModulus) {
+   using BigInt = typename internal::BigInt<Int>::value_type;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     const BigInt modulus = static_cast<BigInt>(modulus_params->modulus);
+@@ -501,7 +503,7 @@ TYPED_TEST(MontgomeryTest, ModExpModulus) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     const BigInt modulus = static_cast<BigInt>(modulus_params->modulus);
+@@ -529,7 +531,7 @@ TYPED_TEST(MontgomeryTest, InverseModulus) {
+   unsigned int seed = 0;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -548,7 +550,7 @@ TYPED_TEST(MontgomeryTest, Serialization) {
+   using Int = typename TypeParam::Int;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (Int i = 0; i < kExhaustiveTest; i++) {
+@@ -587,7 +589,7 @@ TYPED_TEST(MontgomeryTest, ExceedMaxNumCoeffVectorSerialization) {
+   int num_coeffs = kMaxNumCoeffs + 1;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -605,7 +607,7 @@ TYPED_TEST(MontgomeryTest, ExceedMaxNumCoeffVectorSerialization) {
+ 
+ TYPED_TEST(MontgomeryTest, EmptyVectorSerialization) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     std::vector<TypeParam> coeffs;
+@@ -620,7 +622,7 @@ TYPED_TEST(MontgomeryTest, VectorSerialization) {
+   auto prng = absl::make_unique<rlwe::testing::TestingPrng>(0);
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -653,7 +655,7 @@ TYPED_TEST(MontgomeryTest, ExceedMaxNumCoeffVectorDeserialization) {
+   int num_coeffs = kMaxNumCoeffs + 1;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -670,7 +672,7 @@ TYPED_TEST(MontgomeryTest, NegativeVectorDeserialization) {
+   int num_coeffs = -1;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     EXPECT_THAT(
+@@ -686,7 +688,7 @@ TYPED_TEST(MontgomeryTest, ImportRandomWithPrngWithSameKeys) {
+   unsigned int seed_prng = GenerateRandom<unsigned int>(&seed);
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -707,7 +709,7 @@ TYPED_TEST(MontgomeryTest, ImportRandomWithPrngWithDifferentKeys) {
+   unsigned int seed_prng2 = seed_prng1 + 1;  // Different seed
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -727,7 +729,7 @@ TYPED_TEST(MontgomeryTest, VerifyBarrett) {
+   using BigInt = typename internal::BigInt<Int>::value_type;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -754,7 +756,7 @@ TYPED_TEST(MontgomeryTest, BatchOperations) {
+   auto prng = absl::make_unique<rlwe::testing::TestingPrng>(seed_prng);
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+ 
+@@ -765,8 +767,9 @@ TYPED_TEST(MontgomeryTest, BatchOperations) {
+       TypeParam scalar =
+           TypeParam::ImportRandom(prng.get(), modulus_params.get())
+               .ValueOrDie();
+-      auto [scalar_constant, scalar_constant_barrett] =
+-          scalar.GetConstant(modulus_params.get());
++      auto scalar_constants_tuple = scalar.GetConstant(modulus_params.get());
++      auto scalar_constant = std::get<0>(scalar_constants_tuple);
++      auto scalar_constant_barrett = std::get<1>(scalar_constants_tuple);
+       std::vector<TypeParam> expected_add_scalar, expected_sub_scalar,
+           expected_mul_scalar;
+       for (size_t i = 0; i < length; i++) {
+@@ -774,8 +777,9 @@ TYPED_TEST(MontgomeryTest, BatchOperations) {
+                         .ValueOrDie());
+         b.push_back(TypeParam::ImportRandom(prng.get(), modulus_params.get())
+                         .ValueOrDie());
+-        auto [constant, constant_barrett] =
+-            b[i].GetConstant(modulus_params.get());
++        auto constants_tuple = b[i].GetConstant(modulus_params.get());
++        auto constant = std::get<0>(constants_tuple);
++        auto constant_barrett = std::get<1>(constants_tuple); 
+         b_constant.push_back(constant);
+         b_constant_barrett.push_back(constant_barrett);
+         expected_add.push_back(a[i].Add(b[i], modulus_params.get()));
+@@ -844,7 +848,7 @@ TYPED_TEST(MontgomeryTest, BatchOperationsFailsWithVectorsOfDifferentSize) {
+   using Int = typename TypeParam::Int;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     for (size_t length_a : {1, 2, 7, 32, 500, 1024}) {
+@@ -911,7 +915,7 @@ class FakePrng {
+ 
+ TYPED_TEST(MontgomeryTest, PrngTemplateParameterizationWorks) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+                          TypeParam::Params::Create(params.modulus));
+     FakePrng prng;
+diff --git a/ntt_parameters_test.cc b/ntt_parameters_test.cc
+index 189c096..5425de7 100644
+--- a/ntt_parameters_test.cc
++++ b/ntt_parameters_test.cc
+@@ -39,7 +39,7 @@ TYPED_TEST_SUITE(NttParametersTest, rlwe::testing::ModularIntTypes);
+ 
+ TYPED_TEST(NttParametersTest, LogNumCoeffsTooLarge) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     // Do not create a context, since it creates NttParameters already. Instead,
+     // create the modulus parameters manually.
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+@@ -71,7 +71,7 @@ TYPED_TEST(NttParametersTest, PrimitiveNthRootOfUnity) {
+   unsigned int len = 5;
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     // Do not create a context, since it creates NttParameters already. Instead,
+     // create the modulus parameters manually.
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+@@ -97,7 +97,7 @@ TYPED_TEST(NttParametersTest, PrimitiveNthRootOfUnity) {
+ 
+ TYPED_TEST(NttParametersTest, NttPsis) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     // Do not create a context, since it creates NttParameters already. Instead,
+     // create the modulus parameters manually.
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+@@ -131,7 +131,7 @@ TYPED_TEST(NttParametersTest, NttPsis) {
+ 
+ TYPED_TEST(NttParametersTest, NttPsisBitrev) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     // Do not create a context, since it creates NttParameters already. Instead,
+     // create the modulus parameters manually.
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+@@ -159,7 +159,7 @@ TYPED_TEST(NttParametersTest, NttPsisBitrev) {
+ 
+ TYPED_TEST(NttParametersTest, NttPsisInvBitrev) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     // Do not create a context, since it creates NttParameters already. Instead,
+     // create the modulus parameters manually.
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+@@ -208,7 +208,7 @@ TEST(NttParametersRegularTest, Bitrev) {
+ 
+ TYPED_TEST(NttParametersTest, IncorrectNTTParams) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     // Do not create a context, since it creates NttParameters already. Instead,
+     // create the modulus parameters manually.
+     // modulus + 2, will no longer be 1 mod 2*n
+@@ -227,7 +227,7 @@ TYPED_TEST(NttParametersTest, IncorrectNTTParams) {
+ // Test all the NTT Parameter fields.
+ TYPED_TEST(NttParametersTest, Initialize) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     // Do not create a context, since it creates NttParameters already. Instead,
+     // create the modulus parameters manually.
+     ASSERT_OK_AND_ASSIGN(auto modulus_params,
+diff --git a/prng/chacha_prng_util.cc b/prng/chacha_prng_util.cc
+index c49c82d..e63bb61 100644
+--- a/prng/chacha_prng_util.cc
++++ b/prng/chacha_prng_util.cc
+@@ -31,16 +31,27 @@ absl::Status ChaChaPrngResalt(absl::string_view key, int buffer_size,
+                               int* salt_counter, int* position_in_buffer,
+                               std::vector<Uint8>* buffer) {
+   buffer->assign(buffer_size, 0);
+-  std::string salt = "salt";
+-  if (salt.size() > kChaChaNonceSize) {
+-    return absl::InternalError("The salt length is too large.");
++
++  // Following https://tools.ietf.org/html/rfc7539, Sec 2.3, we create the
++  // nonce as a kChaChaNonceSize (=12) bytes string, where the 4 first
++  // bytes are fixed, and the next 8 bytes correspond to the counter.
++  std::string nonce = "salt00000000";
++  if (nonce.size() != kChaChaNonceSize) {
++    return absl::InternalError("The salt length is incorrect.");
++  }
++  Uint64 counter = static_cast<Uint64>(*salt_counter);
++  for (int i = 0; i < 8; i++) {
++    nonce[4 + i] = counter & 0xFF;
++    counter >>= 8;
+   }
+-  salt.resize(kChaChaNonceSize, 0);
+ 
++  // We call the CRYPTO_chacha_20() function from OpenSSL. Note that the last
++  // parameter is a *block* counter. The salt counter needs instead to be
++  // included in the nonce.
+   CRYPTO_chacha_20(buffer->data(), buffer->data(), buffer->size(),
+                    reinterpret_cast<const Uint8*>(key.data()),
+-                   reinterpret_cast<const Uint8*>(salt.data()),
+-                   static_cast<uint32_t>(*salt_counter));
++                   reinterpret_cast<const Uint8*>(nonce.data()),
++                   /* counter = */ 0);
+ 
+   ++(*salt_counter);
+   *position_in_buffer = 0;
+diff --git a/prng/prng_test.cc b/prng/prng_test.cc
+index de7eacc..f98d98e 100644
+--- a/prng/prng_test.cc
++++ b/prng/prng_test.cc
+@@ -142,5 +142,29 @@ TYPED_TEST(PrngTest, ReplayDifferentInKeyTest) {
+   EXPECT_NE(r64, other_r64);
+ }
+ 
++TYPED_TEST(PrngTest, GeneratesUniqueRandomStrings) {
++  const int kKeySize = 20;
++  const int kIterations = 10000;
++  const char charset[] = "abcdefghijklmnopqrstuvwxyz0123456789";
++
++  std::vector<std::string> keys;
++  for (int i = 0; i < kIterations; i++) {
++    // Create a random key
++    std::string key(kKeySize, 0);
++    for (int j = 0; j < kKeySize; j++) {
++      ASSERT_OK_AND_ASSIGN(auto v, this->prng_->Rand8());
++      key[j] = charset[static_cast<int>(v) % sizeof(charset)];
++    }
++
++    // With very high probability (~(1/36)^20), a key will only appear once.
++    int count = 0;
++    for (auto k : keys) {
++      if (k == key) count++;
++    }
++    ASSERT_EQ(count, 0);
++    keys.push_back(key);
++  }
++}
++
+ }  // namespace
+ }  // namespace rlwe
+diff --git a/sample_error_test.cc b/sample_error_test.cc
+index 49bb495..41071c0 100644
+--- a/sample_error_test.cc
++++ b/sample_error_test.cc
+@@ -46,7 +46,7 @@ TYPED_TEST(SampleErrorTest, CheckUpperBoundOnNoise) {
+   auto prng = absl::make_unique<rlwe::testing::TestingPrng>(0);
+ 
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+ 
+@@ -73,7 +73,7 @@ TYPED_TEST(SampleErrorTest, CheckUpperBoundOnNoise) {
+ TYPED_TEST(SampleErrorTest, FailOnTooLargeVariance) {
+   auto prng = absl::make_unique<rlwe::testing::TestingPrng>(0);
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+ 
+diff --git a/serialization.proto b/serialization.proto
+index 6d02b74..b7fefcf 100644
+--- a/serialization.proto
++++ b/serialization.proto
+@@ -15,6 +15,8 @@
+ 
+ syntax = "proto2";
+ 
++option optimize_for = LITE_RUNTIME;
++
+ package rlwe;
+ 
+ // NTT Polynomial
+diff --git a/symmetric_encryption_test.cc b/symmetric_encryption_test.cc
+index 6e58422..6c05be2 100644
+--- a/symmetric_encryption_test.cc
++++ b/symmetric_encryption_test.cc
+@@ -91,7 +91,7 @@ TYPED_TEST_SUITE(SymmetricRlweEncryptionTest, rlwe::testing::ModularIntTypes);
+ TYPED_TEST(SymmetricRlweEncryptionTest, RemoveErrorNegative) {
+   unsigned int seed = 0;
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+ 
+@@ -136,7 +136,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, RemoveErrorNegative) {
+ // different values of t.
+ TYPED_TEST(SymmetricRlweEncryptionTest, RemoveErrorPositive) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     unsigned int seed = 0;
+@@ -167,7 +167,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, RemoveErrorPositive) {
+ // Ensure that the encryption scheme can decrypt its own ciphertexts.
+ TYPED_TEST(SymmetricRlweEncryptionTest, CanDecrypt) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; i++) {
+@@ -187,7 +187,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, CanDecrypt) {
+ // Accessing out of bounds raises errors
+ TYPED_TEST(SymmetricRlweEncryptionTest, OutOfBoundsIndex) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key, this->SampleKey(context.get()));
+@@ -208,7 +208,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, OutOfBoundsIndex) {
+ // Check that the HE scheme is additively homomorphic.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AdditivelyHomomorphic) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; i++) {
+@@ -252,7 +252,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AdditivelyHomomorphic) {
+ // Check that homomorphic addition can be performed in place.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AddHomomorphicallyInPlace) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; i++) {
+@@ -302,7 +302,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AddHomomorphicallyInPlace) {
+ // plaintext.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AddToZero) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; i++) {
+@@ -329,7 +329,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AddToZero) {
+ // Check that homomorphic absorption works.
+ TYPED_TEST(SymmetricRlweEncryptionTest, Absorb) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; i++) {
+@@ -388,7 +388,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, Absorb) {
+ // Check that homomorphic absorption in place works.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AbsorbInPlace) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; i++) {
+@@ -447,7 +447,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AbsorbInPlace) {
+ // Check that homomorphic absorption of a scalar works.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AbsorbScalar) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     unsigned int seed = 0;
+@@ -500,7 +500,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AbsorbScalar) {
+ // Check that homomorphic absorption of a scalar in place works.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AbsorbScalarInPlace) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     unsigned int seed = 0;
+@@ -553,7 +553,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AbsorbScalarInPlace) {
+ // Check that we cannot multiply with an empty ciphertext.
+ TYPED_TEST(SymmetricRlweEncryptionTest, EmptyCipherMultiplication) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key, this->SampleKey(context.get()));
+@@ -601,7 +601,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, MultiplicativelyHomomorphic) {
+   if (sizeof(TypeParam) > 2) {  // No multiplicative homomorphism possible when
+                                 // TypeParam = Uint16
+     for (const auto& params :
+-         rlwe::testing::ContextParameters<TypeParam>::value) {
++         rlwe::testing::ContextParameters<TypeParam>::Value()) {
+       ASSERT_OK_AND_ASSIGN(auto context,
+                            rlwe::RlweContext<TypeParam>::Create(params));
+       for (int i = 0; i < kTestingRounds; i++) {
+@@ -658,7 +658,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, MultiplicativelyHomomorphic) {
+ // Check that many homomorphic additions can be performed.
+ TYPED_TEST(SymmetricRlweEncryptionTest, ManyHomomorphicAdds) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     // Sample a starting plaintext and ciphertext and create aggregators;
+@@ -705,7 +705,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, ManyHomomorphicAdds) {
+ TYPED_TEST(SymmetricRlweEncryptionTest,
+            ExceedMaxNumCoeffDeserializeCiphertext) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+ 
+@@ -733,7 +733,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest,
+ // Check that ciphertext serialization works.
+ TYPED_TEST(SymmetricRlweEncryptionTest, SerializeCiphertext) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -768,7 +768,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, SerializeCiphertext) {
+ // Check that key serialization works.
+ TYPED_TEST(SymmetricRlweEncryptionTest, SerializeKey) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (int i = 0; i < kTestingRounds; i++) {
+@@ -809,7 +809,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, SerializeKey) {
+ // Try an ill-formed key modulus switching
+ TYPED_TEST(SymmetricRlweEncryptionTest, FailingKeyModulusReduction) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     // p is the original modulus and q is the new modulus we want to switch to
+@@ -836,7 +836,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, FailingKeyModulusReduction) {
+ // Try an ill-formed ciphertext modulus switching
+ TYPED_TEST(SymmetricRlweEncryptionTest, FailingCiphertextModulusReduction) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     // p is the original modulus and q is the new modulus we want to switch to
+@@ -871,8 +871,9 @@ TYPED_TEST(SymmetricRlweEncryptionTest, FailingCiphertextModulusReduction) {
+ 
+ // Test modulus switching.
+ TYPED_TEST(SymmetricRlweEncryptionTest, ModulusReduction) {
+-  for (const auto& [params1, params2] :
+-       rlwe::testing::ContextParametersModulusSwitching<TypeParam>::value) {
++  for (const auto& params :
++       rlwe::testing::ContextParametersModulusSwitching<TypeParam>::Value()) {
++    auto params1 = std::get<0>(params), params2 = std::get<1>(params);
+     ASSERT_OK_AND_ASSIGN(auto context1,
+                          rlwe::RlweContext<TypeParam>::Create(params1));
+     ASSERT_OK_AND_ASSIGN(auto context2,
+@@ -913,8 +914,9 @@ TYPED_TEST(SymmetricRlweEncryptionTest, ModulusReduction) {
+ 
+ // Check that modulus switching reduces the error.
+ TYPED_TEST(SymmetricRlweEncryptionTest, ModulusSwitchingReducesLargeError) {
+-  for (const auto& [params1, params2] :
+-       rlwe::testing::ContextParametersModulusSwitching<TypeParam>::value) {
++  for (const auto& params :
++       rlwe::testing::ContextParametersModulusSwitching<TypeParam>::Value()) {
++    auto params1 = std::get<0>(params), params2 = std::get<1>(params);
+     ASSERT_OK_AND_ASSIGN(auto context1,
+                          rlwe::RlweContext<TypeParam>::Create(params1));
+     ASSERT_OK_AND_ASSIGN(auto context2,
+@@ -968,7 +970,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, ModulusSwitchingReducesLargeError) {
+ // different powers of s.
+ TYPED_TEST(SymmetricRlweEncryptionTest, OperationsFailOnMismatchedPowersOfS) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key, this->SampleKey(context.get()));
+@@ -1002,7 +1004,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, OperationsFailOnMismatchedPowersOfS) {
+ // Verifies that the power of S changes as expected in adds / mults.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AddsAndMultPreservePowerOfS) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key, this->SampleKey(context.get()));
+@@ -1037,7 +1039,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AddsAndMultPreservePowerOfS) {
+ // Check that substitutions of the form 2^k + 1 work.
+ TYPED_TEST(SymmetricRlweEncryptionTest, Substitutes) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (int k = 1; k < context->GetLogN(); k++) {
+@@ -1083,7 +1085,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, Substitutes) {
+ // Check that substitution of 2 does not work.
+ TYPED_TEST(SymmetricRlweEncryptionTest, SubstitutionFailsOnEvenPower) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key, this->SampleKey(context.get()));
+@@ -1102,7 +1104,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, SubstitutionFailsOnEvenPower) {
+ // Check that the power of s updates after several substitutions.
+ TYPED_TEST(SymmetricRlweEncryptionTest, PowerOfSUpdatedAfterRepeatedSubs) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     int substitution_power = 5;
+@@ -1127,7 +1129,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, PowerOfSUpdatedAfterRepeatedSubs) {
+ // Check that operations can only be performed when powers of s match.
+ TYPED_TEST(SymmetricRlweEncryptionTest, PowersOfSMustMatchOnOperations) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     int substitution_power = 5;
+@@ -1160,7 +1162,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, PowersOfSMustMatchOnOperations) {
+ // Check that the null key has value 0.
+ TYPED_TEST(SymmetricRlweEncryptionTest, NullKeyHasValueZero) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     rlwe::Polynomial<TypeParam> zero(context->GetN(),
+@@ -1179,7 +1181,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, NullKeyHasValueZero) {
+ // Check the addition and subtraction of keys.
+ TYPED_TEST(SymmetricRlweEncryptionTest, AddAndSubKeys) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key_1, this->SampleKey(context.get()));
+@@ -1203,7 +1205,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, AddAndSubKeys) {
+ // Check that decryption works with added and subtracted keys.
+ TYPED_TEST(SymmetricRlweEncryptionTest, EncryptAndDecryptWithAddAndSubKeys) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto key_1, this->SampleKey(context.get()));
+@@ -1231,7 +1233,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, EncryptAndDecryptWithAddAndSubKeys) {
+ // Check that the scheme is key homomorphic.
+ TYPED_TEST(SymmetricRlweEncryptionTest, IsKeyHomomorphic) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto prng_seed,
+@@ -1319,7 +1321,7 @@ TYPED_TEST(SymmetricRlweEncryptionTest, IsKeyHomomorphic) {
+ // Check that incompatible key cannot be added or subtracted.
+ TYPED_TEST(SymmetricRlweEncryptionTest, CannotAddOrSubIncompatibleKeys) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     ASSERT_OK_AND_ASSIGN(auto context_different_variance,
+diff --git a/symmetric_encryption_with_prng_test.cc b/symmetric_encryption_with_prng_test.cc
+index 88e86e3..beb1324 100644
+--- a/symmetric_encryption_with_prng_test.cc
++++ b/symmetric_encryption_with_prng_test.cc
+@@ -110,7 +110,7 @@ TYPED_TEST_SUITE(SymmetricEncryptionWithPrngTest,
+ // ciphertext.
+ TYPED_TEST(SymmetricEncryptionWithPrngTest, EncryptDecryptSingleCompressed) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; ++i) {
+@@ -126,7 +126,7 @@ TYPED_TEST(SymmetricEncryptionWithPrngTest, EncryptDecryptSingleCompressed) {
+ // ciphertexts.
+ TYPED_TEST(SymmetricEncryptionWithPrngTest, EncryptDecryptMultipleCompressed) {
+   for (const auto& params :
+-       rlwe::testing::ContextParameters<TypeParam>::value) {
++       rlwe::testing::ContextParameters<TypeParam>::Value()) {
+     ASSERT_OK_AND_ASSIGN(auto context,
+                          rlwe::RlweContext<TypeParam>::Create(params));
+     for (unsigned int i = 0; i < kTestingRounds; ++i) {
+diff --git a/testing/coefficient_polynomial.h b/testing/coefficient_polynomial.h
+index 4f32f18..fcff1a2 100644
+--- a/testing/coefficient_polynomial.h
++++ b/testing/coefficient_polynomial.h
+@@ -29,7 +29,8 @@
+ #include "statusor.h"
+ #include "testing/coefficient_polynomial.pb.h"
+ 
+-namespace rlwe::testing {
++namespace rlwe {
++namespace testing {
+ 
+ // A polynomial with ModularInt coefficients that is automatically reduced
+ // modulo <x^n + 1>, where n is the number of coefficients provided in the
+@@ -264,6 +265,7 @@ class CoefficientPolynomial {
+   const ModularIntParams* modulus_params_;
+ };
+ 
+-}  // namespace rlwe::testing
++}  // namespace testing
++}  // namespace rlwe
+ 
+ #endif  // RLWE_TESTING_COEFFICIENT_POLYNOMIAL_H_
+diff --git a/testing/coefficient_polynomial.proto b/testing/coefficient_polynomial.proto
+index b378557..35f02ef 100644
+--- a/testing/coefficient_polynomial.proto
++++ b/testing/coefficient_polynomial.proto
+@@ -15,6 +15,8 @@
+ 
+ syntax = "proto2";
+ 
++option optimize_for = LITE_RUNTIME;
++
+ package rlwe;
+ 
+ // Polynomial in coefficient representation
+diff --git a/testing/coefficient_polynomial_ciphertext.h b/testing/coefficient_polynomial_ciphertext.h
+index 0ed2caa..a8a78de 100644
+--- a/testing/coefficient_polynomial_ciphertext.h
++++ b/testing/coefficient_polynomial_ciphertext.h
+@@ -27,7 +27,8 @@
+ #include "symmetric_encryption.h"
+ #include "testing/coefficient_polynomial.h"
+ 
+-namespace rlwe::testing {
++namespace rlwe {
++namespace testing {
+ 
+ // Container for a vector of polynomials in coefficient representation. This
+ // class is the analogue of SymmetricRlweCiphertext with component polynomials
+@@ -52,8 +53,8 @@ class CoefficientPolynomialCiphertext {
+       const ErrorParams<ModularInt>* error_params)
+       : p_(std::move(p)),
+         modulus_params_(p_[0].ModulusParams()),
+-        power_of_s_(power_of_s),
+-        error_params_(error_params) {}
++        error_params_(error_params), 
++        power_of_s_(power_of_s){}
+ 
+   // Static method that creates a CoefficientPolynomialCiphertext from a
+   // SymmetricRlweCiphertext by performing InverseNtt on each ciphertext
+@@ -163,13 +164,14 @@ class CoefficientPolynomialCiphertext {
+   // ErrorParams.
+   const rlwe::ErrorParams<ModularInt>* error_params_;
+ 
+-  // A heuristic on the amount of error in the ciphertext.
+-  double error_;
+-
+   // The power a in s(x^a) that the ciphertext can be decrypted with.
+   int power_of_s_;
++
++  // A heuristic on the amount of error in the ciphertext.
++  double error_;
+ };
+ 
+-}  //  namespace rlwe::testing
++}  //  namespace testing
++}  //  namespace rlwe
+ 
+ #endif  // RLWE_TESTING_COEFFICIENT_POLYNOMIAL_CIPHERTEXT_H_
+diff --git a/testing/coefficient_polynomial_test.cc b/testing/coefficient_polynomial_test.cc
+index db3e184..bf43ee6 100644
+--- a/testing/coefficient_polynomial_test.cc
++++ b/testing/coefficient_polynomial_test.cc
+@@ -18,6 +18,7 @@
+ #include <random>
+ #include <vector>
+ 
++#include <google/protobuf/message_lite.h>
+ #include <gmock/gmock.h>
+ #include <gtest/gtest.h>
+ #include "constants.h"
+@@ -415,7 +416,7 @@ TEST_F(PolynomialTest, Serialize) {
+                          p.Serialize());
+     ASSERT_OK_AND_ASSIGN(rlwe::SerializedCoefficientPolynomial serialized_q,
+                          q.Serialize());
+-    EXPECT_THAT(serialized_p, EqualsProto(serialized_q));
++    EXPECT_EQ(serialized_p.SerializeAsString(), serialized_q.SerializeAsString());
+ 
+     // Ensure that a serialized polynomial can be deserialized.
+     ASSERT_OK_AND_ASSIGN(
+diff --git a/testing/parameters.h b/testing/parameters.h
+index 05864f0..6f7a08c 100644
+--- a/testing/parameters.h
++++ b/testing/parameters.h
+@@ -26,7 +26,8 @@
+ #include "integral_types.h"
+ #include "montgomery.h"
+ 
+-namespace rlwe::testing {
++namespace rlwe {
++namespace testing {
+ 
+ // ModularInt types for typed tests. A typed test can be defined as follows in
+ // test files.
+@@ -54,50 +55,54 @@ typedef ::testing::Types<
+ // }
+ template <typename ModularInt>
+ struct ContextParameters {
+-  constexpr static std::array<typename RlweContext<ModularInt>::Parameters, 0>
+-      value = {};
++  static std::vector<typename RlweContext<ModularInt>::Parameters> Value() {
++    return {};
++  }
+ };
+ 
+ template <>
+ struct ContextParameters<MontgomeryInt<Uint16>> {
+-  constexpr static std::array<RlweContext<MontgomeryInt<Uint16>>::Parameters, 1>
+-      value = {
++  static std::vector<RlweContext<MontgomeryInt<Uint16>>::Parameters> Value() {
++      return {
+           RlweContext<MontgomeryInt<Uint16>>::Parameters{
+               .modulus = kNewhopeModulus,
+               .log_n = 10,
+               .log_t = 1,
+               .variance = 8},
+       };
++  }
+ };
+ 
+ template <>
+ struct ContextParameters<MontgomeryInt<Uint32>> {
+-  constexpr static std::array<RlweContext<MontgomeryInt<Uint32>>::Parameters, 2>
+-      value = {
++  static std::vector<RlweContext<MontgomeryInt<Uint32>>::Parameters> Value() {
++      return {
+           RlweContext<MontgomeryInt<Uint32>>::Parameters{
+               .modulus = kModulus25, .log_n = 10, .log_t = 1, .variance = 8},
+           RlweContext<MontgomeryInt<Uint32>>::Parameters{
+               .modulus = kModulus29, .log_n = 11, .log_t = 5, .variance = 8},
+       };
++  }
+ };
+ 
+ template <>
+ struct ContextParameters<MontgomeryInt<Uint64>> {
+-  constexpr static std::array<RlweContext<MontgomeryInt<Uint64>>::Parameters, 1>
+-      value = {
++  static std::vector<RlweContext<MontgomeryInt<Uint64>>::Parameters> Value() {
++      return {
+           RlweContext<MontgomeryInt<Uint64>>::Parameters{
+               .modulus = kModulus59, .log_n = 11, .log_t = 10, .variance = 8},
+       };
++  }
+ };
+ 
+ template <>
+ struct ContextParameters<MontgomeryInt<absl::uint128>> {
+-  constexpr static std::array<
+-      RlweContext<MontgomeryInt<absl::uint128>>::Parameters, 1>
+-      value = {
++  static std::vector<RlweContext<MontgomeryInt<absl::uint128>>::Parameters> Value() {
++      return {
+           RlweContext<MontgomeryInt<absl::uint128>>::Parameters{
+               .modulus = kModulus80, .log_n = 11, .log_t = 11, .variance = 8},
+       };
++  }
+ };
+ 
+ // Parameters for testing of modulus switching. These parameters must be
+@@ -120,13 +125,16 @@ struct ContextParameters<MontgomeryInt<absl::uint128>> {
+ template <typename ModularInt>
+ struct ContextParametersModulusSwitching {
+   using Params = typename RlweContext<ModularInt>::Parameters;
+-  constexpr static std::array<std::tuple<Params, Params>, 0> value = {};
++  static std::vector<std::tuple<Params, Params>> Value() {
++    return {};
++  }
+ };
+ 
+ template <>
+ struct ContextParametersModulusSwitching<MontgomeryInt<Uint64>> {
+   using Params = typename RlweContext<MontgomeryInt<Uint64>>::Parameters;
+-  constexpr static std::array<std::tuple<Params, Params>, 1> value = {
++  static std::vector<std::tuple<Params, Params>> Value() {
++    return {
+       std::make_tuple(
+           Params{.modulus = 17592186028033ULL,
+                  .log_n = 10,
+@@ -134,12 +142,14 @@ struct ContextParametersModulusSwitching<MontgomeryInt<Uint64>> {
+                  .variance = 8},
+           Params{
+               .modulus = 1589249ULL, .log_n = 10, .log_t = 4, .variance = 8})};
++  }
+ };
+ 
+ template <>
+ struct ContextParametersModulusSwitching<MontgomeryInt<absl::uint128>> {
+   using Params = typename RlweContext<MontgomeryInt<absl::uint128>>::Parameters;
+-  constexpr static std::array<std::tuple<Params, Params>, 1> value = {
++  static std::vector<std::tuple<Params, Params>> Value() {
++    return {
+       std::make_tuple(
+           Params{.modulus = absl::MakeUint128(4611686018427387903ULL,
+                                               18446744073709355009ULL),
+@@ -150,8 +160,10 @@ struct ContextParametersModulusSwitching<MontgomeryInt<absl::uint128>> {
+                  .log_n = 10,
+                  .log_t = 2,
+                  .variance = 8})};
++  }
+ };
+ 
+-}  // namespace rlwe::testing
++}  // namespace testing
++}  // namespace rlwe
+ 
+ #endif  // RLWE_TESTING_INSTANCES_H_
+diff --git a/testing/protobuf_matchers.h b/testing/protobuf_matchers.h
+index 504ef78..0c7df16 100644
+--- a/testing/protobuf_matchers.h
++++ b/testing/protobuf_matchers.h
+@@ -18,6 +18,7 @@
+ #define RLWE_TESTING_PROTOBUF_MATCHERS_H_
+ 
+ #include <google/protobuf/message.h>
++#include <google/protobuf/message_lite.h>
+ #include <google/protobuf/util/message_differencer.h>
+ #include <gmock/gmock.h>
+ 
+@@ -29,7 +30,7 @@ class EqualsProtoImpl
+  public:
+   EqualsProtoImpl(const google::protobuf::Message& other) : other_(&other) {}
+ 
+-  bool MatchAndExplain(
++  inline bool MatchAndExplain(
+       const google::protobuf::Message& message,
+       ::testing::MatchResultListener* listener) const override {
+     if (!google::protobuf::util::MessageDifferencer::Equals(message, *other_)) {
+@@ -39,11 +40,11 @@ class EqualsProtoImpl
+     return true;
+   }
+ 
+-  void DescribeTo(std::ostream* os) const override {
++  inline void DescribeTo(std::ostream* os) const override {
+     *os << "is equal to another protocol buffer";
+   }
+ 
+-  void DescribeNegationTo(std::ostream* os) const override {
++  inline void DescribeNegationTo(std::ostream* os) const override {
+     *os << "is not equal to another protocol buffer";
+   }
+ 
+@@ -51,11 +52,45 @@ class EqualsProtoImpl
+   const google::protobuf::Message* other_;  // not owned
+ };
+ 
+-::testing::Matcher<const google::protobuf::Message&> EqualsProto(
++inline ::testing::Matcher<const google::protobuf::Message&> EqualsProto(
+     const google::protobuf::Message& other) {
+   return ::testing::Matcher<const google::protobuf::Message&>(new EqualsProtoImpl(other));
+ }
+ 
++class EqualsProtoLiteImpl
++    : public ::testing::MatcherInterface<const google::protobuf::MessageLite&> {
++ public:
++  EqualsProtoLiteImpl(const google::protobuf::MessageLite& other) : other_(&other) {}
++
++  bool MatchAndExplain(
++      const google::protobuf::MessageLite& message,
++      ::testing::MatchResultListener* listener) const override {
++    // TODO(b/159369884): Implement robust equality checks.
++    if (message.SerializeAsString() != other_->SerializeAsString()) {
++      *listener << "protobufs were not equal";
++      return false;
++    }
++    return true;
++  }
++
++  void DescribeTo(std::ostream* os) const override {
++    *os << "is equal to another protocol buffer";
++  }
++
++  void DescribeNegationTo(std::ostream* os) const override {
++    *os << "is not equal to another protocol buffer";
++  }
++
++ private:
++  const google::protobuf::MessageLite* other_;  // not owned
++};
++
++inline ::testing::Matcher<const google::protobuf::MessageLite&> EqualsProto(
++    const google::protobuf::MessageLite& other) {
++  return ::testing::Matcher<const google::protobuf::MessageLite&>(
++      new EqualsProtoLiteImpl(other));
++}
++
+ }  // namespace testing
+ }  // namespace rlwe
+ 
+diff --git a/testing/protobuf_matchers_test.cc b/testing/protobuf_matchers_test.cc
+index 48865f7..7ef759a 100644
+--- a/testing/protobuf_matchers_test.cc
++++ b/testing/protobuf_matchers_test.cc
+@@ -24,11 +24,11 @@ namespace {
+ TEST(EqualsProtoTest, EqualsProtoWorks) {
+   rlwe::SerializedCoefficientPolynomial coeffs;
+   coeffs.set_num_coeffs(10);
+-  EXPECT_THAT(coeffs, rlwe::testing::EqualsProto(coeffs));
++  EXPECT_EQ(coeffs.SerializeAsString(), coeffs.SerializeAsString());
+ 
+   rlwe::SerializedCoefficientPolynomial coeffs_other;
+   coeffs_other.set_num_coeffs(20);
+-  EXPECT_THAT(coeffs, ::testing::Not(rlwe::testing::EqualsProto(coeffs_other)));
++  EXPECT_NE(coeffs.SerializeAsString(), coeffs_other.SerializeAsString());
+ }
+ 
+ }  // namespace
+diff --git a/testing/status_matchers.h b/testing/status_matchers.h
+index 52f9b0a..c482dae 100644
+--- a/testing/status_matchers.h
++++ b/testing/status_matchers.h
+@@ -28,10 +28,10 @@ namespace internal {
+ 
+ // This function and its overload allow the same matcher to be used for Status
+ // and StatusOr tests.
+-absl::Status GetStatus(const absl::Status& status) { return status; }
++inline absl::Status GetStatus(const absl::Status& status) { return status; }
+ 
+ template <typename T>
+-absl::Status GetStatus(const rlwe::StatusOr<T>& statusor) {
++inline absl::Status GetStatus(const rlwe::StatusOr<T>& statusor) {
+   return statusor.status();
+ }
+ 
+@@ -42,7 +42,7 @@ class StatusIsImpl : public ::testing::MatcherInterface<StatusType> {
+                const ::testing::Matcher<const std::string&>& message)
+       : code_(code), message_(message) {}
+ 
+-  bool MatchAndExplain(StatusType status,
++  inline bool MatchAndExplain(StatusType status,
+                        ::testing::MatchResultListener* listener) const {
+     ::testing::StringMatchResultListener str_listener;
+     absl::Status real_status = GetStatus(status);
+@@ -58,14 +58,14 @@ class StatusIsImpl : public ::testing::MatcherInterface<StatusType> {
+     return true;
+   }
+ 
+-  void DescribeTo(std::ostream* os) const {
++  inline void DescribeTo(std::ostream* os) const {
+     *os << "has a status code that ";
+     code_.DescribeTo(os);
+     *os << " and a message that ";
+     message_.DescribeTo(os);
+   }
+ 
+-  void DescribeNegationto(std::ostream* os) const {
++  inline void DescribeNegationto(std::ostream* os) const {
+     *os << "has a status code that ";
+     code_.DescribeNegationTo(os);
+     *os << " and a message that ";
+@@ -99,7 +99,7 @@ class StatusIsPoly {
+ 
+ // This function allows us to avoid a template parameter when writing tests, so
+ // that we can transparently test both Status and StatusOr returns.
+-internal::StatusIsPoly StatusIs(
++inline internal::StatusIsPoly StatusIs(
+     ::testing::Matcher<absl::StatusCode>&& code,
+     ::testing::Matcher<const std::string&>&& message) {
+   return internal::StatusIsPoly(
diff --git a/third_party/shell-encryption/patches/0004-Support-SHELL-component-build.patch b/third_party/shell-encryption/patches/0004-Support-SHELL-component-build.patch
new file mode 100644
index 0000000000000..55072fa3bbb0f
--- /dev/null
+++ b/third_party/shell-encryption/patches/0004-Support-SHELL-component-build.patch
@@ -0,0 +1,655 @@
+diff --git a/galois_key.h b/galois_key.h
+index 0b73a63eff4d0..e6295f1082748 100644
+--- a/galois_key.h
++++ b/galois_key.h
+@@ -23,6 +23,8 @@
+ #include "relinearization_key.h"
+ #include "status_macros.h"
+ #include "statusor.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
++#include "third_party/shell-encryption/base/shell_encryption_export_template.h"
+ 
+ namespace rlwe {
+ 
+@@ -41,7 +43,7 @@ namespace rlwe {
+ //
+ // Details can be found in Appendix D.2 of https://eprint.iacr.org/2011/566.pdf
+ template <typename ModularInt>
+-class GaloisKey {
++class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) GaloisKey {
+  public:
+   // Initializes a GaloisKey based on a SymmetricRlweKey key that can key-switch
+   // two component ciphertexts. A positive log_decomposition_modulus corresponds
+@@ -49,7 +51,7 @@ class GaloisKey {
+   // power of x in the secret key polynomial s(x^substitution_power) that the
+   // ciphertext is encrypted with. The prng_seed is used to generate and encode
+   // the bottom row of the matrix, which consists of random entries.
+-  static rlwe::StatusOr<GaloisKey> Create(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<GaloisKey> Create(
+       const SymmetricRlweKey<ModularInt>& key, absl::string_view prng_seed,
+       Uint64 substitution_power, Uint64 log_decomposition_modulus) {
+     RLWE_ASSIGN_OR_RETURN(auto relinearization_key,
+@@ -88,7 +90,7 @@ class GaloisKey {
+   // SerializedGaloisKey is (2 * num_parts * dimension) where dimension is the
+   // number of digits needed to represent the modulus in base
+   // 2^{log_decomposition_modulus}. Crashes for non-valid input parameters.
+-  static rlwe::StatusOr<GaloisKey> Deserialize(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<GaloisKey> Deserialize(
+       const SerializedGaloisKey& serialized,
+       const typename ModularInt::Params* modulus_params,
+       const NttParameters<ModularInt>* ntt_params) {
+@@ -110,6 +112,14 @@ class GaloisKey {
+   RelinearizationKey<ModularInt> relinearization_key_;
+ };
+ 
++template class EXPORT_TEMPLATE_DECLARE(
++    SHELL_ENCRYPTION_EXPORT) GaloisKey<rlwe::MontgomeryInt<Uint16>>;
++template class EXPORT_TEMPLATE_DECLARE(
++    SHELL_ENCRYPTION_EXPORT) GaloisKey<rlwe::MontgomeryInt<Uint32>>;
++template class EXPORT_TEMPLATE_DECLARE(
++    SHELL_ENCRYPTION_EXPORT) GaloisKey<rlwe::MontgomeryInt<Uint64>>;
++template class EXPORT_TEMPLATE_DECLARE(
++    SHELL_ENCRYPTION_EXPORT) GaloisKey<rlwe::MontgomeryInt<absl::uint128>>;
+ }  //  namespace rlwe
+ 
+ #endif  // RLWE_GALOIS_KEY_H_
+diff --git a/int256.h b/int256.h
+index 540dce2d765b1..4c464a4978412 100644
+--- a/int256.h
++++ b/int256.h
+@@ -18,13 +18,15 @@
+ 
+ #include "absl/numeric/int128.h"
+ #include "integral_types.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
++#include "third_party/shell-encryption/base/shell_encryption_export_template.h"
+ 
+ namespace rlwe {
+ 
+ struct uint256_pod;
+ 
+ // An unsigned 256-bit integer type. Thread-compatible.
+-class uint256 {
++class SHELL_ENCRYPTION_EXPORT uint256 {
+  public:
+   constexpr uint256();
+   constexpr uint256(absl::uint128 top, absl::uint128 bottom);
+@@ -74,11 +76,11 @@ class uint256 {
+   uint256& operator-=(const uint256& b);
+   uint256& operator*=(const uint256& b);
+   // Long division/modulo for uint256.
+-  uint256& operator/=(const uint256& b);
+-  uint256& operator%=(const uint256& b);
++  SHELL_ENCRYPTION_EXPORT uint256& operator/=(const uint256& b);
++  SHELL_ENCRYPTION_EXPORT uint256& operator%=(const uint256& b);
+   uint256 operator++(int);
+   uint256 operator--(int);
+-  uint256& operator<<=(int);
++  SHELL_ENCRYPTION_EXPORT uint256& operator<<=(int);
+   uint256& operator>>=(int);
+   uint256& operator&=(const uint256& b);
+   uint256& operator|=(const uint256& b);
+@@ -90,7 +92,7 @@ class uint256 {
+   friend absl::uint128 Uint256High128(const uint256& v);
+ 
+   // We add "std::" to avoid including all of port.h.
+-  friend std::ostream& operator<<(std::ostream& o, const uint256& b);
++  friend SHELL_ENCRYPTION_EXPORT std::ostream& operator<<(std::ostream& o, const uint256& b);
+ 
+  private:
+   static void DivModImpl(uint256 dividend, uint256 divisor,
+@@ -121,7 +123,7 @@ constexpr uint256 Uint256Max() {
+ 
+ // This is a POD form of uint256 which can be used for static variables which
+ // need to be operated on as uint256.
+-struct uint256_pod {
++struct SHELL_ENCRYPTION_EXPORT uint256_pod {
+   // Note: The ordering of fields is different than 'class uint256' but the
+   // same as its 2-arg constructor.  This enables more obvious initialization
+   // of static instances, which is the primary reason for this struct in the
+diff --git a/montgomery.cc b/montgomery.cc
+index 9fbc5dabee18c..4bd03362420fc 100644
+--- a/montgomery.cc
++++ b/montgomery.cc
+@@ -14,6 +14,8 @@
+ 
+ #include "montgomery.h"
+ 
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
++#include "third_party/shell-encryption/base/shell_encryption_export_template.h"
+ #include "transcription.h"
+ 
+ namespace rlwe {
+@@ -416,12 +418,12 @@ MontgomeryInt<T> MontgomeryInt<T>::MultiplicativeInverse(
+ 
+ // Instantiations of MontgomeryInt and MontgomeryIntParams with specific
+ // integral types.
+-template struct MontgomeryIntParams<Uint16>;
+-template struct MontgomeryIntParams<Uint32>;
+-template struct MontgomeryIntParams<Uint64>;
+-template struct MontgomeryIntParams<absl::uint128>;
+-template class MontgomeryInt<Uint16>;
+-template class MontgomeryInt<Uint32>;
+-template class MontgomeryInt<Uint64>;
+-template class MontgomeryInt<absl::uint128>;
++template struct EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<Uint16>;
++template struct EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<Uint32>;
++template struct EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<Uint64>;
++template struct EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<absl::uint128>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<Uint16>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<Uint32>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<Uint64>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<absl::uint128>;
+ }  // namespace rlwe
+diff --git a/montgomery.h b/montgomery.h
+index 4f0e2eafb815f..c3988ff34da34 100644
+--- a/montgomery.h
++++ b/montgomery.h
+@@ -34,6 +34,8 @@
+ #include "serialization.pb.h"
+ #include "status_macros.h"
+ #include "statusor.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
++#include "third_party/shell-encryption/base/shell_encryption_export_template.h"
+ 
+ namespace rlwe {
+ 
+@@ -43,24 +45,24 @@ namespace internal {
+ template <typename T>
+ struct BigInt;
+ // Specialization for uint8, uint16, uint32, uint64, and uint128.
+-template <>
+-struct BigInt<Uint8> {
++template <> 
++struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) BigInt<Uint8> {
+   typedef Uint16 value_type;
+ };
+-template <>
+-struct BigInt<Uint16> {
++template <> 
++struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) BigInt<Uint16> {
+   typedef Uint32 value_type;
+ };
+-template <>
+-struct BigInt<Uint32> {
++template <> 
++struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) BigInt<Uint32> {
+   typedef Uint64 value_type;
+ };
+-template <>
+-struct BigInt<Uint64> {
++template <> 
++struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) BigInt<Uint64> {
+   typedef absl::uint128 value_type;
+ };
+-template <>
+-struct BigInt<absl::uint128> {
++template <> 
++struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) BigInt<absl::uint128> {
+   typedef uint256 value_type;
+ };
+ 
+@@ -69,7 +71,7 @@ struct BigInt<absl::uint128> {
+ // The parameters necessary for a Montgomery integer. Note that the template
+ // parameters ensure that T is an unsigned integral of at least 8 bits.
+ template <typename T>
+-struct MontgomeryIntParams {
++struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams{
+   // Expose Int and its greater type. BigInt is required in order to multiply
+   // two Int and ensure that no overflow occurs.
+   //
+@@ -159,7 +161,7 @@ struct MontgomeryIntParams {
+   // modulus must be odd.
+   // Returns a tuple of (inv_r, inv_modulus) such that:
+   //     r * inv_r - modulus * inv_modulus = 1
+-  static std::tuple<Int, Int> Inverses(BigInt modulus_bigint, BigInt r);
++  static SHELL_ENCRYPTION_EXPORT std::tuple<Int, Int> Inverses(BigInt modulus_bigint, BigInt r);
+ };
+ 
+ // Stores an integer in Montgomery representation. The goal of this
+@@ -170,7 +172,7 @@ struct MontgomeryIntParams {
+ // The underlying integer type T must be unsigned and must not be bool.
+ // This class is thread safe.
+ template <typename T>
+-class ABSL_MUST_USE_RESULT MontgomeryInt {
++class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) ABSL_MUST_USE_RESULT MontgomeryInt {
+  public:
+   // Expose Int and its greater type. BigInt is required in order to multiply
+   // two Int and ensure that no overflow occurs. This should also be used by
+@@ -184,16 +186,16 @@ class ABSL_MUST_USE_RESULT MontgomeryInt {
+   // Static factory that converts a non-Montgomery representation integer, the
+   // underlying integer type, into a Montgomery representation integer. Does not
+   // take ownership of params. i.e., import "a".
+-  static rlwe::StatusOr<MontgomeryInt> ImportInt(Int n, const Params* params);
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<MontgomeryInt> ImportInt(Int n, const Params* params);
+ 
+   // Static functions to create a MontgomeryInt of 0 and 1.
+-  static MontgomeryInt ImportZero(const Params* params);
+-  static MontgomeryInt ImportOne(const Params* params);
++  static SHELL_ENCRYPTION_EXPORT MontgomeryInt ImportZero(const Params* params);
++  static SHELL_ENCRYPTION_EXPORT MontgomeryInt ImportOne(const Params* params);
+ 
+   // Import a random integer using entropy from specified prng. Does not take
+   // ownership of params or prng.
+   template <typename Prng = rlwe::SecurePrng>
+-  static rlwe::StatusOr<MontgomeryInt> ImportRandom(Prng* prng,
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<MontgomeryInt> ImportRandom(Prng* prng,
+                                                     const Params* params) {
+     // In order to generate unbiased randomness, we uniformly and randomly
+     // sample integers in [0, 2^params->log_modulus) until the generated integer
+@@ -234,13 +236,13 @@ class ABSL_MUST_USE_RESULT MontgomeryInt {
+ 
+   // Serialization.
+   rlwe::StatusOr<std::string> Serialize(const Params* params) const;
+-  static rlwe::StatusOr<std::string> SerializeVector(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::string> SerializeVector(
+       const std::vector<MontgomeryInt>& coeffs, const Params* params);
+ 
+   // Deserialization.
+-  static rlwe::StatusOr<MontgomeryInt> Deserialize(absl::string_view payload,
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<MontgomeryInt> Deserialize(absl::string_view payload,
+                                                    const Params* params);
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> DeserializeVector(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> DeserializeVector(
+       int num_coeffs, absl::string_view serialized, const Params* params);
+ 
+   // Modular multiplication.
+@@ -353,7 +355,7 @@ class ABSL_MUST_USE_RESULT MontgomeryInt {
+   // size.
+ 
+   // Batch addition of two vectors.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchAdd(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchAdd(
+       const std::vector<MontgomeryInt>& in1,
+       const std::vector<MontgomeryInt>& in2, const Params* params);
+   static absl::Status BatchAddInPlace(std::vector<MontgomeryInt>* in1,
+@@ -361,7 +363,7 @@ class ABSL_MUST_USE_RESULT MontgomeryInt {
+                                       const Params* params);
+ 
+   // Batch addition of one vector with a scalar.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchAdd(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchAdd(
+       const std::vector<MontgomeryInt>& in1, const MontgomeryInt& in2,
+       const Params* params);
+   static absl::Status BatchAddInPlace(std::vector<MontgomeryInt>* in1,
+@@ -369,51 +371,51 @@ class ABSL_MUST_USE_RESULT MontgomeryInt {
+                                       const Params* params);
+ 
+   // Batch subtraction of two vectors.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchSub(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchSub(
+       const std::vector<MontgomeryInt>& in1,
+       const std::vector<MontgomeryInt>& in2, const Params* params);
+-  static absl::Status BatchSubInPlace(std::vector<MontgomeryInt>* in1,
++  static SHELL_ENCRYPTION_EXPORT absl::Status BatchSubInPlace(std::vector<MontgomeryInt>* in1,
+                                       const std::vector<MontgomeryInt>& in2,
+                                       const Params* params);
+ 
+   // Batch subtraction of one vector with a scalar.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchSub(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchSub(
+       const std::vector<MontgomeryInt>& in1, const MontgomeryInt& in2,
+       const Params* params);
+-  static absl::Status BatchSubInPlace(std::vector<MontgomeryInt>* in1,
++  static SHELL_ENCRYPTION_EXPORT absl::Status BatchSubInPlace(std::vector<MontgomeryInt>* in1,
+                                       const MontgomeryInt& in2,
+                                       const Params* params);
+ 
+   // Batch multiplication of two vectors.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMul(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMul(
+       const std::vector<MontgomeryInt>& in1,
+       const std::vector<MontgomeryInt>& in2, const Params* params);
+-  static absl::Status BatchMulInPlace(std::vector<MontgomeryInt>* in1,
++  static SHELL_ENCRYPTION_EXPORT absl::Status BatchMulInPlace(std::vector<MontgomeryInt>* in1,
+                                       const std::vector<MontgomeryInt>& in2,
+                                       const Params* params);
+ 
+   // Batch multiplication of two vectors, where the second vector is a constant.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMulConstant(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMulConstant(
+       const std::vector<MontgomeryInt>& in1,
+       const std::vector<Int>& in2_constant,
+       const std::vector<Int>& in2_constant_barrett, const Params* params);
+-  static absl::Status BatchMulConstantInPlace(
++  static SHELL_ENCRYPTION_EXPORT absl::Status BatchMulConstantInPlace(
+       std::vector<MontgomeryInt>* in1, const std::vector<Int>& in2_constant,
+       const std::vector<Int>& in2_constant_barrett, const Params* params);
+ 
+   // Batch multiplication of a vector with a scalar.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMul(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMul(
+       const std::vector<MontgomeryInt>& in1, const MontgomeryInt& in2,
+       const Params* params);
+-  static absl::Status BatchMulInPlace(std::vector<MontgomeryInt>* in1,
++  static SHELL_ENCRYPTION_EXPORT absl::Status BatchMulInPlace(std::vector<MontgomeryInt>* in1,
+                                       const MontgomeryInt& in2,
+                                       const Params* params);
+ 
+   // Batch multiplication of a vector with a constant scalar.
+-  static rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMulConstant(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::vector<MontgomeryInt>> BatchMulConstant(
+       const std::vector<MontgomeryInt>& in1, const Int& constant,
+       const Int& constant_barrett, const Params* params);
+-  static absl::Status BatchMulConstantInPlace(std::vector<MontgomeryInt>* in1,
++  static SHELL_ENCRYPTION_EXPORT absl::Status BatchMulConstantInPlace(std::vector<MontgomeryInt>* in1,
+                                               const Int& constant,
+                                               const Int& constant_barrett,
+                                               const Params* params);
+@@ -423,14 +425,14 @@ class ABSL_MUST_USE_RESULT MontgomeryInt {
+   bool operator!=(const MontgomeryInt& that) const { return !(*this == that); }
+ 
+   // Modular exponentiation.
+-  MontgomeryInt ModExp(Int exponent, const Params* params) const;
++  SHELL_ENCRYPTION_EXPORT MontgomeryInt ModExp(Int exponent, const Params* params) const;
+ 
+   // Inverse.
+-  MontgomeryInt MultiplicativeInverse(const Params* params) const;
++  SHELL_ENCRYPTION_EXPORT  MontgomeryInt MultiplicativeInverse(const Params* params) const;
+ 
+  private:
+   template <typename Prng = rlwe::SecurePrng>
+-  static rlwe::StatusOr<Int> GenerateRandomInt(int log_modulus, Prng* prng) {
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<Int> GenerateRandomInt(int log_modulus, Prng* prng) {
+     // Generate a random Int. As the modulus is always smaller than max(Int),
+     // there will be no issues with overflow.
+     int max_bits_per_step = std::min((int)Params::bitsize_int, (int)64);
+@@ -467,6 +469,17 @@ class ABSL_MUST_USE_RESULT MontgomeryInt {
+   Int n_;
+ };
+ 
++// Instantiations of MontgomeryInt and MontgomeryIntParams with specific
++// integral types.
++extern template struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<Uint16>;
++extern template struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<Uint32>;
++extern template struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<Uint64>;
++extern template struct EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryIntParams<absl::uint128>;
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<Uint16>;
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<Uint32>;
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<Uint64>;
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryInt<absl::uint128>;
++
+ }  // namespace rlwe
+ 
+ #endif  // RLWE_MONTGOMERY_H_
+diff --git a/montgomery_test.cc b/montgomery_test.cc
+index 7caf459a4c08b..2d952ddfbdad4 100644
+--- a/montgomery_test.cc
++++ b/montgomery_test.cc
+@@ -30,6 +30,8 @@
+ #include "testing/status_matchers.h"
+ #include "testing/status_testing.h"
+ #include "testing/testing_prng.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
++#include "third_party/shell-encryption/base/shell_encryption_export_template.h"
+ 
+ namespace rlwe {
+ namespace {
+@@ -65,7 +67,7 @@ uint256 GenerateRandom(unsigned int* seed) {
+ }
+ 
+ template <typename T>
+-class MontgomeryTest : public ::testing::Test {};
++class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryTest : public ::testing::Test {};
+ TYPED_TEST_SUITE(MontgomeryTest, testing::ModularIntTypes);
+ 
+ TYPED_TEST(MontgomeryTest, ModulusTooLarge) {
+diff --git a/ntt_parameters.h b/ntt_parameters.h
+index 55671ec5e65de..eba9579ab87ca 100644
+--- a/ntt_parameters.h
++++ b/ntt_parameters.h
+@@ -24,6 +24,7 @@
+ #include "constants.h"
+ #include "status_macros.h"
+ #include "statusor.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
+ 
+ namespace rlwe {
+ namespace internal {
+@@ -94,7 +95,7 @@ rlwe::StatusOr<std::vector<ModularInt>> NttPsis(
+ // Creates a vector containing the indices necessary to perform the NTT bit
+ // reversal operation. Index i of the returned vector contains an integer with
+ // the rightmost log_n bits of i reversed.
+-std::vector<unsigned int> BitrevArray(unsigned int log_n);
++SHELL_ENCRYPTION_EXPORT std::vector<unsigned int> BitrevArray(unsigned int log_n);
+ 
+ // Helper function: Perform the bit-reversal operation in-place on coeffs_.
+ template <typename ModularInt>
+diff --git a/prng/chacha_prng.h b/prng/chacha_prng.h
+index 27940fd82c646..7e4f719fedaf6 100644
+--- a/prng/chacha_prng.h
++++ b/prng/chacha_prng.h
+@@ -26,6 +26,7 @@
+ #include "prng/chacha_prng_util.h"
+ #include "prng/prng.h"
+ #include "statusor.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
+ 
+ namespace rlwe {
+ 
+@@ -56,7 +57,7 @@ class ChaChaPrng : public SecurePrng {
+   // errors.
+   //
+   // Thread safe.
+-  static rlwe::StatusOr<std::unique_ptr<ChaChaPrng>> Create(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::unique_ptr<ChaChaPrng>> Create(
+       absl::string_view in_key);
+ 
+   // Returns 8 bits of randomness.
+@@ -72,12 +73,12 @@ class ChaChaPrng : public SecurePrng {
+   // Generate a valid seed for the Prng.
+   //
+   // Fails on internal cryptographic errors.
+-  static rlwe::StatusOr<std::string> GenerateSeed() {
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::string> GenerateSeed() {
+     return internal::ChaChaPrngGenerateKey();
+   }
+ 
+   // Output the size of the expected generated seed.
+-  static int SeedLength() { return internal::kChaChaKeyBytesSize; }
++  static SHELL_ENCRYPTION_EXPORT int SeedLength() { return internal::kChaChaKeyBytesSize; }
+ 
+  private:
+   explicit ChaChaPrng(absl::string_view in_key, int position_in_buffer,
+diff --git a/prng/chacha_prng_util.h b/prng/chacha_prng_util.h
+index 8eb8118fe26f9..80f0cedf4a703 100644
+--- a/prng/chacha_prng_util.h
++++ b/prng/chacha_prng_util.h
+@@ -27,6 +27,7 @@
+ #include "absl/strings/string_view.h"
+ #include "integral_types.h"
+ #include "statusor.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
+ 
+ namespace rlwe {
+ namespace internal {
+@@ -37,28 +38,33 @@ const int kChaChaOutputBytes = 255 * 32;
+ 
+ // Once pseudorandom output is exhausted, the salt is updated to construct
+ // new pseudorandom output.
+-absl::Status ChaChaPrngResalt(absl::string_view key, int buffer_size,
+-                              int* salt_counter, int* position_in_buffer,
+-                              std::vector<Uint8>* buffer);
++SHELL_ENCRYPTION_EXPORT absl::Status ChaChaPrngResalt(
++    absl::string_view key,
++    int buffer_size,
++    int* salt_counter,
++    int* position_in_buffer,
++    std::vector<Uint8>* buffer);
+ 
+ // Generates a secure key for instantiating an CHACHA.
+-rlwe::StatusOr<std::string> ChaChaPrngGenerateKey();
++SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::string> ChaChaPrngGenerateKey();
+ 
+ // Returns 8 bits of randomness.
+ //
+ // Fails on internal cryptographic errors.
+-rlwe::StatusOr<Uint8> ChaChaPrngRand8(absl::string_view key,
+-                                      int* position_in_buffer,
+-                                      int* salt_counter,
+-                                      std::vector<Uint8>* buffer);
++SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<Uint8> ChaChaPrngRand8(
++    absl::string_view key,
++    int* position_in_buffer,
++    int* salt_counter,
++    std::vector<Uint8>* buffer);
+ 
+ // Returns 64 bits of randomness.
+ //
+ // Fails on internal cryptographic errors.
+-rlwe::StatusOr<Uint64> ChaChaPrngRand64(absl::string_view key,
+-                                        int* position_in_buffer,
+-                                        int* salt_counter,
+-                                        std::vector<Uint8>* buffer);
++SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<Uint64> ChaChaPrngRand64(
++    absl::string_view key,
++    int* position_in_buffer,
++    int* salt_counter,
++    std::vector<Uint8>* buffer);
+ 
+ }  // namespace internal
+ }  // namespace rlwe
+diff --git a/prng/single_thread_chacha_prng.h b/prng/single_thread_chacha_prng.h
+index fcaff827be355..2fddf6f3530c4 100644
+--- a/prng/single_thread_chacha_prng.h
++++ b/prng/single_thread_chacha_prng.h
+@@ -24,6 +24,7 @@
+ #include "prng/chacha_prng_util.h"
+ #include "prng/prng.h"
+ #include "statusor.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
+ 
+ namespace rlwe {
+ 
+@@ -52,7 +53,7 @@ class SingleThreadChaChaPrng : public SecurePrng {
+   //
+   // Fails if the key is not the expected size or on internal cryptographic
+   // errors.
+-  static rlwe::StatusOr<std::unique_ptr<SingleThreadChaChaPrng>> Create(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<std::unique_ptr<SingleThreadChaChaPrng>> Create(
+       absl::string_view in_key);
+ 
+   // Returns 8 bits of randomness.
+diff --git a/relinearization_key.cc b/relinearization_key.cc
+index 7982a2f71a74c..0b22a50e0abb7 100644
+--- a/relinearization_key.cc
++++ b/relinearization_key.cc
+@@ -22,6 +22,8 @@
+ #include "status_macros.h"
+ #include "statusor.h"
+ #include "symmetric_encryption_with_prng.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
++#include "third_party/shell-encryption/base/shell_encryption_export_template.h"
+ 
+ namespace rlwe {
+ namespace {
+@@ -432,9 +434,9 @@ RelinearizationKey<ModularInt>::Deserialize(
+ // Instantiations of RelinearizationKey with specific MontgomeryInt classes.
+ // If any new types are added, montgomery.h should be updated accordingly (such
+ // as ensuring BigInt is correctly specialized, etc.).
+-template class RelinearizationKey<MontgomeryInt<Uint16>>;
+-template class RelinearizationKey<MontgomeryInt<Uint32>>;
+-template class RelinearizationKey<MontgomeryInt<Uint64>>;
+-template class RelinearizationKey<MontgomeryInt<absl::uint128>>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<Uint16>>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<Uint32>>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<Uint64>>;
++template class EXPORT_TEMPLATE_DEFINE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<absl::uint128>>;
+ 
+ }  //  namespace rlwe
+diff --git a/relinearization_key.h b/relinearization_key.h
+index 265da33e5af15..1aff179b9ed39 100644
+--- a/relinearization_key.h
++++ b/relinearization_key.h
+@@ -22,6 +22,8 @@
+ #include "sample_error.h"
+ #include "statusor.h"
+ #include "symmetric_encryption.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
++#include "third_party/shell-encryption/base/shell_encryption_export_template.h"
+ 
+ namespace rlwe {
+ // Represents a RelinearizationKey constructed from a symmetric-key. Applying a
+@@ -57,7 +59,7 @@ namespace rlwe {
+ // length (k - 1), where k is the number of parts of the ciphertext it applies
+ // to.
+ template <typename ModularInt>
+-class RelinearizationKey {
++class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey {
+   using ModularIntParams = typename ModularInt::Params;
+ 
+  public:
+@@ -73,7 +75,7 @@ class RelinearizationKey {
+   // with (1, s^k). In that case, we would use a relinearization key with
+   // substition_power = k to return the ciphertext to be encrypted with (1,s).
+   // See GaloisKey for an explicit wrapper around RelinearizationKey.
+-  static rlwe::StatusOr<RelinearizationKey> Create(
++  static SHELL_ENCRYPTION_EXPORT rlwe::StatusOr<RelinearizationKey> Create(
+       const SymmetricRlweKey<ModularInt>& key, absl::string_view prng_seed,
+       ssize_t num_parts, Uint64 log_decomposition_modulus,
+       Uint64 substitution_power = 1);
+@@ -192,6 +194,13 @@ class RelinearizationKey {
+   std::string prng_seed_;
+ };
+ 
++// Instantiations of RelinearizationKey with specific MontgomeryInt classes.
++// If any new types are added, montgomery.h should be updated accordingly (such
++// as ensuring BigInt is correctly specialized, etc.).
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<Uint16>>;
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<Uint32>>;
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<Uint64>>;
++extern template class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) RelinearizationKey<MontgomeryInt<absl::uint128>>;
+ }  // namespace rlwe
+ 
+ #endif  // RLWE_RELINEARIZATION_KEY_H_
+diff --git a/statusor.h b/statusor.h
+index 200f62d917d0f..b7ada09372c9f 100644
+--- a/statusor.h
++++ b/statusor.h
+@@ -22,11 +22,12 @@
+ #include "absl/base/attributes.h"
+ #include "absl/status/status.h"
+ #include "absl/types/optional.h"
++#include "third_party/shell-encryption/base/shell_encryption_export.h"
+ 
+ namespace rlwe {
+ 
+ template <typename T>
+-class StatusOr {
++class SHELL_ENCRYPTION_EXPORT StatusOr {
+  public:
+   // Construct a new StatusOr with Status::UNKNOWN status
+   StatusOr();
+@@ -112,12 +113,12 @@ class StatusOr {
+ 
+ namespace internal {
+ 
+-class StatusOrHelper {
++class SHELL_ENCRYPTION_EXPORT StatusOrHelper {
+  public:
+   // Move type-agnostic error handling to the .cc.
+-  static absl::Status HandleInvalidStatusCtorArg();
+-  static absl::Status HandleNullObjectCtorArg();
+-  static void Crash(const absl::Status& status);
++  static SHELL_ENCRYPTION_EXPORT absl::Status HandleInvalidStatusCtorArg();
++  static SHELL_ENCRYPTION_EXPORT absl::Status HandleNullObjectCtorArg();
++  static SHELL_ENCRYPTION_EXPORT void Crash(const absl::Status& status);
+ 
+   // Customized behavior for StatusOr<T> vs. StatusOr<T*>
+   template <typename T>
+@@ -125,13 +126,13 @@ class StatusOrHelper {
+ };
+ 
+ template <typename T>
+-struct StatusOrHelper::Specialize {
++struct SHELL_ENCRYPTION_EXPORT StatusOrHelper::Specialize {
+   // For non-pointer T, a reference can never be NULL.
+   static inline bool IsValueNull(const T& t) { return false; }
+ };
+ 
+ template <typename T>
+-struct StatusOrHelper::Specialize<T*> {
++struct SHELL_ENCRYPTION_EXPORT StatusOrHelper::Specialize<T*> {
+   static inline bool IsValueNull(const T* t) { return t == nullptr; }
+ };
+ 
diff --git a/third_party/shell-encryption/patches/0005-Add-SHELL-go-package.patch b/third_party/shell-encryption/patches/0005-Add-SHELL-go-package.patch
new file mode 100644
index 0000000000000..6019a06bab8be
--- /dev/null
+++ b/third_party/shell-encryption/patches/0005-Add-SHELL-go-package.patch
@@ -0,0 +1,13 @@
+diff --git a/serialization.proto b/serialization.proto
+index b7fefcf191893..57c75a9027e6b 100644
+--- a/serialization.proto
++++ b/serialization.proto
+@@ -19,6 +19,8 @@ option optimize_for = LITE_RUNTIME;
+ 
+ package rlwe;
+ 
++option go_package = "github.com/google/shell-encryption";
++
+ // NTT Polynomial
+ message SerializedNttPolynomial {
+   // Coefficients of the polynomial
diff --git a/third_party/shell-encryption/patches/0006-Quit-using-ValueOrDie.patch b/third_party/shell-encryption/patches/0006-Quit-using-ValueOrDie.patch
new file mode 100644
index 0000000000000..64d9cc4d00aa9
--- /dev/null
+++ b/third_party/shell-encryption/patches/0006-Quit-using-ValueOrDie.patch
@@ -0,0 +1,369 @@
+diff --git a/BUILD.gn b/BUILD.gn
+index 2f929064ff924..55152038d3c19 100644
+--- a/BUILD.gn
++++ b/BUILD.gn
+@@ -106,7 +106,6 @@ if (is_chromeos_ash) {
+       "src/prng/chacha_prng_util.cc",
+       "src/prng/single_thread_chacha_prng.cc",
+       "src/relinearization_key.cc",
+-      "src/statusor.cc",
+     ]
+     public_deps = [
+       ":serialization_proto",
+@@ -163,7 +162,6 @@ if (is_chromeos_ash) {
+       "src/relinearization_key_test.cc",
+       "src/sample_error_test.cc",
+       "src/status_macros_test.cc",
+-      "src/statusor_test.cc",
+       "src/symmetric_encryption_test.cc",
+       "src/symmetric_encryption_with_prng_test.cc",
+       "src/testing/coefficient_polynomial_ciphertext_test.cc",
+diff --git a/patches/0006-Quit-using-ValueOrDie.patch b/patches/0006-Quit-using-ValueOrDie.patch
+new file mode 100644
+index 0000000000000..e69de29bb2d1d
+diff --git a/src/montgomery_test.cc b/src/montgomery_test.cc
+index 2d952ddfbdad4..97444fc6c15c2 100644
+--- a/src/montgomery_test.cc
++++ b/src/montgomery_test.cc
+@@ -768,7 +768,7 @@ TYPED_TEST(MontgomeryTest, BatchOperations) {
+       std::vector<TypeParam> expected_add, expected_sub, expected_mul;
+       TypeParam scalar =
+           TypeParam::ImportRandom(prng.get(), modulus_params.get())
+-              .ValueOrDie();
++              .value();
+       auto scalar_constants_tuple = scalar.GetConstant(modulus_params.get());
+       auto scalar_constant = std::get<0>(scalar_constants_tuple);
+       auto scalar_constant_barrett = std::get<1>(scalar_constants_tuple);
+@@ -776,9 +776,9 @@ TYPED_TEST(MontgomeryTest, BatchOperations) {
+           expected_mul_scalar;
+       for (size_t i = 0; i < length; i++) {
+         a.push_back(TypeParam::ImportRandom(prng.get(), modulus_params.get())
+-                        .ValueOrDie());
++                        .value());
+         b.push_back(TypeParam::ImportRandom(prng.get(), modulus_params.get())
+-                        .ValueOrDie());
++                        .value());
+         auto constants_tuple = b[i].GetConstant(modulus_params.get());
+         auto constant = std::get<0>(constants_tuple);
+         auto constant_barrett = std::get<1>(constants_tuple); 
+diff --git a/src/polynomial_test.cc b/src/polynomial_test.cc
+index 6d5112e67c6b0..e246788d09bcc 100644
+--- a/src/polynomial_test.cc
++++ b/src/polynomial_test.cc
+@@ -55,7 +55,7 @@ template <typename Prng>
+ class PolynomialTest : public ::testing::Test {
+  protected:
+   PolynomialTest()
+-      : params14_(uint_m::Params::Create(rlwe::kNewhopeModulus).ValueOrDie()),
++      : params14_(uint_m::Params::Create(rlwe::kNewhopeModulus).value()),
+         zero_(uint_m::ImportZero(params14_.get())) {}
+ 
+   void SetUp() override { srand(0); }
+@@ -98,7 +98,7 @@ class PolynomialTest : public ::testing::Test {
+   }
+ 
+   std::unique_ptr<Prng> MakePrng(absl::string_view seed) {
+-    auto prng = Prng::Create(seed.substr(0, Prng::SeedLength())).ValueOrDie();
++    auto prng = Prng::Create(seed.substr(0, Prng::SeedLength())).value();
+     return prng;
+   }
+ 
+diff --git a/src/status_macros.h b/src/status_macros.h
+index d297bfe0ed682..2622f6e544b8e 100644
+--- a/src/status_macros.h
++++ b/src/status_macros.h
+@@ -34,7 +34,7 @@
+   if (ABSL_PREDICT_FALSE(!statusor.ok())) {               \
+     return std::move(statusor).status();                  \
+   }                                                       \
+-  lhs = std::move(statusor).ValueOrDie()
++  lhs = std::move(statusor).value()
+ 
+ // Internal helper for concatenating macro values.
+ #define RLWE_STATUS_MACROS_IMPL_CONCAT_INNER_(x, y) x##y
+diff --git a/src/status_macros_test.cc b/src/status_macros_test.cc
+index d43b55c9bb800..1f96d59e5d3b7 100644
+--- a/src/status_macros_test.cc
++++ b/src/status_macros_test.cc
+@@ -27,8 +27,8 @@ namespace {
+ TEST(StatusMacrosTest, TestAssignOrReturn) {
+   StatusOr<StatusOr<int>> a(StatusOr<int>(2));
+   auto f = [&]() -> absl::Status {
+-    RLWE_ASSIGN_OR_RETURN(StatusOr<int> status_or_a, a.ValueOrDie());
+-    EXPECT_EQ(2, status_or_a.ValueOrDie());
++    RLWE_ASSIGN_OR_RETURN(StatusOr<int> status_or_a, a.value());
++    EXPECT_EQ(2, status_or_a.value());
+     return absl::OkStatus();
+   };
+   auto status = f();
+diff --git a/src/statusor.h b/src/statusor.h
+index b7ada09372c9f..2d3ecd810c49c 100644
+--- a/src/statusor.h
++++ b/src/statusor.h
+@@ -17,239 +17,13 @@
+ #ifndef RLWE_STATUSOR_H_
+ #define RLWE_STATUSOR_H_
+ 
+-#include <cassert>
+-
+-#include "absl/base/attributes.h"
+-#include "absl/status/status.h"
+-#include "absl/types/optional.h"
++#include "absl/status/statusor.h"
+ #include "third_party/shell-encryption/base/shell_encryption_export.h"
+ 
+ namespace rlwe {
+ 
+ template <typename T>
+-class SHELL_ENCRYPTION_EXPORT StatusOr {
+- public:
+-  // Construct a new StatusOr with Status::UNKNOWN status
+-  StatusOr();
+-
+-  // Construct a new StatusOr with the given non-ok status. After calling
+-  // this constructor, calls to value() will CHECK-fail.
+-  //
+-  // NOTE: Not explicit - we want to use StatusOr<T> as a return
+-  // value, so it is convenient and sensible to be able to do 'return
+-  // Status()' when the return type is StatusOr<T>.
+-  //
+-  // REQUIRES: status != Status::OK. This requirement is DCHECKed.
+-  // In optimized builds, passing Status::OK here will have the effect
+-  // of passing PosixErrorSpace::EINVAL as a fallback.
+-  StatusOr(const absl::Status& status);
+-
+-  // Construct a new StatusOr with the given value. If T is a plain pointer,
+-  // value must not be NULL. After calling this constructor, calls to
+-  // value() will succeed, and calls to status() will return OK.
+-  //
+-  // NOTE: Not explicit - we want to use StatusOr<T> as a return type
+-  // so it is convenient and sensible to be able to do 'return T()'
+-  // when the return type is StatusOr<T>.
+-  //
+-  // REQUIRES: if T is a plain pointer, value != NULL. This requirement is
+-  // DCHECKed. In optimized builds, passing a NULL pointer here will have
+-  // the effect of passing absl::StatusCode::kInternal as a fallback.
+-  StatusOr(const T& value);
+-
+-  // Copy constructor.
+-  StatusOr(const StatusOr& other);
+-
+-  // Assignment operator.
+-  StatusOr& operator=(const StatusOr& other);
+-
+-  // Move constructor and move-assignment operator.
+-  StatusOr(StatusOr&& other) = default;
+-  StatusOr& operator=(StatusOr&& other) = default;
+-
+-  // Rvalue-reference overloads of the other constructors and assignment
+-  // operators, to support move-only types and avoid unnecessary copying.
+-  StatusOr(T&& value);
+-
+-  // Returns a reference to our status. If this contains a T, then
+-  // returns Status::OK.
+-  const absl::Status& status() const;
+-
+-  // Returns this->status().ok()
+-  bool ok() const;
+-
+-  // Returns a reference to our current value, or CHECK-fails if !this->ok().
+-  const T& ValueOrDie() const&;
+-  T& ValueOrDie() &;
+-  const T&& ValueOrDie() const&&;
+-  T&& ValueOrDie() &&;
+-
+-  // Returns a reference to our current value, or CHECK-fails if !this->ok().
+-  const T& value() const&;
+-  T& value() &;
+-  const T&& value() const&&;
+-  T&& value() &&;
+-
+-  // Ignores any errors. This method does nothing except potentially suppress
+-  // complaints from any tools that are checking that errors are not dropped on
+-  // the floor.
+-  void IgnoreError() const {}
+-
+-  operator absl::Status() const { return status(); }
+-
+-  template <template <typename> class OtherStatusOrType>
+-  operator OtherStatusOrType<T>() {
+-    if (value_) {
+-      return OtherStatusOrType<T>(std::move(value_.value()));
+-    } else {
+-      return OtherStatusOrType<T>(status());
+-    }
+-  }
+-
+- private:
+-  absl::Status status_;
+-  absl::optional<T> value_;
+-};
+-
+-namespace internal {
+-
+-class SHELL_ENCRYPTION_EXPORT StatusOrHelper {
+- public:
+-  // Move type-agnostic error handling to the .cc.
+-  static SHELL_ENCRYPTION_EXPORT absl::Status HandleInvalidStatusCtorArg();
+-  static SHELL_ENCRYPTION_EXPORT absl::Status HandleNullObjectCtorArg();
+-  static SHELL_ENCRYPTION_EXPORT void Crash(const absl::Status& status);
+-
+-  // Customized behavior for StatusOr<T> vs. StatusOr<T*>
+-  template <typename T>
+-  struct Specialize;
+-};
+-
+-template <typename T>
+-struct SHELL_ENCRYPTION_EXPORT StatusOrHelper::Specialize {
+-  // For non-pointer T, a reference can never be NULL.
+-  static inline bool IsValueNull(const T& t) { return false; }
+-};
+-
+-template <typename T>
+-struct SHELL_ENCRYPTION_EXPORT StatusOrHelper::Specialize<T*> {
+-  static inline bool IsValueNull(const T* t) { return t == nullptr; }
+-};
+-
+-}  // namespace internal
+-
+-template <typename T>
+-inline StatusOr<T>::StatusOr()
+-    : status_(absl::UnknownError("")), value_(absl::nullopt) {}
+-
+-template <typename T>
+-inline StatusOr<T>::StatusOr(const absl::Status& status)
+-    : status_(status), value_(absl::nullopt) {
+-  if (status.ok()) {
+-    status_ = internal::StatusOrHelper::HandleInvalidStatusCtorArg();
+-  }
+-}
+-
+-template <typename T>
+-inline StatusOr<T>::StatusOr(const T& value)
+-    : status_(absl::OkStatus()), value_(value) {
+-  if (internal::StatusOrHelper::Specialize<T>::IsValueNull(value)) {
+-    status_ = internal::StatusOrHelper::HandleNullObjectCtorArg();
+-  }
+-}
+-
+-template <typename T>
+-inline StatusOr<T>::StatusOr(const StatusOr& other)
+-    : status_(other.status_), value_(other.value_) {}
+-
+-template <typename T>
+-inline StatusOr<T>& StatusOr<T>::operator=(const StatusOr<T>& other) {
+-  status_ = other.status_;
+-  value_.reset(other.value_);
+-  return *this;
+-}
+-
+-template <typename T>
+-inline StatusOr<T>::StatusOr(T&& value)
+-    : status_(absl::OkStatus()), value_(std::forward<T>(value)) {
+-  if (internal::StatusOrHelper::Specialize<T>::IsValueNull(value_.value())) {
+-    status_ = internal::StatusOrHelper::HandleNullObjectCtorArg();
+-  }
+-}
+-
+-template <typename T>
+-inline const absl::Status& StatusOr<T>::status() const {
+-  return status_;
+-}
+-
+-template <typename T>
+-inline bool StatusOr<T>::ok() const {
+-  return status_.ok();
+-}
+-
+-template <typename T>
+-inline const T& StatusOr<T>::ValueOrDie() const& {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return value_.value();
+-}
+-
+-template <typename T>
+-inline T& StatusOr<T>::ValueOrDie() & {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return value_.value();
+-}
+-
+-template <typename T>
+-inline const T&& StatusOr<T>::ValueOrDie() const&& {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return std::move(value_.value());
+-}
+-
+-template <typename T>
+-inline T&& StatusOr<T>::ValueOrDie() && {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return std::move(value_.value());
+-}
+-
+-template <typename T>
+-inline const T& StatusOr<T>::value() const& {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return value_.value();
+-}
+-
+-template <typename T>
+-inline T& StatusOr<T>::value() & {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return value_.value();
+-}
+-
+-template <typename T>
+-inline const T&& StatusOr<T>::value() const&& {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return std::move(value_.value());
+-}
+-
+-template <typename T>
+-inline T&& StatusOr<T>::value() && {
+-  if (!value_) {
+-    internal::StatusOrHelper::Crash(status());
+-  }
+-  return std::move(value_.value());
+-}
++using StatusOr = absl::StatusOr<T>;
+ 
+ }  // namespace rlwe
+ 
+diff --git a/src/testing/coefficient_polynomial_test.cc b/src/testing/coefficient_polynomial_test.cc
+index bf43ee6f4ae02..e2a36c3d7d6bf 100644
+--- a/src/testing/coefficient_polynomial_test.cc
++++ b/src/testing/coefficient_polynomial_test.cc
+@@ -43,7 +43,7 @@ unsigned int seed = 0;
+ class PolynomialTest : public ::testing::Test {
+  protected:
+   PolynomialTest()
+-      : params14_(uint_m::Params::Create(rlwe::kNewhopeModulus).ValueOrDie()),
++      : params14_(uint_m::Params::Create(rlwe::kNewhopeModulus).value()),
+         one_(uint_m::ImportOne(params14_.get())),
+         zero_(uint_m::ImportZero(params14_.get())) {}
+ 
+diff --git a/src/testing/status_testing.h b/src/testing/status_testing.h
+index 27b8c0ed63073..6adc0278c98d2 100644
+--- a/src/testing/status_testing.h
++++ b/src/testing/status_testing.h
+@@ -43,6 +43,6 @@
+ #define RLWE_ASSERT_OK_AND_ASSIGN_IMPL_(statusor, lhs, rexpr) \
+   auto statusor = (rexpr);                                    \
+   ASSERT_THAT(statusor.ok(), ::testing::Eq(true));            \
+-  lhs = std::move(statusor).ValueOrDie()
++  lhs = std::move(statusor).value()
+ 
+ #endif  // RLWE_TESTING_STATUS_TESTING_H_
diff --git a/third_party/shell-encryption/patches/0007-Fix-Wunused-function-Wunused-local-typedef.patch b/third_party/shell-encryption/patches/0007-Fix-Wunused-function-Wunused-local-typedef.patch
new file mode 100644
index 0000000000000..8cf2156f52661
--- /dev/null
+++ b/third_party/shell-encryption/patches/0007-Fix-Wunused-function-Wunused-local-typedef.patch
@@ -0,0 +1,25 @@
+diff --git a/montgomery_test.cc b/montgomery_test.cc
+index 97444fc6c15c2..d5078fdcc86df 100644
+--- a/montgomery_test.cc
++++ b/montgomery_test.cc
+@@ -59,12 +59,6 @@ absl::uint128 GenerateRandom(unsigned int* seed) {
+   Uint64 lo = GenerateRandom<Uint64>(seed);
+   return absl::MakeUint128(hi, lo);
+ }
+-template <>
+-uint256 GenerateRandom(unsigned int* seed) {
+-  absl::uint128 hi = GenerateRandom<absl::uint128>(seed);
+-  absl::uint128 lo = GenerateRandom<absl::uint128>(seed);
+-  return uint256(hi, lo);
+-}
+ 
+ template <typename T>
+ class EXPORT_TEMPLATE_DECLARE(SHELL_ENCRYPTION_EXPORT) MontgomeryTest : public ::testing::Test {};
+@@ -728,7 +722,6 @@ TYPED_TEST(MontgomeryTest, ImportRandomWithPrngWithDifferentKeys) {
+ // Verifies that Barrett reductions functions properly.
+ TYPED_TEST(MontgomeryTest, VerifyBarrett) {
+   using Int = typename TypeParam::Int;
+-  using BigInt = typename internal::BigInt<Int>::value_type;
+ 
+   for (const auto& params :
+        rlwe::testing::ContextParameters<TypeParam>::Value()) {
diff --git a/third_party/shell-encryption/patches/0008-Fix-Wsign-compare.patch b/third_party/shell-encryption/patches/0008-Fix-Wsign-compare.patch
new file mode 100644
index 0000000000000..87a569ae86d07
--- /dev/null
+++ b/third_party/shell-encryption/patches/0008-Fix-Wsign-compare.patch
@@ -0,0 +1,61 @@
+diff --git a/ntt_parameters.h b/ntt_parameters.h
+index eba9579ab87ca..dc56ab62dd666 100644
+--- a/ntt_parameters.h
++++ b/ntt_parameters.h
+@@ -34,7 +34,7 @@ template <typename ModularInt>
+ void FillWithEveryPower(const ModularInt& base, unsigned int n,
+                         std::vector<ModularInt>* row,
+                         const typename ModularInt::Params* params) {
+-  for (int i = 0; i < n; i++) {
++  for (unsigned int i = 0; i < n; i++) {
+     (*row)[i].AddInPlace(base.ModExp(i, params), params);
+   }
+ }
+@@ -183,7 +183,7 @@ rlwe::StatusOr<NttParameters<ModularInt>> InitializeNttParameters(
+   // Abort if log_n is non-positive.
+   if (log_n <= 0) {
+     return absl::InvalidArgumentError("log_n must be positive");
+-  } else if (log_n > kMaxLogNumCoeffs) {
++  } else if (static_cast<Uint64>(log_n) > kMaxLogNumCoeffs) {
+     return absl::InvalidArgumentError(absl::StrCat(
+         "log_n, ", log_n, ", must be less than ", kMaxLogNumCoeffs, "."));
+   }
+diff --git a/sample_error.h b/sample_error.h
+index 7d570c5cd2e7a..b1f19eb952551 100644
+--- a/sample_error.h
++++ b/sample_error.h
+@@ -57,7 +57,7 @@ static rlwe::StatusOr<std::vector<ModularInt>> SampleFromErrorDistribution(
+   Uint64 k;
+   typename ModularInt::Int coefficient;
+ 
+-  for (int i = 0; i < num_coeffs; i++) {
++  for (unsigned int i = 0; i < num_coeffs; i++) {
+     coefficient = modulus_params->modulus;
+     k = variance << 1;
+ 
+diff --git a/symmetric_encryption.h b/symmetric_encryption.h
+index 987e86f7a9823..06dabb89502d4 100644
+--- a/symmetric_encryption.h
++++ b/symmetric_encryption.h
+@@ -630,9 +630,9 @@ class SymmetricRlweKey {
+   const typename ModularInt::Params* ModulusParams() const {
+     return modulus_params_;
+   }
+-  const unsigned int BitsPerCoeff() const { return log_t_; }
+-  const Uint64 Variance() const { return variance_; }
+-  const unsigned int LogT() const { return log_t_; }
++  unsigned int BitsPerCoeff() const { return log_t_; }
++  Uint64 Variance() const { return variance_; }
++  unsigned int LogT() const { return log_t_; }
+   const ModularInt& PlaintextModulus() const { return t_mod_; }
+   const typename ModularInt::Params* PlaintextModulusParams() const {
+     return plaintext_modulus_params_;
+@@ -941,7 +941,7 @@ rlwe::StatusOr<std::vector<typename ModularInt::Int>> Decrypt(
+   Polynomial<ModularInt> key_powers = key.Key();
+   unsigned int ciphertext_len = ciphertext.Len();
+ 
+-  for (int i = 0; i < ciphertext_len; i++) {
++  for (unsigned int i = 0; i < ciphertext_len; i++) {
+     // Extract component i.
+     RLWE_ASSIGN_OR_RETURN(Polynomial<ModularInt> ci, ciphertext.Component(i));
+ 
diff --git a/third_party/tensorflow-text/patches/0001-Add-score-as-a-possible-BERT-model-output-tensor-nam.patch b/third_party/tensorflow-text/patches/0001-Add-score-as-a-possible-BERT-model-output-tensor-nam.patch
new file mode 100644
index 0000000000000..092935a44735a
--- /dev/null
+++ b/third_party/tensorflow-text/patches/0001-Add-score-as-a-possible-BERT-model-output-tensor-nam.patch
@@ -0,0 +1,51 @@
+From 7a2f5cc794580461d54291848fada0f6eff9dff9 Mon Sep 17 00:00:00 2001
+From: Sarah Krakowiak Criel <skrakowi@chromium.org>
+Date: Thu, 19 Sep 2024 13:47:51 +0000
+Subject: [PATCH] Add 'score' as a possible BERT model output tensor name
+
+---
+ .../cc/task/text/bert_nl_classifier.cc        | 20 +++++++++++++------
+ 1 file changed, 14 insertions(+), 6 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc
+index 6b85f361b6047..fca60b05949df 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc
+@@ -44,7 +44,7 @@ using ::tflite::support::TfLiteSupportStatus;
+ using ::tflite::task::core::FindTensorByName;
+ 
+ namespace {
+-constexpr char kScoreTensorName[] = "probability";
++constexpr const char* kValidScoreTensorNames[] = { "probability", "score" };
+ 
+ absl::Status SanityCheckOptions(const BertNLClassifierOptions& options) {
+   if (!options.has_base_options()) {
+@@ -72,12 +72,20 @@ StatusOr<std::vector<core::Category>> BertNLClassifier::Postprocess(
+                         output_tensors.size()),
+         TfLiteSupportStatus::kInvalidNumOutputTensorsError);
+   }
+-  const TfLiteTensor* scores = FindTensorByName(
++  for (const auto& name : kValidScoreTensorNames) {
++    const TfLiteTensor* scores = FindTensorByName(
+       output_tensors, GetMetadataExtractor()->GetOutputTensorMetadata(),
+-      kScoreTensorName);
+-
+-  // optional labels extracted from metadata
+-  return BuildResults(scores, /*labels=*/nullptr);
++      name);
++    if (scores) {
++      // optional labels extracted from metadata
++      return BuildResults(scores, /*labels=*/nullptr);
++    }
++  }
++  return CreateStatusWithPayload(
++      absl::StatusCode::kInvalidArgument,
++      absl::StrFormat("BertNLClassifier models are expected to have an output "
++                      "tensor by the name: 'score' or 'probability'"),
++      TfLiteSupportStatus::kOutputTensorNotFoundError);
+ }
+ 
+ StatusOr<std::unique_ptr<BertNLClassifier>> BertNLClassifier::CreateFromOptions(
+-- 
+2.46.0.792.g87dc391469-goog
+
diff --git a/third_party/tensorflow-text/patches/0001-Implement-the-GetDependencyHeads-method-for-Dependen.patch b/third_party/tensorflow-text/patches/0001-Implement-the-GetDependencyHeads-method-for-Dependen.patch
new file mode 100644
index 0000000000000..126e3277bdb2d
--- /dev/null
+++ b/third_party/tensorflow-text/patches/0001-Implement-the-GetDependencyHeads-method-for-Dependen.patch
@@ -0,0 +1,156 @@
+From b96b199069e844cbb8dc428adee741fa40e76af8 Mon Sep 17 00:00:00 2001
+From: Xiang Xiao <xiangxiao@google.com>
+Date: Tue, 10 Sep 2024 14:51:46 -0700
+Subject: [PATCH] Implement the GetDependencyHeads method for
+ DependencyParserModel.
+
+This method runs a TFLite dependency parser model on a string and
+returns a vector of dependency head for each token in the string.
+
+Bug: 339037155
+Change-Id: I4a89ad43849fd3fa85b82d01d2cad915aa78e174
+---
+ third_party/tensorflow-text/BUILD.gn          |  2 +
+ .../shims/tensorflow/core/lib/core/errors.h   | 45 +++++++++++++++++++
+ .../shims/tensorflow/core/lib/core/status.h   | 14 ++++++
+ .../shims/tensorflow/core/platform/logging.h  |  8 ++++
+ .../tensorflow_text/core/kernels/mst_solver.h |  7 ++-
+ 5 files changed, 72 insertions(+), 4 deletions(-)
+ create mode 100644 third_party/tensorflow-text/shims/tensorflow/core/lib/core/errors.h
+ create mode 100644 third_party/tensorflow-text/shims/tensorflow/core/lib/core/status.h
+ create mode 100644 third_party/tensorflow-text/shims/tensorflow/core/platform/logging.h
+
+diff --git a/third_party/tensorflow-text/BUILD.gn b/third_party/tensorflow-text/BUILD.gn
+index 9a8d5fef1c5dc..7c5fa1b37c3b4 100644
+--- a/third_party/tensorflow-text/BUILD.gn
++++ b/third_party/tensorflow-text/BUILD.gn
+@@ -17,6 +17,8 @@ config("tensorflow-text-flags") {
+ 
+ static_library("tensorflow-text") {
+   sources = [
++    "src/tensorflow_text/core/kernels/disjoint_set_forest.h",
++    "src/tensorflow_text/core/kernels/mst_solver.h",
+     "src/tensorflow_text/core/kernels/regex_split.cc",
+     "src/tensorflow_text/core/kernels/regex_split.h",
+     "src/tensorflow_text/core/kernels/wordpiece_tokenizer.cc",
+diff --git a/third_party/tensorflow-text/shims/tensorflow/core/lib/core/errors.h b/third_party/tensorflow-text/shims/tensorflow/core/lib/core/errors.h
+new file mode 100644
+index 0000000000000..0475248b26b25
+--- /dev/null
++++ b/third_party/tensorflow-text/shims/tensorflow/core/lib/core/errors.h
+@@ -0,0 +1,45 @@
++// Copyright 2024 The Chromium Authors
++// Use of this source code is governed by a BSD-style license that can be
++// found in the LICENSE file.
++
++#ifndef THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_LIB_CORE_ERRORS_H_
++#define THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_LIB_CORE_ERRORS_H_
++
++#include "absl/status/status.h"
++#include "absl/strings/str_cat.h"
++
++#define TF_PREDICT_FALSE(x) (x)
++#define TF_PREDICT_TRUE(x) (x)
++
++// For propagating errors when calling a function.
++#define TF_RETURN_IF_ERROR(...)             \
++  do {                                      \
++    ::absl::Status _status = (__VA_ARGS__); \
++    if (TF_PREDICT_FALSE(!_status.ok())) {  \
++      return _status;                       \
++    }                                       \
++  } while (0)
++
++namespace tensorflow::errors {
++
++template <typename Arg1, typename Arg2>
++::absl::Status InvalidArgument(Arg1 arg1, Arg2 arg2) {
++  return absl::Status(absl::StatusCode::kInvalidArgument,
++                      absl::StrCat(arg1, arg2));
++}
++
++template <typename Arg1, typename Arg2, typename Arg3, typename Arg4>
++::absl::Status InvalidArgument(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
++  return absl::Status(absl::StatusCode::kInvalidArgument,
++                      absl::StrCat(arg1, arg2, arg3, arg4));
++}
++
++template <typename... Args>
++absl::Status FailedPrecondition(Args... args) {
++  return absl::Status(absl::StatusCode::kFailedPrecondition,
++                      absl::StrCat(args...));
++}
++
++}  // namespace tensorflow::errors
++
++#endif  // THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_LIB_CORE_ERRORS_H_
+diff --git a/third_party/tensorflow-text/shims/tensorflow/core/lib/core/status.h b/third_party/tensorflow-text/shims/tensorflow/core/lib/core/status.h
+new file mode 100644
+index 0000000000000..8b16ba1f64c09
+--- /dev/null
++++ b/third_party/tensorflow-text/shims/tensorflow/core/lib/core/status.h
+@@ -0,0 +1,14 @@
++// Copyright 2024 The Chromium Authors
++// Use of this source code is governed by a BSD-style license that can be
++// found in the LICENSE file.
++
++#ifndef THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_LIB_CORE_STATUS_H_
++#define THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_LIB_CORE_STATUS_H_
++
++#include "absl/status/status.h"
++
++namespace tensorflow {
++using Status = ::absl::Status;
++}
++
++#endif  // THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_LIB_CORE_STATUS_H_
+diff --git a/third_party/tensorflow-text/shims/tensorflow/core/platform/logging.h b/third_party/tensorflow-text/shims/tensorflow/core/platform/logging.h
+new file mode 100644
+index 0000000000000..776917efba118
+--- /dev/null
++++ b/third_party/tensorflow-text/shims/tensorflow/core/platform/logging.h
+@@ -0,0 +1,8 @@
++// Copyright 2024 The Chromium Authors
++// Use of this source code is governed by a BSD-style license that can be
++// found in the LICENSE file.
++
++#ifndef THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_PLATFORM_LOGGING_H_
++#define THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_PLATFORM_LOGGING_H_
++
++#endif  // THIRD_PARTY_TENSORFLOW_TEXT_SHIMS_TENSORFLOW_CORE_PLATFORM_LOGGING_H_
+diff --git a/third_party/tensorflow-text/src/tensorflow_text/core/kernels/mst_solver.h b/third_party/tensorflow-text/src/tensorflow_text/core/kernels/mst_solver.h
+index 818518bc2fdef..50372c5853d27 100644
+--- a/third_party/tensorflow-text/src/tensorflow_text/core/kernels/mst_solver.h
++++ b/third_party/tensorflow-text/src/tensorflow_text/core/kernels/mst_solver.h
+@@ -503,9 +503,9 @@ void MstSolver<Index, Score>::ContractCycle(Index node) {
+   for (const auto &node_and_arc : cycle_) {
+     // Set the |score_offset| to the cost of breaking the cycle by replacing the
+     // arc currently directed into the |cycle_node|.
+-    const Index cycle_node = node_and_arc.first;
++    const Index current_cycle_node = node_and_arc.first;
+     const Score score_offset = -node_and_arc.second->score;
+-    MergeInboundArcs(cycle_node, score_offset, contracted_node);
++    MergeInboundArcs(current_cycle_node, score_offset, contracted_node);
+   }
+ }
+ 
+@@ -586,7 +586,6 @@ tensorflow::Status MstSolver<Index, Score>::ExpansionPhase(
+       argmax[target] = arc.source - 1;
+     }
+   }
+-  DCHECK_GE(num_roots, 1);
+ 
+   // Even when |forest_| is false, |num_roots| can still be more than 1.  While
+   // the root score penalty discourages structures with multiple root arcs, it
+@@ -595,7 +594,7 @@ tensorflow::Status MstSolver<Index, Score>::ExpansionPhase(
+   // produce an all-root structure in spite of the root score penalty.  As this
+   // example illustrates, however, |num_roots| will be more than 1 if and only
+   // if the original digraph is infeasible for trees.
+-  if (!forest_ && num_roots != 1) {
++  if (num_roots < 1 || (!forest_ && num_roots != 1)) {
+     return tensorflow::errors::FailedPrecondition("Infeasible digraph");
+   }
+ 
+-- 
+2.46.0.662.g92d0881bb0-goog
+
diff --git a/third_party/tensorflow_models/patches/0001-add-int8-quantization-support-to-seq_flow_lite-ops.patch b/third_party/tensorflow_models/patches/0001-add-int8-quantization-support-to-seq_flow_lite-ops.patch
new file mode 100644
index 0000000000000..ef7e303be87be
--- /dev/null
+++ b/third_party/tensorflow_models/patches/0001-add-int8-quantization-support-to-seq_flow_lite-ops.patch
@@ -0,0 +1,235 @@
+From d8ed662f7f2e1de66a98e1f8d34ccda73c092317 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Fri, 14 Jun 2024 12:56:17 -0700
+Subject: [PATCH] add int8 quantization support to seq_flow_lite ops
+
+---
+ .../tflite_ops/sequence_string_projection.cc  | 32 +++++-
+ .../tflite_ops/tflite_qrnn_pooling.cc         | 99 +++++++++++++++----
+ 2 files changed, 107 insertions(+), 24 deletions(-)
+
+diff --git a/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/sequence_string_projection.cc b/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/sequence_string_projection.cc
+index f53cf650f16f8..22f4c609e86c9 100644
+--- a/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/sequence_string_projection.cc
++++ b/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/sequence_string_projection.cc
+@@ -28,8 +28,8 @@ limitations under the License.
+ #include "flatbuffers/flexbuffers.h"  // flatbuffer
+ #include "tensorflow/lite/string_util.h"
+ #include "tf_ops/projection_normalizer_util.h"  // seq_flow_lite
+-#include "tf_ops/projection_util.h"  // seq_flow_lite
+-#include "tflite_ops/quantization_util.h"  // seq_flow_lite
++#include "tf_ops/projection_util.h"             // seq_flow_lite
++#include "tflite_ops/quantization_util.h"       // seq_flow_lite
+ 
+ namespace seq_flow_lite {
+ namespace ops {
+@@ -144,8 +144,17 @@ class ProjectionParams {
+   void WordNoveltyFeature(uint8_t* data, int word_count) const {
+     float word_novelty_feature;
+     WordNoveltyFeature(&word_novelty_feature, word_count);
+-    *data = PodQuantize<uint8_t>(word_novelty_feature, 127.0f, 127);
++    *data = PodQuantize<uint8_t>(word_novelty_feature, /*zero_point=*/127,
++                                 /*inverse_scale=*/127.0f);
+   }
++
++  void WordNoveltyFeature(int8_t* data, int word_count) const {
++    float word_novelty_feature;
++    WordNoveltyFeature(&word_novelty_feature, word_count);
++    *data = PodQuantize<int8_t>(word_novelty_feature, /*zero_point=*/0,
++                                /*inverse_scale=*/127.5f);
++  }
++
+   bool DocSizeFeatureEnabled() const { return (doc_size_levels_ != 0); }
+   bool FirstCap() const { return add_first_cap_feature_; }
+   bool AllCaps() const { return add_all_caps_feature_; }
+@@ -161,8 +170,17 @@ class ProjectionParams {
+   void DocSizeFeature(uint8_t* data, int num_tokens) {
+     float doc_size_feature;
+     DocSizeFeature(&doc_size_feature, num_tokens);
+-    *data = PodQuantize<uint8_t>(doc_size_feature, 127.0f, 127);
++    *data = PodQuantize<uint8_t>(doc_size_feature, /*zero_point=*/127,
++                                 /*inverse_scale=*/127.0f);
+   }
++
++  void DocSizeFeature(int8_t* data, int num_tokens) {
++    float doc_size_feature;
++    DocSizeFeature(&doc_size_feature, num_tokens);
++    *data = PodQuantize<int8_t>(doc_size_feature, /*zero_point=*/0,
++                                /*inverse_scale=*/127.5f);
++  }
++
+   void Hash(const std::string& word, std::vector<uint64_t>& hash_codes) {
+     hasher_->GetHashCodes(word, hash_codes);
+   }
+@@ -473,11 +491,15 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
+   if (output->type == kTfLiteUInt8) {
+     const uint8_t kMappingTable[1 << kMapBits] = {127, 255, 0, 127};
+     TypedEval(kMappingTable, params, output->data.uint8);
++  } else if (output->type == kTfLiteInt8) {
++    const int8_t kMappingTable[1 << kMapBits] = {0, 127, -128, 0};
++    TypedEval(kMappingTable, params, output->data.int8);
+   } else if (output->type == kTfLiteFloat32) {
+     const float kMappingTable[1 << kMapBits] = {0.0, 1.0, -1.0, 0.0};
+     TypedEval(kMappingTable, params, output->data.f);
+   } else {
+-    context->ReportError(context, "Output type must be UInt8 or Float32.");
++    context->ReportError(context,
++                         "Output type must be Int8, UInt8, or Float32.");
+     return kTfLiteError;
+   }
+ 
+diff --git a/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/tflite_qrnn_pooling.cc b/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/tflite_qrnn_pooling.cc
+index 6641234c53d4b..205e8a619e5c2 100644
+--- a/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/tflite_qrnn_pooling.cc
++++ b/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/tflite_qrnn_pooling.cc
+@@ -22,7 +22,9 @@ namespace custom {
+ 
+ namespace {
+ 
+-const uint8_t kPoolingForward = 255;
++const uint8_t kPoolingUInt8Forward = 255;
++const int8_t kPoolingInt8Forward = 127;
++const float kPoolingFloatForward = 1.0;
+ 
+ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
+   TF_LITE_ENSURE_EQ(context, node->inputs->size, 3);
+@@ -34,9 +36,11 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
+   TfLiteTensor* constant = &context->tensors[node->inputs->data[1]];
+   TfLiteTensor* direction = &context->tensors[node->inputs->data[2]];
+ 
+-  TF_LITE_ENSURE_EQ(context, multiplier->type, kTfLiteUInt8);
+-  TF_LITE_ENSURE_EQ(context, constant->type, kTfLiteUInt8);
+-  TF_LITE_ENSURE_EQ(context, direction->type, kTfLiteUInt8);
++  TF_LITE_ENSURE(context, (constant->type == kTfLiteUInt8) ||
++                              (constant->type == kTfLiteInt8) ||
++                              (constant->type == kTfLiteFloat32));
++  TF_LITE_ENSURE_TYPES_EQ(context, multiplier->type, constant->type);
++  TF_LITE_ENSURE_TYPES_EQ(context, direction->type, constant->type);
+ 
+   TF_LITE_ENSURE_EQ(context, multiplier->dims->size, 3);
+   TF_LITE_ENSURE_EQ(context, multiplier->dims->data[0], 1);
+@@ -71,9 +75,13 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
+   return kTfLiteOk;
+ }
+ 
+-TfLiteStatus QRNNPooling(TfLiteContext* context, TfLiteTensor* multiplier,
+-                         TfLiteTensor* constant, TfLiteTensor* outputs,
+-                         TfLiteTensor* final_state, bool forward) {
++template <typename T>
++TfLiteStatus QRNNPooling(TfLiteContext* context,
++                         TfLiteTensor* multiplier,
++                         TfLiteTensor* constant,
++                         TfLiteTensor* outputs,
++                         TfLiteTensor* final_state,
++                         bool forward) {
+   const int time_steps = multiplier->dims->data[1];
+   const int state_size = multiplier->dims->data[2];
+ 
+@@ -82,28 +90,67 @@ TfLiteStatus QRNNPooling(TfLiteContext* context, TfLiteTensor* multiplier,
+ 
+   const int32_t out_zero_point = outputs ? outputs->params.zero_point : 0;
+   const float out_inverse_scale = outputs ? 1.0f / outputs->params.scale : 1.0f;
+-  uint8_t* out_ptr = outputs ? outputs->data.uint8 : nullptr;
++  T* outputs_ptr = outputs ? tflite::GetTensorData<T>(outputs) : nullptr;
+   for (int i = 0; i < time_steps; ++i) {
+     for (int j = 0; j < state_size; ++j) {
+       const int time_index = forward ? i : time_steps - (i + 1);
+       const int index = time_index * state_size + j;
+-      float multiplier_value = PodDequantize<uint8_t>(*multiplier, index);
+-      float constant_vale = PodDequantize<uint8_t>(*constant, index);
+-      state[j] = state[j] * multiplier_value + constant_vale;
++      float multiplier_value = PodDequantize<T>(*multiplier, index);
++      float constant_value = PodDequantize<T>(*constant, index);
++      state[j] = state[j] * multiplier_value + constant_value;
+       if (outputs) {
+-        out_ptr[index] =
+-            PodQuantize<uint8_t>(state[j], out_zero_point, out_inverse_scale);
++        outputs_ptr[index] =
++            PodQuantize<T>(state[j], out_zero_point, out_inverse_scale);
+       }
+     }
+   }
+ 
+   if (final_state) {
+-    uint8_t* final_state_ptr = final_state->data.uint8;
++    T* final_state_ptr = tflite::GetTensorData<T>(final_state);
+     const int32_t zero_point = final_state->params.zero_point;
+     const float inverse_scale = 1.0f / final_state->params.scale;
+     for (int j = 0; j < state_size; ++j) {
+-      final_state_ptr[j] =
+-          PodQuantize<uint8_t>(state[j], zero_point, inverse_scale);
++      final_state_ptr[j] = PodQuantize<T>(state[j], zero_point, inverse_scale);
++    }
++  }
++
++  return kTfLiteOk;
++}
++
++template <>
++TfLiteStatus QRNNPooling<float>(TfLiteContext* context,
++                                TfLiteTensor* multiplier,
++                                TfLiteTensor* constant,
++                                TfLiteTensor* outputs,
++                                TfLiteTensor* final_state,
++                                bool forward) {
++  const int time_steps = multiplier->dims->data[1];
++  const int state_size = multiplier->dims->data[2];
++
++  auto state = std::make_unique<float[]>(state_size);
++  memset(state.get(), 0, sizeof(float) * state_size);
++
++  float* multiplier_ptr = tflite::GetTensorData<float>(multiplier);
++  float* constant_ptr = tflite::GetTensorData<float>(constant);
++  float* outputs_ptr =
++      outputs ? tflite::GetTensorData<float>(outputs) : nullptr;
++  for (int i = 0; i < time_steps; ++i) {
++    for (int j = 0; j < state_size; ++j) {
++      const int time_index = forward ? i : time_steps - (i + 1);
++      const int index = time_index * state_size + j;
++      float multiplier_value = multiplier_ptr[index];
++      float constant_value = constant_ptr[index];
++      state[j] = state[j] * multiplier_value + constant_value;
++      if (outputs) {
++        outputs_ptr[index] = state[j];
++      }
++    }
++  }
++
++  if (final_state) {
++    float* final_state_ptr = tflite::GetTensorData<float>(final_state);
++    for (int j = 0; j < state_size; ++j) {
++      final_state_ptr[j] = state[j];
+     }
+   }
+ 
+@@ -126,10 +173,24 @@ TfLiteStatus Invoke(TfLiteContext* context, TfLiteNode* node) {
+ 
+   // When pooling forward the direction parameter is expected to be
+   // kPoolingForward.
+-  return QRNNPooling(context, multiplier, constant, outputs, final_state,
+-                     (direction->data.uint8[0] == kPoolingForward));
++  switch (multiplier->type) {
++    case kTfLiteUInt8:
++      return QRNNPooling<uint8_t>(
++          context, multiplier, constant, outputs, final_state,
++          (tflite::GetTensorData<uint8_t>(direction)[0] ==
++           kPoolingUInt8Forward));
++    case kTfLiteInt8:
++      return QRNNPooling<int8_t>(
++          context, multiplier, constant, outputs, final_state,
++          (tflite::GetTensorData<int8_t>(direction)[0] == kPoolingInt8Forward));
++    case kTfLiteFloat32:
++      return QRNNPooling<float>(
++          context, multiplier, constant, outputs, final_state,
++          (tflite::GetTensorData<float>(direction)[0] == kPoolingFloatForward));
++    default:
++      return kTfLiteError;
++  }
+ }
+-
+ }  // namespace
+ 
+ const char kPoolingOp[] = "PoolingOp";
+-- 
+2.45.2.627.g7a2c4fd464-goog
+
diff --git a/third_party/tensorflow_models/patches/0002-Add-int8-quantization-support-to-the-denylist-op.patch b/third_party/tensorflow_models/patches/0002-Add-int8-quantization-support-to-the-denylist-op.patch
new file mode 100644
index 0000000000000..8f86a41e452e4
--- /dev/null
+++ b/third_party/tensorflow_models/patches/0002-Add-int8-quantization-support-to-the-denylist-op.patch
@@ -0,0 +1,105 @@
+From a7b009d15354e8d80eec463b95c7a7a08489bc58 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 26 Jun 2024 08:56:07 -0700
+Subject: [PATCH] Add int8 quantization support to the denylist op
+
+---
+ .../seq_flow_lite/tflite_ops/denylist.cc      | 58 ++++++++++++-------
+ 1 file changed, 36 insertions(+), 22 deletions(-)
+
+diff --git a/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/denylist.cc b/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/denylist.cc
+index 99671a6bb947e..97f58fdf7c9e4 100644
+--- a/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/denylist.cc
++++ b/third_party/tensorflow_models/src/research/seq_flow_lite/tflite_ops/denylist.cc
+@@ -14,6 +14,8 @@ limitations under the License.
+ ==============================================================================*/
+ #include "tflite_ops/denylist.h"  // seq_flow_lite
+ 
++#include <cstdint>
++
+ #include "absl/container/flat_hash_set.h"
+ #include "tensorflow/lite/context.h"
+ #include "tflite_ops/quantization_util.h"  // seq_flow_lite
+@@ -44,6 +46,34 @@ TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {
+       output_dims);
+ }
+ 
++template <typename T>
++TfLiteStatus QuantizedEval(DenylistOp* op,
++                           TfLiteContext* context,
++                           TfLiteTensor* output_categories,
++                           int input_size) {
++  const uint8_t one = PodQuantize<T>(1.0, output_categories->params.zero_point,
++                                     1.0 / output_categories->params.scale);
++  const uint8_t zero = PodQuantize<T>(0.0, output_categories->params.zero_point,
++                                      1.0 / output_categories->params.scale);
++  int n_categories = op->categories();
++  for (int i = 0; i < input_size; i++) {
++    absl::flat_hash_set<int> categories;
++    TF_LITE_ENSURE_STATUS(op->GetCategories(context, i, categories));
++    if (categories.empty()) {
++      for (int j = 0; j < n_categories; j++) {
++        tflite::GetTensorData<T>(output_categories)[i * n_categories + j] =
++            (j < op->negative_categories()) ? one : zero;
++      }
++    } else {
++      for (int j = 0; j < n_categories; j++) {
++        tflite::GetTensorData<T>(output_categories)[i * n_categories + j] =
++            (categories.find(j) != categories.end()) ? one : zero;
++      }
++    }
++  }
++  return kTfLiteOk;
++}
++
+ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
+   auto* op = reinterpret_cast<DenylistOp*>(node->user_data);
+   TF_LITE_ENSURE_STATUS(op->CheckErrors(context));
+@@ -56,10 +86,10 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
+   for (int i = 0; i < input_dims->size; i++) {
+     input_size *= input_dims->data[i];
+   }
+-  int n_categories = op->categories();
+ 
+   TF_LITE_ENSURE_STATUS(op->InitializeInput(context, node));
+   if (output_categories->type == kTfLiteFloat32) {
++    int n_categories = op->categories();
+     for (int i = 0; i < input_size; i++) {
+       absl::flat_hash_set<int> categories;
+       TF_LITE_ENSURE_STATUS(op->GetCategories(context, i, categories));
+@@ -76,27 +106,11 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
+       }
+     }
+   } else if (output_categories->type == kTfLiteUInt8) {
+-    const uint8_t one =
+-        PodQuantize<uint8_t>(1.0, output_categories->params.zero_point,
+-                             1.0 / output_categories->params.scale);
+-    const uint8_t zero =
+-        PodQuantize<uint8_t>(0.0, output_categories->params.zero_point,
+-                             1.0 / output_categories->params.scale);
+-    for (int i = 0; i < input_size; i++) {
+-      absl::flat_hash_set<int> categories;
+-      TF_LITE_ENSURE_STATUS(op->GetCategories(context, i, categories));
+-      if (categories.empty()) {
+-        for (int j = 0; j < n_categories; j++) {
+-          output_categories->data.uint8[i * n_categories + j] =
+-              (j < op->negative_categories()) ? one : zero;
+-        }
+-      } else {
+-        for (int j = 0; j < n_categories; j++) {
+-          output_categories->data.uint8[i * n_categories + j] =
+-              (categories.find(j) != categories.end()) ? one : zero;
+-        }
+-      }
+-    }
++    TF_LITE_ENSURE_STATUS(
++        QuantizedEval<uint8_t>(op, context, output_categories, input_size));
++  } else if (output_categories->type == kTfLiteInt8) {
++    TF_LITE_ENSURE_STATUS(
++        QuantizedEval<int8_t>(op, context, output_categories, input_size));
+   }
+   op->FinalizeInput();
+   return kTfLiteOk;
+-- 
+2.45.2.741.gdbec12cfda-goog
+
diff --git a/third_party/tflite_support/patches/0001-sentencepiece-tokenization-not-supported.patch b/third_party/tflite_support/patches/0001-sentencepiece-tokenization-not-supported.patch
new file mode 100644
index 0000000000000..f983dd941b7d3
--- /dev/null
+++ b/third_party/tflite_support/patches/0001-sentencepiece-tokenization-not-supported.patch
@@ -0,0 +1,51 @@
+From e514c2694ad7a7353c1f29ca86400d23bac17f73 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:02 -0800
+Subject: [PATCH 01/10] sentencepiece tokenization not supported
+
+---
+ .../cc/text/tokenizers/tokenizer_utils.cc          | 14 ++++----------
+ 1 file changed, 4 insertions(+), 10 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc
+index 0ba0f370cc305..bd4f18fca7f08 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc
+@@ -23,7 +23,6 @@ limitations under the License.
+ #include "tensorflow_lite_support/cc/port/status_macros.h"
+ #include "tensorflow_lite_support/cc/text/tokenizers/bert_tokenizer.h"
+ #include "tensorflow_lite_support/cc/text/tokenizers/regex_tokenizer.h"
+-#include "tensorflow_lite_support/cc/text/tokenizers/sentencepiece_tokenizer.h"
+ #include "tensorflow_lite_support/metadata/metadata_schema_generated.h"
+ 
+ namespace tflite {
+@@ -32,7 +31,6 @@ namespace text {
+ namespace tokenizer {
+ 
+ using ::tflite::ProcessUnit;
+-using ::tflite::SentencePieceTokenizerOptions;
+ using ::tflite::support::CreateStatusWithPayload;
+ using ::tflite::support::StatusOr;
+ using ::tflite::support::TfLiteSupportStatus;
+@@ -77,14 +75,10 @@ StatusOr<std::unique_ptr<Tokenizer>> CreateTokenizerFromProcessUnit(
+                                               vocab_buffer.size());
+     }
+     case ProcessUnitOptions_SentencePieceTokenizerOptions: {
+-      const tflite::SentencePieceTokenizerOptions* options =
+-          tokenizer_process_unit->options_as<SentencePieceTokenizerOptions>();
+-      ASSIGN_OR_RETURN(absl::string_view model_buffer,
+-                       CheckAndLoadFirstAssociatedFile(
+-                           options->sentencePiece_model(), metadata_extractor));
+-      // TODO(b/160647204): Extract sentence piece model vocabulary
+-      return absl::make_unique<SentencePieceTokenizer>(model_buffer.data(),
+-                                                       model_buffer.size());
++      return CreateStatusWithPayload(
++        absl::StatusCode::kInvalidArgument,
++        "Chromium does not support sentencepiece tokenization",
++        TfLiteSupportStatus::kMetadataInvalidTokenizerError);
+     }
+     case ProcessUnitOptions_RegexTokenizerOptions: {
+       const tflite::RegexTokenizerOptions* options =
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0002-rm-noop-deprecated-attribute.patch b/third_party/tflite_support/patches/0002-rm-noop-deprecated-attribute.patch
new file mode 100644
index 0000000000000..08f7ef2a5b506
--- /dev/null
+++ b/third_party/tflite_support/patches/0002-rm-noop-deprecated-attribute.patch
@@ -0,0 +1,26 @@
+From ac9b477facaff6b6cb4668e1cd20468478317ef1 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:06 -0800
+Subject: [PATCH 02/10] rm noop deprecated attribute
+
+---
+ .../cc/task/text/nlclassifier/nl_classifier.h                  | 3 ---
+ 1 file changed, 3 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.h
+index 42989daed506f..554eb306c5e0a 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.h
+@@ -43,9 +43,6 @@ namespace text {
+ namespace nlclassifier {
+ 
+ // Options to identify input and output tensors of the model
+-ABSL_DEPRECATED(
+-    "Prefer using `tflite::task::text::NLClassifierOptions` and "
+-    "`CreateFromOptions`")
+ struct NLClassifierOptions {
+   int input_tensor_index = 0;
+   int output_score_tensor_index = 0;
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0003-do-not-use-absl-any.patch b/third_party/tflite_support/patches/0003-do-not-use-absl-any.patch
new file mode 100644
index 0000000000000..bd403f4133074
--- /dev/null
+++ b/third_party/tflite_support/patches/0003-do-not-use-absl-any.patch
@@ -0,0 +1,64 @@
+From 843d9366447f03115fe80d73679c0ba73f2d58ee Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:10 -0800
+Subject: [PATCH 03/10] do not use absl any
+
+---
+ .../cc/task/vision/core/frame_buffer.h        | 27 -------------------
+ 1 file changed, 27 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/frame_buffer.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/frame_buffer.h
+index 344879341479f..77a41e081b72b 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/frame_buffer.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/frame_buffer.h
+@@ -27,7 +27,6 @@ limitations under the License.
+ #include "absl/strings/str_cat.h"  // from @com_google_absl
+ #include "absl/time/clock.h"  // from @com_google_absl
+ #include "absl/time/time.h"  // from @com_google_absl
+-#include "absl/types/any.h"  // from @com_google_absl
+ #include "absl/types/optional.h"  // from @com_google_absl
+ #include "tensorflow_lite_support/cc/port/integral_types.h"
+ #include "tensorflow_lite_support/cc/port/statusor.h"
+@@ -277,31 +276,6 @@ class FrameBuffer {
+     return {};
+   }
+ 
+-  // Returns the tag associated to the tag_key.
+-  absl::any GetTag(const std::string& tag_key) const {
+-    auto iter = tags_.find(tag_key);
+-    if (iter != tags_.end()) {
+-      return iter->second;
+-    }
+-    return absl::any();
+-  }
+-
+-  // Inserts or updates the tags map with key value pair (tag_key, tag_value).
+-  void InsertOrUpdateTag(const std::string& tag_key, absl::any tag_value) {
+-    tags_[tag_key] = std::move(tag_value);
+-  }
+-
+-  // Inserts the key value pair (tag_key, tag_value) into tags map. If the
+-  // tag_key already exists, an internal error will return.
+-  absl::Status InsertTag(const std::string& tag_key, absl::any tag_value) {
+-    auto iter = tags_.emplace(tag_key, tag_value);
+-    if (iter.second) {
+-      return absl::OkStatus();
+-    }
+-    return absl::InternalError(absl::StrCat(
+-        "tag_key already exists in tags.tag_key was not inserted: ", tag_key));
+-  }
+-
+   // Returns FrameBuffer dimension.
+   const Dimension dimension() const { return dimension_; }
+ 
+@@ -316,7 +290,6 @@ class FrameBuffer {
+ 
+  private:
+   std::vector<Plane> planes_;
+-  std::map<std::string, absl::any> tags_;
+   Dimension dimension_;
+   Format format_;
+   Orientation orientation_;
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0004-rm-stdio-static-init.patch b/third_party/tflite_support/patches/0004-rm-stdio-static-init.patch
new file mode 100644
index 0000000000000..02f5aed98ca8f
--- /dev/null
+++ b/third_party/tflite_support/patches/0004-rm-stdio-static-init.patch
@@ -0,0 +1,38 @@
+From a948100b0aa6e231df0b78d4901d244077a4face Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:12 -0800
+Subject: [PATCH 04/10] rm stdio static init
+
+---
+ .../cc/task/core/tflite_engine.cc                 | 15 ---------------
+ 1 file changed, 15 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc
+index 6ad1124659454..0b9af59afdc79 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc
+@@ -36,21 +36,6 @@ namespace tflite {
+ namespace task {
+ namespace core {
+ 
+-#ifdef __ANDROID__
+-// https://github.com/opencv/opencv/issues/14906
+-// "ios_base::Init" object is not a part of Android's "iostream" header (in case
+-// of clang toolchain, NDK 20).
+-//
+-// Ref1:
+-// https://en.cppreference.com/w/cpp/io/ios_base/Init
+-//       The header <iostream> behaves as if it defines (directly or indirectly)
+-//       an instance of std::ios_base::Init with static storage duration
+-//
+-// Ref2:
+-// https://github.com/gcc-mirror/gcc/blob/gcc-8-branch/libstdc%2B%2B-v3/include/std/iostream#L73-L74
+-static std::ios_base::Init s_iostream_initializer;
+-#endif
+-
+ using ::absl::StatusCode;
+ using ::tflite::proto::ComputeSettings;
+ using ::tflite::support::CreateStatusWithPayload;
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0005-check-cancel-flag-before-calling-invoke.patch b/third_party/tflite_support/patches/0005-check-cancel-flag-before-calling-invoke.patch
new file mode 100644
index 0000000000000..b66a06b75219f
--- /dev/null
+++ b/third_party/tflite_support/patches/0005-check-cancel-flag-before-calling-invoke.patch
@@ -0,0 +1,57 @@
+From 300388985a1835c993499cb413b8d900666651ed Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:16 -0800
+Subject: [PATCH 05/10] check cancel flag before calling invoke
+
+---
+ .../cc/port/default/tflite_wrapper.cc              | 14 ++++++++++----
+ 1 file changed, 10 insertions(+), 4 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc
+index dce66868264cb..70fedca9a3f22 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc
+@@ -258,8 +258,10 @@ absl::Status TfLiteInterpreterWrapper::InvokeWithFallback(
+     const std::function<absl::Status(tflite::Interpreter* interpreter)>&
+         set_inputs) {
+   RETURN_IF_ERROR(set_inputs(interpreter_.get()));
+-  // Reset cancel flag before calling `Invoke()`.
+-  cancel_flag_.Set(false);
++  if (cancel_flag_.Get()) {
++    cancel_flag_.Set(false);
++    return absl::CancelledError("cancelled before Invoke() was called");
++  }
+   TfLiteStatus status = kTfLiteError;
+   if (fallback_on_execution_error_) {
+     status = InterpreterUtils::InvokeWithCPUFallback(interpreter_.get());
+@@ -273,6 +275,7 @@ absl::Status TfLiteInterpreterWrapper::InvokeWithFallback(
+   // Assume the inference is cancelled successfully if Invoke() returns
+   // kTfLiteError and the cancel flag is `true`.
+   if (status == kTfLiteError && cancel_flag_.Get()) {
++    cancel_flag_.Set(false);
+     return absl::CancelledError("Invoke() cancelled.");
+   }
+   if (delegate_) {
+@@ -289,14 +292,17 @@ absl::Status TfLiteInterpreterWrapper::InvokeWithFallback(
+ }
+ 
+ absl::Status TfLiteInterpreterWrapper::InvokeWithoutFallback() {
+-  // Reset cancel flag before calling `Invoke()`.
+-  cancel_flag_.Set(false);
++  if (cancel_flag_.Get()) {
++    cancel_flag_.Set(false);
++    return absl::CancelledError("cancelled before Invoke() was called");
++  }
+   TfLiteStatus status = interpreter_->Invoke();
+   if (status != kTfLiteOk) {
+     // Assume InvokeWithoutFallback() is guarded under caller's synchronization.
+     // Assume the inference is cancelled successfully if Invoke() returns
+     // kTfLiteError and the cancel flag is `true`.
+     if (status == kTfLiteError && cancel_flag_.Get()) {
++      cancel_flag_.Set(false);
+       return absl::CancelledError("Invoke() cancelled.");
+     }
+     return absl::InternalError("Invoke() failed.");
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0006-Fix-TFLite-build-errors-on-linux-when-using-the-syst.patch b/third_party/tflite_support/patches/0006-Fix-TFLite-build-errors-on-linux-when-using-the-syst.patch
new file mode 100644
index 0000000000000..27e43103614da
--- /dev/null
+++ b/third_party/tflite_support/patches/0006-Fix-TFLite-build-errors-on-linux-when-using-the-syst.patch
@@ -0,0 +1,111 @@
+From 3dc1cc4f100d9633736a8937482dcc838d98556a Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:21 -0800
+Subject: [PATCH 06/10] Fix TFLite build errors on linux when using the system
+
+---
+ .../metadata/cc/metadata_extractor.cc                        | 5 +++--
+ .../metadata/cc/metadata_populator.cc                        | 4 ++--
+ .../metadata/cc/utils/zip_readonly_mem_file.cc               | 2 +-
+ .../metadata/cc/utils/zip_readonly_mem_file.h                | 2 +-
+ .../metadata/cc/utils/zip_writable_mem_file.cc               | 2 +-
+ .../metadata/cc/utils/zip_writable_mem_file.h                | 2 +-
+ 6 files changed, 9 insertions(+), 8 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc
+index f4ee9192fe42a..d208da4e03780 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc
+@@ -23,13 +23,14 @@ limitations under the License.
+ #include "absl/strings/str_format.h"  // from @com_google_absl
+ #include "absl/strings/string_view.h"  // from @com_google_absl
+ #include "flatbuffers/flatbuffers.h"  // from @flatbuffers
+-#include "contrib/minizip/ioapi.h"
+-#include "contrib/minizip/unzip.h"
+ #include "tensorflow/lite/schema/schema_generated.h"
+ #include "tensorflow_lite_support/cc/common.h"
+ #include "tensorflow_lite_support/cc/port/status_macros.h"
+ #include "tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.h"
+ #include "tensorflow_lite_support/metadata/metadata_schema_generated.h"
++#include "third_party/zlib/contrib/minizip/ioapi.h"
++#include "third_party/zlib/contrib/minizip/unzip.h"
++
+ 
+ namespace tflite {
+ namespace metadata {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc
+index 9d256b3322fb0..01c68515afd37 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc
+@@ -20,14 +20,14 @@ limitations under the License.
+ #include <functional>
+ 
+ #include "flatbuffers/flatbuffers.h"  // from @flatbuffers
+-#include "contrib/minizip/ioapi.h"
+-#include "contrib/minizip/zip.h"
+ #include "tensorflow/lite/schema/schema_generated.h"
+ #include "tensorflow_lite_support/cc/common.h"
+ #include "tensorflow_lite_support/cc/port/status_macros.h"
+ #include "tensorflow_lite_support/cc/port/statusor.h"
+ #include "tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.h"
+ #include "tensorflow_lite_support/metadata/metadata_schema_generated.h"
++#include "third_party/zlib/contrib/minizip/ioapi.h"
++#include "third_party/zlib/contrib/minizip/unzip.h"
+ 
+ namespace tflite {
+ namespace metadata {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.cc b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.cc
+index 3dac8c24af942..65a4638a868ad 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.cc
+@@ -19,7 +19,7 @@ limitations under the License.
+ #include <cstdio>
+ 
+ #include "absl/strings/string_view.h"  // from @com_google_absl
+-#include "contrib/minizip/ioapi.h"
++#include "third_party/zlib/contrib/minizip/ioapi.h"
+ 
+ namespace tflite {
+ namespace metadata {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.h b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.h
+index 13927a7afa698..1b7bed5987fbc 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_readonly_mem_file.h
+@@ -19,7 +19,7 @@ limitations under the License.
+ #include <cstdlib>
+ 
+ #include "absl/strings/string_view.h"  // from @com_google_absl
+-#include "contrib/minizip/ioapi.h"
++#include "third_party/zlib/contrib/minizip/ioapi.h"
+ 
+ namespace tflite {
+ namespace metadata {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.cc b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.cc
+index 5999be028689a..73e42b8443cef 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.cc
+@@ -19,7 +19,7 @@ limitations under the License.
+ #include <cstdio>
+ 
+ #include "absl/strings/string_view.h"  // from @com_google_absl
+-#include "contrib/minizip/ioapi.h"
++#include "third_party/zlib/contrib/minizip/ioapi.h"
+ 
+ namespace tflite {
+ namespace metadata {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.h b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.h
+index 762dd58f0fb41..bb27d96aef4b5 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_writable_mem_file.h
+@@ -19,7 +19,7 @@ limitations under the License.
+ #include <cstdlib>
+ 
+ #include "absl/strings/string_view.h"  // from @com_google_absl
+-#include "contrib/minizip/ioapi.h"
++#include "third_party/zlib/contrib/minizip/ioapi.h"
+ 
+ namespace tflite {
+ namespace metadata {
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0007-Use-SysNSStringToUTF8-to-convert-NSString.patch b/third_party/tflite_support/patches/0007-Use-SysNSStringToUTF8-to-convert-NSString.patch
new file mode 100644
index 0000000000000..ade80e3d6f855
--- /dev/null
+++ b/third_party/tflite_support/patches/0007-Use-SysNSStringToUTF8-to-convert-NSString.patch
@@ -0,0 +1,25 @@
+From 95fbbe296dc22a585b1453d85aab6b561aa639d1 Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:35 -0800
+Subject: [PATCH 07/10] Use SysNSStringToUTF8 to convert NSString
+
+---
+ .../tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm  | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm b/third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm
+index 39c7b655ff3f2..830eab4359067 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm
++++ b/third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm
+@@ -14,7 +14,7 @@ limitations under the License.
+ ==============================================================================*/
+ #import "tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.h"
+ 
+-std::string MakeString(NSString* str) { return std::string([str UTF8String]); }
++std::string MakeString(NSString* str) { return base::SysNSStringToUTF8(str); }
+ 
+ NSString* MakeNSString(const std::string& str) {
+   return [[NSString alloc] initWithBytes:const_cast<void*>(static_cast<const void*>(str.data()))
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0008-set-executable-bit-for-common_win.bat.patch b/third_party/tflite_support/patches/0008-set-executable-bit-for-common_win.bat.patch
new file mode 100644
index 0000000000000..f7dd04032bff8
--- /dev/null
+++ b/third_party/tflite_support/patches/0008-set-executable-bit-for-common_win.bat.patch
@@ -0,0 +1,16 @@
+From 4139494b443aada98e09bee988a46e9f591b3a3f Mon Sep 17 00:00:00 2001
+From: Robert Ogden <robertogden@chromium.org>
+Date: Wed, 30 Nov 2022 10:24:39 -0800
+Subject: [PATCH 08/10] set executable bit for common_win.bat
+
+---
+ .../src/tensorflow_lite_support/tools/ci_build/common_win.bat     | 0
+ 1 file changed, 0 insertions(+), 0 deletions(-)
+ mode change 100644 => 100755 third_party/tflite_support/src/tensorflow_lite_support/tools/ci_build/common_win.bat
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/tools/ci_build/common_win.bat b/third_party/tflite_support/src/tensorflow_lite_support/tools/ci_build/common_win.bat
+old mode 100644
+new mode 100755
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0009-Remove-whitespace-tokenizer.patch b/third_party/tflite_support/patches/0009-Remove-whitespace-tokenizer.patch
new file mode 100644
index 0000000000000..cd03edbaa7414
--- /dev/null
+++ b/third_party/tflite_support/patches/0009-Remove-whitespace-tokenizer.patch
@@ -0,0 +1,778 @@
+From e17b326bbf9026308c87ac7d9444aa3b4db73288 Mon Sep 17 00:00:00 2001
+From: Daniel Cheng <dcheng@chromium.org>
+Date: Mon, 11 Sep 2023 00:22:25 -0700
+Subject: [PATCH 09/10] Remove whitespace tokenizer.
+
+It uses the unsafe function `chartorune` and is not needed in Chrome. If
+this patch does not apply, it can be regenerated with:
+
+git rm src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer*
+
+Change-Id: I593c1bf1db662e805f79b6a9ce3d4f8a4d515ea6
+---
+ .../custom_ops/kernel/whitespace_tokenizer.cc | 224 ------------------
+ .../custom_ops/kernel/whitespace_tokenizer.h  |  31 ---
+ .../whitespace_tokenizer_op_resolver.cc       |  32 ---
+ .../kernel/whitespace_tokenizer_op_resolver.h |  34 ---
+ ...hitespace_tokenizer_op_resolver_wrapper.cc |  29 ---
+ .../kernel/whitespace_tokenizer_test.cc       | 189 ---------------
+ .../kernel/whitespace_tokenizer_test.py       | 166 -------------
+ 7 files changed, 705 deletions(-)
+ delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.cc
+ delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.h
+ delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.cc
+ delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.h
+ delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver_wrapper.cc
+ delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.cc
+ delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.py
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.cc b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.cc
+deleted file mode 100644
+index dad2f0004be06..0000000000000
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.cc
++++ /dev/null
+@@ -1,224 +0,0 @@
+-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
+-
+-Licensed under the Apache License, Version 2.0 (the "License");
+-you may not use this file except in compliance with the License.
+-You may obtain a copy of the License at
+-
+-    http://www.apache.org/licenses/LICENSE-2.0
+-
+-Unless required by applicable law or agreed to in writing, software
+-distributed under the License is distributed on an "AS IS" BASIS,
+-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-See the License for the specific language governing permissions and
+-limitations under the License.
+-==============================================================================*/
+-
+-#include "tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.h"
+-
+-#include <algorithm>
+-#include <utility>
+-#include <vector>
+-
+-#include "tensorflow/lite/context.h"
+-#include "tensorflow/lite/kernels/kernel_util.h"
+-#include "tensorflow/lite/string_util.h"
+-#include "libutf/utf.h"
+-
+-constexpr int kInput = 0;
+-constexpr int kOutputValues = 0;
+-constexpr int kOutputRowSplitsStart = 1;
+-
+-namespace tflite {
+-namespace ops {
+-namespace custom {
+-namespace whitespace_tokenizer {
+-
+-// This TFLite op implements a whitespace tokenizer, and can output the
+-// tokens as either a padded tensor or a ragged tensor.
+-//
+-// If we're outputting a padded tensor, our outputs are:
+-// * A string tensor
+-//
+-// If we're outputting a ragged tensor, our outputs are:
+-// * A string tensor (the innermost values of the ragged tensor)
+-// * N int64 tensors (the row_splits of the ragged tensor, where N is the
+-//   rank of the input tensor)
+-
+-inline bool OutputIsPaddedTensor(TfLiteNode* node) {
+-  return NumOutputs(node) == 1;
+-}
+-
+-inline int charntorune(Rune* r, const char* s, int n) {
+-  const int bytes_read = chartorune(r, const_cast<char *>(s));
+-  if (bytes_read > n) {
+-    *r = Runeerror;
+-    return 0;
+-  }
+-  return bytes_read;
+-}
+-
+-std::vector<std::pair<const char*, int>> Tokenize(StringRef str) {
+-  const char* p = str.str;
+-  int n = str.len;
+-
+-  std::vector<std::pair<const char*, int>> tokens;
+-  const char* start = nullptr;
+-  while (n > 0) {
+-    Rune r;
+-    int c = charntorune(&r, p, n);
+-    if (r == Runeerror) break;
+-
+-    if (isspacerune(r)) {
+-      if (start != nullptr) {
+-        tokens.push_back({start, p - start});
+-      }
+-      start = nullptr;
+-    } else {
+-      if (start == nullptr) {
+-        start = p;
+-      }
+-    }
+-
+-    p += c;
+-    n -= c;
+-  }
+-  if (start != nullptr) {
+-    tokens.push_back({start, p - start});
+-  }
+-
+-  return tokens;
+-}
+-
+-TfLiteStatus WritePaddedOutput(
+-    const std::vector<std::vector<std::pair<const char*, int>>>& list_of_tokens,
+-    const TfLiteTensor* input, TfLiteTensor* output_values) {
+-  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(input) + 1);
+-  for (int i = 0; i < NumDimensions(input); ++i) {
+-    output_shape->data[i] = SizeOfDimension(input, i);
+-  }
+-
+-  size_t max_tokens = 0;
+-  for (const auto& tokens : list_of_tokens) {
+-    max_tokens = std::max(max_tokens, tokens.size());
+-  }
+-
+-  output_shape->data[NumDimensions(input)] = max_tokens;
+-  DynamicBuffer buffer;
+-  for (const auto& tokens : list_of_tokens) {
+-    for (const auto& token : tokens) {
+-      buffer.AddString(token.first, token.second);
+-    }
+-    for (int i = tokens.size(); i < max_tokens; ++i) {
+-      buffer.AddString(nullptr, 0);
+-    }
+-  }
+-  buffer.WriteToTensor(output_values, output_shape);
+-  return kTfLiteOk;
+-}
+-
+-TfLiteStatus WriteRaggedOutput(
+-    const std::vector<std::vector<std::pair<const char*, int>>>& list_of_tokens,
+-    const TfLiteTensor* input, TfLiteTensor* output_values,
+-    std::vector<TfLiteTensor*> nested_row_splits) {
+-  // The outer dimensions of the ragged tensor are all non-ragged.
+-  for (int i = 0; i < nested_row_splits.size() - 1; ++i) {
+-    int row_splits_step = SizeOfDimension(input, i + 1);
+-    TfLiteTensor* row_splits = nested_row_splits[i];
+-    for (int j = 0; j < SizeOfDimension(row_splits, 0); ++j) {
+-      row_splits->data.i64[j] = j * row_splits_step;
+-    }
+-  }
+-
+-  // Generate the innermost row_splits and values tensors.
+-  TfLiteTensor* row_splits = nested_row_splits.back();
+-  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(1);
+-  DynamicBuffer buffer;
+-  int token_index = 0;
+-  int row_splits_index = 0;
+-  for (const auto& tokens : list_of_tokens) {
+-    row_splits->data.i64[row_splits_index] = token_index;
+-    for (const auto& token : tokens) {
+-      buffer.AddString(token.first, token.second);
+-      ++token_index;
+-    }
+-    ++row_splits_index;
+-  }
+-  row_splits->data.i64[row_splits_index] = token_index;
+-  output_shape->data[0] = token_index;
+-  buffer.WriteToTensor(output_values, output_shape);
+-  return kTfLiteOk;
+-}
+-
+-TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
+-  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);
+-  SetTensorToDynamic(output_values);
+-
+-  if (OutputIsPaddedTensor(node)) {
+-    return kTfLiteOk;
+-  }
+-
+-  const TfLiteTensor* input = GetInput(context, node, kInput);
+-  TF_LITE_ENSURE(context, NumDimensions(input) ==
+-                              (NumOutputs(node) - kOutputRowSplitsStart));
+-
+-  // Resize the row_splits tensors.  We're just adding a ragged inner
+-  // dimension to the shape of the input tensor, so the size of the
+-  // row_splits tensors can be calculated using the input tensor's shape.
+-  int input_size = 1;
+-  for (int i = 0; i < NumDimensions(input); ++i) {
+-    input_size *= SizeOfDimension(input, i);
+-
+-    TfLiteIntArray* row_splits_shape = TfLiteIntArrayCreate(1);
+-    row_splits_shape->data[0] = input_size + 1;
+-    TfLiteTensor* row_splits =
+-        GetOutput(context, node, kOutputRowSplitsStart + i);
+-    TF_LITE_ENSURE_STATUS(
+-        context->ResizeTensor(context, row_splits, row_splits_shape));
+-  }
+-
+-  return kTfLiteOk;
+-}
+-
+-TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
+-  const TfLiteTensor* input = GetInput(context, node, kInput);
+-  int input_size = 1;
+-  for (int i = 0; i < NumDimensions(input); ++i) {
+-    input_size *= SizeOfDimension(input, i);
+-  }
+-
+-  std::vector<std::vector<std::pair<const char*, int>>> list_of_tokens;
+-  list_of_tokens.reserve(input_size);
+-  for (int i = 0; i < input_size; ++i) {
+-    list_of_tokens.emplace_back(Tokenize(GetString(input, i)));
+-  }
+-
+-  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);
+-  TF_LITE_ENSURE(context, IsDynamicTensor(output_values));
+-
+-  if (OutputIsPaddedTensor(node)) {
+-    return WritePaddedOutput(list_of_tokens, input, output_values);
+-  }
+-
+-  std::vector<TfLiteTensor*> nested_row_splits;
+-  nested_row_splits.reserve(NumDimensions(input));
+-  for (int i = 0; i < NumDimensions(input); ++i) {
+-    TfLiteTensor* output_row_splits =
+-        GetOutput(context, node, kOutputRowSplitsStart + i);
+-    nested_row_splits.push_back(output_row_splits);
+-  }
+-  return WriteRaggedOutput(list_of_tokens, input, output_values,
+-                           nested_row_splits);
+-}
+-
+-}  // namespace whitespace_tokenizer
+-
+-TfLiteRegistration* Register_tftext_WhitespaceTokenizer() {
+-  static TfLiteRegistration r = {nullptr, nullptr,
+-                                 whitespace_tokenizer::Prepare,
+-                                 whitespace_tokenizer::Eval};
+-  return &r;
+-}
+-
+-}  // namespace custom
+-}  // namespace ops
+-}  // namespace tflite
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.h b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.h
+deleted file mode 100644
+index b190248087d20..0000000000000
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.h
++++ /dev/null
+@@ -1,31 +0,0 @@
+-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
+-
+-Licensed under the Apache License, Version 2.0 (the "License");
+-you may not use this file except in compliance with the License.
+-You may obtain a copy of the License at
+-
+-    http://www.apache.org/licenses/LICENSE-2.0
+-
+-Unless required by applicable law or agreed to in writing, software
+-distributed under the License is distributed on an "AS IS" BASIS,
+-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-See the License for the specific language governing permissions and
+-limitations under the License.
+-==============================================================================*/
+-
+-#ifndef TENSORFLOW_LITE_SUPPORT_CUSTOM_OPS_KERNEL_WHITESPACE_TOKENIZER_H_
+-#define TENSORFLOW_LITE_SUPPORT_CUSTOM_OPS_KERNEL_WHITESPACE_TOKENIZER_H_
+-
+-#include "tensorflow/lite/context.h"
+-
+-namespace tflite {
+-namespace ops {
+-namespace custom {
+-
+-TfLiteRegistration* Register_tftext_WhitespaceTokenizer();
+-
+-}  // namespace custom
+-}  // namespace ops
+-}  // namespace tflite
+-
+-#endif  // TENSORFLOW_LITE_SUPPORT_CUSTOM_OPS_KERNEL_WHITESPACE_TOKENIZER_H_
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.cc b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.cc
+deleted file mode 100644
+index 534fbef4aff2d..0000000000000
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.cc
++++ /dev/null
+@@ -1,32 +0,0 @@
+-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
+-
+-Licensed under the Apache License, Version 2.0 (the "License");
+-you may not use this file except in compliance with the License.
+-You may obtain a copy of the License at
+-
+-    http://www.apache.org/licenses/LICENSE-2.0
+-
+-Unless required by applicable law or agreed to in writing, software
+-distributed under the License is distributed on an "AS IS" BASIS,
+-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-See the License for the specific language governing permissions and
+-limitations under the License.
+-==============================================================================*/
+-
+-#include "tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.h"
+-
+-#include "tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.h"
+-#include "tensorflow/lite/mutable_op_resolver.h"
+-
+-namespace tflite {
+-namespace ops {
+-namespace custom {
+-
+-void AddWhitespaceTokenizerCustomOp(MutableOpResolver* resolver) {
+-  resolver->AddCustom("tftext:WhitespaceTokenizer",
+-                      Register_tftext_WhitespaceTokenizer());
+-}
+-
+-}  // namespace custom
+-}  // namespace ops
+-}  // namespace tflite
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.h b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.h
+deleted file mode 100644
+index 4f57d8d8010cb..0000000000000
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.h
++++ /dev/null
+@@ -1,34 +0,0 @@
+-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
+-
+-Licensed under the Apache License, Version 2.0 (the "License");
+-you may not use this file except in compliance with the License.
+-You may obtain a copy of the License at
+-
+-    http://www.apache.org/licenses/LICENSE-2.0
+-
+-Unless required by applicable law or agreed to in writing, software
+-distributed under the License is distributed on an "AS IS" BASIS,
+-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-See the License for the specific language governing permissions and
+-limitations under the License.
+-==============================================================================*/
+-
+-#ifndef TENSORFLOW_LITE_SUPPORT_CUSTOM_OPS_KERNEL_WHITESPACE_TOKENIZER_OP_RESOLVER_H_
+-#define TENSORFLOW_LITE_SUPPORT_CUSTOM_OPS_KERNEL_WHITESPACE_TOKENIZER_OP_RESOLVER_H_
+-
+-#include "tensorflow/lite/mutable_op_resolver.h"
+-
+-namespace tflite {
+-namespace ops {
+-namespace custom {
+-
+-// Adds the WhitespaceTokenizer custom op to an op resolver.
+-// This function can be loaded using dlopen.  Since C++ function names get
+-// mangled, declare this function as extern C, so its name is unchanged.
+-extern "C" void AddWhitespaceTokenizerCustomOp(MutableOpResolver* resolver);
+-
+-}  // namespace custom
+-}  // namespace ops
+-}  // namespace tflite
+-
+-#endif  // LETENSORFLOW_LITE_SUPPORT_CUSTOM_OPS_KERNEL_WHITESPACE_TOKENIZER_OP_RESOLVER_H_
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver_wrapper.cc b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver_wrapper.cc
+deleted file mode 100644
+index 03d3ba899395a..0000000000000
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver_wrapper.cc
++++ /dev/null
+@@ -1,29 +0,0 @@
+-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
+-
+-Licensed under the Apache License, Version 2.0 (the "License");
+-you may not use this file except in compliance with the License.
+-You may obtain a copy of the License at
+-
+-    http://www.apache.org/licenses/LICENSE-2.0
+-
+-Unless required by applicable law or agreed to in writing, software
+-distributed under the License is distributed on an "AS IS" BASIS,
+-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-See the License for the specific language governing permissions and
+-limitations under the License.
+-==============================================================================*/
+-
+-#include "pybind11/pybind11.h"
+-#include "tensorflow/lite/mutable_op_resolver.h"
+-#include "tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_op_resolver.h"
+-
+-PYBIND11_MODULE(_pywrap_whitespace_tokenizer_op_resolver, m) {
+-  m.doc() = "_pywrap_whitespace_tokenizer_op_resolver";
+-  m.def(
+-      "AddWhitespaceTokenizerCustomOp",
+-      [](uintptr_t resolver) {
+-        tflite::ops::custom::AddWhitespaceTokenizerCustomOp(
+-            reinterpret_cast<tflite::MutableOpResolver*>(resolver));
+-      },
+-      "Op registerer function for the tftext:WhitespaceTokenizer custom op.");
+-}
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.cc
+deleted file mode 100644
+index 4654e46c4a270..0000000000000
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.cc
++++ /dev/null
+@@ -1,189 +0,0 @@
+-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
+-
+-Licensed under the Apache License, Version 2.0 (the "License");
+-you may not use this file except in compliance with the License.
+-You may obtain a copy of the License at
+-
+-    http://www.apache.org/licenses/LICENSE-2.0
+-
+-Unless required by applicable law or agreed to in writing, software
+-distributed under the License is distributed on an "AS IS" BASIS,
+-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-See the License for the specific language governing permissions and
+-limitations under the License.
+-==============================================================================*/
+-
+-#include "tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer.h"
+-
+-#include <string>
+-#include <vector>
+-
+-#include <gmock/gmock.h>
+-#include <gtest/gtest.h>
+-#include "tensorflow/lite/kernels/test_util.h"
+-#include "tensorflow/lite/schema/schema_generated.h"
+-#include "tensorflow/lite/string_util.h"
+-
+-namespace tflite {
+-namespace ops {
+-namespace custom {
+-namespace whitespace_tokenizer {
+-namespace test {
+-namespace {
+-
+-using ::testing::ElementsAre;
+-using ::testing::ElementsAreArray;
+-
+-}  // namespace
+-
+-enum OutputType { PADDED, RAGGED };
+-
+-class WhitespaceTokenizerModel : public SingleOpModel {
+- public:
+-  WhitespaceTokenizerModel(OutputType output_type,
+-                           const std::vector<std::string>& input_values,
+-                           const std::vector<int>& input_shape)
+-      : input_shape_(input_shape) {
+-    input_ = AddInput(TensorType_STRING);
+-    output_values_ = AddOutput(TensorType_STRING);
+-    if (output_type == RAGGED) {
+-      for (int i = 0; i < input_shape_.size(); ++i) {
+-        output_row_splits_.push_back(AddOutput(TensorType_INT64));
+-      }
+-    }
+-    SetCustomOp("WhitespaceTokenizer", {}, Register_tftext_WhitespaceTokenizer);
+-
+-    BuildInterpreter({input_shape});
+-    PopulateStringTensor(input_, input_values);
+-    Invoke();
+-  }
+-
+-  std::vector<int> GetValuesTensorShape() {
+-    return GetTensorShape(output_values_);
+-  }
+-
+-  std::vector<std::string> ExtractValuesTensorVector() {
+-    std::vector<std::string> r;
+-    TfLiteTensor* tensor = interpreter_->tensor(output_values_);
+-    int n = GetStringCount(tensor);
+-    for (int i = 0; i < n; ++i) {
+-      StringRef ref = GetString(tensor, i);
+-      r.emplace_back(ref.str, ref.len);
+-    }
+-    return r;
+-  }
+-
+-  void CheckRowSplits(const std::vector<int>& token_counts) {
+-    int size = 1;
+-    for (int i = 0; i < input_shape_.size(); ++i) {
+-      size *= input_shape_[i];
+-      EXPECT_THAT(GetTensorShape(output_row_splits_[i]), ElementsAre(size + 1))
+-          << "row_splits " << i << " has the wrong shape";
+-
+-      std::vector<int64_t> expected_values(size + 1);
+-      if (i == input_shape_.size() - 1) {
+-        ASSERT_EQ(token_counts.size(), size);
+-
+-        int index = 0;
+-        expected_values[0] = index;
+-        for (int j = 0; j < size; ++j) {
+-          index += token_counts[j];
+-          expected_values[j + 1] = index;
+-        }
+-      } else {
+-        for (int j = 0; j <= size; ++j) {
+-          expected_values[j] = j * input_shape_[i + 1];
+-        }
+-      }
+-      EXPECT_THAT(ExtractVector<int64_t>(output_row_splits_[i]),
+-                  ElementsAreArray(expected_values))
+-          << "row_splits " << i << " has an incorrect value/index";
+-    }
+-  }
+-
+- private:
+-  int input_;
+-  std::vector<int> input_shape_;
+-  int output_values_;
+-  std::vector<int> output_row_splits_;
+-};  // namespace test
+-
+-TEST(WhitespaceTokenizerTest, SingleStringPaddedOutput) {
+-  WhitespaceTokenizerModel m(PADDED, {"this is a test"}, {1});
+-  EXPECT_THAT(m.GetValuesTensorShape(), ElementsAre(1, 4));
+-  EXPECT_THAT(m.ExtractValuesTensorVector(),
+-              ElementsAre("this", "is", "a", "test"));
+-}
+-
+-TEST(WhitespaceTokenizerTest, SingleStringRaggedOutput) {
+-  WhitespaceTokenizerModel m(RAGGED, {"this is a test"}, {1});
+-  m.CheckRowSplits({4});
+-  EXPECT_THAT(m.ExtractValuesTensorVector(),
+-              ElementsAre("this", "is", "a", "test"));
+-}
+-
+-TEST(WhitespaceTokenizerTest, VectorPaddedOutput) {
+-  WhitespaceTokenizerModel m(PADDED,
+-                             {"this is a test",        //
+-                              "three token sentence",  //
+-                              "many more tokens than that sentence"},
+-                             {3});
+-  EXPECT_THAT(m.GetValuesTensorShape(), ElementsAre(3, 6));
+-  EXPECT_THAT(
+-      m.ExtractValuesTensorVector(),
+-      ElementsAre("this", "is", "a", "test", "", "",         //
+-                  "three", "token", "sentence", "", "", "",  //
+-                  "many", "more", "tokens", "than", "that", "sentence"));
+-}
+-
+-TEST(WhitespaceTokenizerTest, VectorRaggedOutput) {
+-  WhitespaceTokenizerModel m(RAGGED,
+-                             {"this is a test",        //
+-                              "three token sentence",  //
+-                              "many more tokens than that sentence"},
+-                             {3});
+-  m.CheckRowSplits({4, 3, 6});
+-  EXPECT_THAT(
+-      m.ExtractValuesTensorVector(),
+-      ElementsAre("this", "is", "a", "test",     //
+-                  "three", "token", "sentence",  //
+-                  "many", "more", "tokens", "than", "that", "sentence"));
+-}
+-
+-TEST(WhitespaceTokenizerTest, MatrixPaddedOutput) {
+-  WhitespaceTokenizerModel m(PADDED,
+-                             {"a b c", "d e f",  //
+-                              "g h", "i j k l",  //
+-                              "m", "n o p q r"},
+-                             {3, 2});
+-  EXPECT_THAT(m.GetValuesTensorShape(), ElementsAre(3, 2, 5));
+-  EXPECT_THAT(m.ExtractValuesTensorVector(),
+-              ElementsAre("a", "b", "c", "", "",   //
+-                          "d", "e", "f", "", "",   //
+-                          "g", "h", "", "", "",    //
+-                          "i", "j", "k", "l", "",  //
+-                          "m", "", "", "", "",     //
+-                          "n", "o", "p", "q", "r"));
+-}
+-
+-TEST(WhitespaceTokenizerTest, MatrixRAGGEDOutput) {
+-  WhitespaceTokenizerModel m(RAGGED,
+-                             {"a b c", "d e f",  //
+-                              "g h", "i j k l",  //
+-                              "m", "n o p q r"},
+-                             {3, 2});
+-  m.CheckRowSplits({3, 3, 2, 4, 1, 5});
+-  EXPECT_THAT(m.ExtractValuesTensorVector(),
+-              ElementsAre("a", "b", "c",       //
+-                          "d", "e", "f",       //
+-                          "g", "h",            //
+-                          "i", "j", "k", "l",  //
+-                          "m",                 //
+-                          "n", "o", "p", "q", "r"));
+-}
+-
+-}  // namespace test
+-}  // namespace whitespace_tokenizer
+-}  // namespace custom
+-}  // namespace ops
+-}  // namespace tflite
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.py b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.py
+deleted file mode 100644
+index 364698bdeb953..0000000000000
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/whitespace_tokenizer_test.py
++++ /dev/null
+@@ -1,166 +0,0 @@
+-# Copyright 2020 The TensorFlow Authors. All Rights Reserved.
+-#
+-# Licensed under the Apache License, Version 2.0 (the "License");
+-# you may not use this file except in compliance with the License.
+-# You may obtain a copy of the License at
+-#
+-#     http://www.apache.org/licenses/LICENSE-2.0
+-#
+-# Unless required by applicable law or agreed to in writing, software
+-# distributed under the License is distributed on an "AS IS" BASIS,
+-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-# See the License for the specific language governing permissions and
+-# limitations under the License.
+-# ==============================================================================
+-"""Tests for tensorflow_lite_support.custom_ops.kernel.whitespace_tokenizer."""
+-
+-import os
+-import sys
+-import timeit
+-
+-from absl import logging
+-from absl.testing import parameterized
+-import numpy as np
+-import tensorflow as tf
+-import tensorflow_text as tf_text
+-# pylint: disable=g-direct-tensorflow-import
+-from tensorflow.lite.python import interpreter as interpreter_wrapper
+-
+-# Force loaded shared object symbols to be globally visible. This is needed so
+-# that the interpreter_wrapper, in one .so file, can see the op resolver
+-# in a different .so file. Note that this may already be set by default.
+-# pylint: disable=g-import-not-at-top,g-bad-import-order,unused-import
+-if hasattr(sys, 'setdlopenflags') and hasattr(sys, 'getdlopenflags'):
+-  sys.setdlopenflags(sys.getdlopenflags() | os.RTLD_GLOBAL)
+-from tensorflow_lite_support.custom_ops.kernel import _pywrap_whitespace_tokenizer_op_resolver
+-
+-TEST_CASES = [
+-    ['this is a test'],
+-    ['extra   spaces    in     here'],
+-    ['a four token sentence', 'a five token sentence thing.'],
+-    [['a multi dimensional test case', 'a b c d', 'e f g'],
+-     ['h i j', 'k l m 2 3', 'n o p'], ['q r s 0 1', 't u v', 'w x y z']],
+-]
+-
+-INVOKES_FOR_SINGLE_OP_BENCHMARK = 1000
+-INVOKES_FOR_FLEX_DELEGATE_BENCHMARK = 10
+-
+-
+-@tf.function
+-def _call_whitespace_tokenizer_to_tensor(test_case):
+-  tokenizer = tf_text.WhitespaceTokenizer()
+-  return tokenizer.tokenize(test_case).to_tensor()
+-
+-
+-@tf.function
+-def _call_whitespace_tokenizer_to_ragged(test_case):
+-  tokenizer = tf_text.WhitespaceTokenizer()
+-  return tokenizer.tokenize(test_case)
+-
+-
+-class WhitespaceTokenizerTest(parameterized.TestCase):
+-
+-  @parameterized.parameters([t] for t in TEST_CASES)
+-  def testToTensorEquivalence(self, test_case):
+-    tf_output = _call_whitespace_tokenizer_to_tensor(test_case)
+-
+-    model_filename = tf.compat.v1.resource_loader.get_path_to_datafile(
+-        'testdata/whitespace_tokenizer_to_tensor.tflite')
+-    with open(model_filename, 'rb') as file:
+-      model = file.read()
+-    interpreter = interpreter_wrapper.InterpreterWithCustomOps(
+-        model_content=model,
+-        custom_op_registerers=['AddWhitespaceTokenizerCustomOp'])
+-
+-    np_test_case = np.array(test_case, dtype=str)
+-    interpreter.resize_tensor_input(0, np_test_case.shape)
+-    interpreter.allocate_tensors()
+-    interpreter.set_tensor(interpreter.get_input_details()[0]['index'],
+-                           np_test_case)
+-    interpreter.invoke()
+-    tflite_output = interpreter.get_tensor(
+-        interpreter.get_output_details()[0]['index'])
+-
+-    self.assertEqual(tf_output.numpy().tolist(), tflite_output.tolist())
+-
+-  @parameterized.parameters([t] for t in TEST_CASES)
+-  def testToRaggedEquivalence(self, test_case):
+-    tf_output = _call_whitespace_tokenizer_to_ragged(test_case)
+-
+-    np_test_case = np.array(test_case, dtype=str)
+-    rank = len(np_test_case.shape)
+-
+-    model_filename = tf.compat.v1.resource_loader.get_path_to_datafile(
+-        'testdata/whitespace_tokenizer_to_ragged_{}d_input.tflite'.format(rank))
+-    with open(model_filename, 'rb') as file:
+-      model = file.read()
+-    interpreter = interpreter_wrapper.InterpreterWithCustomOps(
+-        model_content=model,
+-        custom_op_registerers=['AddWhitespaceTokenizerCustomOp'])
+-    interpreter.resize_tensor_input(0, np_test_case.shape)
+-    interpreter.allocate_tensors()
+-    interpreter.set_tensor(interpreter.get_input_details()[0]['index'],
+-                           np_test_case)
+-    interpreter.invoke()
+-
+-    # Traverse the nested row_splits/values of the ragged tensor.
+-    for i in range(rank):
+-      tflite_output_cur_row_splits = interpreter.get_tensor(
+-          interpreter.get_output_details()[1 + i]['index'])
+-      self.assertEqual(tf_output.row_splits.numpy().tolist(),
+-                       tflite_output_cur_row_splits.tolist())
+-      tf_output = tf_output.values
+-
+-    tflite_output_values = interpreter.get_tensor(
+-        interpreter.get_output_details()[0]['index'])
+-    self.assertEqual(tf_output.numpy().tolist(), tflite_output_values.tolist())
+-
+-  def testSingleOpLatency(self):
+-    model_filename = tf.compat.v1.resource_loader.get_path_to_datafile(
+-        'testdata/whitespace_tokenizer_to_tensor.tflite')
+-    with open(model_filename, 'rb') as file:
+-      model = file.read()
+-    interpreter = interpreter_wrapper.InterpreterWithCustomOps(
+-        model_content=model,
+-        custom_op_registerers=['AddWhitespaceTokenizerCustomOp'])
+-
+-    latency = 0.0
+-    for test_case in TEST_CASES:
+-      np_test_case = np.array(test_case, dtype=str)
+-      interpreter.resize_tensor_input(0, np_test_case.shape)
+-      interpreter.allocate_tensors()
+-      interpreter.set_tensor(interpreter.get_input_details()[0]['index'],
+-                             np_test_case)
+-      start_time = timeit.default_timer()
+-      for _ in range(INVOKES_FOR_SINGLE_OP_BENCHMARK):
+-        interpreter.invoke()
+-      latency = latency + timeit.default_timer() - start_time
+-
+-    latency = latency / (INVOKES_FOR_SINGLE_OP_BENCHMARK * len(TEST_CASES))
+-    logging.info('Latency: %fms', latency * 1000.0)
+-
+-  def testFlexDelegateLatency(self):
+-    model_filename = tf.compat.v1.resource_loader.get_path_to_datafile(
+-        'testdata/whitespace_tokenizer_flex_delegate.tflite')
+-    with open(model_filename, 'rb') as file:
+-      model = file.read()
+-    interpreter = interpreter_wrapper.Interpreter(model_content=model)
+-
+-    latency = 0.0
+-    for test_case in TEST_CASES:
+-      np_test_case = np.array(test_case, dtype=str)
+-      interpreter.resize_tensor_input(0, np_test_case.shape)
+-      interpreter.allocate_tensors()
+-      interpreter.set_tensor(interpreter.get_input_details()[0]['index'],
+-                             np_test_case)
+-      start_time = timeit.default_timer()
+-      for _ in range(INVOKES_FOR_FLEX_DELEGATE_BENCHMARK):
+-        interpreter.invoke()
+-      latency = latency + timeit.default_timer() - start_time
+-
+-    latency = latency / (INVOKES_FOR_FLEX_DELEGATE_BENCHMARK * len(TEST_CASES))
+-    logging.info('Latency: %fms', latency * 1000.0)
+-
+-
+-if __name__ == '__main__':
+-  tf.test.main()
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/patches/0010-Prefix-ASSIGN_OR_RETURN-and-RETURN_IF_ERROR-macros-w.patch b/third_party/tflite_support/patches/0010-Prefix-ASSIGN_OR_RETURN-and-RETURN_IF_ERROR-macros-w.patch
new file mode 100644
index 0000000000000..56fd3828417b7
--- /dev/null
+++ b/third_party/tflite_support/patches/0010-Prefix-ASSIGN_OR_RETURN-and-RETURN_IF_ERROR-macros-w.patch
@@ -0,0 +1,3869 @@
+From a531e55610df260911dfa8038014d19dcff570d7 Mon Sep 17 00:00:00 2001
+From: Daniel Cheng <dcheng@chromium.org>
+Date: Wed, 20 Sep 2023 09:07:05 -0700
+Subject: [PATCH 10/10] Prefix ASSIGN_OR_RETURN and RETURN_IF_ERROR macros with
+ TFLITE_.
+
+Chrome's //base contains macros with the same name but with different
+definitions. Prefix the third-party ones to avoid the conflict.
+
+Change-Id: I5e4fd29433981b000555669ec3c16e8219ab44f4
+---
+ .../cc/port/default/status_macros.h           |  30 ++--
+ .../cc/port/default/tflite_wrapper.cc         |  30 ++--
+ .../cc/task/audio/audio_classifier.cc         |  12 +-
+ .../cc/task/audio/audio_embedder.cc           |  12 +-
+ .../cc/task/audio/utils/audio_utils.cc        |   2 +-
+ .../cc/task/audio/utils/wav_io.cc             |  34 ++--
+ .../cc/task/audio/utils/wav_io.h              |   2 +-
+ .../cc/task/core/base_task_api.h              |   4 +-
+ .../cc/task/core/classification_head.cc       |  14 +-
+ .../cc/task/core/external_file_handler.cc     |   2 +-
+ .../cc/task/core/score_calibration.cc         |   2 +-
+ .../cc/task/core/task_api_factory.h           |  14 +-
+ .../cc/task/core/task_utils.h                 |  10 +-
+ .../cc/task/core/tflite_engine.cc             |  12 +-
+ .../cc/task/processor/audio_preprocessor.cc   |  10 +-
+ .../cc/task/processor/bert_preprocessor.cc    |  12 +-
+ .../processor/classification_postprocessor.cc |   8 +-
+ .../processor/classification_postprocessor.h  |   4 +-
+ .../task/processor/embedding_postprocessor.cc |   4 +-
+ .../cc/task/processor/embedding_searcher.cc   |  26 +--
+ .../cc/task/processor/image_preprocessor.cc   |  12 +-
+ .../cc/task/processor/processor.h             |   2 +-
+ .../cc/task/processor/regex_preprocessor.cc   |  14 +-
+ .../cc/task/processor/search_postprocessor.cc |  16 +-
+ ...universal_sentence_encoder_preprocessor.cc |   6 +-
+ .../cc/task/text/bert_clu_annotator.cc        |  38 ++---
+ .../cc/task/text/bert_nl_classifier.cc        |  10 +-
+ .../cc/task/text/bert_question_answerer.cc    |  26 +--
+ .../cc/task/text/clu_lib/slot_repr.cc         |  12 +-
+ .../task/text/clu_lib/slot_tagging_output.cc  |   4 +-
+ .../cc/task/text/clu_lib/tflite_modules.cc    |  22 +--
+ .../task/text/nlclassifier/nl_classifier.cc   |  22 +--
+ .../cc/task/text/text_embedder.cc             |  22 +--
+ .../cc/task/text/text_searcher.cc             |  18 +-
+ .../text/universal_sentence_encoder_qa.cc     |  24 +--
+ .../task/vision/core/base_vision_task_api.h   |   2 +-
+ .../task/vision/core/classification_head.cc   |  14 +-
+ .../cc/task/vision/image_classifier.cc        |  28 ++--
+ .../cc/task/vision/image_embedder.cc          |  14 +-
+ .../cc/task/vision/image_searcher.cc          |  10 +-
+ .../cc/task/vision/image_segmenter.cc         |  30 ++--
+ .../cc/task/vision/object_detector.cc         |  54 +++---
+ .../vision/utils/frame_buffer_common_utils.cc |  10 +-
+ .../task/vision/utils/frame_buffer_utils.cc   |  16 +-
+ .../task/vision/utils/image_tensor_specs.cc   |   8 +-
+ .../cc/task/vision/utils/image_utils.cc       |   4 +-
+ .../vision/utils/libyuv_frame_buffer_utils.cc | 156 +++++++++---------
+ .../cc/task/vision/utils/score_calibration.cc |   2 +-
+ .../task/processor/embedding_searcher_test.cc |   6 +-
+ .../test/task/vision/image_classifier_test.cc |   6 +-
+ .../test/task/vision/image_segmenter_test.cc  |   8 +-
+ .../test/task/vision/object_detector_test.cc  |  14 +-
+ .../cc/text/tokenizers/tokenizer_utils.cc     |   6 +-
+ .../cc/utils/jni_utils.cc                     |   2 +-
+ .../sentencepiece_detokenizer_op.cc           |   6 +-
+ .../sentencepiece_tokenizer_op.cc             |  14 +-
+ .../audio/desktop/audio_classifier_lib.cc     |   8 +-
+ .../text/desktop/bert_nl_classifier_demo.cc   |   2 +-
+ .../desktop/bert_question_answerer_demo.cc    |   2 +-
+ .../task/text/desktop/nl_classifier_demo.cc   |   2 +-
+ .../task/text/desktop/text_embedder_demo.cc   |   8 +-
+ .../task/text/desktop/text_searcher_demo.cc   |   4 +-
+ .../vision/desktop/image_classifier_demo.cc   |   6 +-
+ .../vision/desktop/image_embedder_demo.cc     |  16 +-
+ .../vision/desktop/image_searcher_demo.cc     |   6 +-
+ .../vision/desktop/image_segmenter_demo.cc    |  12 +-
+ .../vision/desktop/object_detector_demo.cc    |  10 +-
+ .../java/src/native/task/vision/jni_utils.cc  |   2 +-
+ .../metadata/cc/metadata_extractor.cc         |  12 +-
+ .../scann_ondevice/cc/index.cc                |   4 +-
+ .../scann_ondevice/cc/index_builder.cc        |   2 +-
+ 71 files changed, 499 insertions(+), 499 deletions(-)
+
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_macros.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_macros.h
+index 8970a0e3ca3a2..14029a1f02124 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_macros.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_macros.h
+@@ -25,11 +25,11 @@ limitations under the License.
+ //
+ // For example:
+ //   absl::Status MultiStepFunction() {
+-//      RETURN_IF_ERROR(Function(args...));
+-//      RETURN_IF_ERROR(foo.Method(args...));
++//      TFLITE_RETURN_IF_ERROR(Function(args...));
++//      TFLITE_RETURN_IF_ERROR(foo.Method(args...));
+ //     return absl::OkStatus();
+ //   }
+-#define RETURN_IF_ERROR(expr)                                          \
++#define TFLITE_RETURN_IF_ERROR(expr)                                          \
+   TFLITE_STATUS_MACROS_IMPL_ELSE_BLOCKER_                              \
+   if (::tflite::support::status_macro_internal::StatusAdaptorForMacros \
+           status_macro_internal_adaptor = {(expr)}) {                  \
+@@ -49,8 +49,8 @@ limitations under the License.
+ //
+ // Interface:
+ //
+-//   ASSIGN_OR_RETURN(lhs, rexpr)
+-//   ASSIGN_OR_RETURN(lhs, rexpr, error_expression);
++//   TFLITE_ASSIGN_OR_RETURN(lhs, rexpr)
++//   TFLITE_ASSIGN_OR_RETURN(lhs, rexpr, error_expression);
+ //
+ // WARNING: if lhs is parenthesized, the parentheses are removed. See examples
+ // for more details.
+@@ -60,35 +60,35 @@ limitations under the License.
+ //
+ // Example: Declaring and initializing a new variable (ValueType can be anything
+ //          that can be initialized with assignment, including references):
+-//   ASSIGN_OR_RETURN(ValueType value, MaybeGetValue(arg));
++//   TFLITE_ASSIGN_OR_RETURN(ValueType value, MaybeGetValue(arg));
+ //
+ // Example: Assigning to an existing variable:
+ //   ValueType value;
+-//   ASSIGN_OR_RETURN(value, MaybeGetValue(arg));
++//   TFLITE_ASSIGN_OR_RETURN(value, MaybeGetValue(arg));
+ //
+ // Example: Assigning to an expression with side effects:
+ //   MyProto data;
+-//   ASSIGN_OR_RETURN(*data.mutable_str(), MaybeGetValue(arg));
++//   TFLITE_ASSIGN_OR_RETURN(*data.mutable_str(), MaybeGetValue(arg));
+ //   // No field "str" is added on error.
+ //
+ // Example: Assigning to a std::unique_ptr.
+-//   ASSIGN_OR_RETURN(std::unique_ptr<T> ptr, MaybeGetPtr(arg));
++//   TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<T> ptr, MaybeGetPtr(arg));
+ //
+ // Example: Assigning to a map. Because of C preprocessor
+ // limitation, the type used in ASSIGN_OR_RETURN cannot contain comma, so
+ // wrap lhs in parentheses:
+-//   ASSIGN_OR_RETURN((absl::flat_hash_map<Foo, Bar> my_map), GetMap());
++//   TFLITE_ASSIGN_OR_RETURN((absl::flat_hash_map<Foo, Bar> my_map), GetMap());
+ // Or use auto if the type is obvious enough:
+-//   ASSIGN_OR_RETURN(const auto& my_map, GetMapRef());
++//   TFLITE_ASSIGN_OR_RETURN(const auto& my_map, GetMapRef());
+ //
+ // Example: Assigning to structured bindings. The same situation with comma as
+ // in map, so wrap the statement in parentheses.
+-//   ASSIGN_OR_RETURN((const auto& [first, second]), GetPair());
++//   TFLITE_ASSIGN_OR_RETURN((const auto& [first, second]), GetPair());
+ 
+ #if defined(_WIN32)
+-#define ASSIGN_OR_RETURN(_1, _2, ...) TFLITE_ASSIGN_OR_RETURN_IMPL_2(_1, _2)
++#define TFLITE_ASSIGN_OR_RETURN(_1, _2, ...) TFLITE_ASSIGN_OR_RETURN_IMPL_2(_1, _2)
+ #else
+-#define ASSIGN_OR_RETURN(...)                                      \
++#define TFLITE_ASSIGN_OR_RETURN(...)                                      \
+   TFLITE_STATUS_MACROS_IMPL_GET_VARIADIC_(                         \
+       (__VA_ARGS__, TFLITE_STATUS_MACROS_IMPL_ASSIGN_OR_RETURN_3_, \
+        TFLITE_STATUS_MACROS_IMPL_ASSIGN_OR_RETURN_2_))             \
+@@ -203,7 +203,7 @@ constexpr bool TFLSHasPotentialConditionalOperator(const char* lhs, int index) {
+ // because it thinks you might want the else to bind to the first if.  This
+ // leads to problems with code like:
+ //
+-//   if (do_expr)  RETURN_IF_ERROR(expr) << "Some message";
++//   if (do_expr)  TFLITE_RETURN_IF_ERROR(expr) << "Some message";
+ //
+ // The "switch (0) case 0:" idiom is used to suppress this.
+ #define TFLITE_STATUS_MACROS_IMPL_ELSE_BLOCKER_ \
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc
+index 70fedca9a3f22..f579669e87e03 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/tflite_wrapper.cc
+@@ -82,7 +82,7 @@ absl::Status TfLiteInterpreterWrapper::InitializeWithFallback(
+           const InterpreterCreationResources& resources,
+           std::unique_ptr<tflite::Interpreter>* interpreter_out)
+           -> absl::Status {
+-        RETURN_IF_ERROR(interpreter_initializer(interpreter_out));
++        TFLITE_RETURN_IF_ERROR(interpreter_initializer(interpreter_out));
+         if (*interpreter_out != nullptr &&
+             resources.optional_delegate != nullptr) {
+           TfLiteStatus status =
+@@ -90,7 +90,7 @@ absl::Status TfLiteInterpreterWrapper::InitializeWithFallback(
+                   ->ModifyGraphWithDelegate(resources.optional_delegate);
+           if (status != kTfLiteOk) {
+             *interpreter_out = nullptr;
+-            RETURN_IF_ERROR(
++            TFLITE_RETURN_IF_ERROR(
+                 absl::InvalidArgumentError("Applying delegate failed"));
+           }
+         }
+@@ -112,7 +112,7 @@ absl::Status TfLiteInterpreterWrapper::InitializeWithFallback(
+   interpreter_initializer_ = std::move(interpreter_initializer);
+ 
+   // Sanity check and copy ComputeSettings.
+-  RETURN_IF_ERROR(SanityCheckComputeSettings(compute_settings));
++  TFLITE_RETURN_IF_ERROR(SanityCheckComputeSettings(compute_settings));
+   compute_settings_ = compute_settings;
+   if (compute_settings_.has_settings_to_test_locally()) {
+     flatbuffers::FlatBufferBuilder mini_benchmark_settings_fbb;
+@@ -174,13 +174,13 @@ absl::Status TfLiteInterpreterWrapper::InitializeWithFallbackAndResize(
+     delegate_.reset(nullptr);
+   } else {
+     // Initialize delegate and add it to 'resources'.
+-    RETURN_IF_ERROR(InitializeDelegate());
++    TFLITE_RETURN_IF_ERROR(InitializeDelegate());
+     resources.optional_delegate = delegate_.get();
+   }
+ 
+   absl::Status status = interpreter_initializer_(resources, &interpreter_);
+   if (resources.optional_delegate == nullptr) {
+-    RETURN_IF_ERROR(status);
++    TFLITE_RETURN_IF_ERROR(status);
+   }
+   if (resources.optional_delegate != nullptr && !status.ok()) {
+     // Any error when constructing the interpreter is assumed to be a delegate
+@@ -191,7 +191,7 @@ absl::Status TfLiteInterpreterWrapper::InitializeWithFallbackAndResize(
+     if (fallback_on_compilation_error_) {
+       InterpreterCreationResources fallback_resources{};
+       fallback_resources.optional_delegate = nullptr;
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           interpreter_initializer_(fallback_resources, &interpreter_));
+     } else {
+       // If instructed not to fallback, return error.
+@@ -201,7 +201,7 @@ absl::Status TfLiteInterpreterWrapper::InitializeWithFallbackAndResize(
+     }
+   }
+ 
+-  RETURN_IF_ERROR(resize(interpreter_.get()));
++  TFLITE_RETURN_IF_ERROR(resize(interpreter_.get()));
+   if (compute_settings_.tflite_settings().cpu_settings().num_threads() != -1) {
+     if (interpreter_->SetNumThreads(
+             compute_settings_.tflite_settings().cpu_settings().num_threads()) !=
+@@ -229,25 +229,25 @@ absl::Status TfLiteInterpreterWrapper::InitializeDelegate() {
+         tflite::ConvertFromProto(compute_settings_, &flatbuffers_builder_);
+ 
+     if (which_delegate == Delegate::NNAPI) {
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           LoadDelegatePlugin("Nnapi", *compute_settings->tflite_settings()));
+     } else if (which_delegate == Delegate::HEXAGON) {
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           LoadDelegatePlugin("Hexagon", *compute_settings->tflite_settings()));
+     } else if (which_delegate == Delegate::GPU) {
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           LoadDelegatePlugin("Gpu", *compute_settings->tflite_settings()));
+     } else if (which_delegate == Delegate::EDGETPU) {
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           LoadDelegatePlugin("EdgeTpu", *compute_settings->tflite_settings()));
+     } else if (which_delegate == Delegate::EDGETPU_CORAL) {
+-      RETURN_IF_ERROR(LoadDelegatePlugin("EdgeTpuCoral",
++      TFLITE_RETURN_IF_ERROR(LoadDelegatePlugin("EdgeTpuCoral",
+                                          *compute_settings->tflite_settings()));
+     } else if (which_delegate == Delegate::XNNPACK) {
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           LoadDelegatePlugin("XNNPack", *compute_settings->tflite_settings()));
+     } else if (which_delegate == Delegate::CORE_ML) {
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           LoadDelegatePlugin("CoreML", *compute_settings->tflite_settings()));
+     }
+   }
+@@ -257,7 +257,7 @@ absl::Status TfLiteInterpreterWrapper::InitializeDelegate() {
+ absl::Status TfLiteInterpreterWrapper::InvokeWithFallback(
+     const std::function<absl::Status(tflite::Interpreter* interpreter)>&
+         set_inputs) {
+-  RETURN_IF_ERROR(set_inputs(interpreter_.get()));
++  TFLITE_RETURN_IF_ERROR(set_inputs(interpreter_.get()));
+   if (cancel_flag_.Get()) {
+     cancel_flag_.Set(false);
+     return absl::CancelledError("cancelled before Invoke() was called");
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_classifier.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_classifier.cc
+index 4b1439dcc0719..995ea7b101a7b 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_classifier.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_classifier.cc
+@@ -77,16 +77,16 @@ CreatePostprocessor(TfLiteEngine* engine,
+ StatusOr<std::unique_ptr<AudioClassifier>> AudioClassifier::CreateFromOptions(
+     const AudioClassifierOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the constructed object.
+   auto options_copy = absl::make_unique<AudioClassifierOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(auto audio_classifier,
++  TFLITE_ASSIGN_OR_RETURN(auto audio_classifier,
+                    TaskAPIFactory::CreateFromBaseOptions<AudioClassifier>(
+                        &options_copy->base_options(), std::move(resolver)));
+ 
+-  RETURN_IF_ERROR(audio_classifier->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(audio_classifier->Init(std::move(options_copy)));
+ 
+   return audio_classifier;
+ }
+@@ -108,7 +108,7 @@ absl::Status AudioClassifier::Init(
+   options_ = std::move(options);
+ 
+   // Create preprocessor, assuming having only 1 input tensor.
+-  ASSIGN_OR_RETURN(preprocessor_, processor::AudioPreprocessor::Create(
++  TFLITE_ASSIGN_OR_RETURN(preprocessor_, processor::AudioPreprocessor::Create(
+                                       GetTfLiteEngine(), {0}));
+ 
+   // Assuming all output tensors share the same option. This is an limitation in
+@@ -117,7 +117,7 @@ absl::Status AudioClassifier::Init(
+       GetTfLiteEngine()->OutputCount(GetTfLiteEngine()->interpreter());
+   postprocessors_.reserve(output_count);
+   for (int i = 0; i < output_count; i++) {
+-    ASSIGN_OR_RETURN(auto processor, CreatePostprocessor(GetTfLiteEngine(), {i},
++    TFLITE_ASSIGN_OR_RETURN(auto processor, CreatePostprocessor(GetTfLiteEngine(), {i},
+                                                          options_.get()));
+     postprocessors_.emplace_back(std::move(processor));
+   }
+@@ -140,7 +140,7 @@ AudioClassifier::Postprocess(
+     // ClassificationPostprocessor doesn't set head name for backward
+     // compatibility, so we set it here manually.
+     classification->set_head_name(processor->GetHeadName());
+-    RETURN_IF_ERROR(processor->Postprocess(classification));
++    TFLITE_RETURN_IF_ERROR(processor->Postprocess(classification));
+   }
+ 
+   return result;
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_embedder.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_embedder.cc
+index 56acada352121..6c07586fd0c25 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_embedder.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/audio_embedder.cc
+@@ -37,14 +37,14 @@ tflite::support::StatusOr<double> AudioEmbedder::CosineSimilarity(
+ tflite::support::StatusOr<std::unique_ptr<AudioEmbedder>>
+ AudioEmbedder::CreateFromOptions(const AudioEmbedderOptions& options,
+                                  std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+   auto options_copy = absl::make_unique<AudioEmbedderOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(auto audio_embedder,
++  TFLITE_ASSIGN_OR_RETURN(auto audio_embedder,
+                    core::TaskAPIFactory::CreateFromBaseOptions<AudioEmbedder>(
+                        &options_copy->base_options(), std::move(resolver)));
+ 
+-  RETURN_IF_ERROR(audio_embedder->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(audio_embedder->Init(std::move(options_copy)));
+   return audio_embedder;
+ }
+ 
+@@ -65,7 +65,7 @@ absl::Status AudioEmbedder::Init(
+   options_ = std::move(options);
+ 
+   // Create preprocessor, assuming having only 1 input tensor.
+-  ASSIGN_OR_RETURN(preprocessor_,
++  TFLITE_ASSIGN_OR_RETURN(preprocessor_,
+                    tflite::task::processor::AudioPreprocessor::Create(
+                        GetTfLiteEngine(), {0}));
+ 
+@@ -95,7 +95,7 @@ absl::Status AudioEmbedder::Init(
+           "number of output tensors.",
+           support::TfLiteSupportStatus::kInvalidArgumentError);
+     }
+-    ASSIGN_OR_RETURN(auto processor,
++    TFLITE_ASSIGN_OR_RETURN(auto processor,
+                      processor::EmbeddingPostprocessor::Create(
+                          GetTfLiteEngine(), {i}, std::move(option)));
+     postprocessors_.emplace_back(std::move(processor));
+@@ -110,7 +110,7 @@ AudioEmbedder::Postprocess(
+   tflite::task::processor::EmbeddingResult result;
+   for (int i = 0; i < postprocessors_.size(); i++) {
+     auto processor = postprocessors_.at(i).get();
+-    RETURN_IF_ERROR(processor->Postprocess(result.add_embeddings()));
++    TFLITE_RETURN_IF_ERROR(processor->Postprocess(result.add_embeddings()));
+   }
+   return result;
+ }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/audio_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/audio_utils.cc
+index c1eea28f730d8..9c3df0b501b8d 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/audio_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/audio_utils.cc
+@@ -28,7 +28,7 @@ tflite::support::StatusOr<AudioBuffer> LoadAudioBufferFromFile(
+   uint16_t decoded_channel_count;
+   uint32_t decoded_sample_rate;
+ 
+-  RETURN_IF_ERROR(DecodeLin16WaveAsFloatVector(
++  TFLITE_RETURN_IF_ERROR(DecodeLin16WaveAsFloatVector(
+       contents, wav_data, offset, &decoded_sample_count, &decoded_channel_count,
+       &decoded_sample_rate));
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.cc
+index 0671bb57b123e..fcda04f29b938 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.cc
+@@ -88,7 +88,7 @@ absl::Status IncrementOffset(uint32_t old_offset, size_t increment,
+ absl::Status ExpectText(const std::string& data,
+                         const std::string& expected_text, uint32_t* offset) {
+   uint32_t new_offset;
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       IncrementOffset(*offset, expected_text.size(), data.size(), &new_offset));
+   const std::string found_text(data.begin() + *offset,
+                                data.begin() + new_offset);
+@@ -103,7 +103,7 @@ absl::Status ExpectText(const std::string& data,
+ absl::Status ReadString(const std::string& data, size_t expected_length,
+                         std::string* value, uint32_t* offset) {
+   uint32_t new_offset;
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       IncrementOffset(*offset, expected_length, data.size(), &new_offset));
+   *value = std::string(data.begin() + *offset, data.begin() + new_offset);
+   *offset = new_offset;
+@@ -116,42 +116,42 @@ absl::Status DecodeLin16WaveAsFloatVector(const std::string& wav_string,
+                                           uint32_t* sample_count,
+                                           uint16_t* channel_count,
+                                           uint32_t* sample_rate) {
+-  RETURN_IF_ERROR(ExpectText(wav_string, kRiffChunkId, offset));
++  TFLITE_RETURN_IF_ERROR(ExpectText(wav_string, kRiffChunkId, offset));
+   uint32_t total_file_size;
+-  RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &total_file_size, offset));
+-  RETURN_IF_ERROR(ExpectText(wav_string, kRiffType, offset));
+-  RETURN_IF_ERROR(ExpectText(wav_string, kFormatChunkId, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &total_file_size, offset));
++  TFLITE_RETURN_IF_ERROR(ExpectText(wav_string, kRiffType, offset));
++  TFLITE_RETURN_IF_ERROR(ExpectText(wav_string, kFormatChunkId, offset));
+   uint32_t format_chunk_size;
+-  RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &format_chunk_size, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &format_chunk_size, offset));
+   if ((format_chunk_size != 16) && (format_chunk_size != 18)) {
+     return absl::InvalidArgumentError(absl::StrFormat(
+         "Bad format chunk size for WAV: Expected 16 or 18, but got %" PRIu32,
+         format_chunk_size));
+   }
+   uint16_t audio_format;
+-  RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, &audio_format, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, &audio_format, offset));
+   if (audio_format != 1) {
+     return absl::InvalidArgumentError(absl::StrFormat(
+         "Bad audio format for WAV: Expected 1 (PCM), but got %" PRIu16,
+         audio_format));
+   }
+-  RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, channel_count, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, channel_count, offset));
+   if (*channel_count < 1) {
+     return absl::InvalidArgumentError(absl::StrFormat(
+         "Bad number of channels for WAV: Expected at least 1, but got %" PRIu16,
+         *channel_count));
+   }
+-  RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, sample_rate, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, sample_rate, offset));
+   uint32_t bytes_per_second;
+-  RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &bytes_per_second, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &bytes_per_second, offset));
+   uint16_t bytes_per_sample;
+-  RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, &bytes_per_sample, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, &bytes_per_sample, offset));
+   // Confusingly, bits per sample is defined as holding the number of bits for
+   // one channel, unlike the definition of sample used elsewhere in the WAV
+   // spec. For example, bytes per sample is the memory needed for all channels
+   // for one point in time.
+   uint16_t bits_per_sample;
+-  RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, &bits_per_sample, offset));
++  TFLITE_RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, &bits_per_sample, offset));
+   if (bits_per_sample != 16) {
+     return absl::InvalidArgumentError(
+         absl::StrFormat("Can only read 16-bit WAV files, but received %" PRIu16,
+@@ -182,9 +182,9 @@ absl::Status DecodeLin16WaveAsFloatVector(const std::string& wav_string,
+   bool was_data_found = false;
+   while (*offset < wav_string.size()) {
+     std::string chunk_id;
+-    RETURN_IF_ERROR(ReadString(wav_string, 4, &chunk_id, offset));
++    TFLITE_RETURN_IF_ERROR(ReadString(wav_string, 4, &chunk_id, offset));
+     uint32_t chunk_size;
+-    RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &chunk_size, offset));
++    TFLITE_RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &chunk_size, offset));
+     if (chunk_size > std::numeric_limits<int32_t>::max()) {
+       return absl::InvalidArgumentError(absl::StrFormat(
+           "WAV data chunk '%s' is too large: %" PRIu32
+@@ -202,12 +202,12 @@ absl::Status DecodeLin16WaveAsFloatVector(const std::string& wav_string,
+       uint32_t unused_new_offset = 0;
+       // Validate that the data exists before allocating space for it
+       // (prevent easy OOM errors).
+-      RETURN_IF_ERROR(IncrementOffset(*offset, sizeof(int16_t) * data_count,
++      TFLITE_RETURN_IF_ERROR(IncrementOffset(*offset, sizeof(int16_t) * data_count,
+                                       wav_string.size(), &unused_new_offset));
+       float_values->resize(data_count);
+       for (int i = 0; i < data_count; ++i) {
+         int16_t single_channel_value = 0;
+-        RETURN_IF_ERROR(
++        TFLITE_RETURN_IF_ERROR(
+             ReadValue<int16_t>(wav_string, &single_channel_value, offset));
+         (*float_values)[i] = Int16SampleToFloat(single_channel_value);
+       }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.h
+index fd3b779613f3d..07cb45ba39c1f 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/audio/utils/wav_io.h
+@@ -74,7 +74,7 @@ absl::Status IncrementOffset(uint32_t old_offset, size_t increment,
+ template <class T>
+ absl::Status ReadValue(const std::string& data, T* value, uint32_t* offset) {
+   uint32_t new_offset;
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       IncrementOffset(*offset, sizeof(T), data.size(), &new_offset));
+   if (port::kLittleEndian) {
+     memcpy(value, data.data() + *offset, sizeof(T));
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/base_task_api.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/base_task_api.h
+index d743383734b42..e29cef20e0f43 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/base_task_api.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/base_task_api.h
+@@ -123,7 +123,7 @@ class BaseTaskApi : public BaseUntypedTaskApi {
+         GetTfLiteEngine()->interpreter_wrapper();
+     // Note: AllocateTensors() is already performed by the interpreter wrapper
+     // at InitInterpreter time (see TfLiteEngine).
+-    RETURN_IF_ERROR(Preprocess(GetInputTensors(), args...));
++    TFLITE_RETURN_IF_ERROR(Preprocess(GetInputTensors(), args...));
+     absl::Status status = interpreter_wrapper->InvokeWithoutFallback();
+     if (!status.ok()) {
+       return status.GetPayload(tflite::support::kTfLiteSupportPayload)
+@@ -143,7 +143,7 @@ class BaseTaskApi : public BaseUntypedTaskApi {
+         GetTfLiteEngine()->interpreter_wrapper();
+     // Note: AllocateTensors() is already performed by the interpreter wrapper
+     // at InitInterpreter time (see TfLiteEngine).
+-    RETURN_IF_ERROR(Preprocess(GetInputTensors(), args...));
++    TFLITE_RETURN_IF_ERROR(Preprocess(GetInputTensors(), args...));
+     auto set_inputs_nop =
+         [](tflite::task::core::TfLiteEngine::Interpreter* interpreter)
+         -> absl::Status {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/classification_head.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/classification_head.cc
+index fe2217620be1a..1945f0172099f 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/classification_head.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/classification_head.cc
+@@ -44,7 +44,7 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+           output_tensor_metadata,
+           tflite::AssociatedFileType_TENSOR_AXIS_LABELS);
+   if (!labels_filename.empty()) {
+-    ASSIGN_OR_RETURN(absl::string_view labels_file,
++    TFLITE_ASSIGN_OR_RETURN(absl::string_view labels_file,
+                      metadata_extractor.GetAssociatedFile(labels_filename));
+     const std::string display_names_filename =
+         ModelMetadataExtractor::FindFirstAssociatedFileName(
+@@ -53,15 +53,15 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+             display_names_locale);
+     absl::string_view display_names_file;
+     if (!display_names_filename.empty()) {
+-      ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
++      TFLITE_ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
+                                                display_names_filename));
+     }
+-    ASSIGN_OR_RETURN(head.label_map_items,
++    TFLITE_ASSIGN_OR_RETURN(head.label_map_items,
+                      BuildLabelMapFromFiles(labels_file, display_names_file));
+   }
+ 
+   // Set score threshold, if present.
+-  ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_thresholding_process_unit,
++  TFLITE_ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_thresholding_process_unit,
+                    ModelMetadataExtractor::FindFirstProcessUnit(
+                        output_tensor_metadata,
+                        tflite::ProcessUnitOptions_ScoreThresholdingOptions));
+@@ -72,7 +72,7 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+   }
+ 
+   // Build score calibration parameters, if present.
+-  ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_calibration_process_unit,
++  TFLITE_ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_calibration_process_unit,
+                    ModelMetadataExtractor::FindFirstProcessUnit(
+                        output_tensor_metadata,
+                        tflite::ProcessUnitOptions_ScoreCalibrationOptions));
+@@ -95,10 +95,10 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+           "parameters file with type TENSOR_AXIS_SCORE_CALIBRATION.",
+           TfLiteSupportStatus::kMetadataAssociatedFileNotFoundError);
+     }
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         absl::string_view score_calibration_file,
+         metadata_extractor.GetAssociatedFile(score_calibration_filename));
+-    ASSIGN_OR_RETURN(SigmoidCalibrationParameters sigmoid_params,
++    TFLITE_ASSIGN_OR_RETURN(SigmoidCalibrationParameters sigmoid_params,
+                      BuildSigmoidCalibrationParams(
+                          *score_calibration_process_unit
+                               ->options_as_ScoreCalibrationOptions(),
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/external_file_handler.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/external_file_handler.cc
+index 680e65de03403..f969f4dcc05ab 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/external_file_handler.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/external_file_handler.cc
+@@ -77,7 +77,7 @@ ExternalFileHandler::CreateFromExternalFile(const ExternalFile* external_file) {
+   std::unique_ptr<ExternalFileHandler> handler =
+       absl::WrapUnique(new ExternalFileHandler(external_file));
+ 
+-  RETURN_IF_ERROR(handler->MapExternalFile());
++  TFLITE_RETURN_IF_ERROR(handler->MapExternalFile());
+ 
+   return handler;
+ }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/score_calibration.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/score_calibration.cc
+index 818839a77e43d..a7080f25780e8 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/score_calibration.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/score_calibration.cc
+@@ -211,7 +211,7 @@ StatusOr<SigmoidCalibrationParameters> BuildSigmoidCalibrationParams(
+     if (lines[i].empty()) {
+       continue;
+     }
+-    ASSIGN_OR_RETURN(Sigmoid sigmoid, SigmoidFromLabelAndLine(
++    TFLITE_ASSIGN_OR_RETURN(Sigmoid sigmoid, SigmoidFromLabelAndLine(
+                                           label_map_items[i].name, lines[i]));
+     sigmoid_vector.emplace_back(std::move(sigmoid));
+   }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_api_factory.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_api_factory.h
+index 11e0d1be54ea7..17d8d57468670 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_api_factory.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_api_factory.h
+@@ -56,7 +56,7 @@ class TaskAPIFactory {
+       const tflite::proto::ComputeSettings& compute_settings =
+           tflite::proto::ComputeSettings()) {
+     auto engine = absl::make_unique<TfLiteEngine>(std::move(resolver));
+-    RETURN_IF_ERROR(engine->BuildModelFromFlatBuffer(buffer_data, buffer_size,
++    TFLITE_RETURN_IF_ERROR(engine->BuildModelFromFlatBuffer(buffer_data, buffer_size,
+                                                      compute_settings));
+     return CreateFromTfLiteEngine<T>(std::move(engine), num_threads,
+                                      compute_settings);
+@@ -74,7 +74,7 @@ class TaskAPIFactory {
+       const tflite::proto::ComputeSettings& compute_settings =
+           tflite::proto::ComputeSettings()) {
+     auto engine = absl::make_unique<TfLiteEngine>(std::move(resolver));
+-    RETURN_IF_ERROR(engine->BuildModelFromFile(file_name, compute_settings));
++    TFLITE_RETURN_IF_ERROR(engine->BuildModelFromFile(file_name, compute_settings));
+     return CreateFromTfLiteEngine<T>(std::move(engine), num_threads,
+                                      compute_settings);
+   }
+@@ -91,7 +91,7 @@ class TaskAPIFactory {
+       const tflite::proto::ComputeSettings& compute_settings =
+           tflite::proto::ComputeSettings()) {
+     auto engine = absl::make_unique<TfLiteEngine>(std::move(resolver));
+-    RETURN_IF_ERROR(engine->BuildModelFromFileDescriptor(file_descriptor,
++    TFLITE_RETURN_IF_ERROR(engine->BuildModelFromFileDescriptor(file_descriptor,
+                                                          compute_settings));
+     return CreateFromTfLiteEngine<T>(std::move(engine), num_threads,
+                                      compute_settings);
+@@ -110,7 +110,7 @@ class TaskAPIFactory {
+           const tflite::proto::ComputeSettings& compute_settings =
+               tflite::proto::ComputeSettings()) {
+     auto engine = absl::make_unique<TfLiteEngine>(std::move(resolver));
+-    RETURN_IF_ERROR(engine->BuildModelFromExternalFileProto(external_file,
++    TFLITE_RETURN_IF_ERROR(engine->BuildModelFromExternalFileProto(external_file,
+                                                             compute_settings));
+     return CreateFromTfLiteEngine<T>(std::move(engine), num_threads,
+                                      compute_settings);
+@@ -146,10 +146,10 @@ class TaskAPIFactory {
+     tflite::proto::ComputeSettings compute_settings(
+         base_options->compute_settings());
+     if (compute_settings.has_settings_to_test_locally()) {
+-      RETURN_IF_ERROR(SetMiniBenchmarkFileNameFromBaseOptions(compute_settings,
++      TFLITE_RETURN_IF_ERROR(SetMiniBenchmarkFileNameFromBaseOptions(compute_settings,
+                                                               base_options));
+     }
+-    RETURN_IF_ERROR(engine->BuildModelFromExternalFileProto(
++    TFLITE_RETURN_IF_ERROR(engine->BuildModelFromExternalFileProto(
+         &base_options->model_file(), compute_settings));
+     return CreateFromTfLiteEngine<T>(std::move(engine), compute_settings);
+   }
+@@ -173,7 +173,7 @@ class TaskAPIFactory {
+       std::unique_ptr<TfLiteEngine> engine,
+       const tflite::proto::ComputeSettings& compute_settings =
+           tflite::proto::ComputeSettings()) {
+-    RETURN_IF_ERROR(engine->InitInterpreter(compute_settings));
++    TFLITE_RETURN_IF_ERROR(engine->InitInterpreter(compute_settings));
+     return absl::make_unique<T>(std::move(engine));
+   }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_utils.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_utils.h
+index 08b79b8dba5f2..a722c091651fc 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_utils.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/task_utils.h
+@@ -71,7 +71,7 @@ template <typename T, typename = std::enable_if_t<
+ inline absl::Status PopulateTensor(const T* data, int num_elements,
+                                    TfLiteTensor* tensor) {
+   T* v;
+-  ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
++  TFLITE_ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
+   size_t bytes = num_elements * sizeof(T);
+   if (tensor->bytes != bytes) {
+     return tflite::support::CreateStatusWithPayload(
+@@ -113,7 +113,7 @@ inline absl::Status PopulateTensor<std::string>(
+ template <typename T>
+ inline absl::Status PopulateTensor(const T& data, TfLiteTensor* tensor) {
+   T* v;
+-  ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
++  TFLITE_ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
+   *v = data;
+   return absl::OkStatus();
+ }
+@@ -133,7 +133,7 @@ template <typename T>
+ inline absl::Status PopulateVector(const TfLiteTensor* tensor,
+                                    std::vector<T>* data) {
+   const T* v;
+-  ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
++  TFLITE_ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
+   size_t num = tensor->bytes / sizeof(tensor->type);
+   data->reserve(num);
+   for (size_t i = 0; i < num; i++) {
+@@ -146,7 +146,7 @@ template <>
+ inline absl::Status PopulateVector<std::string>(
+     const TfLiteTensor* tensor, std::vector<std::string>* data) {
+   std::string* v;
+-  ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<std::string>(tensor));
++  TFLITE_ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<std::string>(tensor));
+   (void)v;
+   int num = GetStringCount(tensor);
+   data->reserve(num);
+@@ -166,7 +166,7 @@ template <
+ inline absl::Status PopulateVectorToRepeated(const TfLiteTensor* tensor,
+                                              TRepeatedField* data) {
+   const T* v;
+-  ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
++  TFLITE_ASSIGN_OR_RETURN(v, AssertAndReturnTypedTensor<T>(tensor));
+   size_t num = tensor->bytes / sizeof(tensor->type);
+   data->Resize(num, T());
+   T* pdata = data->mutable_data();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc
+index 0b9af59afdc79..44421ea1df463 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/core/tflite_engine.cc
+@@ -111,7 +111,7 @@ absl::Status TfLiteEngine::InitializeFromModelFileHandler(
+     }
+   }
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       model_metadata_extractor_,
+       tflite::metadata::ModelMetadataExtractor::CreateFromModelBuffer(
+           buffer_data, buffer_size));
+@@ -128,7 +128,7 @@ absl::Status TfLiteEngine::BuildModelFromFlatBuffer(
+   }
+   external_file_ = std::make_unique<ExternalFile>();
+   external_file_->set_file_content(std::string(buffer_data, buffer_size));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       model_file_handler_,
+       ExternalFileHandler::CreateFromExternalFile(external_file_.get()));
+   return InitializeFromModelFileHandler(compute_settings);
+@@ -145,7 +145,7 @@ absl::Status TfLiteEngine::BuildModelFromFile(
+     external_file_ = std::make_unique<ExternalFile>();
+   }
+   external_file_->set_file_name(file_name);
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       model_file_handler_,
+       ExternalFileHandler::CreateFromExternalFile(external_file_.get()));
+   return InitializeFromModelFileHandler(compute_settings);
+@@ -162,7 +162,7 @@ absl::Status TfLiteEngine::BuildModelFromFileDescriptor(
+     external_file_ = std::make_unique<ExternalFile>();
+   }
+   external_file_->mutable_file_descriptor_meta()->set_fd(file_descriptor);
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       model_file_handler_,
+       ExternalFileHandler::CreateFromExternalFile(external_file_.get()));
+   return InitializeFromModelFileHandler(compute_settings);
+@@ -175,7 +175,7 @@ absl::Status TfLiteEngine::BuildModelFromExternalFileProto(
+     return CreateStatusWithPayload(StatusCode::kInternal,
+                                    "Model already built");
+   }
+-  ASSIGN_OR_RETURN(model_file_handler_,
++  TFLITE_ASSIGN_OR_RETURN(model_file_handler_,
+                    ExternalFileHandler::CreateFromExternalFile(external_file));
+   return InitializeFromModelFileHandler(compute_settings);
+ }
+@@ -187,7 +187,7 @@ absl::Status TfLiteEngine::BuildModelFromExternalFileProto(
+                                    "Model already built");
+   }
+   external_file_ = std::move(external_file);
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       model_file_handler_,
+       ExternalFileHandler::CreateFromExternalFile(external_file_.get()));
+   // Dummy proto. InitializeFromModelFileHandler doesn't use this proto.
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/audio_preprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/audio_preprocessor.cc
+index e3ea2b134e3f4..4eaee87081750 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/audio_preprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/audio_preprocessor.cc
+@@ -74,22 +74,22 @@ tflite::support::StatusOr<const AudioProperties*> GetAudioPropertiesSafe(
+ tflite::support::StatusOr<std::unique_ptr<AudioPreprocessor>>
+ AudioPreprocessor::Create(tflite::task::core::TfLiteEngine* engine,
+                           const std::initializer_list<int> input_indices) {
+-  ASSIGN_OR_RETURN(auto processor,
++  TFLITE_ASSIGN_OR_RETURN(auto processor,
+                    Processor::Create<AudioPreprocessor>(
+                        /* num_expected_tensors = */ 1, engine, input_indices));
+ 
+-  RETURN_IF_ERROR(processor->Init());
++  TFLITE_RETURN_IF_ERROR(processor->Init());
+   return processor;
+ }
+ 
+ absl::Status AudioPreprocessor::Init() {
+-  RETURN_IF_ERROR(SetAudioFormatFromMetadata());
+-  RETURN_IF_ERROR(CheckAndSetInputs());
++  TFLITE_RETURN_IF_ERROR(SetAudioFormatFromMetadata());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetInputs());
+   return absl::OkStatus();
+ }
+ 
+ absl::Status AudioPreprocessor::SetAudioFormatFromMetadata() {
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const AudioProperties* props,
+       GetAudioPropertiesSafe(GetTensorMetadata(), tensor_indices_.at(0)));
+   audio_format_.channels = props->channels();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/bert_preprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/bert_preprocessor.cc
+index 76a7a534a27bd..62d5382fe5a17 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/bert_preprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/bert_preprocessor.cc
+@@ -44,11 +44,11 @@ constexpr char kSeparator[] = "[SEP]";
+ StatusOr<std::unique_ptr<BertPreprocessor>> BertPreprocessor::Create(
+     tflite::task::core::TfLiteEngine* engine,
+     const std::initializer_list<int> input_tensor_indices) {
+-  ASSIGN_OR_RETURN(auto processor, Processor::Create<BertPreprocessor>(
++  TFLITE_ASSIGN_OR_RETURN(auto processor, Processor::Create<BertPreprocessor>(
+                                        /* num_expected_tensors = */ 3, engine,
+                                        input_tensor_indices,
+                                        /* requires_metadata = */ false));
+-  RETURN_IF_ERROR(processor->Init());
++  TFLITE_RETURN_IF_ERROR(processor->Init());
+   return processor;
+ }
+ 
+@@ -58,7 +58,7 @@ absl::Status BertPreprocessor::Init() {
+   // BertTokenizer is packed in the processing unit SubgraphMetadata.
+   const tflite::ProcessUnit* tokenizer_metadata =
+       GetMetadataExtractor()->GetInputProcessUnit(kTokenizerProcessUnitIndex);
+-  ASSIGN_OR_RETURN(tokenizer_, CreateTokenizerFromProcessUnit(
++  TFLITE_ASSIGN_OR_RETURN(tokenizer_, CreateTokenizerFromProcessUnit(
+                                    tokenizer_metadata, GetMetadataExtractor()));
+ 
+   const auto& ids_tensor = *GetTensor(kIdsTensorIndex);
+@@ -178,9 +178,9 @@ absl::Status BertPreprocessor::Preprocess(const std::string& input_text) {
+   // input_masks                 1    1   1...  1    1    0  0...  0
+   // segment_ids                 0    0   0...  0    0    0  0...  0
+ 
+-  RETURN_IF_ERROR(PopulateTensor(input_ids, ids_tensor));
+-  RETURN_IF_ERROR(PopulateTensor(input_mask, mask_tensor));
+-  RETURN_IF_ERROR(PopulateTensor(std::vector<int>(input_tensor_length, 0),
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(input_ids, ids_tensor));
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(input_mask, mask_tensor));
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(std::vector<int>(input_tensor_length, 0),
+                                  segment_ids_tensor));
+   return absl::OkStatus();
+ }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.cc
+index 9c11083c4f839..393992056faad 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.cc
+@@ -44,11 +44,11 @@ tflite::support::StatusOr<std::unique_ptr<ClassificationPostprocessor>>
+ ClassificationPostprocessor::Create(
+     core::TfLiteEngine* engine, const std::initializer_list<int> output_indices,
+     std::unique_ptr<ClassificationOptions> options) {
+-  ASSIGN_OR_RETURN(auto processor,
++  TFLITE_ASSIGN_OR_RETURN(auto processor,
+                    Processor::Create<ClassificationPostprocessor>(
+                        /* num_expected_tensors = */ 1, engine, output_indices));
+ 
+-  RETURN_IF_ERROR(processor->Init(std::move(options)));
++  TFLITE_RETURN_IF_ERROR(processor->Init(std::move(options)));
+   return processor;
+ }
+ 
+@@ -70,7 +70,7 @@ absl::Status ClassificationPostprocessor::Init(
+         TfLiteSupportStatus::kInvalidArgumentError);
+   }
+ 
+-  ASSIGN_OR_RETURN(classification_head_,
++  TFLITE_ASSIGN_OR_RETURN(classification_head_,
+                    BuildClassificationHead(*engine_->metadata_extractor(),
+                                            *GetTensorMetadata(),
+                                            options->display_names_locale()));
+@@ -199,7 +199,7 @@ absl::Status ClassificationPostprocessor::Init(
+           StatusCode::kInternal, "Could not create score calibration object.");
+     }
+ 
+-    RETURN_IF_ERROR(score_calibration_->InitializeFromParameters(
++    TFLITE_RETURN_IF_ERROR(score_calibration_->InitializeFromParameters(
+         classification_head_.calibration_params.value()));
+   }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.h
+index 517974c7370ea..c51812472c9c8 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/classification_postprocessor.h
+@@ -107,7 +107,7 @@ absl::Status ClassificationPostprocessor::Postprocess(T* classifications) {
+ 
+   const TfLiteTensor* output_tensor = GetTensor();
+   if (output_tensor->type == kTfLiteUInt8) {
+-    ASSIGN_OR_RETURN(const uint8* output_data,
++    TFLITE_ASSIGN_OR_RETURN(const uint8* output_data,
+                      core::AssertAndReturnTypedTensor<uint8>(output_tensor));
+     for (int j = 0; j < head.label_map_items.size(); ++j) {
+       score_pairs.emplace_back(
+@@ -115,7 +115,7 @@ absl::Status ClassificationPostprocessor::Postprocess(T* classifications) {
+                                             output_tensor->params.zero_point));
+     }
+   } else {
+-    ASSIGN_OR_RETURN(const float* output_data,
++    TFLITE_ASSIGN_OR_RETURN(const float* output_data,
+                      core::AssertAndReturnTypedTensor<float>(output_tensor));
+     for (int j = 0; j < head.label_map_items.size(); ++j) {
+       score_pairs.emplace_back(j, output_data[j]);
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_postprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_postprocessor.cc
+index 83b123fd5c873..8e4ad06902da8 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_postprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_postprocessor.cc
+@@ -24,12 +24,12 @@ tflite::support::StatusOr<std::unique_ptr<EmbeddingPostprocessor>>
+ EmbeddingPostprocessor::Create(core::TfLiteEngine* engine,
+                                const std::initializer_list<int> output_indices,
+                                std::unique_ptr<EmbeddingOptions> options) {
+-  ASSIGN_OR_RETURN(auto processor,
++  TFLITE_ASSIGN_OR_RETURN(auto processor,
+                    Processor::Create<EmbeddingPostprocessor>(
+                        /* num_expected_tensors = */ 1, engine, output_indices,
+                        /* requires_metadata = */ false));
+ 
+-  RETURN_IF_ERROR(processor->Init(std::move(options)));
++  TFLITE_RETURN_IF_ERROR(processor->Init(std::move(options)));
+   return processor;
+ }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_searcher.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_searcher.cc
+index 274d6ae8658b5..c9de0bcfaa990 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_searcher.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/embedding_searcher.cc
+@@ -176,7 +176,7 @@ StatusOr<std::unique_ptr<EmbeddingSearcher>> EmbeddingSearcher::Create(
+     std::optional<absl::string_view> optional_index_file_content) {
+   auto embedding_searcher = std::make_unique<EmbeddingSearcher>();
+ 
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       embedding_searcher->Init(
+           std::move(search_options), optional_index_file_content));
+   return embedding_searcher;
+@@ -185,7 +185,7 @@ StatusOr<std::unique_ptr<EmbeddingSearcher>> EmbeddingSearcher::Create(
+ StatusOr<SearchResult> EmbeddingSearcher::Search(const Embedding& embedding) {
+   // Convert embedding to Eigen matrix, as expected by ScaNN.
+   Eigen::MatrixXf query;
+-  RETURN_IF_ERROR(ConvertEmbeddingToEigenMatrix(embedding, &query));
++  TFLITE_RETURN_IF_ERROR(ConvertEmbeddingToEigenMatrix(embedding, &query));
+ 
+   // Identify partitions to search.
+   std::vector<std::vector<int>> leaves_to_search(
+@@ -203,10 +203,10 @@ StatusOr<SearchResult> EmbeddingSearcher::Search(const Embedding& embedding) {
+       std::make_pair(std::numeric_limits<float>::max(), kNoNeighborId));
+   // Perform search.
+   if (quantizer_) {
+-    RETURN_IF_ERROR(
++    TFLITE_RETURN_IF_ERROR(
+         QuantizedSearch(query, leaves_to_search[0], absl::MakeSpan(top_n)));
+   } else {
+-    RETURN_IF_ERROR(
++    TFLITE_RETURN_IF_ERROR(
+         LinearSearch(query, leaves_to_search[0], absl::MakeSpan(top_n)));
+   }
+ 
+@@ -216,7 +216,7 @@ StatusOr<SearchResult> EmbeddingSearcher::Search(const Embedding& embedding) {
+     if (id == kNoNeighborId) {
+       break;
+     }
+-    ASSIGN_OR_RETURN(auto metadata, index_->GetMetadataAtIndex(id));
++    TFLITE_ASSIGN_OR_RETURN(auto metadata, index_->GetMetadataAtIndex(id));
+     NearestNeighbor* nearest_neighbor = search_result.add_nearest_neighbors();
+     nearest_neighbor->set_distance(distance);
+     nearest_neighbor->set_metadata(std::string(metadata));
+@@ -231,13 +231,13 @@ StatusOr<absl::string_view> EmbeddingSearcher::GetUserInfo() {
+ absl::Status EmbeddingSearcher::Init(
+     std::unique_ptr<SearchOptions> options,
+     std::optional<absl::string_view> optional_index_file_content) {
+-  RETURN_IF_ERROR(SanityCheckOptions(*options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(*options));
+   options_ = std::move(options);
+ 
+   // Initialize index.
+   absl::string_view index_file_content;
+   if (options_->has_index_file()) {
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         index_file_handler_,
+         ExternalFileHandler::CreateFromExternalFile(&options_->index_file()));
+     index_file_content = index_file_handler_->GetFileContent();
+@@ -251,13 +251,13 @@ absl::Status EmbeddingSearcher::Init(
+     }
+     index_file_content = *optional_index_file_content;
+   }
+-  ASSIGN_OR_RETURN(index_,
++  TFLITE_ASSIGN_OR_RETURN(index_,
+                    Index::CreateFromIndexBuffer(index_file_content.data(),
+                                                 index_file_content.size()));
+-  ASSIGN_OR_RETURN(index_config_, index_->GetIndexConfig());
+-  RETURN_IF_ERROR(SanityCheckIndexConfig(index_config_));
++  TFLITE_ASSIGN_OR_RETURN(index_config_, index_->GetIndexConfig());
++  TFLITE_RETURN_IF_ERROR(SanityCheckIndexConfig(index_config_));
+   // Get distance measure once and for all.
+-  ASSIGN_OR_RETURN(distance_measure_,
++  TFLITE_ASSIGN_OR_RETURN(distance_measure_,
+                    GetDistanceMeasure(index_config_.scann_config()));
+ 
+   // Initialize partitioner.
+@@ -296,7 +296,7 @@ absl::Status EmbeddingSearcher::QuantizedSearch(
+   }
+   for (int leaf_id : leaves_to_search) {
+     // Load partition into Eigen matrix.
+-    ASSIGN_OR_RETURN(auto partition, index_->GetPartitionAtIndex(leaf_id));
++    TFLITE_ASSIGN_OR_RETURN(auto partition, index_->GetPartitionAtIndex(leaf_id));
+     int partition_size = partition.size() / dim;
+     Eigen::Map<const Matrix8u> database(
+         reinterpret_cast<const uint8_t*>(partition.data()), dim,
+@@ -319,7 +319,7 @@ absl::Status EmbeddingSearcher::LinearSearch(Eigen::Ref<Eigen::MatrixXf> query,
+   int dim = index_config_.embedding_dim();
+   for (int leaf_id : leaves_to_search) {
+     // Load partition into Eigen matrix.
+-    ASSIGN_OR_RETURN(auto partition, index_->GetPartitionAtIndex(leaf_id));
++    TFLITE_ASSIGN_OR_RETURN(auto partition, index_->GetPartitionAtIndex(leaf_id));
+     int partition_size = partition.size() / (dim * sizeof(float));
+     Eigen::Map<const Eigen::MatrixXf> database(
+         reinterpret_cast<const float*>(partition.data()), dim, partition_size);
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/image_preprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/image_preprocessor.cc
+index 7ad4ad4703789..05a6df3f1a380 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/image_preprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/image_preprocessor.cc
+@@ -38,12 +38,12 @@ tflite::support::StatusOr<std::unique_ptr<ImagePreprocessor>>
+ ImagePreprocessor::Create(
+     core::TfLiteEngine* engine, const std::initializer_list<int> input_indices,
+     const vision::FrameBufferUtils::ProcessEngine& process_engine) {
+-  ASSIGN_OR_RETURN(auto processor,
++  TFLITE_ASSIGN_OR_RETURN(auto processor,
+                    Processor::Create<ImagePreprocessor>(
+                        /* num_expected_tensors = */ 1, engine, input_indices,
+                        /* requires_metadata = */ false));
+ 
+-  RETURN_IF_ERROR(processor->Init(process_engine));
++  TFLITE_RETURN_IF_ERROR(processor->Init(process_engine));
+   return processor;
+ }
+ 
+@@ -72,7 +72,7 @@ absl::Status ImagePreprocessor::Init(
+     const vision::FrameBufferUtils::ProcessEngine& process_engine) {
+   frame_buffer_utils_ = vision::FrameBufferUtils::Create(process_engine);
+ 
+-  ASSIGN_OR_RETURN(input_specs_, vision::BuildInputImageTensorSpecs(
++  TFLITE_ASSIGN_OR_RETURN(input_specs_, vision::BuildInputImageTensorSpecs(
+                                      *engine_->interpreter(),
+                                      *engine_->metadata_extractor()));
+ 
+@@ -137,7 +137,7 @@ absl::Status ImagePreprocessor::Preprocess(const FrameBuffer& frame_buffer,
+         {preprocessed_plane}, to_buffer_dimension, FrameBuffer::Format::kRGB,
+         FrameBuffer::Orientation::kTopLeft);
+ 
+-    RETURN_IF_ERROR(frame_buffer_utils_->Preprocess(
++    TFLITE_RETURN_IF_ERROR(frame_buffer_utils_->Preprocess(
+         frame_buffer, roi, preprocessed_frame_buffer.get()));
+   } else {
+     // Input frame buffer already targets model requirements: skip image
+@@ -165,7 +165,7 @@ absl::Status ImagePreprocessor::Preprocess(const FrameBuffer& frame_buffer,
+             "and input tensor.");
+       }
+       // No normalization required: directly populate data.
+-      RETURN_IF_ERROR(tflite::task::core::PopulateTensor(
++      TFLITE_RETURN_IF_ERROR(tflite::task::core::PopulateTensor(
+           input_data, input_data_byte_size / sizeof(uint8), GetTensor()));
+       break;
+     case kTfLiteFloat32: {
+@@ -177,7 +177,7 @@ absl::Status ImagePreprocessor::Preprocess(const FrameBuffer& frame_buffer,
+             "and input tensor.");
+       }
+       // Normalize and populate.
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           float* normalized_input_data,
+           tflite::task::core::AssertAndReturnTypedTensor<float>(GetTensor()));
+       const tflite::task::vision::NormalizationOptions& normalization_options =
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/processor.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/processor.h
+index e7417ba65bf09..7f76bec5c0f18 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/processor.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/processor.h
+@@ -56,7 +56,7 @@ class Processor {
+       const std::initializer_list<int> tensor_indices,
+       bool requires_metadata = true) {
+     auto processor = absl::make_unique<T>(engine, tensor_indices);
+-    RETURN_IF_ERROR(
++    TFLITE_RETURN_IF_ERROR(
+         processor->SanityCheck(num_expected_tensors, requires_metadata));
+     return processor;
+   }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/regex_preprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/regex_preprocessor.cc
+index af923b4d6f2c1..758514ca3ed6e 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/regex_preprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/regex_preprocessor.cc
+@@ -45,7 +45,7 @@ StatusOr<absl::string_view> CheckAndLoadFirstAssociatedFile(
+         "Invalid vocab_file from input process unit.",
+         TfLiteSupportStatus::kMetadataInvalidTokenizerError);
+   }
+-  ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
++  TFLITE_ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
+                    metadata_extractor->GetAssociatedFile(
+                        associated_files->Get(0)->name()->str()));
+   return vocab_buffer;
+@@ -56,11 +56,11 @@ StatusOr<absl::string_view> CheckAndLoadFirstAssociatedFile(
+ /* static */
+ StatusOr<std::unique_ptr<RegexPreprocessor>> RegexPreprocessor::Create(
+     tflite::task::core::TfLiteEngine* engine, int input_tensor_index) {
+-  ASSIGN_OR_RETURN(auto processor, Processor::Create<RegexPreprocessor>(
++  TFLITE_ASSIGN_OR_RETURN(auto processor, Processor::Create<RegexPreprocessor>(
+                                        /* num_expected_tensors = */ 1, engine,
+                                        {input_tensor_index},
+                                        /* requires_metadata = */ false));
+-  RETURN_IF_ERROR(processor->Init());
++  TFLITE_RETURN_IF_ERROR(processor->Init());
+   return processor;
+ }
+ 
+@@ -70,10 +70,10 @@ absl::Status RegexPreprocessor::Init() {
+     return absl::OkStatus();
+   }
+   // Try if RegexTokenzier metadata can be found.
+-  ASSIGN_OR_RETURN(const auto tokenzier_metadata,
++  TFLITE_ASSIGN_OR_RETURN(const auto tokenzier_metadata,
+                    TryFindRegexTokenizerMetadata());
+ 
+-  ASSIGN_OR_RETURN(tokenizer_, CreateTokenizerFromMetadata(
++  TFLITE_ASSIGN_OR_RETURN(tokenizer_, CreateTokenizerFromMetadata(
+                                    tokenzier_metadata, GetMetadataExtractor()));
+   return absl::OkStatus();
+ }
+@@ -86,7 +86,7 @@ RegexPreprocessor::TryFindRegexTokenizerMetadata() {
+     return nullptr;
+   }
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto tokenizer_metadata,
+       GetMetadataExtractor()->FindFirstProcessUnit(
+           *tensor_metadata, ProcessUnitOptions_RegexTokenizerOptions));
+@@ -120,7 +120,7 @@ RegexPreprocessor::CreateTokenizerFromMetadata(
+       ProcessUnitOptions_RegexTokenizerOptions) {
+     const tflite::RegexTokenizerOptions* options =
+         tokenizer_metadata->options_as<RegexTokenizerOptions>();
+-    ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
++    TFLITE_ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
+                      CheckAndLoadFirstAssociatedFile(options->vocab_file(),
+                                                      metadata_extractor));
+     if (options->delim_regex_pattern() == nullptr) {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc
+index fb34eea170ad8..e78351787229f 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc
+@@ -91,16 +91,16 @@ StatusOr<std::unique_ptr<SearchPostprocessor>> SearchPostprocessor::Create(
+     TfLiteEngine* engine, int output_index,
+     std::unique_ptr<SearchOptions> search_options,
+     std::unique_ptr<EmbeddingOptions> embedding_options) {
+-  ASSIGN_OR_RETURN(auto embedding_postprocessor,
++  TFLITE_ASSIGN_OR_RETURN(auto embedding_postprocessor,
+                    CreateEmbeddingPostprocessor(engine, {output_index},
+                                                 std::move(embedding_options)));
+ 
+-  ASSIGN_OR_RETURN(auto search_processor,
++  TFLITE_ASSIGN_OR_RETURN(auto search_processor,
+                    Processor::Create<SearchPostprocessor>(
+                        /* num_expected_tensors =*/1, engine, {output_index},
+                        /* requires_metadata =*/false));
+ 
+-  RETURN_IF_ERROR(search_processor->Init(std::move(embedding_postprocessor),
++  TFLITE_RETURN_IF_ERROR(search_processor->Init(std::move(embedding_postprocessor),
+                                          std::move(search_options)));
+   return search_processor;
+ }
+@@ -108,10 +108,10 @@ StatusOr<std::unique_ptr<SearchPostprocessor>> SearchPostprocessor::Create(
+ StatusOr<SearchResult> SearchPostprocessor::Postprocess() {
+   // Extract embedding.
+   Embedding embedding;
+-  RETURN_IF_ERROR(embedding_postprocessor_->Postprocess(&embedding));
++  TFLITE_RETURN_IF_ERROR(embedding_postprocessor_->Postprocess(&embedding));
+ 
+   // Search the nearest-neighbor embedding.
+-  ASSIGN_OR_RETURN(SearchResult search_result,
++  TFLITE_ASSIGN_OR_RETURN(SearchResult search_result,
+                    embedding_searcher_->Search(embedding));
+   return search_result;
+ }
+@@ -126,14 +126,14 @@ absl::Status SearchPostprocessor::Init(
+   embedding_postprocessor_ = std::move(embedding_postprocessor);
+ 
+   if (options->has_index_file()) {
+-    ASSIGN_OR_RETURN(embedding_searcher_,
++    TFLITE_ASSIGN_OR_RETURN(embedding_searcher_,
+                      EmbeddingSearcher::Create(std::move(options)));
+   } else {
+     // Index File is expected in the metadata if not provided in the options.
+-    ASSIGN_OR_RETURN(absl::string_view index_file_content,
++    TFLITE_ASSIGN_OR_RETURN(absl::string_view index_file_content,
+                      GetIndexFileContentFromMetadata(*GetMetadataExtractor(),
+                                                      *GetTensorMetadata()));
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         embedding_searcher_,
+         EmbeddingSearcher::Create(std::move(options), index_file_content));
+   }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/universal_sentence_encoder_preprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/universal_sentence_encoder_preprocessor.cc
+index 54dc738e3ab26..7620ef6ce3041 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/universal_sentence_encoder_preprocessor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/universal_sentence_encoder_preprocessor.cc
+@@ -55,10 +55,10 @@ absl::Status UniversalSentenceEncoderPreprocessor::Preprocess(
+     const std::string& text) {
+   // All input tensors must be populated, even though we're only using the
+   // response text input tensor.
+-  RETURN_IF_ERROR(PopulateTensor(std::string(""), GetTensor(kQueryTextIndex)));
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(std::string(""), GetTensor(kQueryTextIndex)));
++  TFLITE_RETURN_IF_ERROR(
+       PopulateTensor(std::string(""), GetTensor(kResponseContextIndex)));
+-  RETURN_IF_ERROR(PopulateTensor(text, GetTensor(kResponseTextIndex)));
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(text, GetTensor(kResponseTextIndex)));
+   return absl::OkStatus();
+ }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_clu_annotator.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_clu_annotator.cc
+index f60a556dbbe1b..71068366d96f5 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_clu_annotator.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_clu_annotator.cc
+@@ -76,17 +76,17 @@ absl::StatusOr<int> FindTensorIdxByName(
+ BertCluAnnotator::CreateFromOptions(
+     const BertCluAnnotatorOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the duration of this
+   // created BertCluAnnotator object.
+   auto options_copy = std::make_unique<BertCluAnnotatorOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto bert_clu_annotator,
+       core::TaskAPIFactory::CreateFromBaseOptions<BertCluAnnotator>(
+           &options_copy->base_options(), std::move(resolver)));
+-  RETURN_IF_ERROR(bert_clu_annotator->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(bert_clu_annotator->Init(std::move(options_copy)));
+   return std::move(bert_clu_annotator);
+ }
+ 
+@@ -102,7 +102,7 @@ absl::Status BertCluAnnotator::Init(
+         "No input process unit found from metadata.",
+         support::TfLiteSupportStatus::kMetadataInvalidTokenizerError);
+   }
+-  ASSIGN_OR_RETURN(tokenizer_,
++  TFLITE_ASSIGN_OR_RETURN(tokenizer_,
+                    support::text::tokenizer::CreateTokenizerFromProcessUnit(
+                        tokenizer_process_unit, GetMetadataExtractor()));
+ 
+@@ -116,31 +116,31 @@ absl::Status BertCluAnnotator::Init(
+ 
+   tensor_index_map_ = std::make_unique<TensorIndexMap>();
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       tensor_index_map_->token_id_idx,
+       FindTensorIdxByName(input_tensors_metadata, kTokenIdTensorName));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       tensor_index_map_->token_mask_idx,
+       FindTensorIdxByName(input_tensors_metadata, kMaskTensorName));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       tensor_index_map_->token_type_id_idx,
+       FindTensorIdxByName(input_tensors_metadata, kTokenTypeIdTensorName));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       tensor_index_map_->domain_names_idx,
+       FindTensorIdxByName(output_tensors_metadata, kDomainTaskNamesTensorName));
+-  ASSIGN_OR_RETURN(tensor_index_map_->domain_scores_idx,
++  TFLITE_ASSIGN_OR_RETURN(tensor_index_map_->domain_scores_idx,
+                    FindTensorIdxByName(output_tensors_metadata,
+                                        kDomainTaskScoresTensorName));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       tensor_index_map_->intent_names_idx,
+       FindTensorIdxByName(output_tensors_metadata, kIntentTaskNamesTensorName));
+-  ASSIGN_OR_RETURN(tensor_index_map_->intent_scores_idx,
++  TFLITE_ASSIGN_OR_RETURN(tensor_index_map_->intent_scores_idx,
+                    FindTensorIdxByName(output_tensors_metadata,
+                                        kIntentTaskScoresTensorName));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       tensor_index_map_->slot_names_idx,
+       FindTensorIdxByName(output_tensors_metadata, kSlotTaskNamesTensorName));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       tensor_index_map_->slot_scores_idx,
+       FindTensorIdxByName(output_tensors_metadata, kSlotTaskScoresTensorName));
+ 
+@@ -150,21 +150,21 @@ absl::Status BertCluAnnotator::Init(
+       interpreter, tensor_index_map_.get(), options_.get(),
+       static_cast<tflite::support::text::tokenizer::BertTokenizer*>(
+           tokenizer_.get()));
+-  RETURN_IF_ERROR(m.status());
++  TFLITE_RETURN_IF_ERROR(m.status());
+   modules_.emplace_back(*std::move(m));
+   // DomainModule.
+   m = DomainModule::Create(interpreter, tensor_index_map_.get(),
+                            options_.get());
+-  RETURN_IF_ERROR(m.status());
++  TFLITE_RETURN_IF_ERROR(m.status());
+   modules_.emplace_back(*std::move(m));
+   // IntentModule.
+   m = IntentModule::Create(interpreter, tensor_index_map_.get(),
+                            options_.get());
+-  RETURN_IF_ERROR(m.status());
++  TFLITE_RETURN_IF_ERROR(m.status());
+   modules_.emplace_back(*std::move(m));
+   // SlotModule.
+   m = SlotModule::Create(interpreter, tensor_index_map_.get(), options_.get());
+-  RETURN_IF_ERROR(m.status());
++  TFLITE_RETURN_IF_ERROR(m.status());
+   modules_.emplace_back(*std::move(m));
+ 
+   return absl::OkStatus();
+@@ -181,7 +181,7 @@ absl::Status BertCluAnnotator::Preprocess(
+   artifacts_.Clear();
+   // Preprocess
+   for (const auto& module : modules_) {
+-    RETURN_IF_ERROR(module->Preprocess(request, &artifacts_));
++    TFLITE_RETURN_IF_ERROR(module->Preprocess(request, &artifacts_));
+   }
+   return absl::OkStatus();
+ }
+@@ -191,7 +191,7 @@ tflite::support::StatusOr<CluResponse> BertCluAnnotator::Postprocess(
+     const CluRequest& request) {
+   CluResponse response;
+   for (const auto& module : modules_) {
+-    RETURN_IF_ERROR(module->Postprocess(&artifacts_, &response));
++    TFLITE_RETURN_IF_ERROR(module->Postprocess(&artifacts_, &response));
+   }
+   return response;
+ }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc
+index 52c898dacb9ca..6b85f361b6047 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_nl_classifier.cc
+@@ -83,15 +83,15 @@ StatusOr<std::vector<core::Category>> BertNLClassifier::Postprocess(
+ StatusOr<std::unique_ptr<BertNLClassifier>> BertNLClassifier::CreateFromOptions(
+     const BertNLClassifierOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   auto options_copy = absl::make_unique<BertNLClassifierOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto bert_nl_classifier,
+       core::TaskAPIFactory::CreateFromBaseOptions<BertNLClassifier>(
+           &options_copy->base_options(), std::move(resolver)));
+-  RETURN_IF_ERROR(bert_nl_classifier->Initialize(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(bert_nl_classifier->Initialize(std::move(options_copy)));
+   return std::move(bert_nl_classifier);
+ }
+ 
+@@ -100,9 +100,9 @@ absl::Status BertNLClassifier::Initialize(
+   options_ = std::move(options);
+ 
+   // Create preprocessor.
+-  ASSIGN_OR_RETURN(auto input_indices,
++  TFLITE_ASSIGN_OR_RETURN(auto input_indices,
+                    GetBertInputTensorIndices(GetTfLiteEngine()));
+-  ASSIGN_OR_RETURN(preprocessor_,
++  TFLITE_ASSIGN_OR_RETURN(preprocessor_,
+                    processor::BertPreprocessor::Create(
+                        GetTfLiteEngine(),
+                        {input_indices[0], input_indices[1], input_indices[2]}));
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_question_answerer.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_question_answerer.cc
+index 444724ae504b0..152be993e86b4 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_question_answerer.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/bert_question_answerer.cc
+@@ -65,17 +65,17 @@ StatusOr<std::unique_ptr<QuestionAnswerer>>
+ BertQuestionAnswerer::CreateFromOptions(
+     const BertQuestionAnswererOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the duration of this
+   // created BertQuestionAnswerer object.
+   auto options_copy = absl::make_unique<BertQuestionAnswererOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto bert_question_answerer,
+       core::TaskAPIFactory::CreateFromBaseOptions<BertQuestionAnswerer>(
+           &options_copy->base_options(), std::move(resolver)));
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       bert_question_answerer->InitializeFromMetadata(std::move(options_copy)));
+   return std::move(bert_question_answerer);
+ }
+@@ -113,7 +113,7 @@ StatusOr<std::unique_ptr<QuestionAnswerer>>
+ BertQuestionAnswerer::CreateBertQuestionAnswererFromFile(
+     const std::string& path_to_model, const std::string& path_to_vocab) {
+   std::unique_ptr<BertQuestionAnswerer> api_to_init;
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       api_to_init,
+       core::TaskAPIFactory::CreateFromFile<BertQuestionAnswerer>(
+           path_to_model,
+@@ -128,7 +128,7 @@ BertQuestionAnswerer::CreateBertQuestionAnswererFromBuffer(
+     const char* model_buffer_data, size_t model_buffer_size,
+     const char* vocab_buffer_data, size_t vocab_buffer_size) {
+   std::unique_ptr<BertQuestionAnswerer> api_to_init;
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       api_to_init,
+       core::TaskAPIFactory::CreateFromBuffer<BertQuestionAnswerer>(
+           model_buffer_data, model_buffer_size,
+@@ -143,7 +143,7 @@ StatusOr<std::unique_ptr<QuestionAnswerer>>
+ BertQuestionAnswerer::CreateAlbertQuestionAnswererFromFile(
+     const std::string& path_to_model, const std::string& path_to_spmodel) {
+   std::unique_ptr<BertQuestionAnswerer> api_to_init;
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       api_to_init,
+       core::TaskAPIFactory::CreateFromFile<BertQuestionAnswerer>(
+           path_to_model,
+@@ -158,7 +158,7 @@ BertQuestionAnswerer::CreateAlbertQuestionAnswererFromBuffer(
+     const char* model_buffer_data, size_t model_buffer_size,
+     const char* spmodel_buffer_data, size_t spmodel_buffer_size) {
+   std::unique_ptr<BertQuestionAnswerer> api_to_init;
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       api_to_init,
+       core::TaskAPIFactory::CreateFromBuffer<BertQuestionAnswerer>(
+           model_buffer_data, model_buffer_size,
+@@ -292,11 +292,11 @@ absl::Status BertQuestionAnswerer::Preprocess(
+   segment_ids.insert(segment_ids.end(), zeros_to_pad, 0);
+ 
+   // input_ids INT32[1, 384]
+-  RETURN_IF_ERROR(PopulateTensor(input_ids, ids_tensor));
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(input_ids, ids_tensor));
+   // input_mask INT32[1, 384]
+-  RETURN_IF_ERROR(PopulateTensor(input_mask, mask_tensor));
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(input_mask, mask_tensor));
+   // segment_ids INT32[1, 384]
+-  RETURN_IF_ERROR(PopulateTensor(segment_ids, segment_ids_tensor));
++  TFLITE_RETURN_IF_ERROR(PopulateTensor(segment_ids, segment_ids_tensor));
+ 
+   return absl::OkStatus();
+ }
+@@ -323,9 +323,9 @@ StatusOr<std::vector<QaAnswer>> BertQuestionAnswerer::Postprocess(
+   std::vector<float> start_logits;
+ 
+   // end_logits FLOAT[1, 384]
+-  RETURN_IF_ERROR(PopulateVector(end_logits_tensor, &end_logits));
++  TFLITE_RETURN_IF_ERROR(PopulateVector(end_logits_tensor, &end_logits));
+   // start_logits FLOAT[1, 384]
+-  RETURN_IF_ERROR(PopulateVector(start_logits_tensor, &start_logits));
++  TFLITE_RETURN_IF_ERROR(PopulateVector(start_logits_tensor, &start_logits));
+ 
+   auto start_indices = ReverseSortIndices(start_logits);
+   auto end_indices = ReverseSortIndices(end_logits);
+@@ -380,7 +380,7 @@ absl::Status BertQuestionAnswerer::InitializeFromMetadata(
+         "No input process unit found from metadata.",
+         TfLiteSupportStatus::kMetadataInvalidTokenizerError);
+   }
+-  ASSIGN_OR_RETURN(tokenizer_,
++  TFLITE_ASSIGN_OR_RETURN(tokenizer_,
+                    CreateTokenizerFromProcessUnit(tokenizer_process_unit,
+                                                   GetMetadataExtractor()));
+   return absl::OkStatus();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_repr.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_repr.cc
+index 114a721ee40ef..917479e9f6041 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_repr.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_repr.cc
+@@ -70,7 +70,7 @@ StatusOr<SlotRepr> SlotRepr::CreateFromIob(const absl::string_view repr) {
+                                             kSlotBTagPrefix, " or ",
+                                             kSlotITagPrefix, ": ", repr));
+   }
+-  ASSIGN_OR_RETURN(const auto domain_name_pair, SplitDomainAndName(full_name));
++  TFLITE_ASSIGN_OR_RETURN(const auto domain_name_pair, SplitDomainAndName(full_name));
+   ret.domain_ = std::string(std::get<0>(domain_name_pair));
+   ret.name_ = std::string(std::get<1>(domain_name_pair));
+   return ret;
+@@ -117,12 +117,12 @@ absl::Status ResolveInconsistentIobTagSeq(std::vector<std::string>* tag_names) {
+   for (size_t i = 0; i < tag_names->size(); ++i) {
+     const auto& tag = tag_names->at(i);
+     if (SlotRepr::IsI(tag)) {
+-      ASSIGN_OR_RETURN(const SlotRepr repr, SlotRepr::CreateFromIob(tag));
++      TFLITE_ASSIGN_OR_RETURN(const SlotRepr repr, SlotRepr::CreateFromIob(tag));
+       if (SlotRepr::IsO(prev_tag)) {
+         // inconsistent case. eg.   O I-time
+         (*tag_names)[i] = repr.BTag();
+       } else {
+-        ASSIGN_OR_RETURN(const SlotRepr prev_repr,
++        TFLITE_ASSIGN_OR_RETURN(const SlotRepr prev_repr,
+                          SlotRepr::CreateFromIob(prev_tag));
+         if (prev_repr.FullName() != repr.FullName()) {
+           // inconsistent case. eg.   B-time I-per    I-time I-per
+@@ -151,7 +151,7 @@ absl::StatusOr<std::vector<SlotMentionStruct>> DecodeSlotChunks(
+   // Make a copy since the input is constant while still modifications are
+   // needed.
+   std::vector<std::string> tag_names_fixed(tag_names.begin(), tag_names.end());
+-  RETURN_IF_ERROR(ResolveInconsistentIobTagSeq(&tag_names_fixed));
++  TFLITE_RETURN_IF_ERROR(ResolveInconsistentIobTagSeq(&tag_names_fixed));
+ 
+   std::vector<SlotMentionStruct> result;
+   // Compute slot tag spans
+@@ -165,7 +165,7 @@ absl::StatusOr<std::vector<SlotMentionStruct>> DecodeSlotChunks(
+     // I tag
+     if (SlotRepr::IsI(tag_str_i)) {
+       SlotRepr slot_tag_i;
+-      ASSIGN_OR_RETURN(slot_tag_i, SlotRepr::CreateFromIob(tag_str_i));
++      TFLITE_ASSIGN_OR_RETURN(slot_tag_i, SlotRepr::CreateFromIob(tag_str_i));
+       if (cur_slot == slot_tag_i) {
+         cur_slot_exclusive_end = token_i + 1;
+         // Compute the phrase level confidence by taking min(tag confidences).
+@@ -194,7 +194,7 @@ absl::StatusOr<std::vector<SlotMentionStruct>> DecodeSlotChunks(
+       cur_slot_start = token_i;
+       cur_slot_exclusive_end = token_i + 1;
+       cur_slot_confidence = tag_probs[token_i];
+-      ASSIGN_OR_RETURN(cur_slot, SlotRepr::CreateFromIob(tag_str_i));
++      TFLITE_ASSIGN_OR_RETURN(cur_slot, SlotRepr::CreateFromIob(tag_str_i));
+     } else {
+       // O tag
+       if (!SlotRepr::IsO(tag_str_i)) {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_tagging_output.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_tagging_output.cc
+index 6643cf6f4e95d..1c582721b6c1c 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_tagging_output.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/slot_tagging_output.cc
+@@ -64,7 +64,7 @@ DecodeSlotChunksPredictOnFirstSubword(
+   const int last_exclusive_end = whole_word_token_alignments.back().second;
+   whole_word_token_alignments.emplace_back(last_exclusive_end,
+                                            last_exclusive_end);
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto slot_mentions,
+       DecodeSlotChunks(first_subword_tag_names, first_subword_tag_probs,
+                        whole_word_token_alignments));
+@@ -105,7 +105,7 @@ absl::Status SlotModulePopulateResponse(
+     // Prepare the data and decode slot chunks.
+     std::vector<SlotMentionStruct> cur_turn_slot_mentions;
+       // Decode slot chunks based on first subword tokens in the turn.
+-    ASSIGN_OR_RETURN(cur_turn_slot_mentions,
++    TFLITE_ASSIGN_OR_RETURN(cur_turn_slot_mentions,
+                      DecodeSlotChunksPredictOnFirstSubword(
+                          cur_turn_start, cur_turn_end, seq_len, tags_as_span,
+                          confidences_as_span, token_alignments_as_span,
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/tflite_modules.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/tflite_modules.cc
+index 634c10b21934b..d60c1b9b6b057 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/tflite_modules.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/clu_lib/tflite_modules.cc
+@@ -65,7 +65,7 @@ absl::Status PopulateInputTextTensorForBERT(
+   std::vector<std::pair<int, int>> alignments;
+   std::vector<int> first_subword_indicators;
+   std::vector<int> segment_id_list;
+-  RETURN_IF_ERROR(BertPreprocessing(
++  TFLITE_RETURN_IF_ERROR(BertPreprocessing(
+       tokenizer, artifacts->reverse_utterance_list_to_encode, max_seq_len,
+       max_history_turns, &token_ids, &alignments, &first_subword_indicators,
+       &segment_id_list, &(artifacts->token_turn_ids)));
+@@ -146,9 +146,9 @@ absl::StatusOr<std::unique_ptr<AbstractModule>> UtteranceSeqModule::Create(
+     const tflite::support::text::tokenizer::BertTokenizer* tokenizer) {
+   auto out = std::make_unique<UtteranceSeqModule>();
+   out->tensor_index_map_ = tensor_index_map;
+-  RETURN_IF_ERROR(out->Init(interpreter, options));
++  TFLITE_RETURN_IF_ERROR(out->Init(interpreter, options));
+   out->tokenizer_ = tokenizer;
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       out->max_seq_len_,
+       GetInputSeqDimSize(tensor_index_map->token_id_idx, interpreter));
+   out->max_history_turns_ = options->max_history_turns();
+@@ -195,13 +195,13 @@ absl::StatusOr<std::unique_ptr<AbstractModule>> DomainModule::Create(
+   auto out = std::make_unique<DomainModule>();
+   out->tensor_index_map_ = tensor_index_map;
+   out->domain_threshold_ = options->domain_threshold();
+-  RETURN_IF_ERROR(out->Init(interpreter, options));
++  TFLITE_RETURN_IF_ERROR(out->Init(interpreter, options));
+   return out;
+ }
+ 
+ absl::Status DomainModule::Postprocess(Artifacts* artifacts,
+                                        CluResponse* response) const {
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const auto t_output,
+       NamesAndConfidencesFromOutput(tensor_index_map_->domain_names_idx,
+                                     tensor_index_map_->domain_scores_idx));
+@@ -225,20 +225,20 @@ absl::StatusOr<std::unique_ptr<AbstractModule>> IntentModule::Create(
+   out->tensor_index_map_ = tensor_index_map;
+   out->intent_threshold_ = options->intent_threshold();
+   out->categorical_slot_threshold_ = options->categorical_slot_threshold();
+-  RETURN_IF_ERROR(out->Init(interpreter, options));
++  TFLITE_RETURN_IF_ERROR(out->Init(interpreter, options));
+   return out;
+ }
+ 
+ absl::Status IntentModule::Postprocess(Artifacts* artifacts,
+                                        CluResponse* response) const {
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const auto t_output,
+       NamesAndConfidencesFromOutput(tensor_index_map_->intent_names_idx,
+                                     tensor_index_map_->intent_scores_idx));
+   const auto& [names, confidences] = t_output;
+ 
+   for (int i = 0; i < names.size(); ++i) {
+-    ASSIGN_OR_RETURN(const auto name, IntentRepr::CreateFromFullName(names[i]));
++    TFLITE_ASSIGN_OR_RETURN(const auto name, IntentRepr::CreateFromFullName(names[i]));
+     // TODO(xysong): Differentiate categorical slots from intents.
+     std::vector<absl::string_view> parts = absl::StrSplit(name.Name(), '=');
+     if (parts.size() == 2) {
+@@ -272,18 +272,18 @@ absl::StatusOr<std::unique_ptr<AbstractModule>> SlotModule::Create(
+   out->tensor_index_map_ = tensor_index_map;
+   out->mentioned_slot_threshold_ =
+       options->mentioned_slot_threshold();
+-  RETURN_IF_ERROR(out->Init(interpreter, options));
++  TFLITE_RETURN_IF_ERROR(out->Init(interpreter, options));
+   return out;
+ }
+ 
+ absl::Status SlotModule::Postprocess(Artifacts* artifacts,
+                                      CluResponse* response) const {
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const auto t_output,
+       NamesAndConfidencesFromOutput(tensor_index_map_->slot_names_idx,
+                                     tensor_index_map_->slot_scores_idx));
+   const auto& [tags, confidences] = t_output;
+-  RETURN_IF_ERROR(SlotModulePopulateResponse(
++  TFLITE_RETURN_IF_ERROR(SlotModulePopulateResponse(
+       tags, confidences, artifacts->token_alignments, artifacts->token_turn_ids,
+       artifacts->first_subword_indicators, mentioned_slot_threshold_,
+       artifacts->reverse_utterance_list_to_encode, response));
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.cc
+index c08abda57401f..181ed79e8a4bd 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/nlclassifier/nl_classifier.cc
+@@ -191,7 +191,7 @@ absl::Status NLClassifier::Initialize(
+     std::unique_ptr<tflite::task::text::NLClassifierOptions> options) {
+   proto_options_ = std::move(options);
+ 
+-  RETURN_IF_ERROR(Initialize(NLClassifierOptions{
++  TFLITE_RETURN_IF_ERROR(Initialize(NLClassifierOptions{
+       /* input_tensor_index= */ proto_options_->input_tensor_index(),
+       /* output_score_tensor_index= */
+       proto_options_->output_score_tensor_index(),
+@@ -222,7 +222,7 @@ absl::Status NLClassifier::Initialize(const NLClassifierOptions& options) {
+   }
+ 
+   // Create preprocessor.
+-  ASSIGN_OR_RETURN(preprocessor_, processor::RegexPreprocessor::Create(
++  TFLITE_ASSIGN_OR_RETURN(preprocessor_, processor::RegexPreprocessor::Create(
+                                       GetTfLiteEngine(), input_index));
+ 
+   // output score tensor should be type
+@@ -295,16 +295,16 @@ absl::Status NLClassifier::Initialize(const NLClassifierOptions& options) {
+ StatusOr<std::unique_ptr<NLClassifier>> NLClassifier::CreateFromOptions(
+     const NLClassifierProtoOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the duration of this
+   // created NLClassifier object.
+   auto options_copy = absl::make_unique<NLClassifierProtoOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(auto nl_classifier,
++  TFLITE_ASSIGN_OR_RETURN(auto nl_classifier,
+                    TaskAPIFactory::CreateFromBaseOptions<NLClassifier>(
+                        &options_copy->base_options(), std::move(resolver)));
+-  RETURN_IF_ERROR(nl_classifier->Initialize(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(nl_classifier->Initialize(std::move(options_copy)));
+ 
+   return nl_classifier;
+ }
+@@ -315,11 +315,11 @@ NLClassifier::CreateFromBufferAndOptions(
+     const NLClassifierOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+   std::unique_ptr<NLClassifier> nl_classifier;
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       nl_classifier,
+       core::TaskAPIFactory::CreateFromBuffer<NLClassifier>(
+           model_buffer_data, model_buffer_size, std::move(resolver)));
+-  RETURN_IF_ERROR(nl_classifier->Initialize(options));
++  TFLITE_RETURN_IF_ERROR(nl_classifier->Initialize(options));
+   return std::move(nl_classifier);
+ }
+ 
+@@ -327,10 +327,10 @@ StatusOr<std::unique_ptr<NLClassifier>> NLClassifier::CreateFromFileAndOptions(
+     const std::string& path_to_model, const NLClassifierOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+   std::unique_ptr<NLClassifier> nl_classifier;
+-  ASSIGN_OR_RETURN(nl_classifier,
++  TFLITE_ASSIGN_OR_RETURN(nl_classifier,
+                    core::TaskAPIFactory::CreateFromFile<NLClassifier>(
+                        path_to_model, std::move(resolver)));
+-  RETURN_IF_ERROR(nl_classifier->Initialize(options));
++  TFLITE_RETURN_IF_ERROR(nl_classifier->Initialize(options));
+   return std::move(nl_classifier);
+ }
+ 
+@@ -338,10 +338,10 @@ StatusOr<std::unique_ptr<NLClassifier>> NLClassifier::CreateFromFdAndOptions(
+     int fd, const NLClassifierOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+   std::unique_ptr<NLClassifier> nl_classifier;
+-  ASSIGN_OR_RETURN(nl_classifier,
++  TFLITE_ASSIGN_OR_RETURN(nl_classifier,
+                    core::TaskAPIFactory::CreateFromFileDescriptor<NLClassifier>(
+                        fd, std::move(resolver)));
+-  RETURN_IF_ERROR(nl_classifier->Initialize(options));
++  TFLITE_RETURN_IF_ERROR(nl_classifier->Initialize(options));
+   return std::move(nl_classifier);
+ }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_embedder.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_embedder.cc
+index 7363540797cf2..dc908baeb4026 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_embedder.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_embedder.cc
+@@ -66,15 +66,15 @@ tflite::support::StatusOr<double> TextEmbedder::CosineSimilarity(
+ tflite::support::StatusOr<std::unique_ptr<TextEmbedder>>
+ TextEmbedder::CreateFromOptions(const TextEmbedderOptions& options,
+                                 std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+   // Copy options to ensure the ExternalFile-s outlive the constructed object.
+   auto options_copy = absl::make_unique<TextEmbedderOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(auto text_embedder,
++  TFLITE_ASSIGN_OR_RETURN(auto text_embedder,
+                    TaskAPIFactory::CreateFromBaseOptions<TextEmbedder>(
+                        &options_copy->base_options(), std::move(resolver)));
+ 
+-  RETURN_IF_ERROR(text_embedder->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(text_embedder->Init(std::move(options_copy)));
+ 
+   return text_embedder;
+ }
+@@ -87,7 +87,7 @@ absl::Status TextEmbedder::Init(std::unique_ptr<TextEmbedderOptions> options) {
+   std::vector<int> output_tensor_indices;
+   if (input_count == 1) {
+     // Assume Regex-based model.
+-    ASSIGN_OR_RETURN(preprocessor_, processor::RegexPreprocessor::Create(
++    TFLITE_ASSIGN_OR_RETURN(preprocessor_, processor::RegexPreprocessor::Create(
+                                         GetTfLiteEngine(), 0));
+     // All output tensors are assumed to be embeddings.
+     for (int i = 0; i < GetTfLiteEngine()->GetOutputs().size(); ++i) {
+@@ -97,9 +97,9 @@ absl::Status TextEmbedder::Init(std::unique_ptr<TextEmbedderOptions> options) {
+     // Check if BertTokenizer is present.
+     if (GetMetadataExtractor()->GetInputProcessUnitsCount() > 0) {
+       // Assume Bert-based model.
+-      ASSIGN_OR_RETURN(auto input_indices,
++      TFLITE_ASSIGN_OR_RETURN(auto input_indices,
+                        GetBertInputTensorIndices(GetTfLiteEngine()));
+-      ASSIGN_OR_RETURN(preprocessor_, processor::BertPreprocessor::Create(
++      TFLITE_ASSIGN_OR_RETURN(preprocessor_, processor::BertPreprocessor::Create(
+                                           GetTfLiteEngine(),
+                                           {input_indices[0], input_indices[1],
+                                            input_indices[2]}));
+@@ -109,13 +109,13 @@ absl::Status TextEmbedder::Init(std::unique_ptr<TextEmbedderOptions> options) {
+       }
+     } else {
+       // Assume Universal Sentence Encoder-based model.
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           auto input_indices,
+           GetUniversalSentenceEncoderInputTensorIndices(GetTfLiteEngine()));
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           auto output_indices,
+           GetUniversalSentenceEncoderOutputTensorIndices(GetTfLiteEngine()));
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           preprocessor_,
+           processor::UniversalSentenceEncoderPreprocessor::Create(
+               GetTfLiteEngine(),
+@@ -154,7 +154,7 @@ absl::Status TextEmbedder::Init(std::unique_ptr<TextEmbedderOptions> options) {
+           "number of output tensors.",
+           support::TfLiteSupportStatus::kInvalidArgumentError);
+     }
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         auto processor,
+         processor::EmbeddingPostprocessor::Create(
+             GetTfLiteEngine(), {output_tensor_indices[i]}, std::move(option)));
+@@ -183,7 +183,7 @@ tflite::support::StatusOr<EmbeddingResult> TextEmbedder::Postprocess(
+     const std::string& input) {
+   EmbeddingResult result;
+   for (int i = 0; i < postprocessors_.size(); ++i) {
+-    RETURN_IF_ERROR(
++    TFLITE_RETURN_IF_ERROR(
+         postprocessors_.at(i)->Postprocess(result.add_embeddings()));
+   }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_searcher.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_searcher.cc
+index fd9cbcb29adfd..9b8de0bb025d4 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_searcher.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/text_searcher.cc
+@@ -65,10 +65,10 @@ StatusOr<std::unique_ptr<TextSearcher>> TextSearcher::CreateFromOptions(
+   // Copy options to ensure the ExternalFile-s outlive the constructed object.
+   auto options_copy = absl::make_unique<TextSearcherOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(auto text_searcher,
++  TFLITE_ASSIGN_OR_RETURN(auto text_searcher,
+                    TaskAPIFactory::CreateFromBaseOptions<TextSearcher>(
+                        &options_copy->base_options(), std::move(resolver)));
+-  RETURN_IF_ERROR(text_searcher->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(text_searcher->Init(std::move(options_copy)));
+ 
+   return text_searcher;
+ }
+@@ -87,7 +87,7 @@ absl::Status TextSearcher::Init(std::unique_ptr<TextSearcherOptions> options) {
+           absl::StrFormat("Expected exactly 1 output tensor, got %d.",
+                           output_count));
+     }
+-    ASSIGN_OR_RETURN(preprocessor_, processor::RegexPreprocessor::Create(
++    TFLITE_ASSIGN_OR_RETURN(preprocessor_, processor::RegexPreprocessor::Create(
+                                         GetTfLiteEngine(), 0));
+     output_tensor_index = 0;
+   } else if (input_count == 3) {
+@@ -100,22 +100,22 @@ absl::Status TextSearcher::Init(std::unique_ptr<TextSearcherOptions> options) {
+             absl::StrFormat("Expected exactly 1 output tensor, got %d.",
+                             output_count));
+       }
+-      ASSIGN_OR_RETURN(auto input_indices,
++      TFLITE_ASSIGN_OR_RETURN(auto input_indices,
+                        GetBertInputTensorIndices(GetTfLiteEngine()));
+-      ASSIGN_OR_RETURN(preprocessor_, processor::BertPreprocessor::Create(
++      TFLITE_ASSIGN_OR_RETURN(preprocessor_, processor::BertPreprocessor::Create(
+                                           GetTfLiteEngine(),
+                                           {input_indices[0], input_indices[1],
+                                            input_indices[2]}));
+       output_tensor_index = 0;
+     } else {
+       // Assume Universal Sentence Encoder-based model.
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           auto input_indices,
+           GetUniversalSentenceEncoderInputTensorIndices(GetTfLiteEngine()));
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           auto output_indices,
+           GetUniversalSentenceEncoderOutputTensorIndices(GetTfLiteEngine()));
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           preprocessor_,
+           processor::UniversalSentenceEncoderPreprocessor::Create(
+               GetTfLiteEngine(),
+@@ -129,7 +129,7 @@ absl::Status TextSearcher::Init(std::unique_ptr<TextSearcherOptions> options) {
+         absl::StrFormat("Expected 1 or 3 input tensors, got %d.", input_count));
+   }
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       postprocessor_,
+       SearchPostprocessor::Create(
+           GetTfLiteEngine(), output_tensor_index,
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/universal_sentence_encoder_qa.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/universal_sentence_encoder_qa.cc
+index 52b0041039acf..439dfa4873459 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/universal_sentence_encoder_qa.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/text/universal_sentence_encoder_qa.cc
+@@ -119,13 +119,13 @@ StatusOr<RetrievalOutput> UniversalSentenceEncoderQA::Retrieve(
+ 
+       // Only encode query for the first time.
+       if (i == 0) {
+-        RETURN_IF_ERROR(
++        TFLITE_RETURN_IF_ERROR(
+             CopyVector(out.query_encoding, output.mutable_query_encoding()));
+       }
+ 
+       // For each answer, set the response result.
+       auto r = output.mutable_response_results()->Add();
+-      RETURN_IF_ERROR(CopyVector(out.response_encoding, r->mutable_encoding()));
++      TFLITE_RETURN_IF_ERROR(CopyVector(out.response_encoding, r->mutable_encoding()));
+     } else {
+       // If response is already encoded, encode query only and keep response
+       // encoding.
+@@ -164,7 +164,7 @@ StatusOr<FeatureVector> UniversalSentenceEncoderQA::EncodeQuery(
+ 
+   const auto& output = Run(query_text, "", "");
+   FeatureVector v;
+-  RETURN_IF_ERROR(CopyVector(output.query_encoding, &v));
++  TFLITE_RETURN_IF_ERROR(CopyVector(output.query_encoding, &v));
+   return v;
+ }
+ 
+@@ -178,7 +178,7 @@ StatusOr<FeatureVector> UniversalSentenceEncoderQA::EncodeResponse(
+ 
+   const auto& output = Run("", response_text, response_context);
+   FeatureVector v;
+-  RETURN_IF_ERROR(CopyVector(output.response_encoding, &v));
++  TFLITE_RETURN_IF_ERROR(CopyVector(output.response_encoding, &v));
+   return v;
+ }
+ 
+@@ -215,11 +215,11 @@ std::vector<size_t> UniversalSentenceEncoderQA::Top(
+ 
+ Status UniversalSentenceEncoderQA::Preprocess(
+     const std::vector<TfLiteTensor*>& input_tensors, const QAInput& input) {
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       PopulateTensor(input.query_text, input_tensors[input_indices_[0]]));
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       PopulateTensor(input.response_context, input_tensors[input_indices_[1]]));
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       PopulateTensor(input.response_text, input_tensors[input_indices_[2]]));
+ 
+   return absl::OkStatus();
+@@ -248,10 +248,10 @@ absl::Status UniversalSentenceEncoderQA::Init(
+     std::unique_ptr<RetrievalOptions> options) {
+   options_ = std::move(options);
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       input_indices_,
+       GetUniversalSentenceEncoderInputTensorIndices(GetTfLiteEngine()));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       output_indices_,
+       GetUniversalSentenceEncoderOutputTensorIndices(GetTfLiteEngine()));
+ 
+@@ -262,18 +262,18 @@ StatusOr<std::unique_ptr<UniversalSentenceEncoderQA>>
+ UniversalSentenceEncoderQA::CreateFromOption(
+     const RetrievalOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the duration of this
+   // created object.
+   auto options_copy = absl::make_unique<RetrievalOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto encoder,
+       TaskAPIFactory::CreateFromBaseOptions<UniversalSentenceEncoderQA>(
+           &options_copy->base_options(), std::move(resolver)));
+ 
+-  RETURN_IF_ERROR(encoder->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(encoder->Init(std::move(options_copy)));
+   return encoder;
+ }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/base_vision_task_api.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/base_vision_task_api.h
+index 76a03671b54af..1d86136da193d 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/base_vision_task_api.h
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/base_vision_task_api.h
+@@ -73,7 +73,7 @@ class BaseVisionTaskApi
+   // already successfully initialized before calling this method.
+   virtual absl::Status CheckAndSetInputs() {
+     // BaseTaskApi always assume having a single input.
+-    ASSIGN_OR_RETURN(preprocessor_,
++    TFLITE_ASSIGN_OR_RETURN(preprocessor_,
+                      ::tflite::task::processor::ImagePreprocessor::Create(
+                          this->GetTfLiteEngine(), {0}, process_engine_));
+     return absl::OkStatus();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/classification_head.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/classification_head.cc
+index b5b57f21e939f..1bcaee2b86ddc 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/classification_head.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/core/classification_head.cc
+@@ -44,7 +44,7 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+           output_tensor_metadata,
+           tflite::AssociatedFileType_TENSOR_AXIS_LABELS);
+   if (!labels_filename.empty()) {
+-    ASSIGN_OR_RETURN(absl::string_view labels_file,
++    TFLITE_ASSIGN_OR_RETURN(absl::string_view labels_file,
+                      metadata_extractor.GetAssociatedFile(labels_filename));
+     const std::string display_names_filename =
+         ModelMetadataExtractor::FindFirstAssociatedFileName(
+@@ -53,15 +53,15 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+             display_names_locale);
+     absl::string_view display_names_file;
+     if (!display_names_filename.empty()) {
+-      ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
++      TFLITE_ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
+                                                display_names_filename));
+     }
+-    ASSIGN_OR_RETURN(head.label_map_items,
++    TFLITE_ASSIGN_OR_RETURN(head.label_map_items,
+                      BuildLabelMapFromFiles(labels_file, display_names_file));
+   }
+ 
+   // Set score threshold, if present.
+-  ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_thresholding_process_unit,
++  TFLITE_ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_thresholding_process_unit,
+                    ModelMetadataExtractor::FindFirstProcessUnit(
+                        output_tensor_metadata,
+                        tflite::ProcessUnitOptions_ScoreThresholdingOptions));
+@@ -72,7 +72,7 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+   }
+ 
+   // Build score calibration parameters, if present.
+-  ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_calibration_process_unit,
++  TFLITE_ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_calibration_process_unit,
+                    ModelMetadataExtractor::FindFirstProcessUnit(
+                        output_tensor_metadata,
+                        tflite::ProcessUnitOptions_ScoreCalibrationOptions));
+@@ -95,10 +95,10 @@ StatusOr<ClassificationHead> BuildClassificationHead(
+           "parameters file with type TENSOR_AXIS_SCORE_CALIBRATION.",
+           TfLiteSupportStatus::kMetadataAssociatedFileNotFoundError);
+     }
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         absl::string_view score_calibration_file,
+         metadata_extractor.GetAssociatedFile(score_calibration_filename));
+-    ASSIGN_OR_RETURN(SigmoidCalibrationParameters sigmoid_params,
++    TFLITE_ASSIGN_OR_RETURN(SigmoidCalibrationParameters sigmoid_params,
+                      BuildSigmoidCalibrationParams(
+                          *score_calibration_process_unit
+                               ->options_as_ScoreCalibrationOptions(),
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_classifier.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_classifier.cc
+index aa1e7707dd99b..60cd7abb83374 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_classifier.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_classifier.cc
+@@ -52,20 +52,20 @@ using ::tflite::task::core::TfLiteEngine;
+ StatusOr<std::unique_ptr<ImageClassifier>> ImageClassifier::CreateFromOptions(
+     const ImageClassifierOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the constructed object.
+   auto options_copy = absl::make_unique<ImageClassifierOptions>(options);
+ 
+   std::unique_ptr<ImageClassifier> image_classifier;
+   if (options_copy->has_model_file_with_metadata()) {
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         image_classifier,
+         TaskAPIFactory::CreateFromExternalFileProto<ImageClassifier>(
+             &options_copy->model_file_with_metadata(), std::move(resolver),
+             options_copy->num_threads(), options_copy->compute_settings()));
+   } else if (options_copy->base_options().has_model_file()) {
+-    ASSIGN_OR_RETURN(image_classifier,
++    TFLITE_ASSIGN_OR_RETURN(image_classifier,
+                      TaskAPIFactory::CreateFromBaseOptions<ImageClassifier>(
+                          &options_copy->base_options(), std::move(resolver)));
+   } else {
+@@ -77,7 +77,7 @@ StatusOr<std::unique_ptr<ImageClassifier>> ImageClassifier::CreateFromOptions(
+         TfLiteSupportStatus::kInvalidArgumentError);
+   }
+ 
+-  RETURN_IF_ERROR(image_classifier->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(image_classifier->Init(std::move(options_copy)));
+ 
+   return image_classifier;
+ }
+@@ -125,18 +125,18 @@ absl::Status ImageClassifier::Init(
+ 
+   // Perform pre-initialization actions (by default, sets the process engine for
+   // image pre-processing to kLibyuv as a sane default).
+-  RETURN_IF_ERROR(PreInit());
++  TFLITE_RETURN_IF_ERROR(PreInit());
+ 
+   // Sanity check and set inputs and outputs.
+-  RETURN_IF_ERROR(CheckAndSetInputs());
+-  RETURN_IF_ERROR(CheckAndSetOutputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetInputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetOutputs());
+ 
+   // Initialize class whitelisting/blacklisting, if any.
+-  RETURN_IF_ERROR(CheckAndSetClassNameSet());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetClassNameSet());
+ 
+   // Perform final initialization (by default, initialize score calibration
+   // parameters, if any).
+-  RETURN_IF_ERROR(PostInit());
++  TFLITE_RETURN_IF_ERROR(PostInit());
+ 
+   return absl::OkStatus();
+ }
+@@ -177,7 +177,7 @@ absl::Status ImageClassifier::CheckAndSetOutputs() {
+       const tflite::TensorMetadata* output_tensor =
+           output_tensor_metadata->Get(i);
+ 
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           ClassificationHead head,
+           BuildClassificationHead(*metadata_extractor, *output_tensor,
+                                   options_->display_names_locale()));
+@@ -364,7 +364,7 @@ absl::Status ImageClassifier::InitScoreCalibrations() {
+           StatusCode::kInternal, "Could not create score calibration object.");
+     }
+ 
+-    RETURN_IF_ERROR(score_calibrations_[i]->InitializeFromParameters(
++    TFLITE_RETURN_IF_ERROR(score_calibrations_[i]->InitializeFromParameters(
+         classification_heads_[i].calibration_params.value()));
+   }
+ 
+@@ -407,7 +407,7 @@ StatusOr<ClassificationResult> ImageClassifier::Postprocess(
+ 
+     const TfLiteTensor* output_tensor = output_tensors[i];
+     if (has_uint8_outputs_) {
+-      ASSIGN_OR_RETURN(const uint8* output_data,
++      TFLITE_ASSIGN_OR_RETURN(const uint8* output_data,
+                        AssertAndReturnTypedTensor<uint8>(output_tensor));
+       for (int j = 0; j < head.label_map_items.size(); ++j) {
+         score_pairs.emplace_back(j, output_tensor->params.scale *
+@@ -415,7 +415,7 @@ StatusOr<ClassificationResult> ImageClassifier::Postprocess(
+                                          output_tensor->params.zero_point));
+       }
+     } else {
+-      ASSIGN_OR_RETURN(const float* output_data,
++      TFLITE_ASSIGN_OR_RETURN(const float* output_data,
+                        AssertAndReturnTypedTensor<float>(output_tensor));
+       for (int j = 0; j < head.label_map_items.size(); ++j) {
+         score_pairs.emplace_back(j, output_data[j]);
+@@ -501,7 +501,7 @@ StatusOr<ClassificationResult> ImageClassifier::Postprocess(
+     }
+   }
+ 
+-  RETURN_IF_ERROR(FillResultsFromLabelMaps(&result));
++  TFLITE_RETURN_IF_ERROR(FillResultsFromLabelMaps(&result));
+ 
+   return result;
+ }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_embedder.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_embedder.cc
+index 0ce46fb9f9806..d24daeac9b61d 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_embedder.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_embedder.cc
+@@ -62,13 +62,13 @@ ImageEmbedder::CreateFromOptions(const ImageEmbedderOptions& options,
+   // Copy options to ensure the ExternalFile-s outlive the constructed object.
+   auto options_copy = absl::make_unique<ImageEmbedderOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto image_embedder,
+       TaskAPIFactory::CreateFromExternalFileProto<ImageEmbedder>(
+           &options_copy->model_file_with_metadata(), std::move(resolver),
+           options_copy->num_threads(), options_copy->compute_settings()));
+ 
+-  RETURN_IF_ERROR(image_embedder->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(image_embedder->Init(std::move(options_copy)));
+ 
+   return image_embedder;
+ }
+@@ -89,19 +89,19 @@ absl::Status ImageEmbedder::Init(
+   options_ = std::move(options);
+ 
+   // Perform pre-initialization actions.
+-  RETURN_IF_ERROR(PreInit());
++  TFLITE_RETURN_IF_ERROR(PreInit());
+ 
+   // Sanity check and set inputs and outputs.
+-  RETURN_IF_ERROR(CheckAndSetInputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetInputs());
+ 
+   // Perform post-initialization actions.
+-  RETURN_IF_ERROR(PostInit());
++  TFLITE_RETURN_IF_ERROR(PostInit());
+ 
+   // ImageEmbedder assumes that all output tensors share the same
+   // embedding option.
+   postprocessors_.reserve(GetTfLiteEngine()->interpreter()->outputs().size());
+   for (int i = 0; i < GetTfLiteEngine()->interpreter()->outputs().size(); i++) {
+-    ASSIGN_OR_RETURN(auto processor,
++    TFLITE_ASSIGN_OR_RETURN(auto processor,
+                      CreatePostprocessor(GetTfLiteEngine(), {i}, *options_));
+     postprocessors_.emplace_back(std::move(processor));
+   }
+@@ -127,7 +127,7 @@ tflite::support::StatusOr<EmbeddingResult> ImageEmbedder::Postprocess(
+     const FrameBuffer& /*frame_buffer*/, const BoundingBox& /*roi*/) {
+   EmbeddingResult result;
+   for (int i = 0; i < postprocessors_.size(); ++i) {
+-    RETURN_IF_ERROR(
++    TFLITE_RETURN_IF_ERROR(
+         postprocessors_.at(i)->Postprocess(result.add_embeddings()));
+   }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_searcher.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_searcher.cc
+index fb8bdf4f36446..6b577cd961f61 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_searcher.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_searcher.cc
+@@ -56,11 +56,11 @@ StatusOr<std::unique_ptr<ImageSearcher>> ImageSearcher::CreateFromOptions(
+   // Copy options to ensure the ExternalFile-s outlive the constructed object.
+   auto options_copy = absl::make_unique<ImageSearcherOptions>(options);
+ 
+-  ASSIGN_OR_RETURN(auto image_searcher,
++  TFLITE_ASSIGN_OR_RETURN(auto image_searcher,
+                    TaskAPIFactory::CreateFromBaseOptions<ImageSearcher>(
+                        &options_copy->base_options(), std::move(resolver)));
+ 
+-  RETURN_IF_ERROR(image_searcher->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(image_searcher->Init(std::move(options_copy)));
+ 
+   return image_searcher;
+ }
+@@ -75,13 +75,13 @@ absl::Status ImageSearcher::Init(
+   options_ = std::move(options);
+ 
+   // Perform pre-initialization actions.
+-  RETURN_IF_ERROR(PreInit());
++  TFLITE_RETURN_IF_ERROR(PreInit());
+ 
+   // Sanity check and set inputs.
+-  RETURN_IF_ERROR(CheckAndSetInputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetInputs());
+ 
+   // Create post-processor.
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       postprocessor_,
+       SearchPostprocessor::Create(GetTfLiteEngine(), 0,
+                                   std::make_unique<processor::SearchOptions>(
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_segmenter.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_segmenter.cc
+index c9dad866f1a68..8bef73b9759ff 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_segmenter.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/image_segmenter.cc
+@@ -117,7 +117,7 @@ StatusOr<std::vector<LabelMapItem>> GetLabelMapIfAny(
+   if (labels_filename.empty()) {
+     return std::vector<LabelMapItem>();
+   }
+-  ASSIGN_OR_RETURN(absl::string_view labels_file,
++  TFLITE_ASSIGN_OR_RETURN(absl::string_view labels_file,
+                    metadata_extractor.GetAssociatedFile(labels_filename));
+   const std::string display_names_filename =
+       ModelMetadataExtractor::FindFirstAssociatedFileName(
+@@ -125,7 +125,7 @@ StatusOr<std::vector<LabelMapItem>> GetLabelMapIfAny(
+           locale);
+   absl::string_view display_names_file = {};
+   if (!display_names_filename.empty()) {
+-    ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
++    TFLITE_ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
+                                              display_names_filename));
+   }
+   return BuildLabelMapFromFiles(labels_file, display_names_file);
+@@ -164,20 +164,20 @@ absl::Status ImageSegmenter::SanityCheckOptions(
+ StatusOr<std::unique_ptr<ImageSegmenter>> ImageSegmenter::CreateFromOptions(
+     const ImageSegmenterOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the constructed object.
+   auto options_copy = absl::make_unique<ImageSegmenterOptions>(options);
+ 
+   std::unique_ptr<ImageSegmenter> image_segmenter;
+   if (options_copy->has_model_file_with_metadata()) {
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         image_segmenter,
+         TaskAPIFactory::CreateFromExternalFileProto<ImageSegmenter>(
+             &options_copy->model_file_with_metadata(), std::move(resolver),
+             options_copy->num_threads(), options_copy->compute_settings()));
+   } else if (options_copy->base_options().has_model_file()) {
+-    ASSIGN_OR_RETURN(image_segmenter,
++    TFLITE_ASSIGN_OR_RETURN(image_segmenter,
+                      TaskAPIFactory::CreateFromBaseOptions<ImageSegmenter>(
+                          &options_copy->base_options(), std::move(resolver)));
+   } else {
+@@ -189,7 +189,7 @@ StatusOr<std::unique_ptr<ImageSegmenter>> ImageSegmenter::CreateFromOptions(
+         TfLiteSupportStatus::kInvalidArgumentError);
+   }
+ 
+-  RETURN_IF_ERROR(image_segmenter->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(image_segmenter->Init(std::move(options_copy)));
+ 
+   return image_segmenter;
+ }
+@@ -201,14 +201,14 @@ absl::Status ImageSegmenter::Init(
+ 
+   // Perform pre-initialization actions (by default, sets the process engine for
+   // image pre-processing to kLibyuv as a sane default).
+-  RETURN_IF_ERROR(PreInit());
++  TFLITE_RETURN_IF_ERROR(PreInit());
+ 
+   // Sanity check and set inputs and outputs.
+-  RETURN_IF_ERROR(CheckAndSetInputs());
+-  RETURN_IF_ERROR(CheckAndSetOutputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetInputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetOutputs());
+ 
+   // Initialize colored_labels_ once and for all.
+-  RETURN_IF_ERROR(InitColoredLabels());
++  TFLITE_RETURN_IF_ERROR(InitColoredLabels());
+ 
+   return absl::OkStatus();
+ }
+@@ -288,7 +288,7 @@ absl::Status ImageSegmenter::CheckAndSetOutputs() {
+                           output_tensor_metadata->size()),
+           TfLiteSupportStatus::kMetadataInconsistencyError);
+     }
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         label_map_,
+         GetLabelMapIfAny(*metadata_extractor, *output_tensor_metadata->Get(0),
+                          options_->display_names_locale()));
+@@ -391,7 +391,7 @@ StatusOr<SegmentationResult> ImageSegmenter::Postprocess(
+         int class_index = 0;
+         float max_confidence = 0.0f;
+         for (int d = 0; d < output_depth_; ++d) {
+-          ASSIGN_OR_RETURN(
++          TFLITE_ASSIGN_OR_RETURN(
+               const float confidence,
+               GetOutputConfidence(*output_tensor, tensor_x, tensor_y, d));
+           if (confidence > max_confidence) {
+@@ -419,7 +419,7 @@ StatusOr<SegmentationResult> ImageSegmenter::Postprocess(
+                           /*to_x=*/&tensor_x,
+                           /*to_y=*/&tensor_y);
+         for (int d = 0; d < output_depth_; ++d) {
+-          ASSIGN_OR_RETURN(
++          TFLITE_ASSIGN_OR_RETURN(
+               float confidence,
+               GetOutputConfidence(*output_tensor, tensor_x, tensor_y, d));
+           confidence_masks->mutable_confidence_mask(d)->add_value(confidence);
+@@ -435,12 +435,12 @@ StatusOr<float> ImageSegmenter::GetOutputConfidence(
+     const TfLiteTensor& output_tensor, int x, int y, int depth) {
+   int index = output_width_ * output_depth_ * y + output_depth_ * x + depth;
+   if (has_uint8_outputs_) {
+-    ASSIGN_OR_RETURN(const uint8* data,
++    TFLITE_ASSIGN_OR_RETURN(const uint8* data,
+                      AssertAndReturnTypedTensor<uint8>(&output_tensor));
+     return output_tensor.params.scale *
+            (static_cast<int>(data[index]) - output_tensor.params.zero_point);
+   } else {
+-    ASSIGN_OR_RETURN(const float* data,
++    TFLITE_ASSIGN_OR_RETURN(const float* data,
+                      AssertAndReturnTypedTensor<float>(&output_tensor));
+     return data[index];
+   }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/object_detector.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/object_detector.cc
+index 0a4d5f7553ee9..a8c221a6dac64 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/object_detector.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/object_detector.cc
+@@ -148,7 +148,7 @@ StatusOr<std::vector<LabelMapItem>> GetLabelMapIfAny(
+   if (labels_filename.empty()) {
+     return std::vector<LabelMapItem>();
+   }
+-  ASSIGN_OR_RETURN(absl::string_view labels_file,
++  TFLITE_ASSIGN_OR_RETURN(absl::string_view labels_file,
+                    metadata_extractor.GetAssociatedFile(labels_filename));
+   const std::string display_names_filename =
+       ModelMetadataExtractor::FindFirstAssociatedFileName(
+@@ -156,7 +156,7 @@ StatusOr<std::vector<LabelMapItem>> GetLabelMapIfAny(
+           locale);
+   absl::string_view display_names_file;
+   if (!display_names_filename.empty()) {
+-    ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
++    TFLITE_ASSIGN_OR_RETURN(display_names_file, metadata_extractor.GetAssociatedFile(
+                                              display_names_filename));
+   }
+   return BuildLabelMapFromFiles(labels_file, display_names_file);
+@@ -165,7 +165,7 @@ StatusOr<std::vector<LabelMapItem>> GetLabelMapIfAny(
+ StatusOr<float> GetScoreThreshold(
+     const ModelMetadataExtractor& metadata_extractor,
+     const TensorMetadata& tensor_metadata) {
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const ProcessUnit* score_thresholding_process_unit,
+       metadata_extractor.FindFirstProcessUnit(
+           tensor_metadata, ProcessUnitOptions_ScoreThresholdingOptions));
+@@ -225,7 +225,7 @@ absl::Status SanityCheckOutputTensors(
+             num_results_tensor->dims->data[0]));
+   }
+ 
+-  ASSIGN_OR_RETURN(float* num_results_data,
++  TFLITE_ASSIGN_OR_RETURN(float* num_results_data,
+                    AssertAndReturnTypedTensor<float>(num_results_tensor));
+   int num_results = static_cast<int>(num_results_data[0]);
+ 
+@@ -312,20 +312,20 @@ absl::Status ObjectDetector::SanityCheckOptions(
+ StatusOr<std::unique_ptr<ObjectDetector>> ObjectDetector::CreateFromOptions(
+     const ObjectDetectorOptions& options,
+     std::unique_ptr<tflite::OpResolver> resolver) {
+-  RETURN_IF_ERROR(SanityCheckOptions(options));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+   // Copy options to ensure the ExternalFile outlives the constructed object.
+   auto options_copy = absl::make_unique<ObjectDetectorOptions>(options);
+ 
+   std::unique_ptr<ObjectDetector> object_detector;
+   if (options_copy->has_model_file_with_metadata()) {
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         object_detector,
+         TaskAPIFactory::CreateFromExternalFileProto<ObjectDetector>(
+             &options_copy->model_file_with_metadata(), std::move(resolver),
+             options_copy->num_threads(), options_copy->compute_settings()));
+   } else if (options_copy->base_options().has_model_file()) {
+-    ASSIGN_OR_RETURN(object_detector,
++    TFLITE_ASSIGN_OR_RETURN(object_detector,
+                      TaskAPIFactory::CreateFromBaseOptions<ObjectDetector>(
+                          &options_copy->base_options(), std::move(resolver)));
+   } else {
+@@ -337,7 +337,7 @@ StatusOr<std::unique_ptr<ObjectDetector>> ObjectDetector::CreateFromOptions(
+         TfLiteSupportStatus::kInvalidArgumentError);
+   }
+ 
+-  RETURN_IF_ERROR(object_detector->Init(std::move(options_copy)));
++  TFLITE_RETURN_IF_ERROR(object_detector->Init(std::move(options_copy)));
+ 
+   return object_detector;
+ }
+@@ -349,18 +349,18 @@ absl::Status ObjectDetector::Init(
+ 
+   // Perform pre-initialization actions (by default, sets the process engine for
+   // image pre-processing to kLibyuv as a sane default).
+-  RETURN_IF_ERROR(PreInit());
++  TFLITE_RETURN_IF_ERROR(PreInit());
+ 
+   // Sanity check and set inputs and outputs.
+-  RETURN_IF_ERROR(CheckAndSetInputs());
+-  RETURN_IF_ERROR(CheckAndSetOutputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetInputs());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetOutputs());
+ 
+   // Initialize class whitelisting/blacklisting, if any.
+-  RETURN_IF_ERROR(CheckAndSetClassIndexSet());
++  TFLITE_RETURN_IF_ERROR(CheckAndSetClassIndexSet());
+ 
+   // Perform final initialization (by default, initialize score calibration
+   // parameters, if any).
+-  RETURN_IF_ERROR(PostInit());
++  TFLITE_RETURN_IF_ERROR(PostInit());
+ 
+   return absl::OkStatus();
+ }
+@@ -386,7 +386,7 @@ StatusOr<SigmoidCalibrationParameters> BuildCalibrationParametersIfAny(
+   // that does sanity checks and builds sigmoid calibration params in:
+   //   https://github.com/tensorflow/tflite-support/blob/64e044408f3d3654de7fc10bca401ed900649ca3/tensorflow_lite_support/cc/task/vision/core/classification_head.cc#L75-L107
+   // Consider to refactor it and reuse the same function.
+-  ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_calibration_process_unit,
++  TFLITE_ASSIGN_OR_RETURN(const tflite::ProcessUnit* score_calibration_process_unit,
+                    ModelMetadataExtractor::FindFirstProcessUnit(
+                        output_tensor_metadata,
+                        tflite::ProcessUnitOptions_ScoreCalibrationOptions));
+@@ -395,12 +395,12 @@ StatusOr<SigmoidCalibrationParameters> BuildCalibrationParametersIfAny(
+         ModelMetadataExtractor::FindFirstAssociatedFileName(
+             output_tensor_metadata,
+             tflite::AssociatedFileType_TENSOR_AXIS_SCORE_CALIBRATION);
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         absl::string_view score_calibration_file,
+         metadata_extractor.GetAssociatedFile(score_calibration_filename));
+ 
+     // Set has_score_calibration to true, only if sigmoid_params is built.
+-    ASSIGN_OR_RETURN(sigmoid_params,
++    TFLITE_ASSIGN_OR_RETURN(sigmoid_params,
+                      BuildSigmoidCalibrationParams(
+                          *score_calibration_process_unit
+                               ->options_as_ScoreCalibrationOptions(),
+@@ -421,7 +421,7 @@ absl::Status ObjectDetector::InitScoreCalibrations() {
+       output_tensor_metadata = metadata_extractor->GetOutputTensorMetadata();
+   const tflite::TensorMetadata* output_tensor =
+       output_tensor_metadata->Get(kDefaultScoresIndex);
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto calibration_params,
+       BuildCalibrationParametersIfAny(*metadata_extractor, *output_tensor,
+                                       label_map_, &has_score_calibration));
+@@ -436,7 +436,7 @@ absl::Status ObjectDetector::InitScoreCalibrations() {
+     return CreateStatusWithPayload(
+         StatusCode::kInternal, "Could not create score calibration object.");
+   }
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       score_calibration_->InitializeFromParameters(calibration_params));
+   return absl::OkStatus();
+ }
+@@ -485,7 +485,7 @@ absl::Status ObjectDetector::CheckAndSetOutputs() {
+ 
+   // Extract mandatory BoundingBoxProperties for easier access at
+   // post-processing time, performing sanity checks on the fly.
+-  ASSIGN_OR_RETURN(const BoundingBoxProperties* bounding_box_properties,
++  TFLITE_ASSIGN_OR_RETURN(const BoundingBoxProperties* bounding_box_properties,
+                    GetBoundingBoxProperties(
+                        *output_tensors_metadata->Get(output_indices_[0])));
+   if (bounding_box_properties->index() == nullptr) {
+@@ -501,7 +501,7 @@ absl::Status ObjectDetector::CheckAndSetOutputs() {
+   }
+ 
+   // Build label map (if available) from metadata.
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       label_map_,
+       GetLabelMapIfAny(*metadata_extractor,
+                        *output_tensors_metadata->Get(output_indices_[1]),
+@@ -511,7 +511,7 @@ absl::Status ObjectDetector::CheckAndSetOutputs() {
+   if (options_->has_score_threshold()) {
+     score_threshold_ = options_->score_threshold();
+   } else {
+-    ASSIGN_OR_RETURN(
++    TFLITE_ASSIGN_OR_RETURN(
+         score_threshold_,
+         GetScoreThreshold(*metadata_extractor,
+                           *output_tensors_metadata->Get(output_indices_[2])));
+@@ -603,10 +603,10 @@ StatusOr<DetectionResult> ObjectDetector::Postprocess(
+   // Most of the checks here should never happen, as outputs have been validated
+   // at construction time. Checking nonetheless and returning internal errors if
+   // something bad happens.
+-  RETURN_IF_ERROR(SanityCheckOutputTensors(output_tensors, output_indices_));
++  TFLITE_RETURN_IF_ERROR(SanityCheckOutputTensors(output_tensors, output_indices_));
+ 
+   // Get number of available results.
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       float* num_results_data,
+       AssertAndReturnTypedTensor<float>(output_tensors[output_indices_[3]]));
+   const int num_results = static_cast<int>(num_results_data[0]);
+@@ -623,13 +623,13 @@ StatusOr<DetectionResult> ObjectDetector::Postprocess(
+     upright_input_frame_dimensions.Swap();
+   }
+ 
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const float* locations,
+       AssertAndReturnTypedTensor<float>(output_tensors[output_indices_[0]]));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const float* classes,
+       AssertAndReturnTypedTensor<float>(output_tensors[output_indices_[1]]));
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const float* scores,
+       AssertAndReturnTypedTensor<float>(output_tensors[output_indices_[2]]));
+   DetectionResult results;
+@@ -671,7 +671,7 @@ StatusOr<DetectionResult> ObjectDetector::Postprocess(
+   }
+ 
+   if (!label_map_.empty()) {
+-    RETURN_IF_ERROR(FillResultsFromLabelMap(&results));
++    TFLITE_RETURN_IF_ERROR(FillResultsFromLabelMap(&results));
+   }
+ 
+   return results;
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_common_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_common_utils.cc
+index 1854cf546d599..e12700079f601 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_common_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_common_utils.cc
+@@ -120,7 +120,7 @@ StatusOr<const uint8*> GetUvRawBuffer(const FrameBuffer& buffer) {
+     return absl::InvalidArgumentError(
+         "Only support getting biplanar UV buffer from NV12/NV21 frame buffer.");
+   }
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+   const uint8* uv_buffer = buffer.format() == FrameBuffer::Format::kNV12
+                                ? yuv_data.u_buffer
+@@ -192,8 +192,8 @@ absl::Status ValidateBufferFormat(const FrameBuffer& buffer) {
+ 
+ absl::Status ValidateBufferFormats(const FrameBuffer& buffer1,
+                                    const FrameBuffer& buffer2) {
+-  RETURN_IF_ERROR(ValidateBufferFormat(buffer1));
+-  RETURN_IF_ERROR(ValidateBufferFormat(buffer2));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferFormat(buffer1));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferFormat(buffer2));
+   return absl::OkStatus();
+ }
+ 
+@@ -391,7 +391,7 @@ StatusOr<std::unique_ptr<FrameBuffer>> CreateFromRawBuffer(
+       return CreateFromOnePlaneNVRawBuffer(buffer, dimension, target_format,
+                                            orientation, timestamp);
+     case FrameBuffer::Format::kYV12: {
+-      ASSIGN_OR_RETURN(const FrameBuffer::Dimension uv_dimension,
++      TFLITE_ASSIGN_OR_RETURN(const FrameBuffer::Dimension uv_dimension,
+                        GetUvPlaneDimension(dimension, target_format));
+       return CreateFromYuvRawBuffer(
+           /*y_plane=*/buffer,
+@@ -401,7 +401,7 @@ StatusOr<std::unique_ptr<FrameBuffer>> CreateFromRawBuffer(
+           /*pixel_stride_uv=*/1, orientation, timestamp);
+     }
+     case FrameBuffer::Format::kYV21: {
+-      ASSIGN_OR_RETURN(const FrameBuffer::Dimension uv_dimension,
++      TFLITE_ASSIGN_OR_RETURN(const FrameBuffer::Dimension uv_dimension,
+                        GetUvPlaneDimension(dimension, target_format));
+       return CreateFromYuvRawBuffer(
+           /*y_plane=*/buffer, /*u_plane=*/buffer + dimension.Size(),
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_utils.cc
+index 9298c60395286..653ff01f331ef 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/frame_buffer_utils.cc
+@@ -398,22 +398,22 @@ absl::Status FrameBufferUtils::Execute(const FrameBuffer& buffer,
+                                        FrameBuffer* output_buffer) {
+   if (absl::holds_alternative<CropResizeOperation>(operation)) {
+     const auto& params = absl::get<CropResizeOperation>(operation);
+-    RETURN_IF_ERROR(
++    TFLITE_RETURN_IF_ERROR(
+         Crop(buffer, params.crop_origin_x, params.crop_origin_y,
+              (params.crop_dimension.width + params.crop_origin_x - 1),
+              (params.crop_dimension.height + params.crop_origin_y - 1),
+              output_buffer));
+   } else if (absl::holds_alternative<UniformCropResizeOperation>(operation)) {
+     const auto& params = absl::get<UniformCropResizeOperation>(operation);
+-    RETURN_IF_ERROR(
++    TFLITE_RETURN_IF_ERROR(
+         Crop(buffer, params.crop_origin_x, params.crop_origin_y,
+              (params.crop_dimension.width + params.crop_origin_x - 1),
+              (params.crop_dimension.height + params.crop_origin_y - 1),
+              output_buffer));
+   } else if (absl::holds_alternative<ConvertOperation>(operation)) {
+-    RETURN_IF_ERROR(Convert(buffer, output_buffer));
++    TFLITE_RETURN_IF_ERROR(Convert(buffer, output_buffer));
+   } else if (absl::holds_alternative<OrientOperation>(operation)) {
+-    RETURN_IF_ERROR(Orient(buffer, output_buffer));
++    TFLITE_RETURN_IF_ERROR(Orient(buffer, output_buffer));
+   } else {
+     return absl::UnimplementedError(absl::StrFormat(
+         "FrameBufferOperation %i is not supported.", operation.index()));
+@@ -494,7 +494,7 @@ absl::Status FrameBufferUtils::Orient(const FrameBuffer& buffer,
+                 output_buffer->format()),
+       output_buffer->dimension(), buffer.format(), buffer.orientation());
+ 
+-  RETURN_IF_ERROR(utils_->Rotate(buffer, params.rotation_angle_deg,
++  TFLITE_RETURN_IF_ERROR(utils_->Rotate(buffer, params.rotation_angle_deg,
+                                  tmp_frame_buffer.get()));
+   if (params.flip == OrientParams::FlipType::kHorizontal) {
+     return utils_->FlipHorizontally(*tmp_frame_buffer, output_buffer);
+@@ -578,7 +578,7 @@ absl::Status FrameBufferUtils::Execute(
+       temp_frame_buffer = FrameBuffer(planes, new_size, new_format,
+                                       new_orientation, buffer.timestamp());
+     }
+-    RETURN_IF_ERROR(Execute(input_frame_buffer, operation, &temp_frame_buffer));
++    TFLITE_RETURN_IF_ERROR(Execute(input_frame_buffer, operation, &temp_frame_buffer));
+   }
+   return absl::OkStatus();
+ }
+@@ -652,9 +652,9 @@ absl::Status FrameBufferUtils::Preprocess(
+   // Execute the processing pipeline.
+   if (frame_buffer_operations.empty()) {
+     // Using resize to perform copy.
+-    RETURN_IF_ERROR(Resize(buffer, output_buffer));
++    TFLITE_RETURN_IF_ERROR(Resize(buffer, output_buffer));
+   } else {
+-    RETURN_IF_ERROR(Execute(buffer, frame_buffer_operations, output_buffer));
++    TFLITE_RETURN_IF_ERROR(Execute(buffer, frame_buffer_operations, output_buffer));
+   }
+   return absl::OkStatus();
+ }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_tensor_specs.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_tensor_specs.cc
+index 392df5e40c662..b0355a2b69e26 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_tensor_specs.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_tensor_specs.cc
+@@ -90,7 +90,7 @@ StatusOr<const ImageProperties*> GetImagePropertiesIfAny(
+ 
+ StatusOr<absl::optional<NormalizationOptions>> GetNormalizationOptionsIfAny(
+     const TensorMetadata& tensor_metadata) {
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       const tflite::ProcessUnit* normalization_process_unit,
+       ModelMetadataExtractor::FindFirstProcessUnit(
+           tensor_metadata, tflite::ProcessUnitOptions_NormalizationOptions));
+@@ -140,14 +140,14 @@ StatusOr<absl::optional<NormalizationOptions>> GetNormalizationOptionsIfAny(
+ StatusOr<ImageTensorSpecs> BuildInputImageTensorSpecs(
+     const TfLiteEngine::Interpreter& interpreter,
+     const tflite::metadata::ModelMetadataExtractor& metadata_extractor) {
+-  ASSIGN_OR_RETURN(const TensorMetadata* metadata,
++  TFLITE_ASSIGN_OR_RETURN(const TensorMetadata* metadata,
+                    GetInputTensorMetadataIfAny(metadata_extractor));
+ 
+   const ImageProperties* props = nullptr;
+   absl::optional<NormalizationOptions> normalization_options;
+   if (metadata != nullptr) {
+-    ASSIGN_OR_RETURN(props, GetImagePropertiesIfAny(*metadata));
+-    ASSIGN_OR_RETURN(normalization_options,
++    TFLITE_ASSIGN_OR_RETURN(props, GetImagePropertiesIfAny(*metadata));
++    TFLITE_ASSIGN_OR_RETURN(normalization_options,
+                      GetNormalizationOptionsIfAny(*metadata));
+   }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_utils.cc
+index 0a0b1b93423fe..c9910c0073d05 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/image_utils.cc
+@@ -63,7 +63,7 @@ StatusOr<ImageData> DecodeImageFromFile(const std::string& file_name) {
+   image_data.pixel_data = stbi_load(file_name.c_str(), &image_data.width,
+                                     &image_data.height, &image_data.channels,
+                                     /*desired_channels=*/0);
+-  RETURN_IF_ERROR(CheckImageData(image_data));
++  TFLITE_RETURN_IF_ERROR(CheckImageData(image_data));
+   return image_data;
+ }
+ 
+@@ -73,7 +73,7 @@ tflite::support::StatusOr<ImageData> DecodeImageFromBuffer(
+   image_data.pixel_data = stbi_load_from_memory(
+       buffer, len, &image_data.width, &image_data.height, &image_data.channels,
+       /*desired_channels=*/0);
+-  RETURN_IF_ERROR(CheckImageData(image_data));
++  TFLITE_RETURN_IF_ERROR(CheckImageData(image_data));
+   return image_data;
+ }
+ 
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/libyuv_frame_buffer_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/libyuv_frame_buffer_utils.cc
+index 623326d5cba49..f697ab800cb12 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/libyuv_frame_buffer_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/libyuv_frame_buffer_utils.cc
+@@ -47,7 +47,7 @@ namespace {
+ // Supported output format includes RGB24 and YV21.
+ absl::Status ConvertFromNv12(const FrameBuffer& buffer,
+                              FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+   switch (output_buffer->format()) {
+     case FrameBuffer::Format::kRGB: {
+@@ -83,7 +83,7 @@ absl::Status ConvertFromNv12(const FrameBuffer& buffer,
+     }
+     case FrameBuffer::Format::kYV12:
+     case FrameBuffer::Format::kYV21: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       int ret = libyuv::NV12ToI420(
+           yuv_data.y_buffer, yuv_data.y_row_stride, yuv_data.u_buffer,
+@@ -100,13 +100,13 @@ absl::Status ConvertFromNv12(const FrameBuffer& buffer,
+       break;
+     }
+     case FrameBuffer::Format::kNV21: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       libyuv::CopyPlane(yuv_data.y_buffer, yuv_data.y_row_stride,
+                         const_cast<uint8*>(output_data.y_buffer),
+                         output_data.y_row_stride, buffer.dimension().width,
+                         buffer.dimension().height);
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           const FrameBuffer::Dimension uv_plane_dimension,
+           GetUvPlaneDimension(buffer.dimension(), buffer.format()));
+       libyuv::SwapUVPlane(yuv_data.u_buffer, yuv_data.uv_row_stride,
+@@ -134,7 +134,7 @@ absl::Status ConvertFromNv12(const FrameBuffer& buffer,
+ // Supported output format includes RGB24 and YV21.
+ absl::Status ConvertFromNv21(const FrameBuffer& buffer,
+                              FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+   switch (output_buffer->format()) {
+     case FrameBuffer::Format::kRGB: {
+@@ -170,7 +170,7 @@ absl::Status ConvertFromNv21(const FrameBuffer& buffer,
+     }
+     case FrameBuffer::Format::kYV12:
+     case FrameBuffer::Format::kYV21: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       int ret = libyuv::NV21ToI420(
+           yuv_data.y_buffer, yuv_data.y_row_stride, yuv_data.v_buffer,
+@@ -187,13 +187,13 @@ absl::Status ConvertFromNv21(const FrameBuffer& buffer,
+       break;
+     }
+     case FrameBuffer::Format::kNV12: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       libyuv::CopyPlane(yuv_data.y_buffer, yuv_data.y_row_stride,
+                         const_cast<uint8*>(output_data.y_buffer),
+                         output_data.y_row_stride, buffer.dimension().width,
+                         buffer.dimension().height);
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           const FrameBuffer::Dimension uv_plane_dimension,
+           GetUvPlaneDimension(buffer.dimension(), buffer.format()));
+       libyuv::SwapUVPlane(yuv_data.v_buffer, yuv_data.uv_row_stride,
+@@ -224,7 +224,7 @@ absl::Status ConvertFromNv21(const FrameBuffer& buffer,
+ // Supported output format includes RGB24, NV12, and NV21.
+ absl::Status ConvertFromYv(const FrameBuffer& buffer,
+                            FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData yuv_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+   switch (output_buffer->format()) {
+     case FrameBuffer::Format::kRGB: {
+@@ -259,7 +259,7 @@ absl::Status ConvertFromYv(const FrameBuffer& buffer,
+       break;
+     }
+     case FrameBuffer::Format::kNV12: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       int ret = libyuv::I420ToNV12(
+           yuv_data.y_buffer, yuv_data.y_row_stride, yuv_data.u_buffer,
+@@ -275,7 +275,7 @@ absl::Status ConvertFromYv(const FrameBuffer& buffer,
+       break;
+     }
+     case FrameBuffer::Format::kNV21: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       int ret = libyuv::I420ToNV21(
+           yuv_data.y_buffer, yuv_data.y_row_stride, yuv_data.u_buffer,
+@@ -300,9 +300,9 @@ absl::Status ConvertFromYv(const FrameBuffer& buffer,
+     }
+     case FrameBuffer::Format::kYV12:
+     case FrameBuffer::Format::kYV21: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_yuv_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_yuv_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           const FrameBuffer::Dimension uv_plane_dimension,
+           GetUvPlaneDimension(buffer.dimension(), buffer.format()));
+       libyuv::CopyPlane(yuv_data.y_buffer, yuv_data.y_row_stride,
+@@ -333,9 +333,9 @@ absl::Status ConvertFromYv(const FrameBuffer& buffer,
+ absl::Status ResizeYv(
+     const FrameBuffer& buffer, FrameBuffer* output_buffer,
+     libyuv::FilterMode interpolation = libyuv::FilterMode::kFilterBilinear) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   // TODO(b/151217096): Choose the optimal image resizing filter to optimize
+   // the model inference performance.
+@@ -360,9 +360,9 @@ absl::Status ResizeYv(
+ absl::Status ResizeNv(
+     const FrameBuffer& buffer, FrameBuffer* output_buffer,
+     libyuv::FilterMode interpolation = libyuv::FilterMode::kFilterBilinear) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   const uint8* src_uv = input_data.u_buffer;
+   const uint8* dst_uv = output_data.u_buffer;
+@@ -391,7 +391,7 @@ absl::Status ResizeNv(
+ // in `dest_argb`.
+ absl::Status ConvertRgbToArgb(const FrameBuffer& buffer, uint8* dest_argb,
+                               int dest_stride_argb) {
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
+   if (buffer.format() != FrameBuffer::Format::kRGB) {
+     return CreateStatusWithPayload(StatusCode::kInternal,
+                                    "RGB input format is expected.",
+@@ -428,7 +428,7 @@ absl::Status ConvertRgbToArgb(const FrameBuffer& buffer, uint8* dest_argb,
+ // stores the conversion result in `output_buffer`.
+ absl::Status ConvertArgbToRgb(uint8* src_argb, int src_stride_argb,
+                               FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
+   if (output_buffer->format() != FrameBuffer::Format::kRGB) {
+     return absl::InternalError("RGB input format is expected.");
+   }
+@@ -464,7 +464,7 @@ absl::Status ConvertArgbToRgb(uint8* src_argb, int src_stride_argb,
+ // memory) format and stores the conversion result in `dest_argb`.
+ absl::Status ConvertRgbaToArgb(const FrameBuffer& buffer, uint8* dest_argb,
+                                int dest_stride_argb) {
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
+   if (buffer.format() != FrameBuffer::Format::kRGBA) {
+     return CreateStatusWithPayload(
+         StatusCode::kInternal, "RGBA input format is expected.",
+@@ -529,15 +529,15 @@ absl::Status ConvertFromRgb(const FrameBuffer& buffer,
+         output_buffer->format() == FrameBuffer::Format::kNV21) {
+       tmp_yuv_buffer = absl::make_unique<uint8[]>(
+           GetFrameBufferByteSize(buffer.dimension(), output_buffer->format()));
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           yuv_frame_buffer,
+           CreateFromRawBuffer(tmp_yuv_buffer.get(), buffer.dimension(),
+                               FrameBuffer::Format::kYV21,
+                               output_buffer->orientation()));
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           yuv_data, FrameBuffer::GetYuvDataFromFrameBuffer(*yuv_frame_buffer));
+     } else {
+-      ASSIGN_OR_RETURN(yuv_data,
++      TFLITE_ASSIGN_OR_RETURN(yuv_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+     }
+     int ret = libyuv::RAWToI420(
+@@ -592,7 +592,7 @@ absl::Status ConvertFromRgba(const FrameBuffer& buffer,
+                                                     FrameBuffer::Format::kRGBA);
+       auto argb_buffer = absl::make_unique<uint8[]>(argb_buffer_size);
+       const int argb_row_bytes = buffer.dimension().width * kRgbaPixelBytes;
+-      RETURN_IF_ERROR(
++      TFLITE_RETURN_IF_ERROR(
+           ConvertRgbaToArgb(buffer, argb_buffer.get(), argb_row_bytes));
+ 
+       // Convert ARGB to kGRAY
+@@ -609,7 +609,7 @@ absl::Status ConvertFromRgba(const FrameBuffer& buffer,
+       break;
+     }
+     case FrameBuffer::Format::kNV12: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       int ret = libyuv::ABGRToNV12(
+           buffer.plane(0).buffer, buffer.plane(0).stride.row_stride_bytes,
+@@ -624,7 +624,7 @@ absl::Status ConvertFromRgba(const FrameBuffer& buffer,
+       break;
+     }
+     case FrameBuffer::Format::kNV21: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       int ret = libyuv::ABGRToNV21(
+           buffer.plane(0).buffer, buffer.plane(0).stride.row_stride_bytes,
+@@ -640,7 +640,7 @@ absl::Status ConvertFromRgba(const FrameBuffer& buffer,
+     }
+     case FrameBuffer::Format::kYV12:
+     case FrameBuffer::Format::kYV21: {
+-      ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++      TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                        FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+       int ret = libyuv::ABGRToI420(
+           buffer.plane(0).buffer, buffer.plane(0).stride.row_stride_bytes,
+@@ -729,7 +729,7 @@ absl::Status RotateRgb(const FrameBuffer& buffer, int angle_deg,
+       GetFrameBufferByteSize(buffer.dimension(), FrameBuffer::Format::kRGBA);
+   auto argb_buffer = absl::make_unique<uint8[]>(argb_buffer_size);
+   const int argb_row_bytes = buffer.dimension().width * kRgbaPixelBytes;
+-  RETURN_IF_ERROR(ConvertRgbToArgb(buffer, argb_buffer.get(), argb_row_bytes));
++  TFLITE_RETURN_IF_ERROR(ConvertRgbToArgb(buffer, argb_buffer.get(), argb_row_bytes));
+ 
+   // Rotate ARGB
+   auto argb_rotated_buffer = absl::make_unique<uint8[]>(argb_buffer_size);
+@@ -776,9 +776,9 @@ absl::Status RotateGray(const FrameBuffer& buffer, int angle_deg,
+ // Rotates YV12/YV21 frame buffer.
+ absl::Status RotateYv(const FrameBuffer& buffer, int angle_deg,
+                       FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   int ret = libyuv::I420Rotate(
+       input_data.y_buffer, input_data.y_row_stride, input_data.u_buffer,
+@@ -807,19 +807,19 @@ absl::Status RotateNv(const FrameBuffer& buffer, int angle_deg,
+                                    "kNV12 or kNV21 input formats are expected.",
+                                    TfLiteSupportStatus::kImageProcessingError);
+   }
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   const int rotated_buffer_size = GetFrameBufferByteSize(
+       output_buffer->dimension(), FrameBuffer::Format::kYV21);
+   auto rotated_yuv_raw_buffer = absl::make_unique<uint8[]>(rotated_buffer_size);
+-  ASSIGN_OR_RETURN(std::unique_ptr<FrameBuffer> rotated_yuv_buffer,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<FrameBuffer> rotated_yuv_buffer,
+                    CreateFromRawBuffer(
+                        rotated_yuv_raw_buffer.get(), output_buffer->dimension(),
+                        /*target_format=*/FrameBuffer::Format::kYV21,
+                        output_buffer->orientation()));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData rotated_yuv_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData rotated_yuv_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*rotated_yuv_buffer));
+   // Get the first chroma plane and use it as the u plane. This is a workaround
+   // for optimizing NV21 rotation. For NV12, the implementation is logical
+@@ -875,7 +875,7 @@ absl::Status FlipPlaneVertically(const FrameBuffer& buffer,
+         TfLiteSupportStatus::kImageProcessingError);
+   }
+ 
+-  ASSIGN_OR_RETURN(int pixel_stride, GetPixelStrides(buffer.format()));
++  TFLITE_ASSIGN_OR_RETURN(int pixel_stride, GetPixelStrides(buffer.format()));
+ 
+   // Flip vertically is achieved by passing in negative height.
+   libyuv::CopyPlane(buffer.plane(0).buffer,
+@@ -899,7 +899,7 @@ absl::Status CropPlane(const FrameBuffer& buffer, int x0, int y0, int x1,
+         TfLiteSupportStatus::kImageProcessingError);
+   }
+ 
+-  ASSIGN_OR_RETURN(int pixel_stride, GetPixelStrides(buffer.format()));
++  TFLITE_ASSIGN_OR_RETURN(int pixel_stride, GetPixelStrides(buffer.format()));
+   FrameBuffer::Dimension crop_dimension = GetCropDimension(x0, x1, y0, y1);
+ 
+   // Cropping is achieved by adjusting origin to (x0, y0).
+@@ -919,9 +919,9 @@ absl::Status CropPlane(const FrameBuffer& buffer, int x0, int y0, int x1,
+ // position (x0, y0) and the bottom right pixel position (x1, y1).
+ absl::Status CropNv(const FrameBuffer& buffer, int x0, int y0, int x1, int y1,
+                     FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   // Crop Y plane by copying the buffer with the origin offset to (x0, y0).
+   int crop_offset_y = input_data.y_row_stride * y0 + x0;
+@@ -937,8 +937,8 @@ absl::Status CropNv(const FrameBuffer& buffer, int x0, int y0, int x1, int y1,
+   // bounding box with odd X or Y starting positions.
+   int crop_offset_chroma = input_data.uv_row_stride * (y0 / 2) +
+                            input_data.uv_pixel_stride * (x0 / 2);
+-  ASSIGN_OR_RETURN(const uint8* input_chroma_buffer, GetUvRawBuffer(buffer));
+-  ASSIGN_OR_RETURN(const uint8* output_chroma_buffer,
++  TFLITE_ASSIGN_OR_RETURN(const uint8* input_chroma_buffer, GetUvRawBuffer(buffer));
++  TFLITE_ASSIGN_OR_RETURN(const uint8* output_chroma_buffer,
+                    GetUvRawBuffer(*output_buffer));
+   libyuv::CopyPlane(
+       input_chroma_buffer + crop_offset_chroma, input_data.uv_row_stride,
+@@ -951,9 +951,9 @@ absl::Status CropNv(const FrameBuffer& buffer, int x0, int y0, int x1, int y1,
+ // position (x0, y0) and the bottom right pixel position (x1, y1).
+ absl::Status CropYv(const FrameBuffer& buffer, int x0, int y0, int x1, int y1,
+                     FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   // Crop Y plane by copying the buffer with the origin offset to (x0, y0).
+   int crop_offset_y = input_data.y_row_stride * y0 + x0;
+@@ -964,7 +964,7 @@ absl::Status CropYv(const FrameBuffer& buffer, int x0, int y0, int x1, int y1,
+       crop_dimension.width, crop_dimension.height);
+   // Crop U plane by copying the buffer with the origin offset to
+   // (x0 / 2, y0 / 2).
+-  ASSIGN_OR_RETURN(const FrameBuffer::Dimension crop_uv_dimension,
++  TFLITE_ASSIGN_OR_RETURN(const FrameBuffer::Dimension crop_uv_dimension,
+                    GetUvPlaneDimension(crop_dimension, buffer.format()));
+   // TODO(b/152629712): Investigate the impact of color shifting caused by the
+   // bounding box with odd X or Y starting positions.
+@@ -1002,7 +1002,7 @@ absl::Status CropResizeYuv(const FrameBuffer& buffer, int x0, int y0, int x1,
+             TfLiteSupportStatus::kImageProcessingError);
+     }
+   }
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+   // Cropping YUV planes by offsetting the origins of each plane.
+   // TODO(b/152629712): Investigate the impact of color shifting caused by the
+@@ -1119,7 +1119,7 @@ absl::Status ResizeRgb(
+       GetFrameBufferByteSize(buffer.dimension(), FrameBuffer::Format::kRGBA);
+   auto argb_buffer = absl::make_unique<uint8[]>(argb_buffer_size);
+   const int argb_row_bytes = buffer.dimension().width * kRgbaPixelBytes;
+-  RETURN_IF_ERROR(ConvertRgbToArgb(buffer, argb_buffer.get(), argb_row_bytes));
++  TFLITE_RETURN_IF_ERROR(ConvertRgbToArgb(buffer, argb_buffer.get(), argb_row_bytes));
+ 
+   // Resize ARGB
+   int resized_argb_buffer_size = GetFrameBufferByteSize(
+@@ -1201,12 +1201,12 @@ absl::Status ResizeRgba(
+ // Flips NV12/NV21 FrameBuffer horizontally.
+ absl::Status FlipHorizontallyNv(const FrameBuffer& buffer,
+                                 FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+-  ASSIGN_OR_RETURN(const uint8* input_chroma_buffer, GetUvRawBuffer(buffer));
+-  ASSIGN_OR_RETURN(const uint8* output_chroma_buffer,
++  TFLITE_ASSIGN_OR_RETURN(const uint8* input_chroma_buffer, GetUvRawBuffer(buffer));
++  TFLITE_ASSIGN_OR_RETURN(const uint8* output_chroma_buffer,
+                    GetUvRawBuffer(*output_buffer));
+ 
+   int ret = libyuv::NV12Mirror(
+@@ -1228,9 +1228,9 @@ absl::Status FlipHorizontallyNv(const FrameBuffer& buffer,
+ // Flips YV12/YV21 FrameBuffer horizontally.
+ absl::Status FlipHorizontallyYv(const FrameBuffer& buffer,
+                                 FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   int ret = libyuv::I420Mirror(
+       input_data.y_buffer, input_data.y_row_stride, input_data.u_buffer,
+@@ -1251,9 +1251,9 @@ absl::Status FlipHorizontallyYv(const FrameBuffer& buffer,
+ // Flips NV12/NV21 FrameBuffer vertically.
+ absl::Status FlipVerticallyNv(const FrameBuffer& buffer,
+                               FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   // Flip Y plane vertically by passing a negative height.
+   libyuv::CopyPlane(input_data.y_buffer, input_data.y_row_stride,
+@@ -1261,10 +1261,10 @@ absl::Status FlipVerticallyNv(const FrameBuffer& buffer,
+                     output_data.y_row_stride, buffer.dimension().width,
+                     -output_buffer->dimension().height);
+   // Flip UV plane vertically by passing a negative height.
+-  ASSIGN_OR_RETURN(const uint8* input_chroma_buffer, GetUvRawBuffer(buffer));
+-  ASSIGN_OR_RETURN(const uint8* output_chroma_buffer,
++  TFLITE_ASSIGN_OR_RETURN(const uint8* input_chroma_buffer, GetUvRawBuffer(buffer));
++  TFLITE_ASSIGN_OR_RETURN(const uint8* output_chroma_buffer,
+                    GetUvRawBuffer(*output_buffer));
+-  ASSIGN_OR_RETURN(const FrameBuffer::Dimension uv_plane_dimension,
++  TFLITE_ASSIGN_OR_RETURN(const FrameBuffer::Dimension uv_plane_dimension,
+                    GetUvPlaneDimension(buffer.dimension(), buffer.format()));
+   libyuv::CopyPlane(
+       input_chroma_buffer, input_data.uv_row_stride,
+@@ -1276,9 +1276,9 @@ absl::Status FlipVerticallyNv(const FrameBuffer& buffer,
+ // Flips NV12/NV21 FrameBuffer vertically.
+ absl::Status FlipVerticallyYv(const FrameBuffer& buffer,
+                               FrameBuffer* output_buffer) {
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData input_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(buffer));
+-  ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
++  TFLITE_ASSIGN_OR_RETURN(FrameBuffer::YuvData output_data,
+                    FrameBuffer::GetYuvDataFromFrameBuffer(*output_buffer));
+   // Flip buffer vertically by passing a negative height.
+   int ret = libyuv::I420Copy(
+@@ -1326,7 +1326,7 @@ absl::Status CropResize(const FrameBuffer& buffer, int x0, int y0, int x1,
+     return CropPlane(buffer, x0, y0, x1, y1, output_buffer);
+   }
+ 
+-  ASSIGN_OR_RETURN(int pixel_stride, GetPixelStrides(buffer.format()));
++  TFLITE_ASSIGN_OR_RETURN(int pixel_stride, GetPixelStrides(buffer.format()));
+   // Cropping is achieved by adjusting origin to (x0, y0).
+   int adjusted_offset =
+       buffer.plane(0).stride.row_stride_bytes * y0 + x0 * pixel_stride;
+@@ -1357,11 +1357,11 @@ absl::Status CropResize(const FrameBuffer& buffer, int x0, int y0, int x1,
+ absl::Status LibyuvFrameBufferUtils::Crop(const FrameBuffer& buffer, int x0,
+                                           int y0, int x1, int y1,
+                                           FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
++  TFLITE_RETURN_IF_ERROR(
+       ValidateCropBufferInputs(buffer, *output_buffer, x0, y0, x1, y1));
+-  RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
+ 
+   switch (buffer.format()) {
+     case FrameBuffer::Format::kRGBA:
+@@ -1383,7 +1383,7 @@ absl::Status LibyuvFrameBufferUtils::Crop(const FrameBuffer& buffer, int x0,
+ 
+ absl::Status LibyuvFrameBufferUtils::Resize(const FrameBuffer& buffer,
+                                             FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(ValidateResizeBufferInputs(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateResizeBufferInputs(buffer, *output_buffer));
+   switch (buffer.format()) {
+     case FrameBuffer::Format::kYV12:
+     case FrameBuffer::Format::kYV21:
+@@ -1407,7 +1407,7 @@ absl::Status LibyuvFrameBufferUtils::Resize(const FrameBuffer& buffer,
+ 
+ absl::Status LibyuvFrameBufferUtils::ResizeNearestNeighbor(
+     const FrameBuffer& buffer, FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(ValidateResizeBufferInputs(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateResizeBufferInputs(buffer, *output_buffer));
+   switch (buffer.format()) {
+     case FrameBuffer::Format::kYV12:
+     case FrameBuffer::Format::kYV21:
+@@ -1432,11 +1432,11 @@ absl::Status LibyuvFrameBufferUtils::ResizeNearestNeighbor(
+ absl::Status LibyuvFrameBufferUtils::Rotate(const FrameBuffer& buffer,
+                                             int angle_deg,
+                                             FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       ValidateRotateBufferInputs(buffer, *output_buffer, angle_deg));
+-  RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
+ 
+   switch (buffer.format()) {
+     case FrameBuffer::Format::kGRAY:
+@@ -1461,10 +1461,10 @@ absl::Status LibyuvFrameBufferUtils::Rotate(const FrameBuffer& buffer,
+ 
+ absl::Status LibyuvFrameBufferUtils::FlipHorizontally(
+     const FrameBuffer& buffer, FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
+-  RETURN_IF_ERROR(ValidateFlipBufferInputs(buffer, *output_buffer));
+-  RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateFlipBufferInputs(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
+ 
+   switch (buffer.format()) {
+     case FrameBuffer::Format::kRGBA:
+@@ -1489,10 +1489,10 @@ absl::Status LibyuvFrameBufferUtils::FlipHorizontally(
+ 
+ absl::Status LibyuvFrameBufferUtils::FlipVertically(
+     const FrameBuffer& buffer, FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
+-  RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
+-  RETURN_IF_ERROR(ValidateFlipBufferInputs(buffer, *output_buffer));
+-  RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferPlaneMetadata(*output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateFlipBufferInputs(buffer, *output_buffer));
++  TFLITE_RETURN_IF_ERROR(ValidateBufferFormats(buffer, *output_buffer));
+ 
+   switch (buffer.format()) {
+     case FrameBuffer::Format::kRGBA:
+@@ -1515,7 +1515,7 @@ absl::Status LibyuvFrameBufferUtils::FlipVertically(
+ 
+ absl::Status LibyuvFrameBufferUtils::Convert(const FrameBuffer& buffer,
+                                              FrameBuffer* output_buffer) {
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       ValidateConvertFormats(buffer.format(), output_buffer->format()));
+   switch (buffer.format()) {
+     case FrameBuffer::Format::kNV12:
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/score_calibration.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/score_calibration.cc
+index f3cfc495ceb10..9e8bd33934867 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/score_calibration.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/vision/utils/score_calibration.cc
+@@ -231,7 +231,7 @@ StatusOr<SigmoidCalibrationParameters> BuildSigmoidCalibrationParams(
+     if (lines[i].empty()) {
+       continue;
+     }
+-    ASSIGN_OR_RETURN(Sigmoid sigmoid, SigmoidFromLabelAndLine(
++    TFLITE_ASSIGN_OR_RETURN(Sigmoid sigmoid, SigmoidFromLabelAndLine(
+                                           label_map_items[i].name, lines[i]));
+     sigmoid_vector.emplace_back(std::move(sigmoid));
+   }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/processor/embedding_searcher_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/processor/embedding_searcher_test.cc
+index 720cc00f60323..a70b5100a2ff3 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/processor/embedding_searcher_test.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/processor/embedding_searcher_test.cc
+@@ -84,13 +84,13 @@ StatusOr<absl::string_view> GetIndexFileContentFromMetadata(
+ StatusOr<std::string> GetIndexFileContentFromModelFile(
+     const std::string& model_path) {
+   auto engine = std::make_unique<core::TfLiteEngine>();
+-  RETURN_IF_ERROR(engine->BuildModelFromFile(model_path));
++  TFLITE_RETURN_IF_ERROR(engine->BuildModelFromFile(model_path));
+ 
+   const tflite::metadata::ModelMetadataExtractor* metadata_extractor =
+       engine->metadata_extractor();
+   const TensorMetadata* tensor_metadata =
+       metadata_extractor->GetOutputTensorMetadata(0);
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       absl::string_view index_file_content,
+       GetIndexFileContentFromMetadata(*metadata_extractor, *tensor_metadata));
+ 
+@@ -103,7 +103,7 @@ StatusOr<std::string> GetIndexFileContentFromModelFile(
+ StatusOr<std::string> GetFileContent(const std::string& file_path) {
+   tflite::task::core::ExternalFile external_file;
+   external_file.set_file_name(file_path);
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       auto handler,
+       core::ExternalFileHandler::CreateFromExternalFile(&external_file));
+   absl::string_view file_content = handler->GetFileContent();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_classifier_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_classifier_test.cc
+index 2ea2c578f0d40..8cc04ca191fdc 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_classifier_test.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_classifier_test.cc
+@@ -556,16 +556,16 @@ class PostprocessTest : public tflite::testing::Test {
+ 
+     static StatusOr<std::unique_ptr<TestImageClassifier>> CreateFromOptions(
+         const ImageClassifierOptions& options) {
+-      RETURN_IF_ERROR(SanityCheckOptions(options));
++      TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+       auto options_copy = absl::make_unique<ImageClassifierOptions>(options);
+ 
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           auto image_classifier,
+           TaskAPIFactory::CreateFromExternalFileProto<TestImageClassifier>(
+               &options_copy->model_file_with_metadata()));
+ 
+-      RETURN_IF_ERROR(image_classifier->Init(std::move(options_copy)));
++      TFLITE_RETURN_IF_ERROR(image_classifier->Init(std::move(options_copy)));
+ 
+       return image_classifier;
+     }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_segmenter_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_segmenter_test.cc
+index 712c9a3dead7e..1c49b3630f91c 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_segmenter_test.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/image_segmenter_test.cc
+@@ -386,16 +386,16 @@ class PostprocessTest : public tflite::testing::Test {
+ 
+     static StatusOr<std::unique_ptr<TestImageSegmenter>> CreateFromOptions(
+         const ImageSegmenterOptions& options) {
+-      RETURN_IF_ERROR(SanityCheckOptions(options));
++      TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+       auto options_copy = absl::make_unique<ImageSegmenterOptions>(options);
+ 
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           auto image_segmenter,
+           TaskAPIFactory::CreateFromExternalFileProto<TestImageSegmenter>(
+               &options_copy->model_file_with_metadata()));
+ 
+-      RETURN_IF_ERROR(image_segmenter->Init(std::move(options_copy)));
++      TFLITE_RETURN_IF_ERROR(image_segmenter->Init(std::move(options_copy)));
+ 
+       return image_segmenter;
+     }
+@@ -429,7 +429,7 @@ class PostprocessTest : public tflite::testing::Test {
+     confidence_scores.resize(/*width*/ 257 *
+                              /*height*/ 257 *
+                              /*classes*/ 21);
+-    RETURN_IF_ERROR(PopulateTensor(confidence_scores, output_tensor));
++    TFLITE_RETURN_IF_ERROR(PopulateTensor(confidence_scores, output_tensor));
+ 
+     return output_tensor;
+   }
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/object_detector_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/object_detector_test.cc
+index 5bae0eefb4341..511b4ba338774 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/object_detector_test.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/test/task/vision/object_detector_test.cc
+@@ -399,16 +399,16 @@ class PostprocessTest : public tflite::testing::Test {
+ 
+     static StatusOr<std::unique_ptr<TestObjectDetector>> CreateFromOptions(
+         const ObjectDetectorOptions& options) {
+-      RETURN_IF_ERROR(SanityCheckOptions(options));
++      TFLITE_RETURN_IF_ERROR(SanityCheckOptions(options));
+ 
+       auto options_copy = absl::make_unique<ObjectDetectorOptions>(options);
+ 
+-      ASSIGN_OR_RETURN(
++      TFLITE_ASSIGN_OR_RETURN(
+           auto object_detector,
+           TaskAPIFactory::CreateFromExternalFileProto<TestObjectDetector>(
+               &options_copy->model_file_with_metadata()));
+ 
+-      RETURN_IF_ERROR(object_detector->Init(std::move(options_copy)));
++      TFLITE_RETURN_IF_ERROR(object_detector->Init(std::move(options_copy)));
+ 
+       return object_detector;
+     }
+@@ -459,7 +459,7 @@ class PostprocessTest : public tflite::testing::Test {
+         /*left=*/0.2, /*top=*/0.4, /*right=*/0.4, /*bottom=*/0.8};
+     // Pad with zeros to fill the 10 locations.
+     locations_data.resize(4 * 10);
+-    RETURN_IF_ERROR(PopulateTensor(locations_data, locations));
++    TFLITE_RETURN_IF_ERROR(PopulateTensor(locations_data, locations));
+     result.push_back(locations);
+ 
+     TfLiteTensor* classes = output_tensors[1];
+@@ -467,19 +467,19 @@ class PostprocessTest : public tflite::testing::Test {
+                                        /*motorcycle*/ 3};
+     // Pad with zeros to fill the 10 classes.
+     classes_data.resize(10);
+-    RETURN_IF_ERROR(PopulateTensor(classes_data, classes));
++    TFLITE_RETURN_IF_ERROR(PopulateTensor(classes_data, classes));
+     result.push_back(classes);
+ 
+     TfLiteTensor* scores = output_tensors[2];
+     std::vector<float> scores_data = {0.8, 0.6, 0.4};
+     // Pad with zeros to fill the 10 scores.
+     scores_data.resize(10);
+-    RETURN_IF_ERROR(PopulateTensor(scores_data, scores));
++    TFLITE_RETURN_IF_ERROR(PopulateTensor(scores_data, scores));
+     result.push_back(scores);
+ 
+     TfLiteTensor* num_results = output_tensors[3];
+     std::vector<float> num_results_data = {10};
+-    RETURN_IF_ERROR(PopulateTensor(num_results_data, num_results));
++    TFLITE_RETURN_IF_ERROR(PopulateTensor(num_results_data, num_results));
+     result.push_back(num_results);
+ 
+     return result;
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc
+index bd4f18fca7f08..135de8e18f525 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/text/tokenizers/tokenizer_utils.cc
+@@ -48,7 +48,7 @@ StatusOr<absl::string_view> CheckAndLoadFirstAssociatedFile(
+         "Invalid vocab_file from input process unit.",
+         TfLiteSupportStatus::kMetadataInvalidTokenizerError);
+   }
+-  ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
++  TFLITE_ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
+                    metadata_extractor->GetAssociatedFile(
+                        associated_files->Get(0)->name()->str()));
+   return vocab_buffer;
+@@ -68,7 +68,7 @@ StatusOr<std::unique_ptr<Tokenizer>> CreateTokenizerFromProcessUnit(
+     case ProcessUnitOptions_BertTokenizerOptions: {
+       const tflite::BertTokenizerOptions* options =
+           tokenizer_process_unit->options_as<tflite::BertTokenizerOptions>();
+-      ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
++      TFLITE_ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
+                        CheckAndLoadFirstAssociatedFile(options->vocab_file(),
+                                                        metadata_extractor));
+       return absl::make_unique<BertTokenizer>(vocab_buffer.data(),
+@@ -83,7 +83,7 @@ StatusOr<std::unique_ptr<Tokenizer>> CreateTokenizerFromProcessUnit(
+     case ProcessUnitOptions_RegexTokenizerOptions: {
+       const tflite::RegexTokenizerOptions* options =
+           tokenizer_process_unit->options_as<RegexTokenizerOptions>();
+-      ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
++      TFLITE_ASSIGN_OR_RETURN(absl::string_view vocab_buffer,
+                        CheckAndLoadFirstAssociatedFile(options->vocab_file(),
+                                                        metadata_extractor));
+       if (options->delim_regex_pattern() == nullptr) {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/utils/jni_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/utils/jni_utils.cc
+index 8508f89a5cd71..8bbc4892c1706 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/utils/jni_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/cc/utils/jni_utils.cc
+@@ -99,7 +99,7 @@ tflite::support::StatusOr<Delegate> ConvertToProtoDelegate(jint delegate) {
+     case 1:
+       return Delegate::NNAPI;
+     case 2:
+-      RETURN_IF_ERROR(loadDelegatePluginLibrary("gpu"));
++      TFLITE_RETURN_IF_ERROR(loadDelegatePluginLibrary("gpu"));
+       return Delegate::GPU;
+     default:
+       break;
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_detokenizer_op.cc b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_detokenizer_op.cc
+index 273ccc8506811..a2939b0e95e4a 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_detokenizer_op.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_detokenizer_op.cc
+@@ -31,11 +31,11 @@ REGISTER_OP("TFSentencepieceDetokenizeOp")
+     .Output("output: string")
+     .SetShapeFn([](tensorflow::shape_inference::InferenceContext* c) {
+       shape_inference::ShapeHandle unused;
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));
+ 
+       shape_inference::DimensionHandle dim;
+-      TF_RETURN_IF_ERROR(c->Subtract(c->NumElements(c->input(2)), 1, &dim));
++      TF_TFLITE_RETURN_IF_ERROR(c->Subtract(c->NumElements(c->input(2)), 1, &dim));
+       c->set_output(0, c->Vector(dim));
+       return OkStatus();
+     });
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_tokenizer_op.cc b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_tokenizer_op.cc
+index f922efa883775..7fd3442d9a791 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_tokenizer_op.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/custom_ops/kernel/sentencepiece/sentencepiece_tokenizer_op.cc
+@@ -42,19 +42,19 @@ REGISTER_OP("TFSentencepieceTokenizeOp")
+     .Output("output_splits: Tsplits")
+     .SetShapeFn([](tensorflow::shape_inference::InferenceContext* c) {
+       tensorflow::shape_inference::ShapeHandle unused;
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 0, &unused));
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(3), 0, &unused));
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(4), 0, &unused));
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(5), 0, &unused));
+-      TF_RETURN_IF_ERROR(c->WithRank(c->input(6), 0, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(2), 0, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(3), 0, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(4), 0, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(5), 0, &unused));
++      TF_TFLITE_RETURN_IF_ERROR(c->WithRank(c->input(6), 0, &unused));
+ 
+       c->set_output(
+           0, c->Vector(
+                  tensorflow::shape_inference::InferenceContext::kUnknownDim));
+ 
+       tensorflow::shape_inference::DimensionHandle num_splits;
+-      TF_RETURN_IF_ERROR(c->Add(c->NumElements(c->input(1)), 1, &num_splits));
++      TF_TFLITE_RETURN_IF_ERROR(c->Add(c->NumElements(c->input(1)), 1, &num_splits));
+       c->set_output(1, c->Vector(num_splits));
+       return tensorflow::OkStatus();
+     });
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/audio/desktop/audio_classifier_lib.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/audio/desktop/audio_classifier_lib.cc
+index d739cb55f26a5..8ed0ea3d6955b 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/audio/desktop/audio_classifier_lib.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/audio/desktop/audio_classifier_lib.cc
+@@ -41,7 +41,7 @@ tflite::support::StatusOr<AudioBuffer> LoadAudioBufferFromFile(
+   uint32 decoded_sample_count;
+   uint16 decoded_channel_count;
+   uint32 decoded_sample_rate;
+-  RETURN_IF_ERROR(DecodeLin16WaveAsFloatVector(
++  TFLITE_RETURN_IF_ERROR(DecodeLin16WaveAsFloatVector(
+       contents, wav_data, offset, &decoded_sample_count, &decoded_channel_count,
+       &decoded_sample_rate));
+ 
+@@ -66,19 +66,19 @@ tflite::support::StatusOr<ClassificationResult> Classify(
+         ->mutable_tflite_settings()
+         ->set_delegate(::tflite::proto::Delegate::EDGETPU_CORAL);
+   }
+-  ASSIGN_OR_RETURN(std::unique_ptr<AudioClassifier> classifier,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<AudioClassifier> classifier,
+                    AudioClassifier::CreateFromOptions(options));
+ 
+   // `wav_data` holds data loaded from the file and needs to outlive `buffer`.
+   std::vector<float> wav_data;
+   uint32_t offset = 0;
+   uint32_t buffer_size = classifier->GetRequiredInputBufferSize();
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       AudioBuffer buffer,
+       LoadAudioBufferFromFile(wav_file, &buffer_size, &offset, &wav_data));
+ 
+   auto start_classify = std::chrono::steady_clock::now();
+-  ASSIGN_OR_RETURN(ClassificationResult result, classifier->Classify(buffer));
++  TFLITE_ASSIGN_OR_RETURN(ClassificationResult result, classifier->Classify(buffer));
+   auto end_classify = std::chrono::steady_clock::now();
+   std::string delegate = use_coral ? "Coral Edge TPU" : "CPU";
+   const auto duration_ms =
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_nl_classifier_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_nl_classifier_demo.cc
+index 02eed2332b2e4..e2d67030fe996 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_nl_classifier_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_nl_classifier_demo.cc
+@@ -50,7 +50,7 @@ absl::Status Classify() {
+         ->set_delegate(::tflite::proto::Delegate::EDGETPU_CORAL);
+   }
+ 
+-  ASSIGN_OR_RETURN(std::unique_ptr<BertNLClassifier> classifier,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<BertNLClassifier> classifier,
+                    BertNLClassifier::CreateFromOptions(options));
+ 
+   auto start_classify = steady_clock::now();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_question_answerer_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_question_answerer_demo.cc
+index 4eaa2bbbdd9f5..9cc347764364f 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_question_answerer_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/bert_question_answerer_demo.cc
+@@ -51,7 +51,7 @@ absl::Status Answer() {
+         ->set_delegate(::tflite::proto::Delegate::EDGETPU_CORAL);
+   }
+ 
+-  ASSIGN_OR_RETURN(std::unique_ptr<QuestionAnswerer> answerer,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<QuestionAnswerer> answerer,
+                    BertQuestionAnswerer::CreateFromOptions(options));
+ 
+   auto start_answer = steady_clock::now();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/nl_classifier_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/nl_classifier_demo.cc
+index 49f233ce1e74c..72ee5b656a18f 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/nl_classifier_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/nl_classifier_demo.cc
+@@ -51,7 +51,7 @@ absl::Status Classify() {
+         ->set_delegate(::tflite::proto::Delegate::EDGETPU_CORAL);
+   }
+ 
+-  ASSIGN_OR_RETURN(std::unique_ptr<NLClassifier> classifier,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<NLClassifier> classifier,
+                    NLClassifier::CreateFromOptions(options));
+ 
+   auto start_classify = steady_clock::now();
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_embedder_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_embedder_demo.cc
+index e28e5fe6a804b..7f3a11cf72795 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_embedder_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_embedder_demo.cc
+@@ -80,13 +80,13 @@ TextEmbedderOptions BuildOptions() {
+ absl::Status ComputeCosineSimilarity() {
+   // Build TextEmbedder.
+   const TextEmbedderOptions options = BuildOptions();
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       std::unique_ptr<TextEmbedder> text_embedder,
+       TextEmbedder::CreateFromOptions(options, CreateTextOpResolver()));
+ 
+   // Run search and display results.
+   auto start_embed = steady_clock::now();
+-  ASSIGN_OR_RETURN(processor::EmbeddingResult first_embedding,
++  TFLITE_ASSIGN_OR_RETURN(processor::EmbeddingResult first_embedding,
+                    text_embedder->Embed(absl::GetFlag(FLAGS_first_sentence)));
+   auto end_embed = steady_clock::now();
+   std::string delegate =
+@@ -97,10 +97,10 @@ absl::Status ComputeCosineSimilarity() {
+                    .count()
+             << " ms" << std::endl;
+ 
+-  ASSIGN_OR_RETURN(processor::EmbeddingResult second_embedding,
++  TFLITE_ASSIGN_OR_RETURN(processor::EmbeddingResult second_embedding,
+                    text_embedder->Embed(absl::GetFlag(FLAGS_second_sentence)));
+   // Compute cosine similarity.
+-  ASSIGN_OR_RETURN(double cosine_similarity,
++  TFLITE_ASSIGN_OR_RETURN(double cosine_similarity,
+                    TextEmbedder::CosineSimilarity(
+                        first_embedding.embeddings(0).feature_vector(),
+                        second_embedding.embeddings(0).feature_vector()));
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_searcher_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_searcher_demo.cc
+index 68c347c2639bb..92b9ffc8adf2b 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_searcher_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/text/desktop/text_searcher_demo.cc
+@@ -101,13 +101,13 @@ void DisplayResults(const processor::SearchResult& result) {
+ absl::Status Search() {
+   // Build TextSearcher.
+   const TextSearcherOptions options = BuildOptions();
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       std::unique_ptr<TextSearcher> text_searcher,
+       TextSearcher::CreateFromOptions(options, CreateTextOpResolver()));
+ 
+   // Run search and display results.
+   auto start_search = steady_clock::now();
+-  ASSIGN_OR_RETURN(processor::SearchResult result,
++  TFLITE_ASSIGN_OR_RETURN(processor::SearchResult result,
+                    text_searcher->Search(absl::GetFlag(FLAGS_input_sentence)));
+   auto end_search = steady_clock::now();
+   std::string delegate =
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_classifier_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_classifier_demo.cc
+index f29bd2de9c535..2650607b13191 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_classifier_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_classifier_demo.cc
+@@ -125,11 +125,11 @@ void DisplayResult(const ClassificationResult& result) {
+ absl::Status Classify() {
+   // Build ImageClassifier.
+   const ImageClassifierOptions& options = BuildOptions();
+-  ASSIGN_OR_RETURN(std::unique_ptr<ImageClassifier> image_classifier,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<ImageClassifier> image_classifier,
+                    ImageClassifier::CreateFromOptions(options));
+ 
+   // Load image in a FrameBuffer.
+-  ASSIGN_OR_RETURN(ImageData image,
++  TFLITE_ASSIGN_OR_RETURN(ImageData image,
+                    DecodeImageFromFile(absl::GetFlag(FLAGS_image_path)));
+   std::unique_ptr<FrameBuffer> frame_buffer;
+   if (image.channels == 3) {
+@@ -146,7 +146,7 @@ absl::Status Classify() {
+ 
+   // Run classification and display results.
+   auto start_classify = steady_clock::now();
+-  ASSIGN_OR_RETURN(ClassificationResult result,
++  TFLITE_ASSIGN_OR_RETURN(ClassificationResult result,
+                    image_classifier->Classify(*frame_buffer));
+   auto end_classify = steady_clock::now();
+   std::string delegate =
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_embedder_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_embedder_demo.cc
+index 50d615a486751..d5f0cb1233457 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_embedder_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_embedder_demo.cc
+@@ -106,22 +106,22 @@ StatusOr<std::unique_ptr<FrameBuffer>> BuildFrameBufferFromImageData(
+ absl::Status ComputeCosineSimilarity() {
+   // Build ImageEmbedder.
+   const ImageEmbedderOptions& options = BuildOptions();
+-  ASSIGN_OR_RETURN(std::unique_ptr<ImageEmbedder> image_embedder,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<ImageEmbedder> image_embedder,
+                    ImageEmbedder::CreateFromOptions(options));
+ 
+   // Load images into FrameBuffer objects.
+-  ASSIGN_OR_RETURN(ImageData first_image,
++  TFLITE_ASSIGN_OR_RETURN(ImageData first_image,
+                    DecodeImageFromFile(absl::GetFlag(FLAGS_first_image_path)));
+-  ASSIGN_OR_RETURN(std::unique_ptr<FrameBuffer> first_frame_buffer,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<FrameBuffer> first_frame_buffer,
+                    BuildFrameBufferFromImageData(first_image));
+-  ASSIGN_OR_RETURN(ImageData second_image,
++  TFLITE_ASSIGN_OR_RETURN(ImageData second_image,
+                    DecodeImageFromFile(absl::GetFlag(FLAGS_second_image_path)));
+-  ASSIGN_OR_RETURN(std::unique_ptr<FrameBuffer> second_frame_buffer,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<FrameBuffer> second_frame_buffer,
+                    BuildFrameBufferFromImageData(second_image));
+ 
+   // Extract feature vectors.
+   auto start_embed = steady_clock::now();
+-  ASSIGN_OR_RETURN(const EmbeddingResult& first_embedding_result,
++  TFLITE_ASSIGN_OR_RETURN(const EmbeddingResult& first_embedding_result,
+                    image_embedder->Embed(*first_frame_buffer));
+   auto end_embed = steady_clock::now();
+   std::string delegate =
+@@ -131,10 +131,10 @@ absl::Status ComputeCosineSimilarity() {
+                    .count()
+             << " ms" << std::endl;
+ 
+-  ASSIGN_OR_RETURN(const EmbeddingResult& second_embedding_result,
++  TFLITE_ASSIGN_OR_RETURN(const EmbeddingResult& second_embedding_result,
+                    image_embedder->Embed(*second_frame_buffer));
+   // Compute cosine similarity.
+-  ASSIGN_OR_RETURN(
++  TFLITE_ASSIGN_OR_RETURN(
+       double cosine_similarity,
+       ImageEmbedder::CosineSimilarity(
+           image_embedder->GetEmbeddingByIndex(first_embedding_result, 0)
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_searcher_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_searcher_demo.cc
+index b661447614bc7..0ef54df645447 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_searcher_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_searcher_demo.cc
+@@ -106,11 +106,11 @@ void DisplayResult(const processor::SearchResult& result) {
+ absl::Status Search() {
+   // Build ImageSearcher.
+   const ImageSearcherOptions options = BuildOptions();
+-  ASSIGN_OR_RETURN(std::unique_ptr<ImageSearcher> image_searcher,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<ImageSearcher> image_searcher,
+                    ImageSearcher::CreateFromOptions(options));
+ 
+   // Load image in a FrameBuffer.
+-  ASSIGN_OR_RETURN(ImageData image,
++  TFLITE_ASSIGN_OR_RETURN(ImageData image,
+                    DecodeImageFromFile(absl::GetFlag(FLAGS_image_path)));
+   std::unique_ptr<FrameBuffer> frame_buffer;
+   if (image.channels == 3) {
+@@ -127,7 +127,7 @@ absl::Status Search() {
+ 
+   // Run search and display results.
+   auto start_search = steady_clock::now();
+-  ASSIGN_OR_RETURN(processor::SearchResult result,
++  TFLITE_ASSIGN_OR_RETURN(processor::SearchResult result,
+                    image_searcher->Search(*frame_buffer));
+   auto end_search = steady_clock::now();
+   std::string delegate =
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_segmenter_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_segmenter_demo.cc
+index 5a566ecbcf921..bebbd44431c90 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_segmenter_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/image_segmenter_demo.cc
+@@ -104,7 +104,7 @@ absl::Status EncodeMaskToPngFile(const SegmentationResult& result) {
+   }
+ 
+   // Encode mask as PNG.
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       EncodeImageToPngFile(mask, absl::GetFlag(FLAGS_output_mask_png)));
+   std::cout << absl::StrFormat("Category mask saved to: %s\n",
+                                absl::GetFlag(FLAGS_output_mask_png));
+@@ -149,11 +149,11 @@ absl::Status DisplayColorLegend(const SegmentationResult& result) {
+ absl::Status Segment() {
+   // Build ImageClassifier.
+   const ImageSegmenterOptions& options = BuildOptions();
+-  ASSIGN_OR_RETURN(std::unique_ptr<ImageSegmenter> image_segmenter,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<ImageSegmenter> image_segmenter,
+                    ImageSegmenter::CreateFromOptions(options));
+ 
+   // Load image in a FrameBuffer.
+-  ASSIGN_OR_RETURN(ImageData image,
++  TFLITE_ASSIGN_OR_RETURN(ImageData image,
+                    DecodeImageFromFile(absl::GetFlag(FLAGS_image_path)));
+   std::unique_ptr<FrameBuffer> frame_buffer;
+   if (image.channels == 3) {
+@@ -170,7 +170,7 @@ absl::Status Segment() {
+ 
+   // Run segmentation and save category mask.
+   auto start_segment = steady_clock::now();
+-  ASSIGN_OR_RETURN(SegmentationResult result,
++  TFLITE_ASSIGN_OR_RETURN(SegmentationResult result,
+                    image_segmenter->Segment(*frame_buffer));
+   auto end_segment = steady_clock::now();
+   std::string delegate =
+@@ -181,10 +181,10 @@ absl::Status Segment() {
+                    .count()
+             << " ms" << std::endl;
+ 
+-  RETURN_IF_ERROR(EncodeMaskToPngFile(result));
++  TFLITE_RETURN_IF_ERROR(EncodeMaskToPngFile(result));
+ 
+   // Display the legend.
+-  RETURN_IF_ERROR(DisplayColorLegend(result));
++  TFLITE_RETURN_IF_ERROR(DisplayColorLegend(result));
+ 
+   // Cleanup and return.
+   ImageDataFree(&image);
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/object_detector_demo.cc b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/object_detector_demo.cc
+index 20f7403207c2e..28d9243e32dd8 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/object_detector_demo.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/examples/task/vision/desktop/object_detector_demo.cc
+@@ -151,7 +151,7 @@ absl::Status EncodeResultToPngFile(const DetectionResult& result,
+     }
+   }
+   // Encode to PNG and return.
+-  RETURN_IF_ERROR(
++  TFLITE_RETURN_IF_ERROR(
+       EncodeImageToPngFile(*image, absl::GetFlag(FLAGS_output_png)));
+   std::cout << absl::StrFormat("Results saved to: %s\n",
+                                absl::GetFlag(FLAGS_output_png));
+@@ -192,11 +192,11 @@ void DisplayResult(const DetectionResult& result) {
+ absl::Status Detect() {
+   // Build ObjectDetector.
+   const ObjectDetectorOptions& options = BuildOptions();
+-  ASSIGN_OR_RETURN(std::unique_ptr<ObjectDetector> object_detector,
++  TFLITE_ASSIGN_OR_RETURN(std::unique_ptr<ObjectDetector> object_detector,
+                    ObjectDetector::CreateFromOptions(options));
+ 
+   // Load image in a FrameBuffer.
+-  ASSIGN_OR_RETURN(ImageData image,
++  TFLITE_ASSIGN_OR_RETURN(ImageData image,
+                    DecodeImageFromFile(absl::GetFlag(FLAGS_image_path)));
+   std::unique_ptr<FrameBuffer> frame_buffer;
+   if (image.channels == 3) {
+@@ -213,7 +213,7 @@ absl::Status Detect() {
+ 
+   // Run object detection and draw results on input image.
+   auto start_detect = steady_clock::now();
+-  ASSIGN_OR_RETURN(DetectionResult result,
++  TFLITE_ASSIGN_OR_RETURN(DetectionResult result,
+                    object_detector->Detect(*frame_buffer));
+   auto end_detect = steady_clock::now();
+   std::string delegate =
+@@ -224,7 +224,7 @@ absl::Status Detect() {
+                    .count()
+             << " ms" << std::endl;
+ 
+-  RETURN_IF_ERROR(EncodeResultToPngFile(result, &image));
++  TFLITE_RETURN_IF_ERROR(EncodeResultToPngFile(result, &image));
+ 
+   // Display results as text.
+   DisplayResult(result);
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/java/src/native/task/vision/jni_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/java/src/native/task/vision/jni_utils.cc
+index 1b08e56ed509b..44254c23a83d4 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/java/src/native/task/vision/jni_utils.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/java/src/native/task/vision/jni_utils.cc
+@@ -179,7 +179,7 @@ StatusOr<std::unique_ptr<FrameBuffer>> CreateFrameBufferFromYuvPlanes(
+       reinterpret_cast<const uint8*>(GetMappedFileBuffer(env, jv_plane).data());
+ 
+   FrameBuffer::Format format;
+-  ASSIGN_OR_RETURN(format,
++  TFLITE_ASSIGN_OR_RETURN(format,
+                    GetYUVImageFormat(u_plane, v_plane, pixel_stride_uv));
+ 
+   return CreateFromYuvRawBuffer(
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc
+index d208da4e03780..4b3f816183c8f 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_extractor.cc
+@@ -79,7 +79,7 @@ tflite::support::StatusOr<ZipFileInfo> GetCurrentZipFileInfo(
+     const unzFile& zf) {
+   // Open file in raw mode, as data is expected to be uncompressed.
+   int method;
+-  RETURN_IF_ERROR(UnzipErrorToStatus(
++  TFLITE_RETURN_IF_ERROR(UnzipErrorToStatus(
+       unzOpenCurrentFile2(zf, &method, /*level=*/nullptr, /*raw=*/1)));
+   if (method != Z_NO_COMPRESSION) {
+     return CreateStatusWithPayload(
+@@ -89,7 +89,7 @@ tflite::support::StatusOr<ZipFileInfo> GetCurrentZipFileInfo(
+ 
+   // Get file info a first time to get filename size.
+   unz_file_info64 file_info;
+-  RETURN_IF_ERROR(UnzipErrorToStatus(unzGetCurrentFileInfo64(
++  TFLITE_RETURN_IF_ERROR(UnzipErrorToStatus(unzGetCurrentFileInfo64(
+       zf, &file_info, /*szFileName=*/nullptr, /*szFileNameBufferSize=*/0,
+       /*extraField=*/nullptr, /*extraFieldBufferSize=*/0,
+       /*szComment=*/nullptr, /*szCommentBufferSize=*/0)));
+@@ -97,7 +97,7 @@ tflite::support::StatusOr<ZipFileInfo> GetCurrentZipFileInfo(
+   // Second call to get file name.
+   auto file_name_size = file_info.size_filename;
+   char* c_file_name = (char*)malloc(file_name_size);
+-  RETURN_IF_ERROR(UnzipErrorToStatus(unzGetCurrentFileInfo64(
++  TFLITE_RETURN_IF_ERROR(UnzipErrorToStatus(unzGetCurrentFileInfo64(
+       zf, &file_info, c_file_name, file_name_size,
+       /*extraField=*/nullptr, /*extraFieldBufferSize=*/0,
+       /*szComment=*/nullptr, /*szCommentBufferSize=*/0)));
+@@ -113,7 +113,7 @@ tflite::support::StatusOr<ZipFileInfo> GetCurrentZipFileInfo(
+   }
+ 
+   // Close file and return.
+-  RETURN_IF_ERROR(UnzipErrorToStatus(unzCloseCurrentFile(zf)));
++  TFLITE_RETURN_IF_ERROR(UnzipErrorToStatus(unzCloseCurrentFile(zf)));
+ 
+   ZipFileInfo result{};
+   result.name = file_name;
+@@ -131,7 +131,7 @@ ModelMetadataExtractor::CreateFromModelBuffer(const char* buffer_data,
+   // https://abseil.io/tips/126.
+   std::unique_ptr<ModelMetadataExtractor> extractor =
+       absl::WrapUnique(new ModelMetadataExtractor());
+-  RETURN_IF_ERROR(extractor->InitFromModelBuffer(buffer_data, buffer_size));
++  TFLITE_RETURN_IF_ERROR(extractor->InitFromModelBuffer(buffer_data, buffer_size));
+   return extractor;
+ }
+ 
+@@ -261,7 +261,7 @@ absl::Status ModelMetadataExtractor::ExtractAssociatedFiles(
+   if (global_info.number_entry > 0) {
+     int error = unzGoToFirstFile(zf);
+     while (error == UNZ_OK) {
+-      ASSIGN_OR_RETURN(auto zip_file_info, GetCurrentZipFileInfo(zf));
++      TFLITE_ASSIGN_OR_RETURN(auto zip_file_info, GetCurrentZipFileInfo(zf));
+       // Store result in map.
+       associated_files_[zip_file_info.name] = absl::string_view(
+           buffer_data + zip_file_info.position, zip_file_info.size);
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc
+index 8e45119d7364d..2c2006725ec25 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc
+@@ -64,13 +64,13 @@ absl::StatusOr<std::unique_ptr<Index>> Index::CreateFromIndexBuffer(
+   // Use absl::WrapUnique() to call private constructor:
+   // https://abseil.io/tips/126.
+   std::unique_ptr<Index> index = absl::WrapUnique(new Index());
+-  RETURN_IF_ERROR(index->InitFromBuffer(buffer_data, buffer_size));
++  TFLITE_RETURN_IF_ERROR(index->InitFromBuffer(buffer_data, buffer_size));
+   return index;
+ }
+ 
+ absl::StatusOr<IndexConfig> Index::GetIndexConfig() const {
+   std::string key(kIndexConfigKey);
+-  ASSIGN_OR_RETURN(absl::string_view value,
++  TFLITE_ASSIGN_OR_RETURN(absl::string_view value,
+                    GetValueForKey(config_iterator_.get(), key));
+   IndexConfig config;
+   if (!config.ParseFromString(std::string(value))) {
+diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc
+index fe5d1ef1175e4..94c85334f0574 100644
+--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc
++++ b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc
+@@ -104,7 +104,7 @@ absl::StatusOr<std::string> CreateIndexBufferImpl(
+   }
+ 
+   std::string buffer;
+-  ASSIGN_OR_RETURN(auto mem_writable_file, MemWritableFile::Create(&buffer));
++  TFLITE_ASSIGN_OR_RETURN(auto mem_writable_file, MemWritableFile::Create(&buffer));
+ 
+   leveldb::Options options;
+   options.compression =
+-- 
+2.42.0.515.g380fc7ccd1-goog
+
diff --git a/third_party/tflite_support/src/third_party/pybind11_protobuf/com_google_protobuf.patch b/third_party/tflite_support/src/third_party/pybind11_protobuf/com_google_protobuf.patch
new file mode 100644
index 0000000000000..d3caa905ee5b8
--- /dev/null
+++ b/third_party/tflite_support/src/third_party/pybind11_protobuf/com_google_protobuf.patch
@@ -0,0 +1,25 @@
+diff --git a/BUILD b/BUILD
+index 7de87f884..adf087cef 100644
+--- a/BUILD
++++ b/BUILD
+@@ -895,6 +895,7 @@ cc_binary(
+         "//conditions:default": [],
+         ":use_fast_cpp_protos": ["//external:python_headers"],
+     }),
++    visibility = ["//visibility:public"],
+ )
+ 
+ config_setting(
+diff --git a/python/google/protobuf/pyext/descriptor.cc b/python/google/protobuf/pyext/descriptor.cc
+index 8c326efa8..605875135 100644
+--- a/python/google/protobuf/pyext/descriptor.cc
++++ b/python/google/protobuf/pyext/descriptor.cc
+@@ -100,7 +100,7 @@ PyObject* PyString_FromCppString(const std::string& str) {
+ // TODO(amauryfa): Change the proto2 compiler to remove the assignments, and
+ // remove this hack.
+ bool _CalledFromGeneratedFile(int stacklevel) {
+-#ifndef PYPY_VERSION
++#if 0  // PyFrameObject is not supported by Python 3.11
+   // This check is not critical and is somewhat difficult to implement correctly
+   // in PyPy.
+   PyFrameObject* frame = PyEval_GetFrame();
\ No newline at end of file
diff --git a/third_party/tflite_support/src/third_party/tensorflow_lite_ios_build.patch b/third_party/tflite_support/src/third_party/tensorflow_lite_ios_build.patch
new file mode 100644
index 0000000000000..2edf08b61da7e
--- /dev/null
+++ b/third_party/tflite_support/src/third_party/tensorflow_lite_ios_build.patch
@@ -0,0 +1,4 @@
+diff --git a/tensorflow/lite/ios/BUILD.apple b/tensorflow/lite/ios/BUILD
+similarity index 100%
+rename from tensorflow/lite/ios/BUILD.apple
+rename to tensorflow/lite/ios/BUILD
diff --git a/third_party/tflite_support/src/third_party/tensorflow_text_a0f49e63.patch b/third_party/tflite_support/src/third_party/tensorflow_text_a0f49e63.patch
new file mode 100644
index 0000000000000..b103ef015ea3c
--- /dev/null
+++ b/third_party/tflite_support/src/third_party/tensorflow_text_a0f49e63.patch
@@ -0,0 +1,38 @@
+This diff patches commit a0f49e63, which has been released os part of Tensorflow
+Text 2.9. We can remove this patch once we update our dependency. This has not
+been done yet due to a Protobuf incompatibility introduced by this update.
+
+diff --git a/tensorflow_text/core/kernels/regex_split.cc b/tensorflow_text/core/kernels/regex_split.cc
+index 473b922e..db422781 100644
+--- a/tensorflow_text/core/kernels/regex_split.cc
++++ b/tensorflow_text/core/kernels/regex_split.cc
+@@ -45,24 +45,24 @@ void RegexSplitImpl(absl::string_view input, const RE2& re2,
+       tokens->push_back(token);
+       // Mark the end of the last token
+       begin_offsets->push_back(token.data() - input.data());
+-      end_offsets->push_back(token.data() + token.length() - input.begin());
++      end_offsets->push_back(token.data() + token.length() - input.data());
+     }
+
+     if (should_include_delim) {
+       // If desired, include the deliminator as a token.
+       tokens->push_back(extracted_delim_token);
+       // Mark the end of the token at the end of the beginning of the delimiter.
+-      begin_offsets->push_back(extracted_delim_token.data() - input.begin());
++      begin_offsets->push_back(extracted_delim_token.data() - input.data());
+       end_offsets->push_back(extracted_delim_token.data() +
+-                             extracted_delim_token.length() - input.begin());
++                             extracted_delim_token.length() - input.data());
+     }
+   }
+
+   // Close the last token.
+   if (!leftover.empty()) {
+     tokens->push_back(leftover);
+-    begin_offsets->push_back(leftover.data() - input.begin());
+-    end_offsets->push_back(leftover.data() + leftover.length() - input.begin());
++    begin_offsets->push_back(leftover.data() - input.data());
++    end_offsets->push_back(leftover.data() + leftover.length() - input.data());
+   }
+ }
+
diff --git a/third_party/tflite_support/src/third_party/tensorflow_text_remove_tf_deps.patch b/third_party/tflite_support/src/third_party/tensorflow_text_remove_tf_deps.patch
new file mode 100644
index 0000000000000..f7b86f9f091dd
--- /dev/null
+++ b/third_party/tflite_support/src/third_party/tensorflow_text_remove_tf_deps.patch
@@ -0,0 +1,32 @@
+diff --git a/tensorflow_text/core/kernels/BUILD b/tensorflow_text/core/kernels/BUILD
+index bdca365..1c20eae 100644
+--- a/tensorflow_text/core/kernels/BUILD
++++ b/tensorflow_text/core/kernels/BUILD
+@@ -209,8 +209,12 @@ cc_library(
+     name = "regex_split",
+     srcs = ["regex_split.cc"],
+     hdrs = ["regex_split.h"],
+-    deps = OSS_DEPS + [
++    deps = [
+         # absl/strings dep
++        "@com_google_absl//absl/container:inlined_vector",
++        "@com_google_absl//absl/strings",
++        "@com_google_absl//absl/types:optional",
++        "@com_google_absl//absl/types:span",
+         "@com_google_re2//:re2",
+     ],
+ )
+@@ -437,8 +441,12 @@ cc_library(
+     name = "wordpiece_tokenizer",
+     srcs = ["wordpiece_tokenizer.cc"],
+     hdrs = ["wordpiece_tokenizer.h"],
+-    deps = OSS_DEPS + [
++    deps = [
+         # absl/strings dep
++        "@com_google_absl//absl/container:inlined_vector",
++        "@com_google_absl//absl/strings",
++        "@com_google_absl//absl/types:optional",
++        "@com_google_absl//absl/types:span",
+         "@icu//:common",
+     ],
+ )
\ No newline at end of file
diff --git a/third_party/tflite_support/src/third_party/zlib.patch b/third_party/tflite_support/src/third_party/zlib.patch
new file mode 100644
index 0000000000000..6304ed83e62fe
--- /dev/null
+++ b/third_party/tflite_support/src/third_party/zlib.patch
@@ -0,0 +1,62 @@
+diff -ruN a/contrib/minizip/ioapi.h b/contrib/minizip/ioapi.h
+--- a/contrib/minizip/ioapi.h
++++ b/contrib/minizip/ioapi.h
+@@ -21,7 +21,7 @@
+ #ifndef _ZLIBIOAPI64_H
+ #define _ZLIBIOAPI64_H
+ 
+-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
++#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__)) && (!defined(__ANDROID__))
+ 
+   // Linux needs this to support file operation on files larger then 4+GB
+   // But might need better if/def to select just the platforms that needs them.
+diff -ruN a/contrib/minizip/miniunz.c b/contrib/minizip/miniunz.c
+--- a/contrib/minizip/miniunz.c
++++ b/contrib/minizip/miniunz.c
+@@ -12,7 +12,7 @@
+          Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+ */
+ 
+-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
++#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__)) && (!defined(__ANDROID__))
+         #ifndef __USE_FILE_OFFSET64
+                 #define __USE_FILE_OFFSET64
+         #endif
+@@ -27,7 +27,7 @@
+         #endif
+ #endif
+ 
+-#ifdef __APPLE__
++#if defined(__APPLE__) || defined(IOAPI_NO_64)
+ // In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
+ #define FOPEN_FUNC(filename, mode) fopen(filename, mode)
+ #define FTELLO_FUNC(stream) ftello(stream)
+@@ -50,6 +50,7 @@
+ # include <direct.h>
+ # include <io.h>
+ #else
++# include <sys/stat.h>
+ # include <unistd.h>
+ # include <utime.h>
+ #endif
+diff -ruN a/contrib/minizip/minizip.c b/contrib/minizip/minizip.c
+--- a/contrib/minizip/minizip.c
++++ b/contrib/minizip/minizip.c
+@@ -13,7 +13,7 @@
+ */
+ 
+ 
+-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
++#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__)) && (!defined(__ANDROID__))
+         #ifndef __USE_FILE_OFFSET64
+                 #define __USE_FILE_OFFSET64
+         #endif
+@@ -28,7 +28,7 @@
+         #endif
+ #endif
+ 
+-#ifdef __APPLE__
++#if defined(__APPLE__) || defined(IOAPI_NO_64)
+ // In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
+ #define FOPEN_FUNC(filename, mode) fopen(filename, mode)
+ #define FTELLO_FUNC(stream) ftello(stream)
diff --git a/third_party/unrar/patches/chromium_changes.patch b/third_party/unrar/patches/chromium_changes.patch
new file mode 100644
index 0000000000000..269ecafc4d596
--- /dev/null
+++ b/third_party/unrar/patches/chromium_changes.patch
@@ -0,0 +1,788 @@
+diff --git a/third_party/unrar/src/archive.cpp b/third_party/unrar/src/archive.cpp
+index 4fc2a893478d6..e922295a7e29d 100644
+--- a/third_party/unrar/src/archive.cpp
++++ b/third_party/unrar/src/archive.cpp
+@@ -359,3 +359,13 @@ uint64 Archive::GetWinSize(uint64 Size,uint &Flags)
+   Flags+=(uint)Fraction*FCI_DICT_FRACT0;
+   return Pow2+Fraction*(Pow2/32);
+ }
++
++#if defined(CHROMIUM_UNRAR)
++void Archive::SetTempFileHandle(FileHandle hF) {
++  hTempFile = hF;
++}
++
++FileHandle Archive::GetTempFileHandle() {
++  return hTempFile;
++}
++#endif
+diff --git a/third_party/unrar/src/archive.hpp b/third_party/unrar/src/archive.hpp
+index db1cb533823bf..d2cd23173c37c 100644
+--- a/third_party/unrar/src/archive.hpp
++++ b/third_party/unrar/src/archive.hpp
+@@ -58,6 +58,13 @@ class Archive:public File
+     QuickOpen QOpen;
+     bool ProhibitQOpen;
+ #endif
++
++#if defined(CHROMIUM_UNRAR)
++    // A handle for a temporary file that should be used when extracting the
++    // archive. This is used to extract the contents while in a sandbox.
++    FileHandle hTempFile;
++#endif
++
+   public:
+     Archive(CommandData *InitCmd=nullptr);
+     ~Archive();
+@@ -94,6 +101,10 @@ class Archive:public File
+     int64 Tell() override;
+     void QOpenUnload() {QOpen.Unload();}
+     void SetProhibitQOpen(bool Mode) {ProhibitQOpen=Mode;}
++#endif
++#if defined(CHROMIUM_UNRAR)
++    void SetTempFileHandle(FileHandle hF);
++    FileHandle GetTempFileHandle();
+ #endif
+     static uint64 GetWinSize(uint64 Size,uint &Flags);
+ 
+diff --git a/third_party/unrar/src/crc.cpp b/third_party/unrar/src/crc.cpp
+index 61c616289ae47..6ec67f2b8a78f 100644
+--- a/third_party/unrar/src/crc.cpp
++++ b/third_party/unrar/src/crc.cpp
+@@ -21,6 +21,7 @@
+ #endif
+ 
+ static uint crc_tables[16][256]; // Tables for Slicing-by-16.
++static bool is_initialized = false;
+ 
+ #ifdef USE_NEON_CRC32
+ static bool CRC_Neon;
+@@ -74,10 +75,13 @@ static void InitTables()
+ }
+ 
+ 
+-struct CallInitCRC {CallInitCRC() {InitTables();}} static CallInit32;
+-
+ uint CRC32(uint StartCRC,const void *Addr,size_t Size)
+ {
++  if (!is_initialized) {
++    is_initialized = true;
++    InitTables();
++  }
++
+   byte *Data=(byte *)Addr;
+ 
+ #ifdef USE_NEON_CRC32
+diff --git a/third_party/unrar/src/errhnd.cpp b/third_party/unrar/src/errhnd.cpp
+index b07e2f6646de9..a202e90944cf1 100644
+--- a/third_party/unrar/src/errhnd.cpp
++++ b/third_party/unrar/src/errhnd.cpp
+@@ -1,10 +1,12 @@
++// NOTE(vakh): The process.h file needs to be included first because "rar.hpp"
++// defines certain macros that cause symbol redefinition errors
++#if defined(UNRAR_NO_EXCEPTIONS)
++#include "base/notreached.h"
++#include "base/process/process.h"
++#endif  // defined(UNRAR_NO_EXCEPTIONS)
+ #include "rar.hpp"
+ 
+-ErrorHandler::ErrorHandler()
+-{
+-  Clean();
+-}
+-
++#include <ostream>
+ 
+ void ErrorHandler::Clean()
+ {
+@@ -342,7 +344,11 @@ void ErrorHandler::Throw(RAR_EXIT Code)
+       mprintf(L"\n%s\n",St(MProgAborted));
+ #endif
+   SetErrorCode(Code);
++#if defined(UNRAR_NO_EXCEPTIONS)
++  NOTREACHED() << "Failed with RAR_EXIT code: " << Code;
++#else
+   throw Code;
++#endif  // defined(UNRAR_NO_EXCEPTIONS)
+ }
+ 
+ 
+diff --git a/third_party/unrar/src/errhnd.hpp b/third_party/unrar/src/errhnd.hpp
+index 065350f94af55..5c539faf0d82a 100644
+--- a/third_party/unrar/src/errhnd.hpp
++++ b/third_party/unrar/src/errhnd.hpp
+@@ -24,14 +24,13 @@ enum RAR_EXIT // RAR exit code.
+ class ErrorHandler
+ {
+   private:
+-    RAR_EXIT ExitCode;
+-    uint ErrCount;
+-    bool EnableBreak;
+-    bool Silent;
+-    bool DisableShutdown; // Shutdown is not suitable after last error.
+-    bool ReadErrIgnoreAll;
++    RAR_EXIT ExitCode = RARX_SUCCESS;
++    uint ErrCount = 0;
++    bool EnableBreak = true;
++    bool Silent = false;
++    bool DisableShutdown = false; // Shutdown is not suitable after last error.
++    bool ReadErrIgnoreAll = false;
+   public:
+-    ErrorHandler();
+     void Clean();
+     void MemoryError();
+     void OpenError(const std::wstring &FileName);
+@@ -68,8 +67,8 @@ class ErrorHandler
+     void SetDisableShutdown() {DisableShutdown=true;}
+     bool IsShutdownEnabled() {return !DisableShutdown;}
+ 
+-    bool UserBreak; // Ctrl+Break is pressed.
+-    bool MainExit; // main() is completed.
++    bool UserBreak = false; // Ctrl+Break is pressed.
++    bool MainExit = false; // main() is completed.
+ };
+ 
+ 
+diff --git a/third_party/unrar/src/extract.cpp b/third_party/unrar/src/extract.cpp
+index c433fb8963e8a..80ce16530d0d8 100644
+--- a/third_party/unrar/src/extract.cpp
++++ b/third_party/unrar/src/extract.cpp
+@@ -665,6 +665,11 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
+       ExtrFile=LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);
+ 
+     File CurFile;
++#if defined(CHROMIUM_UNRAR)
++    // Since extraction is done in a sandbox, this must extract to the temp file
++    // handle instead of the default.
++    CurFile.SetFileHandle(Arc.GetTempFileHandle());
++#endif
+ 
+     bool LinkEntry=Arc.FileHead.RedirType!=FSREDIR_NONE;
+     if (LinkEntry && (Arc.FileHead.RedirType!=FSREDIR_FILECOPY))
+@@ -893,6 +898,9 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
+             UnstoreFile(DataIO,Arc.FileHead.UnpSize);
+           else
+           {
++#if defined (UNRAR_NO_EXCEPTIONS)
++            Unp->Init(Arc.FileHead.WinSize,Arc.FileHead.Solid);
++#else
+             try
+             {
+               Unp->Init(Arc.FileHead.WinSize,Arc.FileHead.Solid);
+@@ -903,6 +911,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
+                 uiMsg(UIERROR_EXTRDICTOUTMEM,Arc.FileName,uint(Arc.FileHead.WinSize/0x40000000+(Arc.FileHead.WinSize%0x40000000!=0 ? 1 : 0)));
+               throw;
+             }
++#endif  // UNRAR_NO_EXCEPTIONS
+ 
+             Unp->SetDestSize(Arc.FileHead.UnpSize);
+ #ifndef SFX_MODULE
+diff --git a/third_party/unrar/src/extract.hpp b/third_party/unrar/src/extract.hpp
+index 18d8f8c9cb776..570475ec6560c 100644
+--- a/third_party/unrar/src/extract.hpp
++++ b/third_party/unrar/src/extract.hpp
+@@ -57,8 +57,8 @@ class CmdExtract
+     unsigned long MatchedArgs;
+     bool FirstFile;
+     bool AllMatchesExact;
+-    bool ReconstructDone;
+-    bool UseExactVolName;
++    bool ReconstructDone=false;
++    bool UseExactVolName=false;
+ 
+     // If any non-zero solid file was successfully unpacked before current.
+     // If true and if current encrypted file is broken, obviously
+@@ -91,6 +91,11 @@ class CmdExtract
+     void ExtractArchiveInit(Archive &Arc);
+     bool ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat);
+     static void UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize);
++
++#if defined(CHROMIUM_UNRAR)
++    int64 GetCurrentFileSize() { return DataIO.CurUnpWrite; }
++    bool IsMissingNextVolume() { return DataIO.NextVolumeMissing; }
++#endif
+ };
+ 
+ #endif
+diff --git a/third_party/unrar/src/file.cpp b/third_party/unrar/src/file.cpp
+index 2d0d785cb2c94..c8097f9775226 100644
+--- a/third_party/unrar/src/file.cpp
++++ b/third_party/unrar/src/file.cpp
+@@ -19,6 +19,10 @@ File::File()
+   ReadErrorMode=FREM_ASK;
+   TruncatedAfterReadError=false;
+   CurFilePos=0;
++
++#ifdef CHROMIUM_UNRAR
++  hOpenFile=FILE_BAD_HANDLE;
++#endif
+ }
+ 
+ 
+@@ -52,6 +56,11 @@ bool File::Open(const std::wstring &Name,uint Mode)
+   bool UpdateMode=(Mode & FMF_UPDATE)!=0;
+   bool WriteMode=(Mode & FMF_WRITE)!=0;
+ #ifdef _WIN_ALL
++#if defined(CHROMIUM_UNRAR)
++  // Do not open a file handle since the sandbox doesn't allow it. Use the
++  // handle provided by the caller.
++  hNewFile = hOpenFile;
++#else
+   uint Access=WriteMode ? GENERIC_WRITE:GENERIC_READ;
+   if (UpdateMode)
+     Access|=GENERIC_WRITE;
+@@ -97,7 +106,14 @@ bool File::Open(const std::wstring &Name,uint Mode)
+     FILETIME ft={0xffffffff,0xffffffff}; // This value prevents atime modification.
+     SetFileTime(hNewFile,NULL,&ft,NULL);
+   }
++#endif  // defined(CHROMIUM_UNRAR)
+ 
++#else
++
++#if defined(CHROMIUM_UNRAR)
++  // Do not open a file handle since the sandbox doesn't allow it. Use the
++  // handle provided by the caller.
++  int handle = hOpenFile;
+ #else
+   int flags=UpdateMode ? O_RDWR:(WriteMode ? O_WRONLY:O_RDONLY);
+ #ifdef O_BINARY
+@@ -115,6 +131,8 @@ bool File::Open(const std::wstring &Name,uint Mode)
+   WideToChar(Name,NameA);
+ 
+   int handle=open(NameA.c_str(),flags);
++#endif  // defined(CHROMIUM_UNRAR)
++
+ #ifdef LOCK_EX
+ 
+ #ifdef _OSF_SOURCE
+@@ -174,6 +192,11 @@ bool File::WOpen(const std::wstring &Name)
+ 
+ bool File::Create(const std::wstring &Name,uint Mode)
+ {
++#if defined(CHROMIUM_UNRAR)
++  // Since the Chromium sandbox does not allow the creation of files, use the
++  // provided file.
++  hFile = hOpenFile;
++#else
+   // OpenIndiana based NAS and CIFS shares fail to set the file time if file
+   // was created in read+write mode and some data was written and not flushed
+   // before SetFileTime call. So we should use the write only mode if we plan
+@@ -211,6 +234,7 @@ bool File::Create(const std::wstring &Name,uint Mode)
+   hFile=fopen(NameA.c_str(),WriteMode ? WRITEBINARY:CREATEBINARY);
+ #endif
+ #endif
++#endif  // defined(CHROMIUM_UNRAR)
+   NewFile=true;
+   HandleType=FILE_HANDLENORMAL;
+   SkipClose=false;
+@@ -245,6 +269,8 @@ bool File::Close()
+   {
+     if (!SkipClose)
+     {
++#if !defined(CHROMIUM_UNRAR)
++// unrar should not close the file handle since it wasn't opened by unrar.
+ #ifdef _WIN_ALL
+       // We use the standard system handle for stdout in Windows
+       // and it must not be closed here.
+@@ -257,6 +283,7 @@ bool File::Close()
+       Success=fclose(hFile)!=EOF;
+ #endif
+ #endif
++#endif  // defined(CHROMIUM_UNRAR)
+     }
+     hFile=FILE_BAD_HANDLE;
+   }
+@@ -836,3 +863,9 @@ int64 File::Copy(File &Dest,int64 Length)
+   return CopySize;
+ }
+ #endif
++
++#if defined(CHROMIUM_UNRAR)
++void File::SetFileHandle(FileHandle hF) {
++  hOpenFile = hF;
++}
++#endif  // defined(CHROMIUM_UNRAR)
+diff --git a/third_party/unrar/src/file.hpp b/third_party/unrar/src/file.hpp
+index a95cc398fab32..e7868bbafe4c9 100644
+--- a/third_party/unrar/src/file.hpp
++++ b/third_party/unrar/src/file.hpp
+@@ -86,6 +86,11 @@ class File
+     std::wstring FileName;
+ 
+     FILE_ERRORTYPE ErrorType;
++
++#if defined(CHROMIUM_UNRAR)
++    FileHandle hOpenFile;
++#endif  // defined(CHROMIUM_UNRAR)
++
+   public:
+     File();
+     virtual ~File();
+@@ -136,6 +141,14 @@ class File
+     void SetExceptions(bool Allow) {AllowExceptions=Allow;}
+     void SetPreserveAtime(bool Preserve) {PreserveAtime=Preserve;}
+     bool IsTruncatedAfterReadError() {return TruncatedAfterReadError;}
++
++#if defined(CHROMIUM_UNRAR)
++    // Since unrar runs in a sandbox, it doesn't have the permission to open
++    // files on the filesystem. Instead, the caller opens the file and passes
++    // the file handle to unrar. This handle is then used to read the file.
++    void SetFileHandle(FileHandle file);
++#endif  // defined(CHROMIUM_UNRAR)
++
+ #ifdef _UNIX
+     int GetFD()
+     {
+diff --git a/third_party/unrar/src/isnt.cpp b/third_party/unrar/src/isnt.cpp
+index b89b2ce54d825..9322a1d1b3d54 100644
+--- a/third_party/unrar/src/isnt.cpp
++++ b/third_party/unrar/src/isnt.cpp
+@@ -1,5 +1,11 @@
+ #include "rar.hpp"
+ 
++#pragma clang diagnostic push
++#pragma clang diagnostic ignored "-Wdeprecated-declarations"
++// GetVersionEx() is deprecated, and the suggested replacement are
++// the IsWindows*OrGreater() functions in VersionHelpers.h. We can't
++// use that because there is no IsWindows11OrGreater() function yet.
++
+ DWORD WinNT()
+ {
+   static int dwPlatformId=-1;
+@@ -25,7 +31,7 @@ DWORD WinNT()
+ 
+ // Replace it with documented Windows 11 check when available.
+ #include <comdef.h>
+-#include <Wbemidl.h>
++#include <WbemIdl.h>
+ #pragma comment(lib, "wbemuuid.lib")
+ 
+ static bool WMI_IsWindows10()
+@@ -106,3 +112,5 @@ bool IsWindows11OrGreater()
+   }
+   return IsWin11;
+ }
++
++#pragma clang diagnostic pop
+diff --git a/third_party/unrar/src/model.cpp b/third_party/unrar/src/model.cpp
+index 69d9267f7c428..e3ef5b7a8c90d 100644
+--- a/third_party/unrar/src/model.cpp
++++ b/third_party/unrar/src/model.cpp
+@@ -43,13 +43,27 @@ void ModelPPM::RestartModelRare()
+   InitRL=-(MaxOrder < 12 ? MaxOrder:12)-1;
+   MinContext = MaxContext = (RARPPM_CONTEXT*) SubAlloc.AllocContext();
+   if (MinContext == NULL)
++  {
++#if defined(UNRAR_NO_EXCEPTIONS)
++    base::TerminateBecauseOutOfMemory(0);
++#else
+     throw std::bad_alloc();
++#endif  // defined(UNRAR_NO_EXCEPTIONS)
++  }
++
+   MinContext->Suffix=NULL;
+   OrderFall=MaxOrder;
+   MinContext->U.SummFreq=(MinContext->NumStats=256)+1;
+   FoundState=MinContext->U.Stats=(RARPPM_STATE*)SubAlloc.AllocUnits(256/2);
+   if (FoundState == NULL)
++  {
++#if defined(UNRAR_NO_EXCEPTIONS)
++    base::TerminateBecauseOutOfMemory(0);
++#else
+     throw std::bad_alloc();
++#endif  // defined(UNRAR_NO_EXCEPTIONS)
++  }
++
+   for (RunLength=InitRL, PrevSuccess=i=0;i < 256;i++) 
+   {
+     MinContext->U.Stats[i].Symbol=i;      
+diff --git a/third_party/unrar/src/os.hpp b/third_party/unrar/src/os.hpp
+index f7e841b098b41..18b755c394ecb 100644
+--- a/third_party/unrar/src/os.hpp
++++ b/third_party/unrar/src/os.hpp
+@@ -30,6 +30,7 @@
+ #define STRICT 1
+ #endif
+ 
++#if !defined(CHROMIUM_UNRAR)
+ // 'ifndef' check here is needed for unrar.dll header to avoid macro
+ // re-definition warnings in third party projects.
+ #ifndef UNICODE
+@@ -39,12 +40,15 @@
+ 
+ #define WINVER _WIN32_WINNT_WINXP
+ #define _WIN32_WINNT _WIN32_WINNT_WINXP
++#endif  // !defined(CHROMIUM_UNRAR)
+ 
+-#if !defined(ZIPSFX)
++#if !defined(ZIPSFX) && !defined(CHROMIUM_UNRAR)
+ #define RAR_SMP
+ #endif
+ 
++#if !defined(CHROMIUM_UNRAR)
+ #define WIN32_LEAN_AND_MEAN
++#endif  // CHROMIUM_UNRAR
+ 
+ #include <windows.h>
+ #include <prsht.h>
+@@ -64,7 +68,7 @@
+ 
+ // For WMI requests.
+ #include <comdef.h>
+-#include <Wbemidl.h>
++#include <WbemIdl.h>
+ #pragma comment(lib, "wbemuuid.lib")
+ 
+ 
+@@ -74,11 +78,13 @@
+ #include <direct.h>
+ #include <intrin.h>
+ 
++#if !defined(CHROMIUM_UNRAR)
+ // Use SSE only for x86/x64, not ARM Windows.
+ #if defined(_M_IX86) || defined(_M_X64)
+   #define USE_SSE
+   #define SSE_ALIGNMENT 16
+ #endif
++#endif  // CHROMIUM_UNRAR
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+@@ -147,6 +153,7 @@
+ #include <utime.h>
+ #include <locale.h>
+ 
++#if !defined(CHROMIUM_UNRAR)
+ #ifdef __GNUC__
+   #if defined(__i386__) || defined(__x86_64__)
+     #include <x86intrin.h>
+@@ -155,6 +162,7 @@
+     #define SSE_ALIGNMENT 16
+   #endif
+ #endif
++#endif  // CHROMIUM_UNRAR
+ 
+ #if defined(__aarch64__) && (defined(__ARM_FEATURE_CRYPTO) || defined(__ARM_FEATURE_CRC32))
+ #include <arm_neon.h>
+@@ -263,9 +271,16 @@
+   #endif
+ #endif
+ 
++// Disable this optimization in Chromium. Although the underlying architecture
++// may allow unaligned access, C and C++ themselves do not allow this. Rather,
++// unaligned loads should be written with either memcpy, or by endian-agnostic
++// reassembling of values with shifts and ORs. Modern compilers recognize these
++// patterns and generate the unaligned load anyway.
++#if !defined(CHROMIUM_UNRAR)
+ #if !defined(BIG_ENDIAN) && defined(_WIN_ALL) || defined(__i386__) || defined(__x86_64__) || defined(__aarch64__)
+ // Allow unaligned integer access, increases speed in some operations.
+ #define ALLOW_MISALIGNED
+ #endif
++#endif
+ 
+ #endif // _RAR_OS_
+diff --git a/third_party/unrar/src/secpassword.cpp b/third_party/unrar/src/secpassword.cpp
+index 8d8f298609a76..a32ea40e3ac25 100644
+--- a/third_party/unrar/src/secpassword.cpp
++++ b/third_party/unrar/src/secpassword.cpp
+@@ -1,6 +1,6 @@
+ #include "rar.hpp"
+ 
+-#if defined(_WIN_ALL)
++#if defined(_WIN_ALL) && !defined(CHROMIUM_UNRAR)
+ typedef BOOL (WINAPI *CRYPTPROTECTMEMORY)(LPVOID pData,DWORD cbData,DWORD dwFlags);
+ typedef BOOL (WINAPI *CRYPTUNPROTECTMEMORY)(LPVOID pData,DWORD cbData,DWORD dwFlags);
+ 
+@@ -177,7 +177,7 @@ void SecHideData(void *Data,size_t DataSize,bool Encode,bool CrossProcess)
+ {
+   // CryptProtectMemory is not available in UWP and CryptProtectData
+   // increases data size not allowing in place conversion.
+-#if defined(_WIN_ALL)
++#if defined(_WIN_ALL) && !defined(CHROMIUM_UNRAR)
+   // Try to utilize the secure Crypt[Un]ProtectMemory if possible.
+   if (GlobalCryptLoader.pCryptProtectMemory==NULL)
+     GlobalCryptLoader.Load();
+diff --git a/third_party/unrar/src/strfn.cpp b/third_party/unrar/src/strfn.cpp
+index 6ad51c8fec1d6..4c69c906c6467 100644
+--- a/third_party/unrar/src/strfn.cpp
++++ b/third_party/unrar/src/strfn.cpp
+@@ -42,6 +42,27 @@ void ArcCharToWide(const char *Src,std::wstring &Dest,ACTW_ENCODING Encoding)
+     UtfToWide(Src,Dest);
+   else
+   {
++#if defined(CHROMIUM_UNRAR)
++    if (Encoding == ACTW_OEM) {
++      // OemToCharBuffA, called by IntToExt, is implemented by user32.dll which
++      // is not available in win32k lockdown sandbox. We can map from the OEM
++      // codepage using CP_OEMCP and MultiByteToWideChar from kernel32.dll
++      // instead, as we're also attempting to map to wide chars.
++      const size_t SrcLength = strlen(Src) + 1;
++      const int size =
++          MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED | MB_USEGLYPHCHARS, Src,
++                              SrcLength, nullptr, 0);
++      if (size <= 0) {
++        Dest.clear();
++      } else {
++        Dest.resize(size);
++        (void)::MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED | MB_USEGLYPHCHARS,
++                                    Src, SrcLength, &Dest[0], size);
++      }
++    } else {
++      CharToWide(Src, Dest);
++    }
++#else
+     std::string NameA;
+     if (Encoding==ACTW_OEM)
+     {
+@@ -49,6 +70,7 @@ void ArcCharToWide(const char *Src,std::wstring &Dest,ACTW_ENCODING Encoding)
+       Src=NameA.data();
+     }
+     CharToWide(Src,Dest);
++#endif  // defined(CHROMIUM_UNRAR)
+   }
+ #else // RAR for Unix.
+   if (Encoding==ACTW_UTF8)
+@@ -388,7 +410,7 @@ void fmtitoa(int64 n,wchar *Str,size_t MaxSize)
+   static wchar ThSep=0; // Thousands separator.
+ #ifdef _WIN_ALL
+   wchar Info[10];
+-  if (!ThSep!=0 && GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_STHOUSAND,Info,ASIZE(Info))>0)
++  if ((!ThSep)!=0 && GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_STHOUSAND,Info,ASIZE(Info))>0)
+     ThSep=*Info;
+ #elif defined(_UNIX)
+   ThSep=*localeconv()->thousands_sep;
+diff --git a/third_party/unrar/src/unicode.cpp b/third_party/unrar/src/unicode.cpp
+index e6d4977b565ff..2bff1bf3f7f67 100644
+--- a/third_party/unrar/src/unicode.cpp
++++ b/third_party/unrar/src/unicode.cpp
+@@ -732,9 +732,18 @@ std::wstring::size_type wcscasestr(const std::wstring &str, const std::wstring &
+ wchar* wcslower(wchar *s)
+ {
+ #ifdef _WIN_ALL
++#if defined(CHROMIUM_UNRAR)
++  // kernel32!LCMapStringEx instead of user32.dll!CharUpper due to win32k
++  // lockdown sandbox in chromium, user32.dll can't be loaded.
++  const size_t s_length = wcslen(s) + 1;
++  (void)LCMapStringEx(LOCALE_NAME_USER_DEFAULT, LCMAP_LOWERCASE, s, s_length, s,
++                      s_length, NULL, NULL, 0);
++  return s;
++#else
+   // _wcslwr requires setlocale and we do not want to depend on setlocale
+   // in Windows. Also CharLower involves less overhead.
+   CharLower(s);
++#endif  // defined(CHROMIUM_UNRAR)
+ #else
+   for (wchar *c=s;*c!=0;c++)
+     *c=towlower(*c);
+@@ -752,9 +761,18 @@ void wcslower(std::wstring &s)
+ wchar* wcsupper(wchar *s)
+ {
+ #ifdef _WIN_ALL
++#if defined(CHROMIUM_UNRAR)
++  // kernel32!LCMapStringEx instead of user32.dll!CharUpper due to win32k
++  // lockdown sandbox in chromium, user32.dll can't be loaded.
++  const size_t s_length = wcslen(s) + 1;
++  (void)LCMapStringEx(LOCALE_NAME_USER_DEFAULT, LCMAP_UPPERCASE, s, s_length, s,
++                      s_length, NULL, NULL, 0);
++  return s;
++#else
+   // _wcsupr requires setlocale and we do not want to depend on setlocale
+   // in Windows. Also CharUpper involves less overhead.
+   CharUpper(s);
++#endif  // defined(CHROMIUM_UNRAR)
+ #else
+   for (wchar *c=s;*c!=0;c++)
+     *c=towupper(*c);
+@@ -775,11 +793,20 @@ void wcsupper(std::wstring &s)
+ int toupperw(int ch)
+ {
+ #if defined(_WIN_ALL)
++#if defined(CHROMIUM_UNRAR)
++  wchar_t ch_as_wide_char = static_cast<wchar_t>(ch & 0xffff);
++  // kernel32!LCMapStringEx instead of user32.dll!CharUpper due to win32k
++  // lockdown sandbox in chromium, user32.dll can't be loaded.
++  (void)LCMapStringEx(LOCALE_NAME_USER_DEFAULT, LCMAP_UPPERCASE,
++                      &ch_as_wide_char, 1, &ch_as_wide_char, 1, NULL, NULL, 0);
++  return int(ch_as_wide_char);
++#else
+   // CharUpper is more reliable than towupper in Windows, which seems to be
+   // C locale dependent even in Unicode version. For example, towupper failed
+   // to convert lowercase Russian characters. Use 0xffff mask to prevent crash
+   // if value larger than 0xffff is passed to this function.
+   return (int)(INT_PTR)CharUpper((wchar *)(INT_PTR)(ch&0xffff));
++#endif  // defined(CHROMIUM_UNRAR)
+ #else
+   return towupper(ch);
+ #endif
+@@ -789,10 +816,19 @@ int toupperw(int ch)
+ int tolowerw(int ch)
+ {
+ #if defined(_WIN_ALL)
++#if defined(CHROMIUM_UNRAR)
++  wchar_t ch_as_wide_char = static_cast<wchar_t>(ch & 0xffff);
++  // kernel32!LCMapStringEx instead of user32.dll!CharLower due to win32k
++  // lockdown sandbox in chromium, user32.dll can't be loaded.
++  (void)LCMapStringEx(LOCALE_NAME_USER_DEFAULT, LCMAP_LOWERCASE,
++                      &ch_as_wide_char, 1, &ch_as_wide_char, 1, NULL, NULL, 0);
++  return int(ch_as_wide_char);
++#else
+   // CharLower is more reliable than towlower in Windows.
+   // See comment for towupper above. Use 0xffff mask to prevent crash
+   // if value larger than 0xffff is passed to this function.
+   return (int)(INT_PTR)CharLower((wchar *)(INT_PTR)(ch&0xffff));
++#endif  // defined(CHROMIUM_UNRAR)
+ #else
+   return towlower(ch);
+ #endif
+@@ -829,7 +865,6 @@ int64 atoilw(const std::wstring &s)
+ 
+ 
+ #ifdef DBCS_SUPPORTED
+-SupportDBCS gdbcs;
+ 
+ SupportDBCS::SupportDBCS()
+ {
+@@ -846,6 +881,11 @@ void SupportDBCS::Init()
+     IsLeadByte[I]=IsDBCSLeadByte(I)!=0;
+ }
+ 
++// static
++SupportDBCS& SupportDBCS::GetInstance() {
++  static SupportDBCS supportDBCS;
++  return supportDBCS;
++}
+ 
+ char* SupportDBCS::charnext(const char *s)
+ {
+diff --git a/third_party/unrar/src/unicode.hpp b/third_party/unrar/src/unicode.hpp
+index 2d867b3aefef0..81cf99e380896 100644
+--- a/third_party/unrar/src/unicode.hpp
++++ b/third_party/unrar/src/unicode.hpp
+@@ -46,14 +46,14 @@ class SupportDBCS
+     SupportDBCS();
+     void Init();
+     char* charnext(const char *s);
++  static SupportDBCS& GetInstance();
+ 
+     bool IsLeadByte[256];
+     bool DBCSMode;
+ };
+-extern SupportDBCS gdbcs;
+ 
+-inline char* charnext(const char *s) {return (char *)(gdbcs.DBCSMode ? gdbcs.charnext(s):s+1);}
+-inline bool IsDBCSMode() {return gdbcs.DBCSMode;}
++inline char* charnext(const char *s) {return (char *)(SupportDBCS::GetInstance().DBCSMode ? SupportDBCS::GetInstance().charnext(s):s+1);}
++inline bool IsDBCSMode() {return SupportDBCS::GetInstance().DBCSMode;}
+ 
+ #else
+ #define charnext(s) ((s)+1)
+diff --git a/third_party/unrar/src/unpack.cpp b/third_party/unrar/src/unpack.cpp
+index a5950ea1ac4e2..f7e2e01abb943 100644
+--- a/third_party/unrar/src/unpack.cpp
++++ b/third_party/unrar/src/unpack.cpp
+@@ -1,3 +1,9 @@
++// NOTE(vakh): The process.h file needs to be included first because "rar.hpp"
++// defines certain macros that cause symbol redefinition errors
++#if defined(UNRAR_NO_EXCEPTIONS)
++#include "base/process/memory.h"
++#endif  // defined(UNRAR_NO_EXCEPTIONS)
++
+ #include "rar.hpp"
+ 
+ #include "coder.cpp"
+@@ -15,6 +21,12 @@
+ #include "unpack50.cpp"
+ #include "unpack50frag.cpp"
+ 
++#if defined(UNRAR_NO_EXCEPTIONS)
++#define UNRAR_FATAL_BAD_ALLOC(size) base::TerminateBecauseOutOfMemory(size)
++#else
++#define UNRAR_FATAL_BAD_ALLOC(size) throw std::bad_alloc()
++#endif
++
+ Unpack::Unpack(ComprDataIO *DataIO)
+ :Inp(true),VMCodeInp(true)
+ {
+@@ -87,7 +99,7 @@ void Unpack::Init(uint64 WinSize,bool Solid)
+     WinSize=MinAllocSize;
+ 
+   if (WinSize>Min(0x10000000000ULL,UNPACK_MAX_DICT)) // Window size must not exceed 1 TB.
+-    throw std::bad_alloc();
++    UNRAR_FATAL_BAD_ALLOC(WinSize);
+ 
+   // 32-bit build can't unpack dictionaries exceeding 32-bit even in theory.
+   // Also we've not verified if WrapUp and WrapDown work properly in 32-bit
+@@ -95,7 +107,7 @@ void Unpack::Init(uint64 WinSize,bool Solid)
+   // distances. Since such version is unlikely to allocate >2GB anyway,
+   // we prohibit >2GB dictionaries for 32-bit build here.
+   if (WinSize>0x80000000 && sizeof(size_t)<=4)
+-    throw std::bad_alloc();
++    UNRAR_FATAL_BAD_ALLOC(WinSize);
+ 
+   // Solid block shall use the same window size for all files.
+   // But if Window isn't initialized when Solid is set, it means that
+@@ -120,23 +132,27 @@ void Unpack::Init(uint64 WinSize,bool Solid)
+   // or increasing the size of non-solid window. So we could safely reject
+   // current window data without copying them to a new window.
+   if (Solid && (Window!=NULL || Fragmented && WinSize>FragWindow.GetWinSize()))
+-    throw std::bad_alloc();
++    UNRAR_FATAL_BAD_ALLOC(WinSize);
+ 
+   Alloc.delete_l<byte>(Window); // delete Window;
+   Window=nullptr;
+   
++#if !defined(UNRAR_NO_EXCEPTIONS)
+   try
+   {
++#endif  // UNRAR_NO_EXCEPTIONS
+     if (!Fragmented)
+       Window=Alloc.new_l<byte>((size_t)WinSize,false); // Window=new byte[(size_t)WinSize];
++#if !defined(UNRAR_NO_EXCEPTIONS)
+   }
+   catch (std::bad_alloc) // Use the fragmented window in this case.
+   {
+   }
++#endif  // UNRAR_NO_EXCEPTIONS
+ 
+   if (Window==nullptr)
+     if (WinSize<0x1000000 || sizeof(size_t)>4)
+-      throw std::bad_alloc(); // Exclude RAR4, small dictionaries and 64-bit.
++      UNRAR_FATAL_BAD_ALLOC(WinSize);
+     else
+     {
+       if (WinSize>FragWindow.GetWinSize())
+diff --git a/third_party/unrar/src/unpack50frag.cpp b/third_party/unrar/src/unpack50frag.cpp
+index 9208405e04eb6..b1776e6e8dd62 100644
+--- a/third_party/unrar/src/unpack50frag.cpp
++++ b/third_party/unrar/src/unpack50frag.cpp
+@@ -1,3 +1,11 @@
++#include "base/process/memory.h"
++
++#if defined(UNRAR_NO_EXCEPTIONS)
++#define UNRAR_FATAL_BAD_ALLOC(size) base::TerminateBecauseOutOfMemory(size)
++#else
++#define UNRAR_FATAL_BAD_ALLOC(size) throw std::bad_alloc()
++#endif
++
+ FragmentedWindow::FragmentedWindow()
+ {
+   memset(Mem,0,sizeof(Mem));
+@@ -49,7 +57,7 @@ void FragmentedWindow::Init(size_t WinSize)
+       Size-=Size/32;
+     }
+     if (NewMem==NULL)
+-      throw std::bad_alloc();
++      UNRAR_FATAL_BAD_ALLOC(Size);
+ 
+     // Clean the window to generate the same output when unpacking corrupt
+     // RAR files, which may access to unused areas of sliding dictionary.
+@@ -61,7 +69,8 @@ void FragmentedWindow::Init(size_t WinSize)
+     BlockNum++;
+   }
+   if (TotalSize<WinSize) // Not found enough free blocks.
+-    throw std::bad_alloc();
++    UNRAR_FATAL_BAD_ALLOC(WinSize);
++
+   LastAllocated=WinSize;
+ }
+ 
diff --git a/third_party/utf/patches/0001-adding-CJK-ideograph-to-isalpha.patch b/third_party/utf/patches/0001-adding-CJK-ideograph-to-isalpha.patch
new file mode 100644
index 0000000000000..e7f17782d45fb
--- /dev/null
+++ b/third_party/utf/patches/0001-adding-CJK-ideograph-to-isalpha.patch
@@ -0,0 +1,34 @@
+From c7a56e4a83600719e7caf7c4eb7a825d27e198e3 Mon Sep 17 00:00:00 2001
+From: mcrouse <mcrouse@google.com>
+Date: Wed, 3 Mar 2021 17:57:52 -0800
+Subject: [PATCH] adding CJK ideograph to isalpha
+
+---
+ third_party/utf/src/runetype/isalpharune.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/third_party/utf/src/runetype/isalpharune.c b/third_party/utf/src/runetype/isalpharune.c
+index 901433d2e056..2be409b902cc 100644
+--- a/third_party/utf/src/runetype/isalpharune.c
++++ b/third_party/utf/src/runetype/isalpharune.c
+@@ -48,8 +48,6 @@ static Rune singles[][1] = {
+ 	{ 0x2E2F },
+ 	{ 0x3400 },
+ 	{ 0x4DB5 },
+-	{ 0x4E00 },
+-	{ 0x9FD5 },
+ 	{ 0xA9CF },
+ 	{ 0xAA7A },
+ 	{ 0xAC00 },
+@@ -305,6 +303,8 @@ static Rune ranges[][2] = {
+ 	{ 0x3131, 0x318E },
+ 	{ 0x31A0, 0x31BA },
+ 	{ 0x31F0, 0x31FF },
++    // Added manually to handle CJK ideographs, see crbug/1184370
++	{ 0x4E00, 0x9FD5 },
+ 	{ 0xA000, 0xA48C },
+ 	{ 0xA4D0, 0xA4FD },
+ 	{ 0xA500, 0xA60C },
+-- 
+2.30.1.766.gb4fecdf3b7-goog
+
diff --git a/third_party/utf/patches/0001-adding-awk-built-files.patch b/third_party/utf/patches/0001-adding-awk-built-files.patch
new file mode 100644
index 0000000000000..114da12058c58
--- /dev/null
+++ b/third_party/utf/patches/0001-adding-awk-built-files.patch
@@ -0,0 +1,1426 @@
+From 9f0e7004bd995c210acf4af2ba6522e5b0e32375 Mon Sep 17 00:00:00 2001
+From: Michael Crouse <mcrouse@chromium.org>
+Date: Tue, 5 Jan 2021 12:36:11 -0800
+Subject: [PATCH] adding awk built files
+
+---
+ third_party/utf/src/.gitignore             |  15 -
+ third_party/utf/src/runetype/isalpharune.c | 703 +++++++++++++++++++++
+ third_party/utf/src/runetype/iscntrlrune.c |   9 +
+ third_party/utf/src/runetype/isdigitrune.c |  61 ++
+ third_party/utf/src/runetype/islowerrune.c | 303 +++++++++
+ third_party/utf/src/runetype/isspacerune.c |  20 +
+ third_party/utf/src/runetype/istitlerune.c |  20 +
+ third_party/utf/src/runetype/isupperrune.c | 220 +++++++
+ 8 files changed, 1336 insertions(+), 15 deletions(-)
+ delete mode 100644 third_party/utf/src/.gitignore
+ create mode 100644 third_party/utf/src/runetype/isalpharune.c
+ create mode 100644 third_party/utf/src/runetype/iscntrlrune.c
+ create mode 100644 third_party/utf/src/runetype/isdigitrune.c
+ create mode 100644 third_party/utf/src/runetype/islowerrune.c
+ create mode 100644 third_party/utf/src/runetype/isspacerune.c
+ create mode 100644 third_party/utf/src/runetype/istitlerune.c
+ create mode 100644 third_party/utf/src/runetype/isupperrune.c
+
+diff --git a/third_party/utf/src/.gitignore b/third_party/utf/src/.gitignore
+deleted file mode 100644
+index ef31efb857d6..000000000000
+--- a/third_party/utf/src/.gitignore
++++ /dev/null
+@@ -1,15 +0,0 @@
+-lib/libutf.a
+-runestr/*.o
+-runetype/*.o
+-runetype/isalpharune.c
+-runetype/iscntrlrune.c
+-runetype/isdigitrune.c
+-runetype/islowerrune.c
+-runetype/isspacerune.c
+-runetype/istitlerune.c
+-runetype/isupperrune.c
+-test/boundary
+-test/kosme
+-test/malformed
+-test/overlong
+-utf/*.o
+diff --git a/third_party/utf/src/runetype/isalpharune.c b/third_party/utf/src/runetype/isalpharune.c
+new file mode 100644
+index 000000000000..901433d2e056
+--- /dev/null
++++ b/third_party/utf/src/runetype/isalpharune.c
+@@ -0,0 +1,703 @@
++/* Automatically generated by mkrunetype.awk */
++#include "runetype.h"
++#define ISRUNE isalpharune
++#define SINGLES singles
++static Rune singles[][1] = {
++	{ 0x00AA },
++	{ 0x00B5 },
++	{ 0x00BA },
++	{ 0x0559 },
++	{ 0x06FF },
++	{ 0x07B1 },
++	{ 0x07FA },
++	{ 0x081A },
++	{ 0x0824 },
++	{ 0x0828 },
++	{ 0x093D },
++	{ 0x0950 },
++	{ 0x09BD },
++	{ 0x09CE },
++	{ 0x0ABD },
++	{ 0x0AD0 },
++	{ 0x0AF9 },
++	{ 0x0B3D },
++	{ 0x0B71 },
++	{ 0x0BD0 },
++	{ 0x0C3D },
++	{ 0x0C80 },
++	{ 0x0CBD },
++	{ 0x0D3D },
++	{ 0x0D4E },
++	{ 0x0E8D },
++	{ 0x0EBD },
++	{ 0x0F00 },
++	{ 0x103F },
++	{ 0x1061 },
++	{ 0x108E },
++	{ 0x10CD },
++	{ 0x17D7 },
++	{ 0x17DC },
++	{ 0x1AA7 },
++	{ 0x2071 },
++	{ 0x207F },
++	{ 0x2102 },
++	{ 0x2107 },
++	{ 0x214E },
++	{ 0x2D2D },
++	{ 0x2D6F },
++	{ 0x2E2F },
++	{ 0x3400 },
++	{ 0x4DB5 },
++	{ 0x4E00 },
++	{ 0x9FD5 },
++	{ 0xA9CF },
++	{ 0xAA7A },
++	{ 0xAC00 },
++	{ 0xD7A3 },
++	{ 0x1083C },
++	{ 0x10A00 },
++	{ 0x11176 },
++	{ 0x1133D },
++	{ 0x11350 },
++	{ 0x11644 },
++	{ 0x118FF },
++	{ 0x11C40 },
++	{ 0x16F50 },
++	{ 0x16FE0 },
++	{ 0x17000 },
++	{ 0x187EC },
++	{ 0x1D4A2 },
++	{ 0x1EE42 },
++	{ 0x20000 },
++	{ 0x2A6D6 },
++	{ 0x2A700 },
++	{ 0x2B734 },
++	{ 0x2B740 },
++	{ 0x2B81D },
++	{ 0x2B820 },
++	{ 0x2CEA1 },
++};
++#define RANGES ranges
++static Rune ranges[][2] = {
++	{ 0x0041, 0x005A },
++	{ 0x0061, 0x007A },
++	{ 0x00C0, 0x00D6 },
++	{ 0x00D8, 0x00F6 },
++	{ 0x00F8, 0x02C1 },
++	{ 0x02C6, 0x02D1 },
++	{ 0x02E0, 0x02E4 },
++	{ 0x0370, 0x0374 },
++	{ 0x0376, 0x0377 },
++	{ 0x037A, 0x037D },
++	{ 0x0388, 0x038A },
++	{ 0x038E, 0x03A1 },
++	{ 0x03A3, 0x03F5 },
++	{ 0x03F7, 0x0481 },
++	{ 0x048A, 0x052F },
++	{ 0x0531, 0x0556 },
++	{ 0x0561, 0x0587 },
++	{ 0x05D0, 0x05EA },
++	{ 0x05F0, 0x05F2 },
++	{ 0x0620, 0x064A },
++	{ 0x066E, 0x066F },
++	{ 0x0671, 0x06D3 },
++	{ 0x06E5, 0x06E6 },
++	{ 0x06EE, 0x06EF },
++	{ 0x06FA, 0x06FC },
++	{ 0x0712, 0x072F },
++	{ 0x074D, 0x07A5 },
++	{ 0x07CA, 0x07EA },
++	{ 0x07F4, 0x07F5 },
++	{ 0x0800, 0x0815 },
++	{ 0x0840, 0x0858 },
++	{ 0x08A0, 0x08B4 },
++	{ 0x08B6, 0x08BD },
++	{ 0x0904, 0x0939 },
++	{ 0x0958, 0x0961 },
++	{ 0x0971, 0x0980 },
++	{ 0x0985, 0x098C },
++	{ 0x098F, 0x0990 },
++	{ 0x0993, 0x09A8 },
++	{ 0x09AA, 0x09B0 },
++	{ 0x09B6, 0x09B9 },
++	{ 0x09DC, 0x09DD },
++	{ 0x09DF, 0x09E1 },
++	{ 0x09F0, 0x09F1 },
++	{ 0x0A05, 0x0A0A },
++	{ 0x0A0F, 0x0A10 },
++	{ 0x0A13, 0x0A28 },
++	{ 0x0A2A, 0x0A30 },
++	{ 0x0A32, 0x0A33 },
++	{ 0x0A35, 0x0A36 },
++	{ 0x0A38, 0x0A39 },
++	{ 0x0A59, 0x0A5C },
++	{ 0x0A72, 0x0A74 },
++	{ 0x0A85, 0x0A8D },
++	{ 0x0A8F, 0x0A91 },
++	{ 0x0A93, 0x0AA8 },
++	{ 0x0AAA, 0x0AB0 },
++	{ 0x0AB2, 0x0AB3 },
++	{ 0x0AB5, 0x0AB9 },
++	{ 0x0AE0, 0x0AE1 },
++	{ 0x0B05, 0x0B0C },
++	{ 0x0B0F, 0x0B10 },
++	{ 0x0B13, 0x0B28 },
++	{ 0x0B2A, 0x0B30 },
++	{ 0x0B32, 0x0B33 },
++	{ 0x0B35, 0x0B39 },
++	{ 0x0B5C, 0x0B5D },
++	{ 0x0B5F, 0x0B61 },
++	{ 0x0B85, 0x0B8A },
++	{ 0x0B8E, 0x0B90 },
++	{ 0x0B92, 0x0B95 },
++	{ 0x0B99, 0x0B9A },
++	{ 0x0B9E, 0x0B9F },
++	{ 0x0BA3, 0x0BA4 },
++	{ 0x0BA8, 0x0BAA },
++	{ 0x0BAE, 0x0BB9 },
++	{ 0x0C05, 0x0C0C },
++	{ 0x0C0E, 0x0C10 },
++	{ 0x0C12, 0x0C28 },
++	{ 0x0C2A, 0x0C39 },
++	{ 0x0C58, 0x0C5A },
++	{ 0x0C60, 0x0C61 },
++	{ 0x0C85, 0x0C8C },
++	{ 0x0C8E, 0x0C90 },
++	{ 0x0C92, 0x0CA8 },
++	{ 0x0CAA, 0x0CB3 },
++	{ 0x0CB5, 0x0CB9 },
++	{ 0x0CE0, 0x0CE1 },
++	{ 0x0CF1, 0x0CF2 },
++	{ 0x0D05, 0x0D0C },
++	{ 0x0D0E, 0x0D10 },
++	{ 0x0D12, 0x0D3A },
++	{ 0x0D54, 0x0D56 },
++	{ 0x0D5F, 0x0D61 },
++	{ 0x0D7A, 0x0D7F },
++	{ 0x0D85, 0x0D96 },
++	{ 0x0D9A, 0x0DB1 },
++	{ 0x0DB3, 0x0DBB },
++	{ 0x0DC0, 0x0DC6 },
++	{ 0x0E01, 0x0E30 },
++	{ 0x0E32, 0x0E33 },
++	{ 0x0E40, 0x0E46 },
++	{ 0x0E81, 0x0E82 },
++	{ 0x0E87, 0x0E88 },
++	{ 0x0E94, 0x0E97 },
++	{ 0x0E99, 0x0E9F },
++	{ 0x0EA1, 0x0EA3 },
++	{ 0x0EAA, 0x0EAB },
++	{ 0x0EAD, 0x0EB0 },
++	{ 0x0EB2, 0x0EB3 },
++	{ 0x0EC0, 0x0EC4 },
++	{ 0x0EDC, 0x0EDF },
++	{ 0x0F40, 0x0F47 },
++	{ 0x0F49, 0x0F6C },
++	{ 0x0F88, 0x0F8C },
++	{ 0x1000, 0x102A },
++	{ 0x1050, 0x1055 },
++	{ 0x105A, 0x105D },
++	{ 0x1065, 0x1066 },
++	{ 0x106E, 0x1070 },
++	{ 0x1075, 0x1081 },
++	{ 0x10A0, 0x10C5 },
++	{ 0x10D0, 0x10FA },
++	{ 0x10FC, 0x1248 },
++	{ 0x124A, 0x124D },
++	{ 0x1250, 0x1256 },
++	{ 0x125A, 0x125D },
++	{ 0x1260, 0x1288 },
++	{ 0x128A, 0x128D },
++	{ 0x1290, 0x12B0 },
++	{ 0x12B2, 0x12B5 },
++	{ 0x12B8, 0x12BE },
++	{ 0x12C2, 0x12C5 },
++	{ 0x12C8, 0x12D6 },
++	{ 0x12D8, 0x1310 },
++	{ 0x1312, 0x1315 },
++	{ 0x1318, 0x135A },
++	{ 0x1380, 0x138F },
++	{ 0x13A0, 0x13F5 },
++	{ 0x13F8, 0x13FD },
++	{ 0x1401, 0x166C },
++	{ 0x166F, 0x167F },
++	{ 0x1681, 0x169A },
++	{ 0x16A0, 0x16EA },
++	{ 0x16F1, 0x16F8 },
++	{ 0x1700, 0x170C },
++	{ 0x170E, 0x1711 },
++	{ 0x1720, 0x1731 },
++	{ 0x1740, 0x1751 },
++	{ 0x1760, 0x176C },
++	{ 0x176E, 0x1770 },
++	{ 0x1780, 0x17B3 },
++	{ 0x1820, 0x1877 },
++	{ 0x1880, 0x1884 },
++	{ 0x1887, 0x18A8 },
++	{ 0x18B0, 0x18F5 },
++	{ 0x1900, 0x191E },
++	{ 0x1950, 0x196D },
++	{ 0x1970, 0x1974 },
++	{ 0x1980, 0x19AB },
++	{ 0x19B0, 0x19C9 },
++	{ 0x1A00, 0x1A16 },
++	{ 0x1A20, 0x1A54 },
++	{ 0x1B05, 0x1B33 },
++	{ 0x1B45, 0x1B4B },
++	{ 0x1B83, 0x1BA0 },
++	{ 0x1BAE, 0x1BAF },
++	{ 0x1BBA, 0x1BE5 },
++	{ 0x1C00, 0x1C23 },
++	{ 0x1C4D, 0x1C4F },
++	{ 0x1C5A, 0x1C7D },
++	{ 0x1C80, 0x1C88 },
++	{ 0x1CE9, 0x1CEC },
++	{ 0x1CEE, 0x1CF1 },
++	{ 0x1CF5, 0x1CF6 },
++	{ 0x1D00, 0x1DBF },
++	{ 0x1E00, 0x1F15 },
++	{ 0x1F18, 0x1F1D },
++	{ 0x1F20, 0x1F45 },
++	{ 0x1F48, 0x1F4D },
++	{ 0x1F50, 0x1F57 },
++	{ 0x1F5F, 0x1F7D },
++	{ 0x1F80, 0x1FB4 },
++	{ 0x1FB6, 0x1FBC },
++	{ 0x1FC2, 0x1FC4 },
++	{ 0x1FC6, 0x1FCC },
++	{ 0x1FD0, 0x1FD3 },
++	{ 0x1FD6, 0x1FDB },
++	{ 0x1FE0, 0x1FEC },
++	{ 0x1FF2, 0x1FF4 },
++	{ 0x1FF6, 0x1FFC },
++	{ 0x2090, 0x209C },
++	{ 0x210A, 0x2113 },
++	{ 0x2119, 0x211D },
++	{ 0x212A, 0x212D },
++	{ 0x212F, 0x2139 },
++	{ 0x213C, 0x213F },
++	{ 0x2145, 0x2149 },
++	{ 0x2183, 0x2184 },
++	{ 0x2C00, 0x2C2E },
++	{ 0x2C30, 0x2C5E },
++	{ 0x2C60, 0x2CE4 },
++	{ 0x2CEB, 0x2CEE },
++	{ 0x2CF2, 0x2CF3 },
++	{ 0x2D00, 0x2D25 },
++	{ 0x2D30, 0x2D67 },
++	{ 0x2D80, 0x2D96 },
++	{ 0x2DA0, 0x2DA6 },
++	{ 0x2DA8, 0x2DAE },
++	{ 0x2DB0, 0x2DB6 },
++	{ 0x2DB8, 0x2DBE },
++	{ 0x2DC0, 0x2DC6 },
++	{ 0x2DC8, 0x2DCE },
++	{ 0x2DD0, 0x2DD6 },
++	{ 0x2DD8, 0x2DDE },
++	{ 0x3005, 0x3006 },
++	{ 0x3031, 0x3035 },
++	{ 0x303B, 0x303C },
++	{ 0x3041, 0x3096 },
++	{ 0x309D, 0x309F },
++	{ 0x30A1, 0x30FA },
++	{ 0x30FC, 0x30FF },
++	{ 0x3105, 0x312D },
++	{ 0x3131, 0x318E },
++	{ 0x31A0, 0x31BA },
++	{ 0x31F0, 0x31FF },
++	{ 0xA000, 0xA48C },
++	{ 0xA4D0, 0xA4FD },
++	{ 0xA500, 0xA60C },
++	{ 0xA610, 0xA61F },
++	{ 0xA62A, 0xA62B },
++	{ 0xA640, 0xA66E },
++	{ 0xA67F, 0xA69D },
++	{ 0xA6A0, 0xA6E5 },
++	{ 0xA717, 0xA71F },
++	{ 0xA722, 0xA788 },
++	{ 0xA78B, 0xA7AE },
++	{ 0xA7B0, 0xA7B7 },
++	{ 0xA7F7, 0xA801 },
++	{ 0xA803, 0xA805 },
++	{ 0xA807, 0xA80A },
++	{ 0xA80C, 0xA822 },
++	{ 0xA840, 0xA873 },
++	{ 0xA882, 0xA8B3 },
++	{ 0xA8F2, 0xA8F7 },
++	{ 0xA90A, 0xA925 },
++	{ 0xA930, 0xA946 },
++	{ 0xA960, 0xA97C },
++	{ 0xA984, 0xA9B2 },
++	{ 0xA9E0, 0xA9E4 },
++	{ 0xA9E6, 0xA9EF },
++	{ 0xA9FA, 0xA9FE },
++	{ 0xAA00, 0xAA28 },
++	{ 0xAA40, 0xAA42 },
++	{ 0xAA44, 0xAA4B },
++	{ 0xAA60, 0xAA76 },
++	{ 0xAA7E, 0xAAAF },
++	{ 0xAAB5, 0xAAB6 },
++	{ 0xAAB9, 0xAABD },
++	{ 0xAADB, 0xAADD },
++	{ 0xAAE0, 0xAAEA },
++	{ 0xAAF2, 0xAAF4 },
++	{ 0xAB01, 0xAB06 },
++	{ 0xAB09, 0xAB0E },
++	{ 0xAB11, 0xAB16 },
++	{ 0xAB20, 0xAB26 },
++	{ 0xAB28, 0xAB2E },
++	{ 0xAB30, 0xAB5A },
++	{ 0xAB5C, 0xAB65 },
++	{ 0xAB70, 0xABE2 },
++	{ 0xD7B0, 0xD7C6 },
++	{ 0xD7CB, 0xD7FB },
++	{ 0xF900, 0xFA6D },
++	{ 0xFA70, 0xFAD9 },
++	{ 0xFB00, 0xFB06 },
++	{ 0xFB13, 0xFB17 },
++	{ 0xFB1F, 0xFB28 },
++	{ 0xFB2A, 0xFB36 },
++	{ 0xFB38, 0xFB3C },
++	{ 0xFB40, 0xFB41 },
++	{ 0xFB43, 0xFB44 },
++	{ 0xFB46, 0xFBB1 },
++	{ 0xFBD3, 0xFD3D },
++	{ 0xFD50, 0xFD8F },
++	{ 0xFD92, 0xFDC7 },
++	{ 0xFDF0, 0xFDFB },
++	{ 0xFE70, 0xFE74 },
++	{ 0xFE76, 0xFEFC },
++	{ 0xFF21, 0xFF3A },
++	{ 0xFF41, 0xFF5A },
++	{ 0xFF66, 0xFFBE },
++	{ 0xFFC2, 0xFFC7 },
++	{ 0xFFCA, 0xFFCF },
++	{ 0xFFD2, 0xFFD7 },
++	{ 0xFFDA, 0xFFDC },
++	{ 0x10000, 0x1000B },
++	{ 0x1000D, 0x10026 },
++	{ 0x10028, 0x1003A },
++	{ 0x1003C, 0x1003D },
++	{ 0x1003F, 0x1004D },
++	{ 0x10050, 0x1005D },
++	{ 0x10080, 0x100FA },
++	{ 0x10280, 0x1029C },
++	{ 0x102A0, 0x102D0 },
++	{ 0x10300, 0x1031F },
++	{ 0x10330, 0x10340 },
++	{ 0x10342, 0x10349 },
++	{ 0x10350, 0x10375 },
++	{ 0x10380, 0x1039D },
++	{ 0x103A0, 0x103C3 },
++	{ 0x103C8, 0x103CF },
++	{ 0x10400, 0x1049D },
++	{ 0x104B0, 0x104D3 },
++	{ 0x104D8, 0x104FB },
++	{ 0x10500, 0x10527 },
++	{ 0x10530, 0x10563 },
++	{ 0x10600, 0x10736 },
++	{ 0x10740, 0x10755 },
++	{ 0x10760, 0x10767 },
++	{ 0x10800, 0x10805 },
++	{ 0x1080A, 0x10835 },
++	{ 0x10837, 0x10838 },
++	{ 0x1083F, 0x10855 },
++	{ 0x10860, 0x10876 },
++	{ 0x10880, 0x1089E },
++	{ 0x108E0, 0x108F2 },
++	{ 0x108F4, 0x108F5 },
++	{ 0x10900, 0x10915 },
++	{ 0x10920, 0x10939 },
++	{ 0x10980, 0x109B7 },
++	{ 0x109BE, 0x109BF },
++	{ 0x10A10, 0x10A13 },
++	{ 0x10A15, 0x10A17 },
++	{ 0x10A19, 0x10A33 },
++	{ 0x10A60, 0x10A7C },
++	{ 0x10A80, 0x10A9C },
++	{ 0x10AC0, 0x10AC7 },
++	{ 0x10AC9, 0x10AE4 },
++	{ 0x10B00, 0x10B35 },
++	{ 0x10B40, 0x10B55 },
++	{ 0x10B60, 0x10B72 },
++	{ 0x10B80, 0x10B91 },
++	{ 0x10C00, 0x10C48 },
++	{ 0x10C80, 0x10CB2 },
++	{ 0x10CC0, 0x10CF2 },
++	{ 0x11003, 0x11037 },
++	{ 0x11083, 0x110AF },
++	{ 0x110D0, 0x110E8 },
++	{ 0x11103, 0x11126 },
++	{ 0x11150, 0x11172 },
++	{ 0x11183, 0x111B2 },
++	{ 0x111C1, 0x111C4 },
++	{ 0x11200, 0x11211 },
++	{ 0x11213, 0x1122B },
++	{ 0x11280, 0x11286 },
++	{ 0x1128A, 0x1128D },
++	{ 0x1128F, 0x1129D },
++	{ 0x1129F, 0x112A8 },
++	{ 0x112B0, 0x112DE },
++	{ 0x11305, 0x1130C },
++	{ 0x1130F, 0x11310 },
++	{ 0x11313, 0x11328 },
++	{ 0x1132A, 0x11330 },
++	{ 0x11332, 0x11333 },
++	{ 0x11335, 0x11339 },
++	{ 0x1135D, 0x11361 },
++	{ 0x11400, 0x11434 },
++	{ 0x11447, 0x1144A },
++	{ 0x11480, 0x114AF },
++	{ 0x114C4, 0x114C5 },
++	{ 0x11580, 0x115AE },
++	{ 0x115D8, 0x115DB },
++	{ 0x11600, 0x1162F },
++	{ 0x11680, 0x116AA },
++	{ 0x11700, 0x11719 },
++	{ 0x118A0, 0x118DF },
++	{ 0x11AC0, 0x11AF8 },
++	{ 0x11C00, 0x11C08 },
++	{ 0x11C0A, 0x11C2E },
++	{ 0x11C72, 0x11C8F },
++	{ 0x12000, 0x12399 },
++	{ 0x12480, 0x12543 },
++	{ 0x13000, 0x1342E },
++	{ 0x14400, 0x14646 },
++	{ 0x16800, 0x16A38 },
++	{ 0x16A40, 0x16A5E },
++	{ 0x16AD0, 0x16AED },
++	{ 0x16B00, 0x16B2F },
++	{ 0x16B40, 0x16B43 },
++	{ 0x16B63, 0x16B77 },
++	{ 0x16B7D, 0x16B8F },
++	{ 0x16F00, 0x16F44 },
++	{ 0x16F93, 0x16F9F },
++	{ 0x18800, 0x18AF2 },
++	{ 0x1B000, 0x1B001 },
++	{ 0x1BC00, 0x1BC6A },
++	{ 0x1BC70, 0x1BC7C },
++	{ 0x1BC80, 0x1BC88 },
++	{ 0x1BC90, 0x1BC99 },
++	{ 0x1D400, 0x1D454 },
++	{ 0x1D456, 0x1D49C },
++	{ 0x1D49E, 0x1D49F },
++	{ 0x1D4A5, 0x1D4A6 },
++	{ 0x1D4A9, 0x1D4AC },
++	{ 0x1D4AE, 0x1D4B9 },
++	{ 0x1D4BD, 0x1D4C3 },
++	{ 0x1D4C5, 0x1D505 },
++	{ 0x1D507, 0x1D50A },
++	{ 0x1D50D, 0x1D514 },
++	{ 0x1D516, 0x1D51C },
++	{ 0x1D51E, 0x1D539 },
++	{ 0x1D53B, 0x1D53E },
++	{ 0x1D540, 0x1D544 },
++	{ 0x1D54A, 0x1D550 },
++	{ 0x1D552, 0x1D6A5 },
++	{ 0x1D6A8, 0x1D6C0 },
++	{ 0x1D6C2, 0x1D6DA },
++	{ 0x1D6DC, 0x1D6FA },
++	{ 0x1D6FC, 0x1D714 },
++	{ 0x1D716, 0x1D734 },
++	{ 0x1D736, 0x1D74E },
++	{ 0x1D750, 0x1D76E },
++	{ 0x1D770, 0x1D788 },
++	{ 0x1D78A, 0x1D7A8 },
++	{ 0x1D7AA, 0x1D7C2 },
++	{ 0x1D7C4, 0x1D7CB },
++	{ 0x1E800, 0x1E8C4 },
++	{ 0x1E900, 0x1E943 },
++	{ 0x1EE00, 0x1EE03 },
++	{ 0x1EE05, 0x1EE1F },
++	{ 0x1EE21, 0x1EE22 },
++	{ 0x1EE29, 0x1EE32 },
++	{ 0x1EE34, 0x1EE37 },
++	{ 0x1EE4D, 0x1EE4F },
++	{ 0x1EE51, 0x1EE52 },
++	{ 0x1EE61, 0x1EE62 },
++	{ 0x1EE67, 0x1EE6A },
++	{ 0x1EE6C, 0x1EE72 },
++	{ 0x1EE74, 0x1EE77 },
++	{ 0x1EE79, 0x1EE7C },
++	{ 0x1EE80, 0x1EE89 },
++	{ 0x1EE8B, 0x1EE9B },
++	{ 0x1EEA1, 0x1EEA3 },
++	{ 0x1EEA5, 0x1EEA9 },
++	{ 0x1EEAB, 0x1EEBB },
++	{ 0x2F800, 0x2FA1D },
++};
++#define LACES1 laces1
++static Rune laces1[][2] = {
++	{ 0x00D6, 0x00D8 },
++	{ 0x00F6, 0x00F8 },
++	{ 0x02EC, 0x02EE },
++	{ 0x0374, 0x0376 },
++	{ 0x037D, 0x037F },
++	{ 0x0386, 0x0388 },
++	{ 0x038A, 0x038E },
++	{ 0x03A1, 0x03A3 },
++	{ 0x03F5, 0x03F7 },
++	{ 0x052F, 0x0531 },
++	{ 0x066F, 0x0671 },
++	{ 0x06D3, 0x06D5 },
++	{ 0x0710, 0x0712 },
++	{ 0x08B4, 0x08B6 },
++	{ 0x09A8, 0x09AA },
++	{ 0x09B0, 0x09B2 },
++	{ 0x09DD, 0x09DF },
++	{ 0x0A28, 0x0A2A },
++	{ 0x0A30, 0x0A32 },
++	{ 0x0A33, 0x0A35 },
++	{ 0x0A36, 0x0A38 },
++	{ 0x0A5C, 0x0A5E },
++	{ 0x0A8D, 0x0A8F },
++	{ 0x0A91, 0x0A93 },
++	{ 0x0AA8, 0x0AAA },
++	{ 0x0AB0, 0x0AB2 },
++	{ 0x0AB3, 0x0AB5 },
++	{ 0x0B28, 0x0B2A },
++	{ 0x0B30, 0x0B32 },
++	{ 0x0B33, 0x0B35 },
++	{ 0x0B5D, 0x0B5F },
++	{ 0x0B83, 0x0B85 },
++	{ 0x0B90, 0x0B92 },
++	{ 0x0B9A, 0x0B9E },
++	{ 0x0C0C, 0x0C0E },
++	{ 0x0C10, 0x0C12 },
++	{ 0x0C28, 0x0C2A },
++	{ 0x0C8C, 0x0C8E },
++	{ 0x0C90, 0x0C92 },
++	{ 0x0CA8, 0x0CAA },
++	{ 0x0CB3, 0x0CB5 },
++	{ 0x0CDE, 0x0CE0 },
++	{ 0x0D0C, 0x0D0E },
++	{ 0x0D10, 0x0D12 },
++	{ 0x0DB1, 0x0DB3 },
++	{ 0x0DBB, 0x0DBD },
++	{ 0x0E30, 0x0E32 },
++	{ 0x0E82, 0x0E84 },
++	{ 0x0E88, 0x0E8A },
++	{ 0x0E97, 0x0E99 },
++	{ 0x0E9F, 0x0EA1 },
++	{ 0x0EA3, 0x0EA7 },
++	{ 0x0EAB, 0x0EAD },
++	{ 0x0EB0, 0x0EB2 },
++	{ 0x0EC4, 0x0EC6 },
++	{ 0x0F47, 0x0F49 },
++	{ 0x10C5, 0x10C7 },
++	{ 0x10FA, 0x10FC },
++	{ 0x1248, 0x124A },
++	{ 0x1256, 0x125A },
++	{ 0x1288, 0x128A },
++	{ 0x12B0, 0x12B2 },
++	{ 0x12BE, 0x12C2 },
++	{ 0x12D6, 0x12D8 },
++	{ 0x1310, 0x1312 },
++	{ 0x167F, 0x1681 },
++	{ 0x170C, 0x170E },
++	{ 0x176C, 0x176E },
++	{ 0x18A8, 0x18AA },
++	{ 0x1CEC, 0x1CEE },
++	{ 0x1F57, 0x1F5F },
++	{ 0x1FB4, 0x1FB6 },
++	{ 0x1FBC, 0x1FBE },
++	{ 0x1FC4, 0x1FC6 },
++	{ 0x1FF4, 0x1FF6 },
++	{ 0x2113, 0x2115 },
++	{ 0x2124, 0x212A },
++	{ 0x212D, 0x212F },
++	{ 0x2C2E, 0x2C30 },
++	{ 0x2C5E, 0x2C60 },
++	{ 0x2D25, 0x2D27 },
++	{ 0x2DA6, 0x2DA8 },
++	{ 0x2DAE, 0x2DB0 },
++	{ 0x2DB6, 0x2DB8 },
++	{ 0x2DBE, 0x2DC0 },
++	{ 0x2DC6, 0x2DC8 },
++	{ 0x2DCE, 0x2DD0 },
++	{ 0x2DD6, 0x2DD8 },
++	{ 0x309F, 0x30A1 },
++	{ 0x30FA, 0x30FC },
++	{ 0xA7AE, 0xA7B0 },
++	{ 0xA801, 0xA803 },
++	{ 0xA805, 0xA807 },
++	{ 0xA80A, 0xA80C },
++	{ 0xA8FB, 0xA8FD },
++	{ 0xA9E4, 0xA9E6 },
++	{ 0xA9FE, 0xAA00 },
++	{ 0xAA42, 0xAA44 },
++	{ 0xAAAF, 0xAAB1 },
++	{ 0xAAC0, 0xAAC2 },
++	{ 0xAB26, 0xAB28 },
++	{ 0xAB2E, 0xAB30 },
++	{ 0xAB5A, 0xAB5C },
++	{ 0xFB1D, 0xFB1F },
++	{ 0xFB28, 0xFB2A },
++	{ 0xFB36, 0xFB38 },
++	{ 0xFB3C, 0xFB40 },
++	{ 0xFB41, 0xFB43 },
++	{ 0xFB44, 0xFB46 },
++	{ 0xFE74, 0xFE76 },
++	{ 0x1000B, 0x1000D },
++	{ 0x10026, 0x10028 },
++	{ 0x1003A, 0x1003C },
++	{ 0x1003D, 0x1003F },
++	{ 0x10340, 0x10342 },
++	{ 0x10808, 0x1080A },
++	{ 0x10835, 0x10837 },
++	{ 0x108F2, 0x108F4 },
++	{ 0x10A13, 0x10A15 },
++	{ 0x10A17, 0x10A19 },
++	{ 0x10AC7, 0x10AC9 },
++	{ 0x111DA, 0x111DC },
++	{ 0x11211, 0x11213 },
++	{ 0x11286, 0x1128A },
++	{ 0x1128D, 0x1128F },
++	{ 0x1129D, 0x1129F },
++	{ 0x11328, 0x1132A },
++	{ 0x11330, 0x11332 },
++	{ 0x11333, 0x11335 },
++	{ 0x114C5, 0x114C7 },
++	{ 0x11C08, 0x11C0A },
++	{ 0x1D454, 0x1D456 },
++	{ 0x1D49C, 0x1D49E },
++	{ 0x1D4AC, 0x1D4AE },
++	{ 0x1D4B9, 0x1D4BD },
++	{ 0x1D4C3, 0x1D4C5 },
++	{ 0x1D505, 0x1D507 },
++	{ 0x1D514, 0x1D516 },
++	{ 0x1D51C, 0x1D51E },
++	{ 0x1D539, 0x1D53B },
++	{ 0x1D53E, 0x1D540 },
++	{ 0x1D544, 0x1D546 },
++	{ 0x1D550, 0x1D552 },
++	{ 0x1D6C0, 0x1D6C2 },
++	{ 0x1D6DA, 0x1D6DC },
++	{ 0x1D6FA, 0x1D6FC },
++	{ 0x1D714, 0x1D716 },
++	{ 0x1D734, 0x1D736 },
++	{ 0x1D74E, 0x1D750 },
++	{ 0x1D76E, 0x1D770 },
++	{ 0x1D788, 0x1D78A },
++	{ 0x1D7A8, 0x1D7AA },
++	{ 0x1D7C2, 0x1D7C4 },
++	{ 0x1EE03, 0x1EE05 },
++	{ 0x1EE1F, 0x1EE21 },
++	{ 0x1EE22, 0x1EE24 },
++	{ 0x1EE27, 0x1EE29 },
++	{ 0x1EE32, 0x1EE34 },
++	{ 0x1EE37, 0x1EE3B },
++	{ 0x1EE47, 0x1EE4D },
++	{ 0x1EE4F, 0x1EE51 },
++	{ 0x1EE52, 0x1EE54 },
++	{ 0x1EE57, 0x1EE61 },
++	{ 0x1EE62, 0x1EE64 },
++	{ 0x1EE6A, 0x1EE6C },
++	{ 0x1EE72, 0x1EE74 },
++	{ 0x1EE77, 0x1EE79 },
++	{ 0x1EE7C, 0x1EE80 },
++	{ 0x1EE89, 0x1EE8B },
++	{ 0x1EEA3, 0x1EEA5 },
++	{ 0x1EEA9, 0x1EEAB },
++};
++#include "runetypebody.h"
+diff --git a/third_party/utf/src/runetype/iscntrlrune.c b/third_party/utf/src/runetype/iscntrlrune.c
+new file mode 100644
+index 000000000000..bee8628f3d68
+--- /dev/null
++++ b/third_party/utf/src/runetype/iscntrlrune.c
+@@ -0,0 +1,9 @@
++/* Automatically generated by mkrunetype.awk */
++#include "runetype.h"
++#define ISRUNE iscntrlrune
++#define RANGES ranges
++static Rune ranges[][2] = {
++	{ 0x0000, 0x001F },
++	{ 0x007F, 0x009F },
++};
++#include "runetypebody.h"
+diff --git a/third_party/utf/src/runetype/isdigitrune.c b/third_party/utf/src/runetype/isdigitrune.c
+new file mode 100644
+index 000000000000..8be079b9afe4
+--- /dev/null
++++ b/third_party/utf/src/runetype/isdigitrune.c
+@@ -0,0 +1,61 @@
++/* Automatically generated by mkrunetype.awk */
++#include "runetype.h"
++#define ISRUNE isdigitrune
++#define RANGES ranges
++static Rune ranges[][2] = {
++	{ 0x0030, 0x0039 },
++	{ 0x0660, 0x0669 },
++	{ 0x06F0, 0x06F9 },
++	{ 0x07C0, 0x07C9 },
++	{ 0x0966, 0x096F },
++	{ 0x09E6, 0x09EF },
++	{ 0x0A66, 0x0A6F },
++	{ 0x0AE6, 0x0AEF },
++	{ 0x0B66, 0x0B6F },
++	{ 0x0BE6, 0x0BEF },
++	{ 0x0C66, 0x0C6F },
++	{ 0x0CE6, 0x0CEF },
++	{ 0x0D66, 0x0D6F },
++	{ 0x0DE6, 0x0DEF },
++	{ 0x0E50, 0x0E59 },
++	{ 0x0ED0, 0x0ED9 },
++	{ 0x0F20, 0x0F29 },
++	{ 0x1040, 0x1049 },
++	{ 0x1090, 0x1099 },
++	{ 0x17E0, 0x17E9 },
++	{ 0x1810, 0x1819 },
++	{ 0x1946, 0x194F },
++	{ 0x19D0, 0x19D9 },
++	{ 0x1A80, 0x1A89 },
++	{ 0x1A90, 0x1A99 },
++	{ 0x1B50, 0x1B59 },
++	{ 0x1BB0, 0x1BB9 },
++	{ 0x1C40, 0x1C49 },
++	{ 0x1C50, 0x1C59 },
++	{ 0xA620, 0xA629 },
++	{ 0xA8D0, 0xA8D9 },
++	{ 0xA900, 0xA909 },
++	{ 0xA9D0, 0xA9D9 },
++	{ 0xA9F0, 0xA9F9 },
++	{ 0xAA50, 0xAA59 },
++	{ 0xABF0, 0xABF9 },
++	{ 0xFF10, 0xFF19 },
++	{ 0x104A0, 0x104A9 },
++	{ 0x11066, 0x1106F },
++	{ 0x110F0, 0x110F9 },
++	{ 0x11136, 0x1113F },
++	{ 0x111D0, 0x111D9 },
++	{ 0x112F0, 0x112F9 },
++	{ 0x11450, 0x11459 },
++	{ 0x114D0, 0x114D9 },
++	{ 0x11650, 0x11659 },
++	{ 0x116C0, 0x116C9 },
++	{ 0x11730, 0x11739 },
++	{ 0x118E0, 0x118E9 },
++	{ 0x11C50, 0x11C59 },
++	{ 0x16A60, 0x16A69 },
++	{ 0x16B50, 0x16B59 },
++	{ 0x1D7CE, 0x1D7FF },
++	{ 0x1E950, 0x1E959 },
++};
++#include "runetypebody.h"
+diff --git a/third_party/utf/src/runetype/islowerrune.c b/third_party/utf/src/runetype/islowerrune.c
+new file mode 100644
+index 000000000000..76f68a5863e3
+--- /dev/null
++++ b/third_party/utf/src/runetype/islowerrune.c
+@@ -0,0 +1,303 @@
++/* Automatically generated by mkrunetype.awk */
++#include "runetype.h"
++#define ISRUNE islowerrune
++#define TORUNE toupperrune
++#define SINGLES singles
++static Rune singles[][2] = {
++	{ 0x00B5, 0x039C },
++	{ 0x00DF, 0x00DF },
++	{ 0x00FF, 0x0178 },
++	{ 0x0131, 0x0049 },
++	{ 0x0138, 0x0138 },
++	{ 0x0149, 0x0149 },
++	{ 0x017F, 0x0053 },
++	{ 0x0180, 0x0243 },
++	{ 0x0188, 0x0187 },
++	{ 0x018C, 0x018B },
++	{ 0x018D, 0x018D },
++	{ 0x0192, 0x0191 },
++	{ 0x0195, 0x01F6 },
++	{ 0x0199, 0x0198 },
++	{ 0x019A, 0x023D },
++	{ 0x019B, 0x019B },
++	{ 0x019E, 0x0220 },
++	{ 0x01A8, 0x01A7 },
++	{ 0x01AD, 0x01AC },
++	{ 0x01B0, 0x01AF },
++	{ 0x01B9, 0x01B8 },
++	{ 0x01BA, 0x01BA },
++	{ 0x01BD, 0x01BC },
++	{ 0x01BE, 0x01BE },
++	{ 0x01BF, 0x01F7 },
++	{ 0x01C6, 0x01C4 },
++	{ 0x01C9, 0x01C7 },
++	{ 0x01CC, 0x01CA },
++	{ 0x01DD, 0x018E },
++	{ 0x01F0, 0x01F0 },
++	{ 0x01F3, 0x01F1 },
++	{ 0x01F5, 0x01F4 },
++	{ 0x0221, 0x0221 },
++	{ 0x023C, 0x023B },
++	{ 0x0242, 0x0241 },
++	{ 0x0250, 0x2C6F },
++	{ 0x0251, 0x2C6D },
++	{ 0x0252, 0x2C70 },
++	{ 0x0253, 0x0181 },
++	{ 0x0254, 0x0186 },
++	{ 0x0255, 0x0255 },
++	{ 0x0258, 0x0258 },
++	{ 0x0259, 0x018F },
++	{ 0x025A, 0x025A },
++	{ 0x025B, 0x0190 },
++	{ 0x025C, 0xA7AB },
++	{ 0x0260, 0x0193 },
++	{ 0x0261, 0xA7AC },
++	{ 0x0262, 0x0262 },
++	{ 0x0263, 0x0194 },
++	{ 0x0264, 0x0264 },
++	{ 0x0265, 0xA78D },
++	{ 0x0266, 0xA7AA },
++	{ 0x0267, 0x0267 },
++	{ 0x0268, 0x0197 },
++	{ 0x0269, 0x0196 },
++	{ 0x026A, 0xA7AE },
++	{ 0x026B, 0x2C62 },
++	{ 0x026C, 0xA7AD },
++	{ 0x026F, 0x019C },
++	{ 0x0270, 0x0270 },
++	{ 0x0271, 0x2C6E },
++	{ 0x0272, 0x019D },
++	{ 0x0275, 0x019F },
++	{ 0x027D, 0x2C64 },
++	{ 0x0280, 0x01A6 },
++	{ 0x0283, 0x01A9 },
++	{ 0x0287, 0xA7B1 },
++	{ 0x0288, 0x01AE },
++	{ 0x0289, 0x0244 },
++	{ 0x028C, 0x0245 },
++	{ 0x0292, 0x01B7 },
++	{ 0x0293, 0x0293 },
++	{ 0x029D, 0xA7B2 },
++	{ 0x029E, 0xA7B0 },
++	{ 0x0377, 0x0376 },
++	{ 0x0390, 0x0390 },
++	{ 0x03AC, 0x0386 },
++	{ 0x03B0, 0x03B0 },
++	{ 0x03C2, 0x03A3 },
++	{ 0x03CC, 0x038C },
++	{ 0x03D0, 0x0392 },
++	{ 0x03D1, 0x0398 },
++	{ 0x03D5, 0x03A6 },
++	{ 0x03D6, 0x03A0 },
++	{ 0x03D7, 0x03CF },
++	{ 0x03F0, 0x039A },
++	{ 0x03F1, 0x03A1 },
++	{ 0x03F2, 0x03F9 },
++	{ 0x03F3, 0x037F },
++	{ 0x03F5, 0x0395 },
++	{ 0x03F8, 0x03F7 },
++	{ 0x03FB, 0x03FA },
++	{ 0x03FC, 0x03FC },
++	{ 0x04CF, 0x04C0 },
++	{ 0x0587, 0x0587 },
++	{ 0x1C80, 0x0412 },
++	{ 0x1C81, 0x0414 },
++	{ 0x1C82, 0x041E },
++	{ 0x1C85, 0x0422 },
++	{ 0x1C86, 0x042A },
++	{ 0x1C87, 0x0462 },
++	{ 0x1C88, 0xA64A },
++	{ 0x1D79, 0xA77D },
++	{ 0x1D7D, 0x2C63 },
++	{ 0x1E9B, 0x1E60 },
++	{ 0x1E9F, 0x1E9F },
++	{ 0x1F50, 0x1F50 },
++	{ 0x1F51, 0x1F59 },
++	{ 0x1F52, 0x1F52 },
++	{ 0x1F53, 0x1F5B },
++	{ 0x1F54, 0x1F54 },
++	{ 0x1F55, 0x1F5D },
++	{ 0x1F56, 0x1F56 },
++	{ 0x1F57, 0x1F5F },
++	{ 0x1FB2, 0x1FB2 },
++	{ 0x1FB3, 0x1FBC },
++	{ 0x1FB4, 0x1FB4 },
++	{ 0x1FBE, 0x0399 },
++	{ 0x1FC2, 0x1FC2 },
++	{ 0x1FC3, 0x1FCC },
++	{ 0x1FC4, 0x1FC4 },
++	{ 0x1FE5, 0x1FEC },
++	{ 0x1FF2, 0x1FF2 },
++	{ 0x1FF3, 0x1FFC },
++	{ 0x1FF4, 0x1FF4 },
++	{ 0x210A, 0x210A },
++	{ 0x2113, 0x2113 },
++	{ 0x212F, 0x212F },
++	{ 0x2134, 0x2134 },
++	{ 0x2139, 0x2139 },
++	{ 0x214E, 0x2132 },
++	{ 0x2184, 0x2183 },
++	{ 0x2C61, 0x2C60 },
++	{ 0x2C65, 0x023A },
++	{ 0x2C66, 0x023E },
++	{ 0x2C71, 0x2C71 },
++	{ 0x2C73, 0x2C72 },
++	{ 0x2C74, 0x2C74 },
++	{ 0x2C76, 0x2C75 },
++	{ 0x2CE4, 0x2CE4 },
++	{ 0x2CF3, 0x2CF2 },
++	{ 0x2D27, 0x10C7 },
++	{ 0x2D2D, 0x10CD },
++	{ 0xA78C, 0xA78B },
++	{ 0xA78E, 0xA78E },
++	{ 0xA7FA, 0xA7FA },
++	{ 0xAB53, 0xA7B3 },
++	{ 0x1D4BB, 0x1D4BB },
++	{ 0x1D7CB, 0x1D7CB },
++};
++#define RANGES ranges
++static Rune ranges[][3] = {
++	{ 0x0061, 0x007A, 0x0041 },
++	{ 0x00E0, 0x00F6, 0x00C0 },
++	{ 0x00F8, 0x00FE, 0x00D8 },
++	{ 0x01AA, 0x01AB, 0x01AA },
++	{ 0x0234, 0x0239, 0x0234 },
++	{ 0x023F, 0x0240, 0x2C7E },
++	{ 0x0256, 0x0257, 0x0189 },
++	{ 0x025D, 0x025F, 0x025D },
++	{ 0x026D, 0x026E, 0x026D },
++	{ 0x0273, 0x0274, 0x0273 },
++	{ 0x0276, 0x027C, 0x0276 },
++	{ 0x027E, 0x027F, 0x027E },
++	{ 0x0281, 0x0282, 0x0281 },
++	{ 0x0284, 0x0286, 0x0284 },
++	{ 0x028A, 0x028B, 0x01B1 },
++	{ 0x028D, 0x0291, 0x028D },
++	{ 0x0295, 0x029C, 0x0295 },
++	{ 0x029F, 0x02AF, 0x029F },
++	{ 0x037B, 0x037D, 0x03FD },
++	{ 0x03AD, 0x03AF, 0x0388 },
++	{ 0x03B1, 0x03C1, 0x0391 },
++	{ 0x03C3, 0x03CB, 0x03A3 },
++	{ 0x03CD, 0x03CE, 0x038E },
++	{ 0x0430, 0x044F, 0x0410 },
++	{ 0x0450, 0x045F, 0x0400 },
++	{ 0x0561, 0x0586, 0x0531 },
++	{ 0x13F8, 0x13FD, 0x13F0 },
++	{ 0x1C83, 0x1C84, 0x0421 },
++	{ 0x1D00, 0x1D2B, 0x1D00 },
++	{ 0x1D6B, 0x1D77, 0x1D6B },
++	{ 0x1D7A, 0x1D7C, 0x1D7A },
++	{ 0x1D7E, 0x1D9A, 0x1D7E },
++	{ 0x1E96, 0x1E9A, 0x1E96 },
++	{ 0x1E9C, 0x1E9D, 0x1E9C },
++	{ 0x1F00, 0x1F07, 0x1F08 },
++	{ 0x1F10, 0x1F15, 0x1F18 },
++	{ 0x1F20, 0x1F27, 0x1F28 },
++	{ 0x1F30, 0x1F37, 0x1F38 },
++	{ 0x1F40, 0x1F45, 0x1F48 },
++	{ 0x1F60, 0x1F67, 0x1F68 },
++	{ 0x1F70, 0x1F71, 0x1FBA },
++	{ 0x1F72, 0x1F75, 0x1FC8 },
++	{ 0x1F76, 0x1F77, 0x1FDA },
++	{ 0x1F78, 0x1F79, 0x1FF8 },
++	{ 0x1F7A, 0x1F7B, 0x1FEA },
++	{ 0x1F7C, 0x1F7D, 0x1FFA },
++	{ 0x1F80, 0x1F87, 0x1F88 },
++	{ 0x1F90, 0x1F97, 0x1F98 },
++	{ 0x1FA0, 0x1FA7, 0x1FA8 },
++	{ 0x1FB0, 0x1FB1, 0x1FB8 },
++	{ 0x1FB6, 0x1FB7, 0x1FB6 },
++	{ 0x1FC6, 0x1FC7, 0x1FC6 },
++	{ 0x1FD0, 0x1FD1, 0x1FD8 },
++	{ 0x1FD2, 0x1FD3, 0x1FD2 },
++	{ 0x1FD6, 0x1FD7, 0x1FD6 },
++	{ 0x1FE0, 0x1FE1, 0x1FE8 },
++	{ 0x1FE2, 0x1FE4, 0x1FE2 },
++	{ 0x1FE6, 0x1FE7, 0x1FE6 },
++	{ 0x1FF6, 0x1FF7, 0x1FF6 },
++	{ 0x210E, 0x210F, 0x210E },
++	{ 0x213C, 0x213D, 0x213C },
++	{ 0x2146, 0x2149, 0x2146 },
++	{ 0x2C30, 0x2C5E, 0x2C00 },
++	{ 0x2C77, 0x2C7B, 0x2C77 },
++	{ 0x2D00, 0x2D25, 0x10A0 },
++	{ 0xA730, 0xA731, 0xA730 },
++	{ 0xA771, 0xA778, 0xA771 },
++	{ 0xA794, 0xA795, 0xA794 },
++	{ 0xAB30, 0xAB52, 0xAB30 },
++	{ 0xAB54, 0xAB5A, 0xAB54 },
++	{ 0xAB60, 0xAB65, 0xAB60 },
++	{ 0xAB70, 0xABBF, 0x13A0 },
++	{ 0xFB00, 0xFB06, 0xFB00 },
++	{ 0xFB13, 0xFB17, 0xFB13 },
++	{ 0xFF41, 0xFF5A, 0xFF21 },
++	{ 0x10428, 0x1044F, 0x10400 },
++	{ 0x104D8, 0x104FB, 0x104B0 },
++	{ 0x10CC0, 0x10CF2, 0x10C80 },
++	{ 0x118C0, 0x118DF, 0x118A0 },
++	{ 0x1D41A, 0x1D433, 0x1D41A },
++	{ 0x1D44E, 0x1D454, 0x1D44E },
++	{ 0x1D456, 0x1D467, 0x1D456 },
++	{ 0x1D482, 0x1D49B, 0x1D482 },
++	{ 0x1D4B6, 0x1D4B9, 0x1D4B6 },
++	{ 0x1D4BD, 0x1D4C3, 0x1D4BD },
++	{ 0x1D4C5, 0x1D4CF, 0x1D4C5 },
++	{ 0x1D4EA, 0x1D503, 0x1D4EA },
++	{ 0x1D51E, 0x1D537, 0x1D51E },
++	{ 0x1D552, 0x1D56B, 0x1D552 },
++	{ 0x1D586, 0x1D59F, 0x1D586 },
++	{ 0x1D5BA, 0x1D5D3, 0x1D5BA },
++	{ 0x1D5EE, 0x1D607, 0x1D5EE },
++	{ 0x1D622, 0x1D63B, 0x1D622 },
++	{ 0x1D656, 0x1D66F, 0x1D656 },
++	{ 0x1D68A, 0x1D6A5, 0x1D68A },
++	{ 0x1D6C2, 0x1D6DA, 0x1D6C2 },
++	{ 0x1D6DC, 0x1D6E1, 0x1D6DC },
++	{ 0x1D6FC, 0x1D714, 0x1D6FC },
++	{ 0x1D716, 0x1D71B, 0x1D716 },
++	{ 0x1D736, 0x1D74E, 0x1D736 },
++	{ 0x1D750, 0x1D755, 0x1D750 },
++	{ 0x1D770, 0x1D788, 0x1D770 },
++	{ 0x1D78A, 0x1D78F, 0x1D78A },
++	{ 0x1D7AA, 0x1D7C2, 0x1D7AA },
++	{ 0x1D7C4, 0x1D7C9, 0x1D7C4 },
++	{ 0x1E922, 0x1E943, 0x1E900 },
++};
++#define LACES2 laces2
++static Rune laces2[][2] = {
++	{ 0x0101, 0x012F },
++	{ 0x0133, 0x0137 },
++	{ 0x013A, 0x0148 },
++	{ 0x014B, 0x0177 },
++	{ 0x017A, 0x017E },
++	{ 0x0183, 0x0185 },
++	{ 0x01A1, 0x01A5 },
++	{ 0x01B4, 0x01B6 },
++	{ 0x01CE, 0x01DC },
++	{ 0x01DF, 0x01EF },
++	{ 0x01F9, 0x021F },
++	{ 0x0223, 0x0233 },
++	{ 0x0247, 0x024F },
++	{ 0x0371, 0x0373 },
++	{ 0x03D9, 0x03EF },
++	{ 0x0461, 0x0481 },
++	{ 0x048B, 0x04BF },
++	{ 0x04C2, 0x04CE },
++	{ 0x04D1, 0x052F },
++	{ 0x1E01, 0x1E95 },
++	{ 0x1EA1, 0x1EFF },
++	{ 0x2C68, 0x2C6C },
++	{ 0x2C81, 0x2CE3 },
++	{ 0x2CEC, 0x2CEE },
++	{ 0xA641, 0xA66D },
++	{ 0xA681, 0xA69B },
++	{ 0xA723, 0xA72F },
++	{ 0xA733, 0xA76F },
++	{ 0xA77A, 0xA77C },
++	{ 0xA77F, 0xA787 },
++	{ 0xA791, 0xA793 },
++	{ 0xA797, 0xA7A9 },
++	{ 0xA7B5, 0xA7B7 },
++};
++#include "runetypebody.h"
+diff --git a/third_party/utf/src/runetype/isspacerune.c b/third_party/utf/src/runetype/isspacerune.c
+new file mode 100644
+index 000000000000..4078260d0b29
+--- /dev/null
++++ b/third_party/utf/src/runetype/isspacerune.c
+@@ -0,0 +1,20 @@
++/* Automatically generated by mkrunetype.awk */
++#include "runetype.h"
++#define ISRUNE isspacerune
++#define SINGLES singles
++static Rune singles[][1] = {
++	{ 0x0085 },
++	{ 0x00A0 },
++	{ 0x1680 },
++	{ 0x202F },
++	{ 0x205F },
++	{ 0x3000 },
++};
++#define RANGES ranges
++static Rune ranges[][2] = {
++	{ 0x0009, 0x000D },
++	{ 0x001C, 0x0020 },
++	{ 0x2000, 0x200A },
++	{ 0x2028, 0x2029 },
++};
++#include "runetypebody.h"
+diff --git a/third_party/utf/src/runetype/istitlerune.c b/third_party/utf/src/runetype/istitlerune.c
+new file mode 100644
+index 000000000000..70beb51c02b5
+--- /dev/null
++++ b/third_party/utf/src/runetype/istitlerune.c
+@@ -0,0 +1,20 @@
++/* Automatically generated by mkrunetype.awk */
++#include "runetype.h"
++#define ISRUNE istitlerune
++#define SINGLES singles
++static Rune singles[][1] = {
++	{ 0x01C5 },
++	{ 0x01C8 },
++	{ 0x01CB },
++	{ 0x01F2 },
++	{ 0x1FBC },
++	{ 0x1FCC },
++	{ 0x1FFC },
++};
++#define RANGES ranges
++static Rune ranges[][2] = {
++	{ 0x1F88, 0x1F8F },
++	{ 0x1F98, 0x1F9F },
++	{ 0x1FA8, 0x1FAF },
++};
++#include "runetypebody.h"
+diff --git a/third_party/utf/src/runetype/isupperrune.c b/third_party/utf/src/runetype/isupperrune.c
+new file mode 100644
+index 000000000000..d0c0bdce3ce6
+--- /dev/null
++++ b/third_party/utf/src/runetype/isupperrune.c
+@@ -0,0 +1,220 @@
++/* Automatically generated by mkrunetype.awk */
++#include "runetype.h"
++#define ISRUNE isupperrune
++#define TORUNE tolowerrune
++#define SINGLES singles
++static Rune singles[][2] = {
++	{ 0x0130, 0x0069 },
++	{ 0x0178, 0x00FF },
++	{ 0x0181, 0x0253 },
++	{ 0x0186, 0x0254 },
++	{ 0x0187, 0x0188 },
++	{ 0x018B, 0x018C },
++	{ 0x018E, 0x01DD },
++	{ 0x018F, 0x0259 },
++	{ 0x0190, 0x025B },
++	{ 0x0191, 0x0192 },
++	{ 0x0193, 0x0260 },
++	{ 0x0194, 0x0263 },
++	{ 0x0196, 0x0269 },
++	{ 0x0197, 0x0268 },
++	{ 0x0198, 0x0199 },
++	{ 0x019C, 0x026F },
++	{ 0x019D, 0x0272 },
++	{ 0x019F, 0x0275 },
++	{ 0x01A6, 0x0280 },
++	{ 0x01A7, 0x01A8 },
++	{ 0x01A9, 0x0283 },
++	{ 0x01AC, 0x01AD },
++	{ 0x01AE, 0x0288 },
++	{ 0x01AF, 0x01B0 },
++	{ 0x01B7, 0x0292 },
++	{ 0x01B8, 0x01B9 },
++	{ 0x01BC, 0x01BD },
++	{ 0x01C4, 0x01C6 },
++	{ 0x01C7, 0x01C9 },
++	{ 0x01CA, 0x01CC },
++	{ 0x01F1, 0x01F3 },
++	{ 0x01F4, 0x01F5 },
++	{ 0x01F6, 0x0195 },
++	{ 0x01F7, 0x01BF },
++	{ 0x0220, 0x019E },
++	{ 0x023A, 0x2C65 },
++	{ 0x023B, 0x023C },
++	{ 0x023D, 0x019A },
++	{ 0x023E, 0x2C66 },
++	{ 0x0241, 0x0242 },
++	{ 0x0243, 0x0180 },
++	{ 0x0244, 0x0289 },
++	{ 0x0245, 0x028C },
++	{ 0x0376, 0x0377 },
++	{ 0x037F, 0x03F3 },
++	{ 0x0386, 0x03AC },
++	{ 0x038C, 0x03CC },
++	{ 0x03CF, 0x03D7 },
++	{ 0x03F4, 0x03B8 },
++	{ 0x03F7, 0x03F8 },
++	{ 0x03F9, 0x03F2 },
++	{ 0x03FA, 0x03FB },
++	{ 0x04C0, 0x04CF },
++	{ 0x10C7, 0x2D27 },
++	{ 0x10CD, 0x2D2D },
++	{ 0x1E9E, 0x00DF },
++	{ 0x1F59, 0x1F51 },
++	{ 0x1F5B, 0x1F53 },
++	{ 0x1F5D, 0x1F55 },
++	{ 0x1F5F, 0x1F57 },
++	{ 0x1FEC, 0x1FE5 },
++	{ 0x2102, 0x2102 },
++	{ 0x2107, 0x2107 },
++	{ 0x2115, 0x2115 },
++	{ 0x2124, 0x2124 },
++	{ 0x2126, 0x03C9 },
++	{ 0x2128, 0x2128 },
++	{ 0x212A, 0x006B },
++	{ 0x212B, 0x00E5 },
++	{ 0x2132, 0x214E },
++	{ 0x2133, 0x2133 },
++	{ 0x2145, 0x2145 },
++	{ 0x2183, 0x2184 },
++	{ 0x2C60, 0x2C61 },
++	{ 0x2C62, 0x026B },
++	{ 0x2C63, 0x1D7D },
++	{ 0x2C64, 0x027D },
++	{ 0x2C6D, 0x0251 },
++	{ 0x2C6E, 0x0271 },
++	{ 0x2C6F, 0x0250 },
++	{ 0x2C70, 0x0252 },
++	{ 0x2C72, 0x2C73 },
++	{ 0x2C75, 0x2C76 },
++	{ 0x2CF2, 0x2CF3 },
++	{ 0xA77D, 0x1D79 },
++	{ 0xA78B, 0xA78C },
++	{ 0xA78D, 0x0265 },
++	{ 0xA7AA, 0x0266 },
++	{ 0xA7AB, 0x025C },
++	{ 0xA7AC, 0x0261 },
++	{ 0xA7AD, 0x026C },
++	{ 0xA7AE, 0x026A },
++	{ 0xA7B0, 0x029E },
++	{ 0xA7B1, 0x0287 },
++	{ 0xA7B2, 0x029D },
++	{ 0xA7B3, 0xAB53 },
++	{ 0x1D49C, 0x1D49C },
++	{ 0x1D4A2, 0x1D4A2 },
++	{ 0x1D546, 0x1D546 },
++	{ 0x1D7CA, 0x1D7CA },
++};
++#define RANGES ranges
++static Rune ranges[][3] = {
++	{ 0x0041, 0x005A, 0x0061 },
++	{ 0x00C0, 0x00D6, 0x00E0 },
++	{ 0x00D8, 0x00DE, 0x00F8 },
++	{ 0x0189, 0x018A, 0x0256 },
++	{ 0x01B1, 0x01B2, 0x028A },
++	{ 0x0388, 0x038A, 0x03AD },
++	{ 0x038E, 0x038F, 0x03CD },
++	{ 0x0391, 0x03A1, 0x03B1 },
++	{ 0x03A3, 0x03AB, 0x03C3 },
++	{ 0x03D2, 0x03D4, 0x03D2 },
++	{ 0x03FD, 0x03FF, 0x037B },
++	{ 0x0400, 0x040F, 0x0450 },
++	{ 0x0410, 0x042F, 0x0430 },
++	{ 0x0531, 0x0556, 0x0561 },
++	{ 0x10A0, 0x10C5, 0x2D00 },
++	{ 0x13A0, 0x13EF, 0xAB70 },
++	{ 0x13F0, 0x13F5, 0x13F8 },
++	{ 0x1F08, 0x1F0F, 0x1F00 },
++	{ 0x1F18, 0x1F1D, 0x1F10 },
++	{ 0x1F28, 0x1F2F, 0x1F20 },
++	{ 0x1F38, 0x1F3F, 0x1F30 },
++	{ 0x1F48, 0x1F4D, 0x1F40 },
++	{ 0x1F68, 0x1F6F, 0x1F60 },
++	{ 0x1FB8, 0x1FB9, 0x1FB0 },
++	{ 0x1FBA, 0x1FBB, 0x1F70 },
++	{ 0x1FC8, 0x1FCB, 0x1F72 },
++	{ 0x1FD8, 0x1FD9, 0x1FD0 },
++	{ 0x1FDA, 0x1FDB, 0x1F76 },
++	{ 0x1FE8, 0x1FE9, 0x1FE0 },
++	{ 0x1FEA, 0x1FEB, 0x1F7A },
++	{ 0x1FF8, 0x1FF9, 0x1F78 },
++	{ 0x1FFA, 0x1FFB, 0x1F7C },
++	{ 0x210B, 0x210D, 0x210B },
++	{ 0x2110, 0x2112, 0x2110 },
++	{ 0x2119, 0x211D, 0x2119 },
++	{ 0x212C, 0x212D, 0x212C },
++	{ 0x2130, 0x2131, 0x2130 },
++	{ 0x213E, 0x213F, 0x213E },
++	{ 0x2C00, 0x2C2E, 0x2C30 },
++	{ 0x2C7E, 0x2C7F, 0x023F },
++	{ 0xFF21, 0xFF3A, 0xFF41 },
++	{ 0x10400, 0x10427, 0x10428 },
++	{ 0x104B0, 0x104D3, 0x104D8 },
++	{ 0x10C80, 0x10CB2, 0x10CC0 },
++	{ 0x118A0, 0x118BF, 0x118C0 },
++	{ 0x1D400, 0x1D419, 0x1D400 },
++	{ 0x1D434, 0x1D44D, 0x1D434 },
++	{ 0x1D468, 0x1D481, 0x1D468 },
++	{ 0x1D49E, 0x1D49F, 0x1D49E },
++	{ 0x1D4A5, 0x1D4A6, 0x1D4A5 },
++	{ 0x1D4A9, 0x1D4AC, 0x1D4A9 },
++	{ 0x1D4AE, 0x1D4B5, 0x1D4AE },
++	{ 0x1D4D0, 0x1D4E9, 0x1D4D0 },
++	{ 0x1D504, 0x1D505, 0x1D504 },
++	{ 0x1D507, 0x1D50A, 0x1D507 },
++	{ 0x1D50D, 0x1D514, 0x1D50D },
++	{ 0x1D516, 0x1D51C, 0x1D516 },
++	{ 0x1D538, 0x1D539, 0x1D538 },
++	{ 0x1D53B, 0x1D53E, 0x1D53B },
++	{ 0x1D540, 0x1D544, 0x1D540 },
++	{ 0x1D54A, 0x1D550, 0x1D54A },
++	{ 0x1D56C, 0x1D585, 0x1D56C },
++	{ 0x1D5A0, 0x1D5B9, 0x1D5A0 },
++	{ 0x1D5D4, 0x1D5ED, 0x1D5D4 },
++	{ 0x1D608, 0x1D621, 0x1D608 },
++	{ 0x1D63C, 0x1D655, 0x1D63C },
++	{ 0x1D670, 0x1D689, 0x1D670 },
++	{ 0x1D6A8, 0x1D6C0, 0x1D6A8 },
++	{ 0x1D6E2, 0x1D6FA, 0x1D6E2 },
++	{ 0x1D71C, 0x1D734, 0x1D71C },
++	{ 0x1D756, 0x1D76E, 0x1D756 },
++	{ 0x1D790, 0x1D7A8, 0x1D790 },
++	{ 0x1E900, 0x1E921, 0x1E922 },
++};
++#define LACES1 laces1
++static Rune laces1[][2] = {
++	{ 0x0100, 0x012E },
++	{ 0x0132, 0x0136 },
++	{ 0x0139, 0x0147 },
++	{ 0x014A, 0x0176 },
++	{ 0x0179, 0x017D },
++	{ 0x0182, 0x0184 },
++	{ 0x01A0, 0x01A4 },
++	{ 0x01B3, 0x01B5 },
++	{ 0x01CD, 0x01DB },
++	{ 0x01DE, 0x01EE },
++	{ 0x01F8, 0x021E },
++	{ 0x0222, 0x0232 },
++	{ 0x0246, 0x024E },
++	{ 0x0370, 0x0372 },
++	{ 0x03D8, 0x03EE },
++	{ 0x0460, 0x0480 },
++	{ 0x048A, 0x04BE },
++	{ 0x04C1, 0x04CD },
++	{ 0x04D0, 0x052E },
++	{ 0x1E00, 0x1E94 },
++	{ 0x1EA0, 0x1EFE },
++	{ 0x2C67, 0x2C6B },
++	{ 0x2C80, 0x2CE2 },
++	{ 0x2CEB, 0x2CED },
++	{ 0xA640, 0xA66C },
++	{ 0xA680, 0xA69A },
++	{ 0xA722, 0xA72E },
++	{ 0xA732, 0xA76E },
++	{ 0xA779, 0xA77B },
++	{ 0xA77E, 0xA786 },
++	{ 0xA790, 0xA792 },
++	{ 0xA796, 0xA7A8 },
++	{ 0xA7B4, 0xA7B6 },
++};
++#include "runetypebody.h"
+-- 
+2.29.2.729.g45daf8777d-goog
+
diff --git a/third_party/utf/patches/0001-adding-korean-characters-to-ranges.patch b/third_party/utf/patches/0001-adding-korean-characters-to-ranges.patch
new file mode 100644
index 0000000000000..ae5c9183bbb41
--- /dev/null
+++ b/third_party/utf/patches/0001-adding-korean-characters-to-ranges.patch
@@ -0,0 +1,33 @@
+From 67038ecd125a5ae019819bbc9bb4de21c8f27e30 Mon Sep 17 00:00:00 2001
+From: mcrouse <mcrouse@google.com>
+Date: Fri, 5 Mar 2021 15:30:53 -0800
+Subject: [PATCH] adding korean characters to ranges
+
+---
+ third_party/utf/src/runetype/isalpharune.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/third_party/utf/src/runetype/isalpharune.c b/third_party/utf/src/runetype/isalpharune.c
+index 901433d2e056..086c0a8649b5 100644
+--- a/third_party/utf/src/runetype/isalpharune.c
++++ b/third_party/utf/src/runetype/isalpharune.c
+@@ -52,8 +52,6 @@ static Rune singles[][1] = {
+ 	{ 0x9FD5 },
+ 	{ 0xA9CF },
+ 	{ 0xAA7A },
+-	{ 0xAC00 },
+-	{ 0xD7A3 },
+ 	{ 0x1083C },
+ 	{ 0x10A00 },
+ 	{ 0x11176 },
+@@ -349,6 +347,7 @@ static Rune ranges[][2] = {
+ 	{ 0xAB30, 0xAB5A },
+ 	{ 0xAB5C, 0xAB65 },
+ 	{ 0xAB70, 0xABE2 },
++	{ 0xAC00, 0xD7A3 },
+ 	{ 0xD7B0, 0xD7C6 },
+ 	{ 0xD7CB, 0xD7FB },
+ 	{ 0xF900, 0xFA6D },
+-- 
+2.30.1.766.gb4fecdf3b7-goog
+
diff --git a/third_party/utf/patches/0001-utftab-refactor.patch b/third_party/utf/patches/0001-utftab-refactor.patch
new file mode 100644
index 0000000000000..2f2f221c2a536
--- /dev/null
+++ b/third_party/utf/patches/0001-utftab-refactor.patch
@@ -0,0 +1,50 @@
+From 791f91a0169528abfe02ab9893fd4dab72b362c1 Mon Sep 17 00:00:00 2001
+From: Sophie Chang <sophiechang@chromium.org>
+Date: Wed, 3 Feb 2021 04:42:04 +0000
+Subject: [PATCH] utftab refactor
+
+---
+ third_party/utf/src/utf/chartorune.c |  8 --------
+ third_party/utf/src/utf/utftab.c     | 11 +++++++++++
+ 2 files changed, 11 insertions(+), 8 deletions(-)
+ create mode 100644 third_party/utf/src/utf/utftab.c
+
+diff --git a/third_party/utf/src/utf/chartorune.c b/third_party/utf/src/utf/chartorune.c
+index f5ed9a8c077c..3073d23de245 100644
+--- a/third_party/utf/src/utf/chartorune.c
++++ b/third_party/utf/src/utf/chartorune.c
+@@ -1,14 +1,6 @@
+ /* See LICENSE file for copyright and license details. */
+ #include "utf.h"
+ 
+-/* lookup table for the number of bytes expected in a sequence */
+-const unsigned char utftab[64] = {
+-	0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 1100xxxx */
+-	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 1101xxxx */
+-	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 1110xxxx */
+-	4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 0, 0, /* 1111xxxx */
+-};
+-
+ int
+ charntorune(Rune *p, const char *s, size_t len)
+ {
+diff --git a/third_party/utf/src/utf/utftab.c b/third_party/utf/src/utf/utftab.c
+new file mode 100644
+index 000000000000..141580c16d9a
+--- /dev/null
++++ b/third_party/utf/src/utf/utftab.c
+@@ -0,0 +1,11 @@
++/* See LICENSE file for copyright and license details. */
++#include "utf.h"
++
++/* lookup table for the number of bytes expected in a sequence */
++const unsigned char utftab[64] = {
++        0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 1100xxxx */
++        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 1101xxxx */
++        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 1110xxxx */
++        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 0, 0, /* 1111xxxx */
++};
++
+-- 
+2.30.0.365.g02bc693789-goog
+
diff --git a/third_party/wtl/wtl10.patch b/third_party/wtl/wtl10.patch
new file mode 100644
index 0000000000000..05b8b8a753742
--- /dev/null
+++ b/third_party/wtl/wtl10.patch
@@ -0,0 +1,37 @@
+From 23ef510bb7a3f38ecf2d05edd04ccc5bcf210c0d Mon Sep 17 00:00:00 2001
+From: Sorin Jianu <sorin@chromium.org>
+Date: Thu, 13 Jun 2019 15:45:01 -0700
+Subject: [PATCH] fix atlverify
+
+---
+ third_party/wtl/include/atlapp.h | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/third_party/wtl/include/atlapp.h b/third_party/wtl/include/atlapp.h
+index c61be7e18faf..6c4d9b0f6e2a 100644
+--- a/third_party/wtl/include/atlapp.h
++++ b/third_party/wtl/include/atlapp.h
+@@ -187,7 +187,7 @@ inline HFONT AtlGetDefaultGuiFont()
+ inline HFONT AtlCreateControlFont()
+ {
+ 	LOGFONT lf = {};
+-	ATLVERIFY(::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0) != FALSE);
++	ATLVERIFY(::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0));
+ 	HFONT hFont = ::CreateFontIndirect(&lf);
+ 	ATLASSERT(hFont != NULL);
+ 	return hFont;
+@@ -199,9 +199,9 @@ inline HFONT AtlCreateBoldFont(HFONT hFont = NULL)
+ {
+ 	LOGFONT lf = {};
+ 	if(hFont == NULL)
+-		ATLVERIFY(::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0) != FALSE);
++		ATLVERIFY(::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0));
+ 	else
+-		ATLVERIFY(::GetObject(hFont, sizeof(LOGFONT), &lf) == sizeof(LOGFONT));
++		(void)(ATLVERIFY(::GetObject(hFont, sizeof(LOGFONT), &lf) == sizeof(LOGFONT)));
+ 	lf.lfWeight = FW_BOLD;
+ 	HFONT hFontBold =  ::CreateFontIndirect(&lf);
+ 	ATLASSERT(hFontBold != NULL);
+-- 
+2.21.0.windows.1
+
diff --git a/third_party/zlib/patches/0000-build.patch b/third_party/zlib/patches/0000-build.patch
new file mode 100644
index 0000000000000..1861194dd50cd
--- /dev/null
+++ b/third_party/zlib/patches/0000-build.patch
@@ -0,0 +1,158 @@
+diff --git a/contrib/minizip/ioapi.c b/contrib/minizip/ioapi.c
+index 782d32469ae5d..a38881dca90a2 100644
+--- a/contrib/minizip/ioapi.c
++++ b/contrib/minizip/ioapi.c
+@@ -14,7 +14,7 @@
+         #define _CRT_SECURE_NO_WARNINGS
+ #endif
+ 
+-#if defined(__APPLE__) || defined(IOAPI_NO_64) || defined(__HAIKU__) || defined(MINIZIP_FOPEN_NO_64)
++#if defined(__APPLE__) || defined(__Fuchsia__) || defined(IOAPI_NO_64) || defined(__HAIKU__) || defined(MINIZIP_FOPEN_NO_64)
+ // In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
+ #define FOPEN_FUNC(filename, mode) fopen(filename, mode)
+ #define FTELLO_FUNC(stream) ftello(stream)
+diff --git a/contrib/minizip/iowin32.c b/contrib/minizip/iowin32.c
+index 08536e94b8a28..bbd7773e67146 100644
+--- a/contrib/minizip/iowin32.c
++++ b/contrib/minizip/iowin32.c
+@@ -25,7 +25,12 @@
+ #define INVALID_SET_FILE_POINTER ((DWORD)-1)
+ #endif
+ 
++#ifdef _WIN32_WINNT
++#undef _WIN32_WINNT
++#define _WIN32_WINNT 0x601
++#endif
+ 
++#if _WIN32_WINNT >= _WIN32_WINNT_WIN8
+ // see Include/shared/winapifamily.h in the Windows Kit
+ #if defined(WINAPI_FAMILY_PARTITION) && (!(defined(IOWIN32_USING_WINRT_API)))
+ 
+@@ -37,6 +42,7 @@
+ #define IOWIN32_USING_WINRT_API 1
+ #endif
+ #endif
++#endif
+ 
+ typedef struct
+ {
+diff --git a/gzread.c b/gzread.c
+index 956b91ea7d9e..832d3ef98c59 100644
+--- a/gzread.c
++++ b/gzread.c
+@@ -443,7 +443,11 @@ z_size_t ZEXPORT gzfread(buf, size, nitems, file)
+ #  undef z_gzgetc
+ #else
+ #  undef gzgetc
++#  ifdef Z_CR_PREFIX_SET
++#    define gzgetc Cr_z_gzgetc
++#  endif
+ #endif
++
+ int ZEXPORT gzgetc(file)
+     gzFile file;
+ {
+diff --git a/zconf.h b/zconf.h
+index 5e1d68a004e9..a7a815f575a7 100644
+--- a/zconf.h
++++ b/zconf.h
+@@ -8,6 +8,10 @@
+ #ifndef ZCONF_H
+ #define ZCONF_H
+ 
++/*
++ * This library is also built as a part of AOSP, which does not need to include
++ * chromeconf.h. This config does not want chromeconf.h, so it can set this
++ * macro to opt out. While this works today, there's no guarantee that building
++ * zlib outside of Chromium keeps working in the future.
++ */
++#if !defined(CHROMIUM_ZLIB_NO_CHROMECONF)
++/* This include does prefixing as below, but with an updated set of names.  Also
++ * sets up export macros in component builds. */
++#include "chromeconf.h"
++#endif
++
+ /*
+  * If you *really* need a unique prefix for all types and library functions,
+  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+@@ -431,7 +434,7 @@ typedef uLong FAR uLongf;
+    typedef unsigned long z_crc_t;
+ #endif
+ 
+-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
++#if !defined(_WIN32)
+ #  define Z_HAVE_UNISTD_H
+ #endif
+ 
+diff --git a/zlib.h b/zlib.h
+index f09cdaf1e054..99fd467f6b1a 100644
+--- a/zlib.h
++++ b/zlib.h
+@@ -1824,6 +1824,11 @@ ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
+ #  undef z_gzgetc
+ #  define z_gzgetc(g) \
+           ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
++#elif defined(Z_CR_PREFIX_SET)
++#    undef gzgetc
++#    define gzgetc(g) \
++          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) \
++                     : (Cr_z_gzgetc)(g))
+ #else
+ #  define gzgetc(g) \
+           ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
+@@ -1853,11 +1858,29 @@ ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
+ #    define z_adler32_combine z_adler32_combine64
+ #    define z_crc32_combine z_crc32_combine64
+ #  else
++#    ifdef gzopen
++#      undef gzopen
++#    endif
+ #    define gzopen gzopen64
++#    ifdef gzseek
++#      undef gzseek
++#    endif
+ #    define gzseek gzseek64
++#    ifdef gztell
++#      undef gztell
++#    endif
+ #    define gztell gztell64
++#    ifdef gzoffset
++#      undef gzoffset
++#    endif
+ #    define gzoffset gzoffset64
++#    ifdef adler32_combine
++#      undef adler32_combine
++#    endif
+ #    define adler32_combine adler32_combine64
++#    ifdef crc32_combine
++#      undef crc32_combine
++#    endif
+ #    define crc32_combine crc32_combine64
+ #  endif
+ #  ifndef Z_LARGE64
+diff --git a/zutil.h b/zutil.h
+index b079ea6a80f5..80375b8b6109 100644
+--- a/zutil.h
++++ b/zutil.h
+@@ -28,6 +28,21 @@
+ #  include <string.h>
+ #  include <stdlib.h>
+ #endif
++#ifdef NO_ERRNO_H
++#   ifdef _WIN32_WCE
++      /* The Microsoft C Run-Time Library for Windows CE doesn't have
++       * errno.  We define it as a global variable to simplify porting.
++       * Its value is always 0 and should not be used.  We rename it to
++       * avoid conflict with other libraries that use the same workaround.
++       */
++#     define errno z_errno
++#   endif
++    extern int errno;
++#else
++#  ifndef _WIN32_WCE
++#    include <errno.h>
++#  endif
++#endif
+ 
+ #ifdef Z_SOLO
+    typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
diff --git a/third_party/zlib/patches/0001-simd.patch b/third_party/zlib/patches/0001-simd.patch
new file mode 100644
index 0000000000000..dccf5056064e9
--- /dev/null
+++ b/third_party/zlib/patches/0001-simd.patch
@@ -0,0 +1,1214 @@
+diff --git a/crc32.c b/crc32.c
+index 9580440c0e6b..9162429cc7b4 100644
+--- a/crc32.c
++++ b/crc32.c
+@@ -28,6 +28,8 @@
+ #  endif /* !DYNAMIC_CRC_TABLE */
+ #endif /* MAKECRCH */
+ 
++#include "deflate.h"
++#include "x86.h"
+ #include "zutil.h"      /* for STDC and FAR definitions */
+ 
+ /* Definitions for doing the crc four data bytes at a time. */
+@@ -440,3 +442,28 @@ uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
+ {
+     return crc32_combine_(crc1, crc2, len2);
+ }
++
++ZLIB_INTERNAL void crc_reset(deflate_state *const s)
++{
++    if (x86_cpu_enable_simd) {
++        crc_fold_init(s);
++        return;
++    }
++    s->strm->adler = crc32(0L, Z_NULL, 0);
++}
++
++ZLIB_INTERNAL void crc_finalize(deflate_state *const s)
++{
++    if (x86_cpu_enable_simd)
++        s->strm->adler = crc_fold_512to32(s);
++}
++
++ZLIB_INTERNAL void copy_with_crc(z_streamp strm, Bytef *dst, long size)
++{
++    if (x86_cpu_enable_simd) {
++        crc_fold_copy(strm->state, dst, strm->next_in, size);
++        return;
++    }
++    zmemcpy(dst, strm->next_in, size);
++    strm->adler = crc32(strm->adler, dst, size);
++}
+diff --git a/crc_folding.c b/crc_folding.c
+new file mode 100644
+index 000000000000..48d77744aaf4
+--- /dev/null
++++ b/crc_folding.c
+@@ -0,0 +1,493 @@
++/*
++ * Compute the CRC32 using a parallelized folding approach with the PCLMULQDQ
++ * instruction.
++ *
++ * A white paper describing this algorithm can be found at:
++ * http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/fast-crc-computation-generic-polynomials-pclmulqdq-paper.pdf
++ *
++ * Copyright (C) 2013 Intel Corporation. All rights reserved.
++ * Authors:
++ * 	Wajdi Feghali   <wajdi.k.feghali@intel.com>
++ * 	Jim Guilford    <james.guilford@intel.com>
++ * 	Vinodh Gopal    <vinodh.gopal@intel.com>
++ * 	Erdinc Ozturk   <erdinc.ozturk@intel.com>
++ * 	Jim Kukunas     <james.t.kukunas@linux.intel.com>
++ *
++ * For conditions of distribution and use, see copyright notice in zlib.h
++ */
++
++#include "deflate.h"
++
++#include <inttypes.h>
++#include <emmintrin.h>
++#include <immintrin.h>
++#include <wmmintrin.h>
++
++#define CRC_LOAD(s) \
++    do { \
++        __m128i xmm_crc0 = _mm_loadu_si128((__m128i *)s->crc0 + 0);\
++        __m128i xmm_crc1 = _mm_loadu_si128((__m128i *)s->crc0 + 1);\
++        __m128i xmm_crc2 = _mm_loadu_si128((__m128i *)s->crc0 + 2);\
++        __m128i xmm_crc3 = _mm_loadu_si128((__m128i *)s->crc0 + 3);\
++        __m128i xmm_crc_part = _mm_loadu_si128((__m128i *)s->crc0 + 4);
++
++#define CRC_SAVE(s) \
++        _mm_storeu_si128((__m128i *)s->crc0 + 0, xmm_crc0);\
++        _mm_storeu_si128((__m128i *)s->crc0 + 1, xmm_crc1);\
++        _mm_storeu_si128((__m128i *)s->crc0 + 2, xmm_crc2);\
++        _mm_storeu_si128((__m128i *)s->crc0 + 3, xmm_crc3);\
++        _mm_storeu_si128((__m128i *)s->crc0 + 4, xmm_crc_part);\
++    } while (0);
++
++ZLIB_INTERNAL void crc_fold_init(deflate_state *const s)
++{
++    CRC_LOAD(s)
++
++    xmm_crc0 = _mm_cvtsi32_si128(0x9db42487);
++    xmm_crc1 = _mm_setzero_si128();
++    xmm_crc2 = _mm_setzero_si128();
++    xmm_crc3 = _mm_setzero_si128();
++
++    CRC_SAVE(s)
++
++    s->strm->adler = 0;
++}
++
++local void fold_1(deflate_state *const s,
++        __m128i *xmm_crc0, __m128i *xmm_crc1,
++        __m128i *xmm_crc2, __m128i *xmm_crc3)
++{
++    const __m128i xmm_fold4 = _mm_set_epi32(
++            0x00000001, 0x54442bd4,
++            0x00000001, 0xc6e41596);
++
++    __m128i x_tmp3;
++    __m128 ps_crc0, ps_crc3, ps_res;
++
++    x_tmp3 = *xmm_crc3;
++
++    *xmm_crc3 = *xmm_crc0;
++    *xmm_crc0 = _mm_clmulepi64_si128(*xmm_crc0, xmm_fold4, 0x01);
++    *xmm_crc3 = _mm_clmulepi64_si128(*xmm_crc3, xmm_fold4, 0x10);
++    ps_crc0 = _mm_castsi128_ps(*xmm_crc0);
++    ps_crc3 = _mm_castsi128_ps(*xmm_crc3);
++    ps_res = _mm_xor_ps(ps_crc0, ps_crc3);
++
++    *xmm_crc0 = *xmm_crc1;
++    *xmm_crc1 = *xmm_crc2;
++    *xmm_crc2 = x_tmp3;
++    *xmm_crc3 = _mm_castps_si128(ps_res);
++}
++
++local void fold_2(deflate_state *const s,
++        __m128i *xmm_crc0, __m128i *xmm_crc1,
++        __m128i *xmm_crc2, __m128i *xmm_crc3)
++{
++    const __m128i xmm_fold4 = _mm_set_epi32(
++            0x00000001, 0x54442bd4,
++            0x00000001, 0xc6e41596);
++
++    __m128i x_tmp3, x_tmp2;
++    __m128 ps_crc0, ps_crc1, ps_crc2, ps_crc3, ps_res31, ps_res20;
++
++    x_tmp3 = *xmm_crc3;
++    x_tmp2 = *xmm_crc2;
++
++    *xmm_crc3 = *xmm_crc1;
++    *xmm_crc1 = _mm_clmulepi64_si128(*xmm_crc1, xmm_fold4, 0x01);
++    *xmm_crc3 = _mm_clmulepi64_si128(*xmm_crc3, xmm_fold4, 0x10);
++    ps_crc3 = _mm_castsi128_ps(*xmm_crc3);
++    ps_crc1 = _mm_castsi128_ps(*xmm_crc1);
++    ps_res31= _mm_xor_ps(ps_crc3, ps_crc1);
++
++    *xmm_crc2 = *xmm_crc0;
++    *xmm_crc0 = _mm_clmulepi64_si128(*xmm_crc0, xmm_fold4, 0x01);
++    *xmm_crc2 = _mm_clmulepi64_si128(*xmm_crc2, xmm_fold4, 0x10);
++    ps_crc0 = _mm_castsi128_ps(*xmm_crc0);
++    ps_crc2 = _mm_castsi128_ps(*xmm_crc2);
++    ps_res20= _mm_xor_ps(ps_crc0, ps_crc2);
++
++    *xmm_crc0 = x_tmp2;
++    *xmm_crc1 = x_tmp3;
++    *xmm_crc2 = _mm_castps_si128(ps_res20);
++    *xmm_crc3 = _mm_castps_si128(ps_res31);
++}
++
++local void fold_3(deflate_state *const s,
++        __m128i *xmm_crc0, __m128i *xmm_crc1,
++        __m128i *xmm_crc2, __m128i *xmm_crc3)
++{
++    const __m128i xmm_fold4 = _mm_set_epi32(
++            0x00000001, 0x54442bd4,
++            0x00000001, 0xc6e41596);
++
++    __m128i x_tmp3;
++    __m128 ps_crc0, ps_crc1, ps_crc2, ps_crc3, ps_res32, ps_res21, ps_res10;
++
++    x_tmp3 = *xmm_crc3;
++
++    *xmm_crc3 = *xmm_crc2;
++    *xmm_crc2 = _mm_clmulepi64_si128(*xmm_crc2, xmm_fold4, 0x01);
++    *xmm_crc3 = _mm_clmulepi64_si128(*xmm_crc3, xmm_fold4, 0x10);
++    ps_crc2 = _mm_castsi128_ps(*xmm_crc2);
++    ps_crc3 = _mm_castsi128_ps(*xmm_crc3);
++    ps_res32 = _mm_xor_ps(ps_crc2, ps_crc3);
++
++    *xmm_crc2 = *xmm_crc1;
++    *xmm_crc1 = _mm_clmulepi64_si128(*xmm_crc1, xmm_fold4, 0x01);
++    *xmm_crc2 = _mm_clmulepi64_si128(*xmm_crc2, xmm_fold4, 0x10);
++    ps_crc1 = _mm_castsi128_ps(*xmm_crc1);
++    ps_crc2 = _mm_castsi128_ps(*xmm_crc2);
++    ps_res21= _mm_xor_ps(ps_crc1, ps_crc2);
++
++    *xmm_crc1 = *xmm_crc0;
++    *xmm_crc0 = _mm_clmulepi64_si128(*xmm_crc0, xmm_fold4, 0x01);
++    *xmm_crc1 = _mm_clmulepi64_si128(*xmm_crc1, xmm_fold4, 0x10);
++    ps_crc0 = _mm_castsi128_ps(*xmm_crc0);
++    ps_crc1 = _mm_castsi128_ps(*xmm_crc1);
++    ps_res10= _mm_xor_ps(ps_crc0, ps_crc1);
++
++    *xmm_crc0 = x_tmp3;
++    *xmm_crc1 = _mm_castps_si128(ps_res10);
++    *xmm_crc2 = _mm_castps_si128(ps_res21);
++    *xmm_crc3 = _mm_castps_si128(ps_res32);
++}
++
++local void fold_4(deflate_state *const s,
++        __m128i *xmm_crc0, __m128i *xmm_crc1,
++        __m128i *xmm_crc2, __m128i *xmm_crc3)
++{
++    const __m128i xmm_fold4 = _mm_set_epi32(
++            0x00000001, 0x54442bd4,
++            0x00000001, 0xc6e41596);
++
++    __m128i x_tmp0, x_tmp1, x_tmp2, x_tmp3;
++    __m128 ps_crc0, ps_crc1, ps_crc2, ps_crc3;
++    __m128 ps_t0, ps_t1, ps_t2, ps_t3;
++    __m128 ps_res0, ps_res1, ps_res2, ps_res3;
++
++    x_tmp0 = *xmm_crc0;
++    x_tmp1 = *xmm_crc1;
++    x_tmp2 = *xmm_crc2;
++    x_tmp3 = *xmm_crc3;
++
++    *xmm_crc0 = _mm_clmulepi64_si128(*xmm_crc0, xmm_fold4, 0x01);
++    x_tmp0 = _mm_clmulepi64_si128(x_tmp0, xmm_fold4, 0x10);
++    ps_crc0 = _mm_castsi128_ps(*xmm_crc0);
++    ps_t0 = _mm_castsi128_ps(x_tmp0);
++    ps_res0 = _mm_xor_ps(ps_crc0, ps_t0);
++
++    *xmm_crc1 = _mm_clmulepi64_si128(*xmm_crc1, xmm_fold4, 0x01);
++    x_tmp1 = _mm_clmulepi64_si128(x_tmp1, xmm_fold4, 0x10);
++    ps_crc1 = _mm_castsi128_ps(*xmm_crc1);
++    ps_t1 = _mm_castsi128_ps(x_tmp1);
++    ps_res1 = _mm_xor_ps(ps_crc1, ps_t1);
++
++    *xmm_crc2 = _mm_clmulepi64_si128(*xmm_crc2, xmm_fold4, 0x01);
++    x_tmp2 = _mm_clmulepi64_si128(x_tmp2, xmm_fold4, 0x10);
++    ps_crc2 = _mm_castsi128_ps(*xmm_crc2);
++    ps_t2 = _mm_castsi128_ps(x_tmp2);
++    ps_res2 = _mm_xor_ps(ps_crc2, ps_t2);
++
++    *xmm_crc3 = _mm_clmulepi64_si128(*xmm_crc3, xmm_fold4, 0x01);
++    x_tmp3 = _mm_clmulepi64_si128(x_tmp3, xmm_fold4, 0x10);
++    ps_crc3 = _mm_castsi128_ps(*xmm_crc3);
++    ps_t3 = _mm_castsi128_ps(x_tmp3);
++    ps_res3 = _mm_xor_ps(ps_crc3, ps_t3);
++
++    *xmm_crc0 = _mm_castps_si128(ps_res0);
++    *xmm_crc1 = _mm_castps_si128(ps_res1);
++    *xmm_crc2 = _mm_castps_si128(ps_res2);
++    *xmm_crc3 = _mm_castps_si128(ps_res3);
++}
++
++local const unsigned zalign(32) pshufb_shf_table[60] = {
++	0x84838281,0x88878685,0x8c8b8a89,0x008f8e8d, /* shl 15 (16 - 1)/shr1 */
++	0x85848382,0x89888786,0x8d8c8b8a,0x01008f8e, /* shl 14 (16 - 3)/shr2 */
++	0x86858483,0x8a898887,0x8e8d8c8b,0x0201008f, /* shl 13 (16 - 4)/shr3 */
++	0x87868584,0x8b8a8988,0x8f8e8d8c,0x03020100, /* shl 12 (16 - 4)/shr4 */
++	0x88878685,0x8c8b8a89,0x008f8e8d,0x04030201, /* shl 11 (16 - 5)/shr5 */
++	0x89888786,0x8d8c8b8a,0x01008f8e,0x05040302, /* shl 10 (16 - 6)/shr6 */
++	0x8a898887,0x8e8d8c8b,0x0201008f,0x06050403, /* shl  9 (16 - 7)/shr7 */
++	0x8b8a8988,0x8f8e8d8c,0x03020100,0x07060504, /* shl  8 (16 - 8)/shr8 */
++	0x8c8b8a89,0x008f8e8d,0x04030201,0x08070605, /* shl  7 (16 - 9)/shr9 */
++	0x8d8c8b8a,0x01008f8e,0x05040302,0x09080706, /* shl  6 (16 -10)/shr10*/
++	0x8e8d8c8b,0x0201008f,0x06050403,0x0a090807, /* shl  5 (16 -11)/shr11*/
++	0x8f8e8d8c,0x03020100,0x07060504,0x0b0a0908, /* shl  4 (16 -12)/shr12*/
++	0x008f8e8d,0x04030201,0x08070605,0x0c0b0a09, /* shl  3 (16 -13)/shr13*/
++	0x01008f8e,0x05040302,0x09080706,0x0d0c0b0a, /* shl  2 (16 -14)/shr14*/
++	0x0201008f,0x06050403,0x0a090807,0x0e0d0c0b  /* shl  1 (16 -15)/shr15*/
++};
++
++local void partial_fold(deflate_state *const s, const size_t len,
++        __m128i *xmm_crc0, __m128i *xmm_crc1,
++        __m128i *xmm_crc2, __m128i *xmm_crc3,
++        __m128i *xmm_crc_part)
++{
++
++    const __m128i xmm_fold4 = _mm_set_epi32(
++            0x00000001, 0x54442bd4,
++            0x00000001, 0xc6e41596);
++    const __m128i xmm_mask3 = _mm_set1_epi32(0x80808080);
++
++    __m128i xmm_shl, xmm_shr, xmm_tmp1, xmm_tmp2, xmm_tmp3;
++    __m128i xmm_a0_0, xmm_a0_1;
++    __m128 ps_crc3, psa0_0, psa0_1, ps_res;
++
++    xmm_shl = _mm_load_si128((__m128i *)pshufb_shf_table + (len - 1));
++    xmm_shr = xmm_shl;
++    xmm_shr = _mm_xor_si128(xmm_shr, xmm_mask3);
++
++    xmm_a0_0 = _mm_shuffle_epi8(*xmm_crc0, xmm_shl);
++
++    *xmm_crc0 = _mm_shuffle_epi8(*xmm_crc0, xmm_shr);
++    xmm_tmp1 = _mm_shuffle_epi8(*xmm_crc1, xmm_shl);
++    *xmm_crc0 = _mm_or_si128(*xmm_crc0, xmm_tmp1);
++
++    *xmm_crc1 = _mm_shuffle_epi8(*xmm_crc1, xmm_shr);
++    xmm_tmp2 = _mm_shuffle_epi8(*xmm_crc2, xmm_shl);
++    *xmm_crc1 = _mm_or_si128(*xmm_crc1, xmm_tmp2);
++
++    *xmm_crc2 = _mm_shuffle_epi8(*xmm_crc2, xmm_shr);
++    xmm_tmp3 = _mm_shuffle_epi8(*xmm_crc3, xmm_shl);
++    *xmm_crc2 = _mm_or_si128(*xmm_crc2, xmm_tmp3);
++
++    *xmm_crc3 = _mm_shuffle_epi8(*xmm_crc3, xmm_shr);
++    *xmm_crc_part = _mm_shuffle_epi8(*xmm_crc_part, xmm_shl);
++    *xmm_crc3 = _mm_or_si128(*xmm_crc3, *xmm_crc_part);
++
++    xmm_a0_1 = _mm_clmulepi64_si128(xmm_a0_0, xmm_fold4, 0x10);
++    xmm_a0_0 = _mm_clmulepi64_si128(xmm_a0_0, xmm_fold4, 0x01);
++
++    ps_crc3 = _mm_castsi128_ps(*xmm_crc3);
++    psa0_0 = _mm_castsi128_ps(xmm_a0_0);
++    psa0_1 = _mm_castsi128_ps(xmm_a0_1);
++
++    ps_res = _mm_xor_ps(ps_crc3, psa0_0);
++    ps_res = _mm_xor_ps(ps_res, psa0_1);
++
++    *xmm_crc3 = _mm_castps_si128(ps_res);
++}
++
++ZLIB_INTERNAL void crc_fold_copy(deflate_state *const s,
++        unsigned char *dst, const unsigned char *src, long len)
++{
++    unsigned long algn_diff;
++    __m128i xmm_t0, xmm_t1, xmm_t2, xmm_t3;
++
++    CRC_LOAD(s)
++
++    if (len < 16) {
++        if (len == 0)
++            return;
++        goto partial;
++    }
++
++    algn_diff = 0 - (uintptr_t)src & 0xF;
++    if (algn_diff) {
++        xmm_crc_part = _mm_loadu_si128((__m128i *)src);
++        _mm_storeu_si128((__m128i *)dst, xmm_crc_part);
++
++        dst += algn_diff;
++        src += algn_diff;
++        len -= algn_diff;
++
++        partial_fold(s, algn_diff, &xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3,
++            &xmm_crc_part);
++    }
++
++    while ((len -= 64) >= 0) {
++        xmm_t0 = _mm_load_si128((__m128i *)src);
++        xmm_t1 = _mm_load_si128((__m128i *)src + 1);
++        xmm_t2 = _mm_load_si128((__m128i *)src + 2);
++        xmm_t3 = _mm_load_si128((__m128i *)src + 3);
++
++        fold_4(s, &xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);
++
++        _mm_storeu_si128((__m128i *)dst, xmm_t0);
++        _mm_storeu_si128((__m128i *)dst + 1, xmm_t1);
++        _mm_storeu_si128((__m128i *)dst + 2, xmm_t2);
++        _mm_storeu_si128((__m128i *)dst + 3, xmm_t3);
++
++        xmm_crc0 = _mm_xor_si128(xmm_crc0, xmm_t0);
++        xmm_crc1 = _mm_xor_si128(xmm_crc1, xmm_t1);
++        xmm_crc2 = _mm_xor_si128(xmm_crc2, xmm_t2);
++        xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t3);
++
++        src += 64;
++        dst += 64;
++    }
++
++    /*
++     * len = num bytes left - 64
++     */
++    if (len + 16 >= 0) {
++        len += 16;
++
++        xmm_t0 = _mm_load_si128((__m128i *)src);
++        xmm_t1 = _mm_load_si128((__m128i *)src + 1);
++        xmm_t2 = _mm_load_si128((__m128i *)src + 2);
++
++        fold_3(s, &xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);
++
++        _mm_storeu_si128((__m128i *)dst, xmm_t0);
++        _mm_storeu_si128((__m128i *)dst + 1, xmm_t1);
++        _mm_storeu_si128((__m128i *)dst + 2, xmm_t2);
++
++        xmm_crc1 = _mm_xor_si128(xmm_crc1, xmm_t0);
++        xmm_crc2 = _mm_xor_si128(xmm_crc2, xmm_t1);
++        xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t2);
++
++        if (len == 0)
++            goto done;
++
++        dst += 48;
++        src += 48;
++    } else if (len + 32 >= 0) {
++        len += 32;
++
++        xmm_t0 = _mm_load_si128((__m128i *)src);
++        xmm_t1 = _mm_load_si128((__m128i *)src + 1);
++
++        fold_2(s, &xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);
++
++        _mm_storeu_si128((__m128i *)dst, xmm_t0);
++        _mm_storeu_si128((__m128i *)dst + 1, xmm_t1);
++
++        xmm_crc2 = _mm_xor_si128(xmm_crc2, xmm_t0);
++        xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t1);
++
++        if (len == 0)
++            goto done;
++
++        dst += 32;
++        src += 32;
++    } else if (len + 48 >= 0) {
++        len += 48;
++
++        xmm_t0 = _mm_load_si128((__m128i *)src);
++
++        fold_1(s, &xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);
++
++        _mm_storeu_si128((__m128i *)dst, xmm_t0);
++
++        xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t0);
++
++        if (len == 0)
++            goto done;
++
++        dst += 16;
++        src += 16;
++    } else {
++        len += 64;
++        if (len == 0)
++            goto done;
++    }
++
++partial:
++
++#if defined(_MSC_VER)
++    /* VS does not permit the use of _mm_set_epi64x in 32-bit builds */
++    {
++        int32_t parts[4] = {0, 0, 0, 0};
++        memcpy(&parts, src, len);
++        xmm_crc_part = _mm_set_epi32(parts[3], parts[2], parts[1], parts[0]);
++    }
++#else
++    {
++        int64_t parts[2] = {0, 0};
++        memcpy(&parts, src, len);
++        xmm_crc_part = _mm_set_epi64x(parts[1], parts[0]);
++    }
++#endif
++
++    zmemcpy(dst, src, len);  /* TODO: Possibly generate more efficient code. */
++    partial_fold(s, len, &xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3,
++        &xmm_crc_part);
++done:
++    CRC_SAVE(s)
++}
++
++local const unsigned zalign(16) crc_k[] = {
++    0xccaa009e, 0x00000000, /* rk1 */
++    0x751997d0, 0x00000001, /* rk2 */
++    0xccaa009e, 0x00000000, /* rk5 */
++    0x63cd6124, 0x00000001, /* rk6 */
++    0xf7011640, 0x00000001, /* rk7 */
++    0xdb710640, 0x00000001  /* rk8 */
++};
++
++local const unsigned zalign(16) crc_mask[4] = {
++    0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000000
++};
++
++local const unsigned zalign(16) crc_mask2[4] = {
++    0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
++};
++
++unsigned ZLIB_INTERNAL crc_fold_512to32(deflate_state *const s)
++{
++    const __m128i xmm_mask  = _mm_load_si128((__m128i *)crc_mask);
++    const __m128i xmm_mask2 = _mm_load_si128((__m128i *)crc_mask2);
++
++    unsigned crc;
++    __m128i x_tmp0, x_tmp1, x_tmp2, crc_fold;
++
++    CRC_LOAD(s)
++
++    /*
++     * k1
++     */
++    crc_fold = _mm_load_si128((__m128i *)crc_k);
++
++    x_tmp0 = _mm_clmulepi64_si128(xmm_crc0, crc_fold, 0x10);
++    xmm_crc0 = _mm_clmulepi64_si128(xmm_crc0, crc_fold, 0x01);
++    xmm_crc1 = _mm_xor_si128(xmm_crc1, x_tmp0);
++    xmm_crc1 = _mm_xor_si128(xmm_crc1, xmm_crc0);
++
++    x_tmp1 = _mm_clmulepi64_si128(xmm_crc1, crc_fold, 0x10);
++    xmm_crc1 = _mm_clmulepi64_si128(xmm_crc1, crc_fold, 0x01);
++    xmm_crc2 = _mm_xor_si128(xmm_crc2, x_tmp1);
++    xmm_crc2 = _mm_xor_si128(xmm_crc2, xmm_crc1);
++
++    x_tmp2 = _mm_clmulepi64_si128(xmm_crc2, crc_fold, 0x10);
++    xmm_crc2 = _mm_clmulepi64_si128(xmm_crc2, crc_fold, 0x01);
++    xmm_crc3 = _mm_xor_si128(xmm_crc3, x_tmp2);
++    xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_crc2);
++
++    /*
++     * k5
++     */
++    crc_fold = _mm_load_si128((__m128i *)crc_k + 1);
++
++    xmm_crc0 = xmm_crc3;
++    xmm_crc3 = _mm_clmulepi64_si128(xmm_crc3, crc_fold, 0);
++    xmm_crc0 = _mm_srli_si128(xmm_crc0, 8);
++    xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_crc0);
++
++    xmm_crc0 = xmm_crc3;
++    xmm_crc3 = _mm_slli_si128(xmm_crc3, 4);
++    xmm_crc3 = _mm_clmulepi64_si128(xmm_crc3, crc_fold, 0x10);
++    xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_crc0);
++    xmm_crc3 = _mm_and_si128(xmm_crc3, xmm_mask2);
++
++    /*
++     * k7
++     */
++    xmm_crc1 = xmm_crc3;
++    xmm_crc2 = xmm_crc3;
++    crc_fold = _mm_load_si128((__m128i *)crc_k + 2);
++
++    xmm_crc3 = _mm_clmulepi64_si128(xmm_crc3, crc_fold, 0);
++    xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_crc2);
++    xmm_crc3 = _mm_and_si128(xmm_crc3, xmm_mask);
++
++    xmm_crc2 = xmm_crc3;
++    xmm_crc3 = _mm_clmulepi64_si128(xmm_crc3, crc_fold, 0x10);
++    xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_crc2);
++    xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_crc1);
++
++    crc = _mm_extract_epi32(xmm_crc3, 2);
++    return ~crc;
++    CRC_SAVE(s)
++}
+diff --git a/deflate.c b/deflate.c
+index 1ec761448de9..aa0c9c67a6dc 100644
+--- a/deflate.c
++++ b/deflate.c
+@@ -48,8 +48,9 @@
+  */
+ 
+ /* @(#) $Id$ */
+-
++#include <assert.h>
+ #include "deflate.h"
++#include "x86.h"
+ 
+ const char deflate_copyright[] =
+    " deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler ";
+@@ -86,7 +87,7 @@ local block_state deflate_huff   OF((deflate_state *s, int flush));
+ local void lm_init        OF((deflate_state *s));
+ local void putShortMSB    OF((deflate_state *s, uInt b));
+ local void flush_pending  OF((z_streamp strm));
+-local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
++unsigned ZLIB_INTERNAL deflate_read_buf OF((z_streamp strm, Bytef *buf, unsigned size));
+ #ifdef ASMV
+ #  pragma message("Assembler code may have bugs -- use at your own risk")
+       void match_init OF((void)); /* asm code initialization */
+@@ -100,6 +101,20 @@ local  void check_match OF((deflate_state *s, IPos start, IPos match,
+                             int length));
+ #endif
+ 
++/* From crc32.c */
++extern void ZLIB_INTERNAL crc_reset(deflate_state *const s);
++extern void ZLIB_INTERNAL crc_finalize(deflate_state *const s);
++extern void ZLIB_INTERNAL copy_with_crc(z_streamp strm, Bytef *dst, long size);
++
++#ifdef _MSC_VER
++#define INLINE __inline
++#else
++#define INLINE inline
++#endif
++
++/* Inline optimisation */
++local INLINE Pos insert_string_sse(deflate_state *const s, const Pos str);
++
+ /* ===========================================================================
+  * Local data
+  */
+@@ -162,7 +177,6 @@ local const config configuration_table[10] = {
+  */
+ #define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
+ 
+-
+ /* ===========================================================================
+  * Insert string str in the dictionary and set match_head to the previous head
+  * of the hash chain (the most recent string with same hash key). Return
+@@ -173,17 +187,28 @@ local const config configuration_table[10] = {
+  *    characters and the first MIN_MATCH bytes of str are valid (except for
+  *    the last MIN_MATCH-1 bytes of the input file).
+  */
++local INLINE Pos insert_string_c(deflate_state *const s, const Pos str)
++{
++    Pos ret;
++
++    UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]);
+ #ifdef FASTEST
+-#define INSERT_STRING(s, str, match_head) \
+-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+-    match_head = s->head[s->ins_h], \
+-    s->head[s->ins_h] = (Pos)(str))
++    ret = s->head[s->ins_h];
+ #else
+-#define INSERT_STRING(s, str, match_head) \
+-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+-    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
+-    s->head[s->ins_h] = (Pos)(str))
++    ret = s->prev[str & s->w_mask] = s->head[s->ins_h];
+ #endif
++    s->head[s->ins_h] = str;
++
++    return ret;
++}
++
++local INLINE Pos insert_string(deflate_state *const s, const Pos str)
++{
++    if (x86_cpu_enable_simd)
++        return insert_string_sse(s, str);
++    return insert_string_c(s, str);
++}
++
+ 
+ /* ===========================================================================
+  * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
+@@ -248,6 +273,7 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+     const char *version;
+     int stream_size;
+ {
++    unsigned window_padding = 8;
+     deflate_state *s;
+     int wrap = 1;
+     static const char my_version[] = ZLIB_VERSION;
+@@ -257,6 +283,8 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+      * output size for (length,distance) codes is <= 24 bits.
+      */
+ 
++    x86_check_features();
++
+     if (version == Z_NULL || version[0] != my_version[0] ||
+         stream_size != sizeof(z_stream)) {
+         return Z_VERSION_ERROR;
+@@ -313,12 +341,19 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+     s->w_size = 1 << s->w_bits;
+     s->w_mask = s->w_size - 1;
+ 
+-    s->hash_bits = (uInt)memLevel + 7;
++    if (x86_cpu_enable_simd) {
++        s->hash_bits = 15;
++    } else {
++        s->hash_bits = memLevel + 7;
++    }
++
+     s->hash_size = 1 << s->hash_bits;
+     s->hash_mask = s->hash_size - 1;
+     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
+ 
+-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
++    s->window = (Bytef *) ZALLOC(strm,
++                                 s->w_size + window_padding,
++                                 2*sizeof(Byte));
+     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
+     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+ 
+@@ -418,11 +453,7 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
+         str = s->strstart;
+         n = s->lookahead - (MIN_MATCH-1);
+         do {
+-            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
+-#ifndef FASTEST
+-            s->prev[str & s->w_mask] = s->head[s->ins_h];
+-#endif
+-            s->head[s->ins_h] = (Pos)str;
++            insert_string(s, str);
+             str++;
+         } while (--n);
+         s->strstart = str;
+@@ -848,7 +879,7 @@ int ZEXPORT deflate (strm, flush)
+ #ifdef GZIP
+     if (s->status == GZIP_STATE) {
+         /* gzip header */
+-        strm->adler = crc32(0L, Z_NULL, 0);
++        crc_reset(s);
+         put_byte(s, 31);
+         put_byte(s, 139);
+         put_byte(s, 8);
+@@ -1049,6 +1080,7 @@ int ZEXPORT deflate (strm, flush)
+     /* Write the trailer */
+ #ifdef GZIP
+     if (s->wrap == 2) {
++        crc_finalize(s);
+         put_byte(s, (Byte)(strm->adler & 0xff));
+         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
+         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
+@@ -1161,7 +1193,7 @@ int ZEXPORT deflateCopy (dest, source)
+  * allocating a large strm->next_in buffer and copying from it.
+  * (See also flush_pending()).
+  */
+-local unsigned read_buf(strm, buf, size)
++ZLIB_INTERNAL unsigned deflate_read_buf(strm, buf, size)
+     z_streamp strm;
+     Bytef *buf;
+     unsigned size;
+@@ -1173,15 +1205,16 @@ local unsigned read_buf(strm, buf, size)
+ 
+     strm->avail_in  -= len;
+ 
+-    zmemcpy(buf, strm->next_in, len);
+-    if (strm->state->wrap == 1) {
+-        strm->adler = adler32(strm->adler, buf, len);
+-    }
+ #ifdef GZIP
+-    else if (strm->state->wrap == 2) {
+-        strm->adler = crc32(strm->adler, buf, len);
+-    }
++    if (strm->state->wrap == 2)
++        copy_with_crc(strm, buf, len);
++    else 
+ #endif
++    {
++        zmemcpy(buf, strm->next_in, len);
++        if (strm->state->wrap == 1)
++            strm->adler = adler32(strm->adler, buf, len);
++    }
+     strm->next_in  += len;
+     strm->total_in += len;
+ 
+@@ -1479,7 +1512,19 @@ local void check_match(s, start, match, length)
+  *    performed for at least two bytes (required for the zip translate_eol
+  *    option -- not supported here).
+  */
+-local void fill_window(s)
++local void fill_window_c(deflate_state *s);
++
++local void fill_window(deflate_state *s)
++{
++    if (x86_cpu_enable_simd) {
++        fill_window_sse(s);
++        return;
++    }
++
++    fill_window_c(s);
++}
++
++local void fill_window_c(s)
+     deflate_state *s;
+ {
+     unsigned n;
+@@ -1847,7 +1892,7 @@ local block_state deflate_fast(s, flush)
+          */
+         hash_head = NIL;
+         if (s->lookahead >= MIN_MATCH) {
+-            INSERT_STRING(s, s->strstart, hash_head);
++            hash_head = insert_string(s, s->strstart);
+         }
+ 
+         /* Find the longest match, discarding those <= prev_length.
+@@ -1878,7 +1923,7 @@ local block_state deflate_fast(s, flush)
+                 s->match_length--; /* string at strstart already in table */
+                 do {
+                     s->strstart++;
+-                    INSERT_STRING(s, s->strstart, hash_head);
++                    hash_head = insert_string(s, s->strstart);
+                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+                      * always MIN_MATCH bytes ahead.
+                      */
+@@ -1950,7 +1995,7 @@ local block_state deflate_slow(s, flush)
+          */
+         hash_head = NIL;
+         if (s->lookahead >= MIN_MATCH) {
+-            INSERT_STRING(s, s->strstart, hash_head);
++            hash_head = insert_string(s, s->strstart);
+         }
+ 
+         /* Find the longest match, discarding those <= prev_length.
+@@ -2001,7 +2046,7 @@ local block_state deflate_slow(s, flush)
+             s->prev_length -= 2;
+             do {
+                 if (++s->strstart <= max_insert) {
+-                    INSERT_STRING(s, s->strstart, hash_head);
++                    hash_head = insert_string(s, s->strstart);
+                 }
+             } while (--s->prev_length != 0);
+             s->match_available = 0;
+@@ -2161,3 +2206,37 @@ local block_state deflate_huff(s, flush)
+         FLUSH_BLOCK(s, 0);
+     return block_done;
+ }
++
++/* Safe to inline this as GCC/clang will use inline asm and Visual Studio will
++ * use intrinsic without extra params
++ */
++local INLINE Pos insert_string_sse(deflate_state *const s, const Pos str)
++{
++    Pos ret;
++    unsigned *ip, val, h = 0;
++
++    ip = (unsigned *)&s->window[str];
++    val = *ip;
++
++    if (s->level >= 6)
++        val &= 0xFFFFFF;
++
++/* Windows clang should use inline asm */
++#if defined(_MSC_VER) && !defined(__clang__)
++    h = _mm_crc32_u32(h, val);
++#elif defined(__i386__) || defined(__amd64__)
++    __asm__ __volatile__ (
++        "crc32 %1,%0\n\t"
++    : "+r" (h)
++    : "r" (val)
++    );
++#else
++    /* This should never happen */
++    assert(0);
++#endif
++
++    ret = s->head[h & s->hash_mask];
++    s->head[h & s->hash_mask] = str;
++    s->prev[str & s->w_mask] = ret;
++    return ret;
++}
+diff --git a/deflate.h b/deflate.h
+index 23ecdd312bc0..ab56df7663b6 100644
+--- a/deflate.h
++++ b/deflate.h
+@@ -109,7 +109,7 @@ typedef struct internal_state {
+     ulg   gzindex;       /* where in extra, name, or comment */
+     Byte  method;        /* can only be DEFLATED */
+     int   last_flush;    /* value of flush param for previous deflate call */
+-
++    unsigned zalign(16) crc0[4 * 5];
+                 /* used by deflate.c: */
+ 
+     uInt  w_size;        /* LZ77 window size (32K by default) */
+@@ -346,4 +346,14 @@ void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
+               flush = _tr_tally(s, distance, length)
+ #endif
+ 
++/* Functions that are SIMD optimised on x86 */
++void ZLIB_INTERNAL crc_fold_init(deflate_state* const s);
++void ZLIB_INTERNAL crc_fold_copy(deflate_state* const s,
++                                 unsigned char* dst,
++                                 const unsigned char* src,
++                                 long len);
++unsigned ZLIB_INTERNAL crc_fold_512to32(deflate_state* const s);
++
++void ZLIB_INTERNAL fill_window_sse(deflate_state* s);
++
+ #endif /* DEFLATE_H */
+diff --git a/fill_window_sse.c b/fill_window_sse.c
+new file mode 100644
+index 000000000000..949ccce1ba9c
+--- /dev/null
++++ b/fill_window_sse.c
+@@ -0,0 +1,177 @@
++/*
++ * Fill Window with SSE2-optimized hash shifting
++ *
++ * Copyright (C) 2013 Intel Corporation
++ * Authors:
++ *  Arjan van de Ven    <arjan@linux.intel.com>
++ *  Jim Kukunas         <james.t.kukunas@linux.intel.com>
++ *
++ * For conditions of distribution and use, see copyright notice in zlib.h
++ */
++
++#include <immintrin.h>
++#include "deflate.h"
++
++#define UPDATE_HASH(s,h,i) \
++    {\
++        if (s->level < 6) { \
++            h = (3483 * (s->window[i]) +\
++                 23081* (s->window[i+1]) +\
++                 6954 * (s->window[i+2]) +\
++                 20947* (s->window[i+3])) & s->hash_mask;\
++        } else {\
++            h = (25881* (s->window[i]) +\
++                 24674* (s->window[i+1]) +\
++                 25811* (s->window[i+2])) & s->hash_mask;\
++        }\
++    }\
++
++extern int deflate_read_buf OF((z_streamp strm, Bytef *buf, unsigned size));
++
++void fill_window_sse(deflate_state *s)
++{
++    const __m128i xmm_wsize = _mm_set1_epi16(s->w_size);
++
++    register unsigned n;
++    register Posf *p;
++    unsigned more;    /* Amount of free space at the end of the window. */
++    uInt wsize = s->w_size;
++
++    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
++
++    do {
++        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
++
++        /* Deal with !@#$% 64K limit: */
++        if (sizeof(int) <= 2) {
++            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
++                more = wsize;
++
++            } else if (more == (unsigned)(-1)) {
++                /* Very unlikely, but possible on 16 bit machine if
++                 * strstart == 0 && lookahead == 1 (input done a byte at time)
++                 */
++                more--;
++            }
++        }
++
++        /* If the window is almost full and there is insufficient lookahead,
++         * move the upper half to the lower one to make room in the upper half.
++         */
++        if (s->strstart >= wsize+MAX_DIST(s)) {
++
++            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
++            s->match_start -= wsize;
++            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
++            s->block_start -= (long) wsize;
++
++            /* Slide the hash table (could be avoided with 32 bit values
++               at the expense of memory usage). We slide even when level == 0
++               to keep the hash table consistent if we switch back to level > 0
++               later. (Using level 0 permanently is not an optimal usage of
++               zlib, so we don't care about this pathological case.)
++             */
++            n = s->hash_size;
++            p = &s->head[n];
++            p -= 8;
++            do {
++                __m128i value, result;
++
++                value = _mm_loadu_si128((__m128i *)p);
++                result = _mm_subs_epu16(value, xmm_wsize);
++                _mm_storeu_si128((__m128i *)p, result);
++
++                p -= 8;
++                n -= 8;
++            } while (n > 0);
++
++            n = wsize;
++#ifndef FASTEST
++            p = &s->prev[n];
++            p -= 8;
++            do {
++                __m128i value, result;
++
++                value = _mm_loadu_si128((__m128i *)p);
++                result = _mm_subs_epu16(value, xmm_wsize);
++                _mm_storeu_si128((__m128i *)p, result);
++
++                p -= 8;
++                n -= 8;
++            } while (n > 0);
++#endif
++            more += wsize;
++        }
++        if (s->strm->avail_in == 0) break;
++
++        /* If there was no sliding:
++         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
++         *    more == window_size - lookahead - strstart
++         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
++         * => more >= window_size - 2*WSIZE + 2
++         * In the BIG_MEM or MMAP case (not yet supported),
++         *   window_size == input_size + MIN_LOOKAHEAD  &&
++         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
++         * Otherwise, window_size == 2*WSIZE so more >= 2.
++         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
++         */
++        Assert(more >= 2, "more < 2");
++
++        n = deflate_read_buf(s->strm,
++                             s->window + s->strstart + s->lookahead,
++                             more);
++        s->lookahead += n;
++
++        /* Initialize the hash value now that we have some input: */
++        if (s->lookahead >= MIN_MATCH) {
++            uInt str = s->strstart;
++            s->ins_h = s->window[str];
++            if (str >= 1)
++                UPDATE_HASH(s, s->ins_h, str + 1 - (MIN_MATCH-1));
++#if MIN_MATCH != 3
++            Call UPDATE_HASH() MIN_MATCH-3 more times
++#endif
++        }
++        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
++         * but this is not important since only literal bytes will be emitted.
++         */
++
++    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
++
++    /* If the WIN_INIT bytes after the end of the current data have never been
++     * written, then zero those bytes in order to avoid memory check reports of
++     * the use of uninitialized (or uninitialised as Julian writes) bytes by
++     * the longest match routines.  Update the high water mark for the next
++     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
++     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
++     */
++    if (s->high_water < s->window_size) {
++        ulg curr = s->strstart + (ulg)(s->lookahead);
++        ulg init;
++
++        if (s->high_water < curr) {
++            /* Previous high water mark below current data -- zero WIN_INIT
++             * bytes or up to end of window, whichever is less.
++             */
++            init = s->window_size - curr;
++            if (init > WIN_INIT)
++                init = WIN_INIT;
++            zmemzero(s->window + curr, (unsigned)init);
++            s->high_water = curr + init;
++        }
++        else if (s->high_water < (ulg)curr + WIN_INIT) {
++            /* High water mark at or above current data, but below current data
++             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
++             * to end of window, whichever is less.
++             */
++            init = (ulg)curr + WIN_INIT - s->high_water;
++            if (init > s->window_size - s->high_water)
++                init = s->window_size - s->high_water;
++            zmemzero(s->window + s->high_water, (unsigned)init);
++            s->high_water += init;
++        }
++    }
++
++    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
++           "not enough room for search");
++}
+diff --git a/simd_stub.c b/simd_stub.c
+new file mode 100644
+index 000000000000..c6d46051498f
+--- /dev/null
++++ b/simd_stub.c
+@@ -0,0 +1,35 @@
++/* simd_stub.c -- stub implementations
++* Copyright (C) 2014 Intel Corporation
++* For conditions of distribution and use, see copyright notice in zlib.h
++*/
++#include <assert.h>
++
++#include "deflate.h"
++#include "x86.h"
++
++int ZLIB_INTERNAL x86_cpu_enable_simd = 0;
++
++void ZLIB_INTERNAL crc_fold_init(deflate_state *const s) {
++    assert(0);
++}
++
++void ZLIB_INTERNAL crc_fold_copy(deflate_state *const s,
++                                 unsigned char *dst,
++                                 const unsigned char *src,
++                                 long len) {
++    assert(0);
++}
++
++unsigned ZLIB_INTERNAL crc_fold_512to32(deflate_state *const s) {
++    assert(0);
++    return 0;
++}
++
++void ZLIB_INTERNAL fill_window_sse(deflate_state *s)
++{
++    assert(0);
++}
++
++void x86_check_features(void)
++{
++}
+diff --git a/x86.c b/x86.c
+new file mode 100644
+index 000000000000..e56fe8b85a39
+--- /dev/null
++++ b/x86.c
+@@ -0,0 +1,92 @@
++/*
++ * x86 feature check
++ *
++ * Copyright (C) 2013 Intel Corporation. All rights reserved.
++ * Author:
++ *  Jim Kukunas
++ * 
++ * For conditions of distribution and use, see copyright notice in zlib.h
++ */
++
++#include "x86.h"
++#include "zutil.h"
++
++int ZLIB_INTERNAL x86_cpu_enable_simd = 0;
++
++#ifndef _MSC_VER
++#include <pthread.h>
++
++pthread_once_t cpu_check_inited_once = PTHREAD_ONCE_INIT;
++static void _x86_check_features(void);
++
++void x86_check_features(void)
++{
++  pthread_once(&cpu_check_inited_once, _x86_check_features);
++}
++
++static void _x86_check_features(void)
++{
++    int x86_cpu_has_sse2;
++    int x86_cpu_has_sse42;
++    int x86_cpu_has_pclmulqdq;
++    unsigned eax, ebx, ecx, edx;
++
++    eax = 1;
++#ifdef __i386__
++    __asm__ __volatile__ (
++        "xchg %%ebx, %1\n\t"
++        "cpuid\n\t"
++        "xchg %1, %%ebx\n\t"
++    : "+a" (eax), "=S" (ebx), "=c" (ecx), "=d" (edx)
++    );
++#else
++    __asm__ __volatile__ (
++        "cpuid\n\t"
++    : "+a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
++    );
++#endif  /* (__i386__) */
++
++    x86_cpu_has_sse2 = edx & 0x4000000;
++    x86_cpu_has_sse42 = ecx & 0x100000;
++    x86_cpu_has_pclmulqdq = ecx & 0x2;
++
++    x86_cpu_enable_simd = x86_cpu_has_sse2 &&
++                          x86_cpu_has_sse42 &&
++                          x86_cpu_has_pclmulqdq;
++}
++#else
++#include <intrin.h>
++#include <windows.h>
++
++static BOOL CALLBACK _x86_check_features(PINIT_ONCE once,
++                                         PVOID param,
++                                         PVOID *context);
++static INIT_ONCE cpu_check_inited_once = INIT_ONCE_STATIC_INIT;
++
++void x86_check_features(void)
++{
++    InitOnceExecuteOnce(&cpu_check_inited_once, _x86_check_features,
++                        NULL, NULL);
++}
++
++static BOOL CALLBACK _x86_check_features(PINIT_ONCE once,
++                                         PVOID param,
++                                         PVOID *context)
++{
++    int x86_cpu_has_sse2;
++    int x86_cpu_has_sse42;
++    int x86_cpu_has_pclmulqdq;
++    int regs[4];
++
++    __cpuid(regs, 1);
++
++    x86_cpu_has_sse2 = regs[3] & 0x4000000;
++    x86_cpu_has_sse42= regs[2] & 0x100000;
++    x86_cpu_has_pclmulqdq = regs[2] & 0x2;
++
++    x86_cpu_enable_simd = x86_cpu_has_sse2 &&
++                          x86_cpu_has_sse42 &&
++                          x86_cpu_has_pclmulqdq;
++    return TRUE;
++}
++#endif  /* _MSC_VER */
+diff --git a/x86.h b/x86.h
+new file mode 100644
+index 000000000000..ebcf10ab09d2
+--- /dev/null
++++ b/x86.h
+@@ -0,0 +1,15 @@
++/* x86.h -- check for x86 CPU features
++* Copyright (C) 2013 Intel Corporation Jim Kukunas
++* For conditions of distribution and use, see copyright notice in zlib.h
++*/
++
++#ifndef X86_H
++#define X86_H
++
++#include "zlib.h"
++
++extern int x86_cpu_enable_simd;
++
++void x86_check_features(void);
++
++#endif  /* X86_H */
+diff --git a/zutil.h b/zutil.h
+index 80375b8b6109..4425bcf75eb3 100644
+--- a/zutil.h
++++ b/zutil.h
+@@ -283,4 +283,10 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
+ #define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
+                     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
+ 
++#ifdef _MSC_VER
++#define zalign(x) __declspec(align(x))
++#else
++#define zalign(x) __attribute__((aligned((x))))
++#endif
++
+ #endif /* ZUTIL_H */
diff --git a/third_party/zlib/patches/0002-uninitializedcheck.patch b/third_party/zlib/patches/0002-uninitializedcheck.patch
new file mode 100644
index 0000000000000..7c497839d30b8
--- /dev/null
+++ b/third_party/zlib/patches/0002-uninitializedcheck.patch
@@ -0,0 +1,27 @@
+From 1a03e7aec95d89c659fd91f195b99893b6458cd7 Mon Sep 17 00:00:00 2001
+From: Adenilson Cavalcanti <adenilson.cavalcanti@arm.com>
+Date: Wed, 27 Sep 2017 13:59:04 -0700
+Subject: [PATCH] Zlib patch: prevent uninitialized use of state->check
+
+No need to call the Adler32 checksum function, just set
+the struct field to the expected value.
+
+Upstream bug: madler/zlib#245
+---
+ third_party/zlib/inflate.c                             |  2 +-
+ 1 files changed, 1 insertion(+), 1 deletions(-)
+ delete mode 100644 third_party/zlib/patches/0002-uninitializedcheck.patch
+
+diff --git a/third_party/zlib/inflate.c b/third_party/zlib/inflate.c
+index bec9497..5c40cf1 100644
+--- a/third_party/zlib/inflate.c
++++ b/third_party/zlib/inflate.c
+@@ -228,7 +228,7 @@ int stream_size;
+     state->strm = strm;
+     state->window = Z_NULL;
+     state->mode = HEAD;     /* to pass state test in inflateReset2() */
+-    state->check = adler32(0L, Z_NULL, 0);
++    state->check = 1L;      /* 1L is the result of adler32() zero length data */
+     ret = inflateReset2(strm, windowBits);
+     if (ret != Z_OK) {
+         ZFREE(strm, state);
diff --git a/third_party/zlib/patches/0003-uninitializedjump.patch b/third_party/zlib/patches/0003-uninitializedjump.patch
new file mode 100644
index 0000000000000..7aae3238a5011
--- /dev/null
+++ b/third_party/zlib/patches/0003-uninitializedjump.patch
@@ -0,0 +1,15 @@
+diff --git a/third_party/zlib/deflate.c b/third_party/zlib/deflate.c
+index a39e62787862..c6053fd1c7ea 100644
+--- a/third_party/zlib/deflate.c
++++ b/third_party/zlib/deflate.c
+@@ -318,6 +318,10 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+                                  s->w_size + window_padding,
+                                  2*sizeof(Byte));
+     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
++    /* Avoid use of uninitialized value, see:
++     * https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11360
++     */
++    zmemzero(s->prev, s->w_size * sizeof(Pos));
+     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+ 
+     s->high_water = 0;      /* nothing written to s->window yet */
diff --git a/third_party/zlib/patches/0004-fix-uwp.patch b/third_party/zlib/patches/0004-fix-uwp.patch
new file mode 100644
index 0000000000000..edef10a202567
--- /dev/null
+++ b/third_party/zlib/patches/0004-fix-uwp.patch
@@ -0,0 +1,27 @@
+diff --git a/third_party/zlib/contrib/minizip/iowin32.c b/third_party/zlib/contrib/minizip/iowin32.c
+index bbd7773e67146..3f6867fd7e40b 100644
+--- a/third_party/zlib/contrib/minizip/iowin32.c
++++ b/third_party/zlib/contrib/minizip/iowin32.c
+@@ -30,19 +30,12 @@
+ #define _WIN32_WINNT 0x601
+ #endif
+ 
+-#if _WIN32_WINNT >= _WIN32_WINNT_WIN8
+-// see Include/shared/winapifamily.h in the Windows Kit
+-#if defined(WINAPI_FAMILY_PARTITION) && (!(defined(IOWIN32_USING_WINRT_API)))
+-
+-#if !defined(WINAPI_FAMILY_ONE_PARTITION)
+-#define WINAPI_FAMILY_ONE_PARTITION(PartitionSet, Partition) ((WINAPI_FAMILY & PartitionSet) == Partition)
+-#endif
+-
+-#if WINAPI_FAMILY_ONE_PARTITION(WINAPI_FAMILY, WINAPI_PARTITION_APP)
++#if !defined(IOWIN32_USING_WINRT_API)
++#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
++// Windows Store or Universal Windows Platform
+ #define IOWIN32_USING_WINRT_API 1
+ #endif
+ #endif
+-#endif
+ 
+ typedef struct
+ {
diff --git a/third_party/zlib/patches/0005-infcover-gtest.patch b/third_party/zlib/patches/0005-infcover-gtest.patch
new file mode 100644
index 0000000000000..f5443bd7d88e1
--- /dev/null
+++ b/third_party/zlib/patches/0005-infcover-gtest.patch
@@ -0,0 +1,405 @@
+From 409594639f15d825202971db7a275023e05772ff Mon Sep 17 00:00:00 2001
+From: Adenilson Cavalcanti <adenilson.cavalcanti@arm.com>
+Date: Tue, 28 Apr 2020 10:48:01 -0700
+Subject: [PATCH] Local Changes:   - make C tests build as C++ code so we can
+ use gtest.   - use gtest EXPECT_TRUE instead of C assert.   - replace C
+ streams for C++ (portability issues).
+
+---
+ test/infcover.c | 167 ++++++++++++++++++++++++++----------------------
+ 1 file changed, 90 insertions(+), 77 deletions(-)
+
+diff --git a/test/infcover.c b/test/infcover.c
+index 2be0164..a8c51c7 100644
+--- a/test/infcover.c
++++ b/test/infcover.c
+@@ -4,11 +4,12 @@
+  */
+ 
+ /* to use, do: ./configure --cover && make cover */
+-
++// clang-format off
++#include "infcover.h"
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+-#include <assert.h>
++
+ #include "zlib.h"
+ 
+ /* get definition of internal structure so we can mess with it (see pull()),
+@@ -17,8 +18,22 @@
+ #include "inftrees.h"
+ #include "inflate.h"
+ 
++/* XXX: use C++ streams instead of printf/fputs/etc due to portability
++ * as type sizes can vary between platforms.
++ */
++#include <iostream>
+ #define local static
+ 
++/* XXX: hacking C assert and plugging into GTest. */
++#include "gtest.h"
++#if defined(assert)
++#undef assert
++#define assert EXPECT_TRUE
++#endif
++
++/* XXX: handle what is a reserved word in C++. */
++#define try try_f
++
+ /* -- memory tracking routines -- */
+ 
+ /*
+@@ -72,7 +87,7 @@ local void *mem_alloc(void *mem, unsigned count, unsigned size)
+ {
+     void *ptr;
+     struct mem_item *item;
+-    struct mem_zone *zone = mem;
++    struct mem_zone *zone = static_cast<struct mem_zone *>(mem);
+     size_t len = count * (size_t)size;
+ 
+     /* induced allocation failure */
+@@ -87,7 +102,7 @@ local void *mem_alloc(void *mem, unsigned count, unsigned size)
+     memset(ptr, 0xa5, len);
+ 
+     /* create a new item for the list */
+-    item = malloc(sizeof(struct mem_item));
++    item = static_cast<struct mem_item *>(malloc(sizeof(struct mem_item)));
+     if (item == NULL) {
+         free(ptr);
+         return NULL;
+@@ -112,7 +127,7 @@ local void *mem_alloc(void *mem, unsigned count, unsigned size)
+ local void mem_free(void *mem, void *ptr)
+ {
+     struct mem_item *item, *next;
+-    struct mem_zone *zone = mem;
++    struct mem_zone *zone = static_cast<struct mem_zone *>(mem);
+ 
+     /* if no zone, just do a free */
+     if (zone == NULL) {
+@@ -159,7 +174,7 @@ local void mem_setup(z_stream *strm)
+ {
+     struct mem_zone *zone;
+ 
+-    zone = malloc(sizeof(struct mem_zone));
++    zone = static_cast<struct mem_zone *>(malloc(sizeof(struct mem_zone)));
+     assert(zone != NULL);
+     zone->first = NULL;
+     zone->total = 0;
+@@ -175,33 +190,33 @@ local void mem_setup(z_stream *strm)
+ /* set a limit on the total memory allocation, or 0 to remove the limit */
+ local void mem_limit(z_stream *strm, size_t limit)
+ {
+-    struct mem_zone *zone = strm->opaque;
++    struct mem_zone *zone = static_cast<struct mem_zone *>(strm->opaque);
+ 
+     zone->limit = limit;
+ }
+ 
+ /* show the current total requested allocations in bytes */
+-local void mem_used(z_stream *strm, char *prefix)
++local void mem_used(z_stream *strm, const char *prefix)
+ {
+-    struct mem_zone *zone = strm->opaque;
++    struct mem_zone *zone = static_cast<struct mem_zone *>(strm->opaque);
+ 
+-    fprintf(stderr, "%s: %lu allocated\n", prefix, zone->total);
++    std::cout << prefix << ": " << zone->total << " allocated" << std::endl;
+ }
+ 
+ /* show the high water allocation in bytes */
+-local void mem_high(z_stream *strm, char *prefix)
++local void mem_high(z_stream *strm, const char *prefix)
+ {
+-    struct mem_zone *zone = strm->opaque;
++    struct mem_zone *zone = static_cast<struct mem_zone *>(strm->opaque);
+ 
+-    fprintf(stderr, "%s: %lu high water mark\n", prefix, zone->highwater);
++    std::cout << prefix << ": " << zone->highwater << " high water mark" << std::endl;
+ }
+ 
+ /* release the memory allocation zone -- if there are any surprises, notify */
+-local void mem_done(z_stream *strm, char *prefix)
++local void mem_done(z_stream *strm, const char *prefix)
+ {
+     int count = 0;
+     struct mem_item *item, *next;
+-    struct mem_zone *zone = strm->opaque;
++    struct mem_zone *zone = static_cast<struct mem_zone *>(strm->opaque);
+ 
+     /* show high water mark */
+     mem_high(strm, prefix);
+@@ -218,13 +233,20 @@ local void mem_done(z_stream *strm, char *prefix)
+ 
+     /* issue alerts about anything unexpected */
+     if (count || zone->total)
+-        fprintf(stderr, "** %s: %lu bytes in %d blocks not freed\n",
+-                prefix, zone->total, count);
++        std::cout << "** " << prefix << ": "
++                  << zone->total << " bytes in "
++                  << count << " blocks not freed"
++                  << std::endl;
++
+     if (zone->notlifo)
+-        fprintf(stderr, "** %s: %d frees not LIFO\n", prefix, zone->notlifo);
++        std::cout << "** " << prefix << ": "
++                  << zone->notlifo << " frees not LIFO"
++                  << std::endl;
++
+     if (zone->rogue)
+-        fprintf(stderr, "** %s: %d frees not recognized\n",
+-                prefix, zone->rogue);
++        std::cout << "** " << prefix << ": "
++                  << zone->rogue << " frees not recognized"
++                  << std::endl;
+ 
+     /* free the zone and delete from the stream */
+     free(zone);
+@@ -247,7 +269,7 @@ local unsigned char *h2b(const char *hex, unsigned *len)
+     unsigned char *in, *re;
+     unsigned next, val;
+ 
+-    in = malloc((strlen(hex) + 1) >> 1);
++    in = static_cast<unsigned char *>(malloc((strlen(hex) + 1) >> 1));
+     if (in == NULL)
+         return NULL;
+     next = 0;
+@@ -268,7 +290,7 @@ local unsigned char *h2b(const char *hex, unsigned *len)
+     } while (*hex++);       /* go through the loop with the terminating null */
+     if (len != NULL)
+         *len = next;
+-    re = realloc(in, next);
++    re = static_cast<unsigned char *>(realloc(in, next));
+     return re == NULL ? in : re;
+ }
+ 
+@@ -281,7 +303,7 @@ local unsigned char *h2b(const char *hex, unsigned *len)
+    header information is collected with inflateGetHeader().  If a zlib stream
+    is looking for a dictionary, then an empty dictionary is provided.
+    inflate() is run until all of the input data is consumed. */
+-local void inf(char *hex, char *what, unsigned step, int win, unsigned len,
++local void inf(const char *hex, const char *what, unsigned step, int win, unsigned len,
+                int err)
+ {
+     int ret;
+@@ -298,7 +320,7 @@ local void inf(char *hex, char *what, unsigned step, int win, unsigned len,
+         mem_done(&strm, what);
+         return;
+     }
+-    out = malloc(len);                          assert(out != NULL);
++    out = static_cast<unsigned char *>(malloc(len));                          assert(out != NULL);
+     if (win == 47) {
+         head.extra = out;
+         head.extra_max = len;
+@@ -347,7 +369,7 @@ local void inf(char *hex, char *what, unsigned step, int win, unsigned len,
+ }
+ 
+ /* cover all of the lines in inflate.c up to inflate() */
+-local void cover_support(void)
++void cover_support(void)
+ {
+     int ret;
+     z_stream strm;
+@@ -381,11 +403,11 @@ local void cover_support(void)
+     strm.next_in = Z_NULL;
+     ret = inflateInit(&strm);                   assert(ret == Z_OK);
+     ret = inflateEnd(&strm);                    assert(ret == Z_OK);
+-    fputs("inflate built-in memory routines\n", stderr);
++    std::cout << "inflate built-in memory routines" << std::endl;;
+ }
+ 
+ /* cover all inflate() header and trailer cases and code after inflate() */
+-local void cover_wrap(void)
++void cover_wrap(void)
+ {
+     int ret;
+     z_stream strm, copy;
+@@ -394,7 +416,7 @@ local void cover_wrap(void)
+     ret = inflate(Z_NULL, 0);                   assert(ret == Z_STREAM_ERROR);
+     ret = inflateEnd(Z_NULL);                   assert(ret == Z_STREAM_ERROR);
+     ret = inflateCopy(Z_NULL, Z_NULL);          assert(ret == Z_STREAM_ERROR);
+-    fputs("inflate bad parameters\n", stderr);
++    std::cout << "inflate bad parameters" << std::endl;
+ 
+     inf("1f 8b 0 0", "bad gzip method", 0, 31, 0, Z_DATA_ERROR);
+     inf("1f 8b 8 80", "bad gzip flags", 0, 31, 0, Z_DATA_ERROR);
+@@ -415,9 +437,9 @@ local void cover_wrap(void)
+     strm.next_in = Z_NULL;
+     ret = inflateInit2(&strm, -8);
+     strm.avail_in = 2;
+-    strm.next_in = (void *)"\x63";
++    strm.next_in = (Bytef *)"\x63";
+     strm.avail_out = 1;
+-    strm.next_out = (void *)&ret;
++    strm.next_out = (Bytef *)&ret;
+     mem_limit(&strm, 1);
+     ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);
+     ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);
+@@ -428,11 +450,11 @@ local void cover_wrap(void)
+     mem_limit(&strm, (sizeof(struct inflate_state) << 1) + 256);
+     ret = inflatePrime(&strm, 16, 0);           assert(ret == Z_OK);
+     strm.avail_in = 2;
+-    strm.next_in = (void *)"\x80";
++    strm.next_in = (Bytef *)"\x80";
+     ret = inflateSync(&strm);                   assert(ret == Z_DATA_ERROR);
+     ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_STREAM_ERROR);
+     strm.avail_in = 4;
+-    strm.next_in = (void *)"\0\0\xff\xff";
++    strm.next_in = (Bytef *)"\0\0\xff\xff";
+     ret = inflateSync(&strm);                   assert(ret == Z_OK);
+     (void)inflateSyncPoint(&strm);
+     ret = inflateCopy(&copy, &strm);            assert(ret == Z_MEM_ERROR);
+@@ -454,7 +476,7 @@ local unsigned pull(void *desc, unsigned char **buf)
+         next = 0;
+         return 0;   /* no input (already provided at next_in) */
+     }
+-    state = (void *)((z_stream *)desc)->state;
++    state = reinterpret_cast<struct inflate_state *>(((z_stream *)desc)->state);
+     if (state != Z_NULL)
+         state->mode = SYNC;     /* force an otherwise impossible situation */
+     return next < sizeof(dat) ? (*buf = dat + next++, 1) : 0;
+@@ -467,7 +489,7 @@ local int push(void *desc, unsigned char *buf, unsigned len)
+ }
+ 
+ /* cover inflateBack() up to common deflate data cases and after those */
+-local void cover_back(void)
++void cover_back(void)
+ {
+     int ret;
+     z_stream strm;
+@@ -479,17 +501,17 @@ local void cover_back(void)
+     ret = inflateBack(Z_NULL, Z_NULL, Z_NULL, Z_NULL, Z_NULL);
+                                                 assert(ret == Z_STREAM_ERROR);
+     ret = inflateBackEnd(Z_NULL);               assert(ret == Z_STREAM_ERROR);
+-    fputs("inflateBack bad parameters\n", stderr);
++    std::cout << "inflateBack bad parameters" << std::endl;;
+ 
+     mem_setup(&strm);
+     ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);
+     strm.avail_in = 2;
+-    strm.next_in = (void *)"\x03";
++    strm.next_in = (Bytef *)"\x03";
+     ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);
+                                                 assert(ret == Z_STREAM_END);
+         /* force output error */
+     strm.avail_in = 3;
+-    strm.next_in = (void *)"\x63\x00";
++    strm.next_in = (Bytef *)"\x63\x00";
+     ret = inflateBack(&strm, pull, Z_NULL, push, &strm);
+                                                 assert(ret == Z_BUF_ERROR);
+         /* force mode error by mucking with state */
+@@ -500,11 +522,11 @@ local void cover_back(void)
+ 
+     ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);
+     ret = inflateBackEnd(&strm);                assert(ret == Z_OK);
+-    fputs("inflateBack built-in memory routines\n", stderr);
++    std::cout << "inflateBack built-in memory routines" << std::endl;;
+ }
+ 
+ /* do a raw inflate of data in hexadecimal with both inflate and inflateBack */
+-local int try(char *hex, char *id, int err)
++local int try(const char *hex, const char *id, int err)
+ {
+     int ret;
+     unsigned len, size;
+@@ -518,11 +540,11 @@ local int try(char *hex, char *id, int err)
+ 
+     /* allocate work areas */
+     size = len << 3;
+-    out = malloc(size);
++    out = static_cast<unsigned char *>(malloc(size));
+     assert(out != NULL);
+-    win = malloc(32768);
++    win = static_cast<unsigned char *>(malloc(32768));
+     assert(win != NULL);
+-    prefix = malloc(strlen(id) + 6);
++    prefix = static_cast<char *>(malloc(strlen(id) + 6));
+     assert(prefix != NULL);
+ 
+     /* first with inflate */
+@@ -578,7 +600,7 @@ local int try(char *hex, char *id, int err)
+ }
+ 
+ /* cover deflate data cases in both inflate() and inflateBack() */
+-local void cover_inflate(void)
++void cover_inflate(void)
+ {
+     try("0 0 0 0 0", "invalid stored block lengths", 1);
+     try("3 0", "fixed", 0);
+@@ -613,32 +635,33 @@ local void cover_inflate(void)
+     inf("63 18 5 40 c 0", "window wrap", 3, -8, 300, Z_OK);
+ }
+ 
++/* XXX(cavalcantii): fix linking error due inflate_table. */
+ /* cover remaining lines in inftrees.c */
+-local void cover_trees(void)
+-{
+-    int ret;
+-    unsigned bits;
+-    unsigned short lens[16], work[16];
+-    code *next, table[ENOUGH_DISTS];
+-
+-    /* we need to call inflate_table() directly in order to manifest not-
+-       enough errors, since zlib insures that enough is always enough */
+-    for (bits = 0; bits < 15; bits++)
+-        lens[bits] = (unsigned short)(bits + 1);
+-    lens[15] = 15;
+-    next = table;
+-    bits = 15;
+-    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);
+-                                                assert(ret == 1);
+-    next = table;
+-    bits = 1;
+-    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);
+-                                                assert(ret == 1);
+-    fputs("inflate_table not enough errors\n", stderr);
+-}
++/* void cover_trees(void) */
++/* { */
++/*     int ret; */
++/*     unsigned bits; */
++/*     unsigned short lens[16], work[16]; */
++/*     code *next, table[ENOUGH_DISTS]; */
++
++/*     /\* we need to call inflate_table() directly in order to manifest not- */
++/*        enough errors, since zlib insures that enough is always enough *\/ */
++/*     for (bits = 0; bits < 15; bits++) */
++/*         lens[bits] = (unsigned short)(bits + 1); */
++/*     lens[15] = 15; */
++/*     next = table; */
++/*     bits = 15; */
++/*     ret = inflate_table(DISTS, lens, 16, &next, &bits, work); */
++/*                                                 assert(ret == 1); */
++/*     next = table; */
++/*     bits = 1; */
++/*     ret = inflate_table(DISTS, lens, 16, &next, &bits, work); */
++/*                                                 assert(ret == 1); */
++/*     fputs("inflate_table not enough errors\n", stderr); */
++/* } */
+ 
+ /* cover remaining inffast.c decoding and window copying */
+-local void cover_fast(void)
++void cover_fast(void)
+ {
+     inf("e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68"
+         " ff 7f 0f 0 0 0", "fast length extra bits", 0, -8, 258, Z_DATA_ERROR);
+@@ -658,14 +681,4 @@ local void cover_fast(void)
+         Z_STREAM_END);
+ }
+ 
+-int main(void)
+-{
+-    fprintf(stderr, "%s\n", zlibVersion());
+-    cover_support();
+-    cover_wrap();
+-    cover_back();
+-    cover_inflate();
+-    cover_trees();
+-    cover_fast();
+-    return 0;
+-}
++// clang-format on
+-- 
+2.21.1 (Apple Git-122.3)
+
diff --git a/third_party/zlib/patches/0006-fix-check_match.patch b/third_party/zlib/patches/0006-fix-check_match.patch
new file mode 100644
index 0000000000000..b21c363b1ec1e
--- /dev/null
+++ b/third_party/zlib/patches/0006-fix-check_match.patch
@@ -0,0 +1,42 @@
+From 8304bdda5293ffd5b3efce8e4f54904b387029d6 Mon Sep 17 00:00:00 2001
+From: Hans Wennborg <hans@chromium.org>
+Date: Wed, 23 Sep 2020 16:36:38 +0200
+Subject: [PATCH] Avoid crashing in check_match when prev_match == -1
+
+prev_match can be set to -1 after sliding the window. In that case, the
+window has slid past the first byte of the last match, which means it
+cannot be compared in check_match.
+
+This would cause zlib to crash on some inputs to deflate when built
+with ZLIB_DEBUG enabled.
+
+Check for this situation and avoid crashing by not trying to compare
+the first byte.
+
+Bug: 1113142
+---
+ third_party/zlib/deflate.c | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+diff --git a/third_party/zlib/deflate.c b/third_party/zlib/deflate.c
+index cfdd2f46b230..d70732ec6fc2 100644
+--- a/third_party/zlib/deflate.c
++++ b/third_party/zlib/deflate.c
+@@ -2060,7 +2060,13 @@ local block_state deflate_slow(s, flush)
+             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+             /* Do not insert strings in hash table beyond this. */
+ 
+-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
++            if (s->prev_match == -1) {
++                /* The window has slid one byte past the previous match,
++                 * so the first byte cannot be compared. */
++                check_match(s, s->strstart, s->prev_match+1, s->prev_length-1);
++            } else {
++                check_match(s, s->strstart-1, s->prev_match, s->prev_length);
++            }
+ 
+             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
+                            s->prev_length - MIN_MATCH, bflush);
+-- 
+2.28.0.681.g6f77f65b4e-goog
+
diff --git a/third_party/zlib/patches/0007-zero-init-deflate-window.patch b/third_party/zlib/patches/0007-zero-init-deflate-window.patch
new file mode 100644
index 0000000000000..9dbbf53a8c6b6
--- /dev/null
+++ b/third_party/zlib/patches/0007-zero-init-deflate-window.patch
@@ -0,0 +1,40 @@
+From 92537ee19784e0e545f06d89b7d89ab532a18cff Mon Sep 17 00:00:00 2001
+From: Hans Wennborg <hans@chromium.org>
+Date: Tue, 3 Nov 2020 15:54:09 +0100
+Subject: [PATCH] [zlib] Zero-initialize the window used for deflation
+
+Otherwise MSan complains about use-of-uninitialized values in the
+window.
+This happens in both regular deflate's longest_match and deflate_rle.
+
+Before crrev.com/822755 we used to suppress those reports, but it seems
+better to fix it properly. That will also allow us to catch other
+potential issues with MSan in these functions.
+
+The instances of this that we've seen only reproduce with
+fill_window_sse(), not with the regular fill_window() function. Since
+the former doesn't exist in upstream zlib, I'm not planning to send this
+patch upstream.
+
+Bug: 1137613, 1144420
+---
+ third_party/zlib/deflate.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/third_party/zlib/deflate.c b/third_party/zlib/deflate.c
+index 8bf93e524875..fc7ae45905ff 100644
+--- a/third_party/zlib/deflate.c
++++ b/third_party/zlib/deflate.c
+@@ -321,6 +321,9 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+     s->window = (Bytef *) ZALLOC(strm,
+                                  s->w_size + window_padding,
+                                  2*sizeof(Byte));
++    /* Avoid use of unitialized values in the window, see crbug.com/1137613 and
++     * crbug.com/1144420 */
++    zmemzero(s->window, (s->w_size + window_padding) * (2 * sizeof(Byte)));
+     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
+     /* Avoid use of uninitialized value, see:
+      * https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11360
+-- 
+2.29.1.341.ge80a0c044ae-goog
+
diff --git a/third_party/zlib/patches/0008-minizip-zip-unzip-tools.patch b/third_party/zlib/patches/0008-minizip-zip-unzip-tools.patch
new file mode 100644
index 0000000000000..a359e0f72b0f9
--- /dev/null
+++ b/third_party/zlib/patches/0008-minizip-zip-unzip-tools.patch
@@ -0,0 +1,82 @@
+From 0c7de17000659f4f79de878296892c46be0aff77 Mon Sep 17 00:00:00 2001
+From: Noel Gordon <noel@chromium.org>
+Date: Wed, 26 May 2021 21:57:43 +1000
+Subject: [PATCH] Build minizip zip and unzip tools
+
+---
+ third_party/zlib/contrib/minizip/miniunz.c | 13 ++++++-------
+ third_party/zlib/contrib/minizip/minizip.c |  7 +++----
+ 2 files changed, 9 insertions(+), 11 deletions(-)
+
+diff --git a/third_party/zlib/contrib/minizip/miniunz.c b/third_party/zlib/contrib/minizip/miniunz.c
+index 616c30325e07c..f4ad16bdd377b 100644
+--- a/third_party/zlib/contrib/minizip/miniunz.c
++++ b/third_party/zlib/contrib/minizip/miniunz.c
+@@ -12,7 +12,7 @@
+          Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+ */
+ 
+-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
++#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__)) && (!defined(__ANDROID_API__))
+         #ifndef __USE_FILE_OFFSET64
+                 #define __USE_FILE_OFFSET64
+         #endif
+@@ -27,7 +27,7 @@
+         #endif
+ #endif
+ 
+-#if defined(__APPLE__) || defined(__HAIKU__) || defined(MINIZIP_FOPEN_NO_64)
++#if defined(__APPLE__) || defined(__HAIKU__) || defined(MINIZIP_FOPEN_NO_64) || defined(__Fuchsia__) || defined(__ANDROID_API__)
+ // In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
+ #define FOPEN_FUNC(filename, mode) fopen(filename, mode)
+ #define FTELLO_FUNC(stream) ftello(stream)
+@@ -97,7 +97,7 @@ static void change_file_date(const char *filename, uLong dosdate, tm_unz tmu_dat
+   LocalFileTimeToFileTime(&ftLocal,&ftm);
+   SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);
+   CloseHandle(hFile);
+-#elif defined(__unix__) || defined(__unix) || defined(__APPLE__)
++#elif defined(__unix__) || defined(__unix) || defined(__APPLE__) || defined(__Fuchsia__) || defined(__ANDROID_API__)
+   (void)dosdate;
+   struct utimbuf ut;
+   struct tm newdate;
+@@ -129,7 +129,7 @@ static int mymkdir(const char* dirname) {
+     int ret=0;
+ #ifdef _WIN32
+     ret = _mkdir(dirname);
+-#elif defined(__unix__) || defined(__unix) || defined(__APPLE__)
++#elif defined(__unix__) || defined(__unix) || defined(__APPLE__) || defined(__Fuchsia__) || defined(__ANDROID_API__)
+     ret = mkdir (dirname,0775);
+ #else
+     (void)dirname;
+diff --git a/third_party/zlib/contrib/minizip/minizip.c b/third_party/zlib/contrib/minizip/minizip.c
+index a44e36a01869d..53fdd363e6222 100644
+--- a/third_party/zlib/contrib/minizip/minizip.c
++++ b/third_party/zlib/contrib/minizip/minizip.c
+@@ -12,8 +12,7 @@
+          Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+ */
+ 
+-
+-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
++#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__)) && (!defined(__ANDROID_API__))
+         #ifndef __USE_FILE_OFFSET64
+                 #define __USE_FILE_OFFSET64
+         #endif
+@@ -28,7 +27,7 @@
+         #endif
+ #endif
+ 
+-#if defined(__APPLE__) || defined(__HAIKU__) || defined(MINIZIP_FOPEN_NO_64)
++#if defined(__APPLE__) || defined(__HAIKU__) || defined(MINIZIP_FOPEN_NO_64) || defined(__Fuchsia__) || defined(__ANDROID_API__)
+ // In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
+ #define FOPEN_FUNC(filename, mode) fopen(filename, mode)
+ #define FTELLO_FUNC(stream) ftello(stream)
+@@ -96,7 +95,7 @@ static int filetime(const char *f, tm_zip *tmzip, uLong *dt) {
+   }
+   return ret;
+ }
+-#elif defined(__unix__) || defined(__unix) || defined(__APPLE__)
++#elif defined(__unix__) || defined(__unix) || defined(__APPLE__) || defined(__Fuchsia__) || defined(__ANDROID_API__)
+ /* f: name of file to get info on, tmzip: return value: access,
+    modification and creation times, dt: dostime */
+ static int filetime(const char *f, tm_zip *tmzip, uLong *dt) {
diff --git a/third_party/zlib/patches/0009-infcover-oob.patch b/third_party/zlib/patches/0009-infcover-oob.patch
new file mode 100644
index 0000000000000..648360f332d49
--- /dev/null
+++ b/third_party/zlib/patches/0009-infcover-oob.patch
@@ -0,0 +1,24 @@
+From 75690b2683667be5535ac6243438115dc9c40f6a Mon Sep 17 00:00:00 2001
+From: Florian Mayer <fmayer@google.com>
+Date: Wed, 16 Mar 2022 16:38:36 -0700
+Subject: [PATCH] Fix out of bounds in infcover.c.
+
+---
+ test/infcover.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/test/infcover.c b/test/infcover.c
+index 2be01646c..a6d83693c 100644
+--- a/test/infcover.c
++++ b/test/infcover.c
+@@ -373,7 +373,9 @@ local void cover_support(void)
+     mem_setup(&strm);
+     strm.avail_in = 0;
+     strm.next_in = Z_NULL;
+-    ret = inflateInit_(&strm, ZLIB_VERSION - 1, (int)sizeof(z_stream));
++    char versioncpy[] = ZLIB_VERSION;
++    versioncpy[0] -= 1;
++    ret = inflateInit_(&strm, versioncpy, (int)sizeof(z_stream));
+                                                 assert(ret == Z_VERSION_ERROR);
+     mem_done(&strm, "wrong version");
+ 
diff --git a/third_party/zlib/patches/0010-cmake-enable-simd.patch b/third_party/zlib/patches/0010-cmake-enable-simd.patch
new file mode 100644
index 0000000000000..3893101b7c6a7
--- /dev/null
+++ b/third_party/zlib/patches/0010-cmake-enable-simd.patch
@@ -0,0 +1,96 @@
+diff --git a/third_party/zlib/CMakeLists.txt b/third_party/zlib/CMakeLists.txt
+index b412dc7feb732..0431278405046 100644
+--- a/third_party/zlib/CMakeLists.txt
++++ b/third_party/zlib/CMakeLists.txt
+@@ -1,4 +1,4 @@
+-cmake_minimum_required(VERSION 2.4.4)
++cmake_minimum_required(VERSION 3.0)
+ set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
+ 
+ project(zlib C)
+@@ -21,6 +21,26 @@ check_include_file(sys/types.h HAVE_SYS_TYPES_H)
+ check_include_file(stdint.h    HAVE_STDINT_H)
+ check_include_file(stddef.h    HAVE_STDDEF_H)
+ 
++option(ENABLE_SIMD_OPTIMIZATIONS "Enable all SIMD optimizations" OFF)
++
++# TODO(cavalcantii): add support for other OSes (e.g. Android, fuchsia, osx)
++# and architectures (e.g. Arm).
++if (ENABLE_SIMD_OPTIMIZATIONS)
++   add_definitions(-DINFLATE_CHUNK_SIMD_SSE2)
++   add_definitions(-DADLER32_SIMD_SSSE3)
++   add_definitions(-DINFLATE_CHUNK_READ_64LE)
++   add_definitions(-DCRC32_SIMD_SSE42_PCLMUL)
++   add_definitions(-DDEFLATE_SLIDE_HASH_SSE2)
++   add_compile_options(-msse4.2 -mpclmul)
++   # Required by CPU features detection code.
++   add_definitions(-DX86_NOT_WINDOWS)
++   # Apparently some environments (e.g. CentOS) require to explicitly link
++   # with pthread and that is required by the CPU features detection code.
++   find_package (Threads REQUIRED)
++   SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pthread")
++   SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pthread")
++endif()
++
+ #
+ # Check to see if we have large file support
+ #
+@@ -120,10 +140,25 @@ set(ZLIB_SRCS
+     zutil.c
+ )
+ 
+-if(NOT MINGW)
+-    set(ZLIB_DLL_SRCS
+-        win32/zlib1.rc # If present will override custom build rule below.
+-    )
++
++#============================================================================
++# Update list of source files if optimizations were enabled
++#============================================================================
++if (ENABLE_SIMD_OPTIMIZATIONS)
++  list(REMOVE_ITEM ZLIB_SRCS inflate.c)
++
++  list(APPEND ZLIB_PRIVATE_HDRS ${CMAKE_CURRENT_SOURCE_DIR}/adler32_simd.h)
++  list(APPEND ZLIB_PRIVATE_HDRS ${CMAKE_CURRENT_SOURCE_DIR}/contrib/optimizations/chunkcopy.h)
++  list(APPEND ZLIB_PRIVATE_HDRS ${CMAKE_CURRENT_SOURCE_DIR}/contrib/optimizations/inffast_chunk.h)
++  list(APPEND ZLIB_PRIVATE_HDRS ${CMAKE_CURRENT_SOURCE_DIR}/cpu_features.h)
++  list(APPEND ZLIB_PRIVATE_HDRS ${CMAKE_CURRENT_SOURCE_DIR}/crc32_simd.h)
++
++  list(APPEND ZLIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/adler32_simd.c)
++  list(APPEND ZLIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/contrib/optimizations/inffast_chunk.c)
++  list(APPEND ZLIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/contrib/optimizations/inflate.c)
++  list(APPEND ZLIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/cpu_features.c)
++  list(APPEND ZLIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/crc32_simd.c)
++  list(APPEND ZLIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/crc_folding.c)
+ endif()
+ 
+ # parse the full version number from zlib.h and include in ZLIB_FULL_VERSION
+@@ -191,23 +226,9 @@ if(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )
+ endif()
+ 
+ #============================================================================
+-# Example binaries
++# Benchmarker
+ #============================================================================
+-
+-add_executable(example test/example.c)
+-target_link_libraries(example zlib)
+-add_test(example example)
+-
+-add_executable(minigzip test/minigzip.c)
+-target_link_libraries(minigzip zlib)
+-
+-if(HAVE_OFF64_T)
+-    add_executable(example64 test/example.c)
+-    target_link_libraries(example64 zlib)
+-    set_target_properties(example64 PROPERTIES COMPILE_FLAGS "-D_FILE_OFFSET_BITS=64")
+-    add_test(example64 example64)
+-
+-    add_executable(minigzip64 test/minigzip.c)
+-    target_link_libraries(minigzip64 zlib)
+-    set_target_properties(minigzip64 PROPERTIES COMPILE_FLAGS "-D_FILE_OFFSET_BITS=64")
+-endif()
++enable_language(CXX)
++set(CMAKE_CXX_STANDARD 14) # workaround for older compilers (e.g. g++ 5.4).
++add_executable(zlib_bench contrib/bench/zlib_bench.cc)
++target_link_libraries(zlib_bench zlib)
diff --git a/third_party/zlib/patches/0011-avx512.patch b/third_party/zlib/patches/0011-avx512.patch
new file mode 100644
index 0000000000000..6d409b77383d5
--- /dev/null
+++ b/third_party/zlib/patches/0011-avx512.patch
@@ -0,0 +1,357 @@
+From 87fc8e3e38323cfdabf8da3927488e3e57073b02 Mon Sep 17 00:00:00 2001
+From: Jia Liu <jia3.liu@intel.com>
+Date: Thu, 30 Mar 2023 11:13:16 +0800
+Subject: [PATCH] Enabled AVX512 for CRC32
+
+Enabled AVX512 for CRC32 that provide best of known performance
+beyond current SSE SIMD optimization. It enables multiple folding
+operations and AVX512 new instructions, providing ~3.5X CRC32
+performance and ~3.7% gain on Zlib_bench gzip performance.
+---
+ CMakeLists.txt |   8 +-
+ cpu_features.c |   9 +++
+ cpu_features.h |   1 +
+ crc32.c        |  14 +++-
+ crc32_simd.c   | 198 ++++++++++++++++++++++++++++++++++++++++++++++++-
+ crc32_simd.h   |   6 ++
+ 6 files changed, 230 insertions(+), 6 deletions(-)
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index f06e193..d45b902 100644
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -22,6 +22,7 @@ check_include_file(stdint.h    HAVE_STDINT_H)
+ check_include_file(stddef.h    HAVE_STDDEF_H)
+ 
+ option(ENABLE_SIMD_OPTIMIZATIONS "Enable all SIMD optimizations" OFF)
++option(ENABLE_SIMD_AVX512 "Enable SIMD AXV512 optimizations" OFF)
+ 
+ # TODO(cavalcantii): add support for other OSes (e.g. Android, fuchsia, osx)
+ # and architectures (e.g. Arm).
+@@ -30,8 +31,13 @@ if (ENABLE_SIMD_OPTIMIZATIONS)
+    add_definitions(-DADLER32_SIMD_SSSE3)
+    add_definitions(-DINFLATE_CHUNK_READ_64LE)
+    add_definitions(-DCRC32_SIMD_SSE42_PCLMUL)
++   if (ENABLE_SIMD_AVX512)
++    add_definitions(-DCRC32_SIMD_AVX512_PCLMUL)
++    add_compile_options(-mvpclmulqdq -msse2 -mavx512f -mpclmul)
++   else()
++    add_compile_options(-msse4.2 -mpclmul)
++   endif()
+    add_definitions(-DDEFLATE_SLIDE_HASH_SSE2)
+-   add_compile_options(-msse4.2 -mpclmul)
+    # Required by CPU features detection code.
+    add_definitions(-DX86_NOT_WINDOWS)
+    # Apparently some environments (e.g. CentOS) require to explicitly link
+diff --git a/cpu_features.c b/cpu_features.c
+index 877d5f2..ac6ee88 100644
+--- a/cpu_features.c
++++ b/cpu_features.c
+@@ -31,6 +31,7 @@ int ZLIB_INTERNAL arm_cpu_enable_pmull = 0;
+ int ZLIB_INTERNAL x86_cpu_enable_sse2 = 0;
+ int ZLIB_INTERNAL x86_cpu_enable_ssse3 = 0;
+ int ZLIB_INTERNAL x86_cpu_enable_simd = 0;
++int ZLIB_INTERNAL x86_cpu_enable_avx512 = 0;
+ 
+ #ifndef CPU_NO_SIMD
+ 
+@@ -138,6 +139,10 @@ static void _cpu_check_features(void)
+ /* On x86 we simply use a instruction to check the CPU features.
+  * (i.e. CPUID).
+  */
++#ifdef CRC32_SIMD_AVX512_PCLMUL
++#include <immintrin.h>
++#include <xsaveintrin.h>
++#endif
+ static void _cpu_check_features(void)
+ {
+     int x86_cpu_has_sse2;
+@@ -164,6 +169,10 @@ static void _cpu_check_features(void)
+     x86_cpu_enable_simd = x86_cpu_has_sse2 &&
+                           x86_cpu_has_sse42 &&
+                           x86_cpu_has_pclmulqdq;
++
++#ifdef CRC32_SIMD_AVX512_PCLMUL
++    x86_cpu_enable_avx512 = _xgetbv(0) & 0x00000040;
++#endif
+ }
+ #endif
+ #endif
+diff --git a/cpu_features.h b/cpu_features.h
+index 279246c..aed3e83 100644
+--- a/cpu_features.h
++++ b/cpu_features.h
+@@ -14,5 +14,6 @@ extern int arm_cpu_enable_pmull;
+ extern int x86_cpu_enable_sse2;
+ extern int x86_cpu_enable_ssse3;
+ extern int x86_cpu_enable_simd;
++extern int x86_cpu_enable_avx512;
+ 
+ void cpu_check_features(void);
+diff --git a/crc32.c b/crc32.c
+index 4486098..acb6972 100644
+--- a/crc32.c
++++ b/crc32.c
+@@ -773,7 +773,19 @@ unsigned long ZEXPORT crc32_z(crc, buf, len)
+     }
+ 
+ #endif
+-#if defined(CRC32_SIMD_SSE42_PCLMUL)
++#if defined(CRC32_SIMD_AVX512_PCLMUL)
++    if (x86_cpu_enable_avx512 && len >= Z_CRC32_AVX512_MINIMUM_LENGTH) {
++        /* crc32 64-byte chunks */
++        z_size_t chunk_size = len & ~Z_CRC32_AVX512_CHUNKSIZE_MASK;
++        crc = ~crc32_avx512_simd_(buf, chunk_size, ~(uint32_t)crc);
++        /* check remaining data */
++        len -= chunk_size;
++        if (!len)
++            return crc;
++        /* Fall into the default crc32 for the remaining data. */
++        buf += chunk_size;
++    }
++#elif defined(CRC32_SIMD_SSE42_PCLMUL)
+     if (x86_cpu_enable_simd && len >= Z_CRC32_SSE42_MINIMUM_LENGTH) {
+         /* crc32 16-byte chunks */
+         z_size_t chunk_size = len & ~Z_CRC32_SSE42_CHUNKSIZE_MASK;
+diff --git a/crc32_simd.c b/crc32_simd.c
+index d80beba..7428270 100644
+--- a/crc32_simd.c
++++ b/crc32_simd.c
+@@ -6,17 +6,207 @@
+  */
+ 
+ #include "crc32_simd.h"
+-
+-#if defined(CRC32_SIMD_SSE42_PCLMUL)
++#if defined(CRC32_SIMD_AVX512_PCLMUL)
+ 
+ /*
+- * crc32_sse42_simd_(): compute the crc32 of the buffer, where the buffer
+- * length must be at least 64, and a multiple of 16. Based on:
++ * crc32_avx512_simd_(): compute the crc32 of the buffer, where the buffer
++ * length must be at least 256, and a multiple of 64. Based on:
+  *
+  * "Fast CRC Computation for Generic Polynomials Using PCLMULQDQ Instruction"
+  *  V. Gopal, E. Ozturk, et al., 2009, http://intel.ly/2ySEwL0
+  */
+ 
++#include <emmintrin.h>
++#include <smmintrin.h>
++#include <wmmintrin.h>
++#include <immintrin.h>
++
++uint32_t ZLIB_INTERNAL crc32_avx512_simd_(  /* AVX512+PCLMUL */
++    const unsigned char *buf,
++    z_size_t len,
++    uint32_t crc)
++{
++    /*
++     * Definitions of the bit-reflected domain constants k1,k2,k3,k4
++     * are similar to those given at the end of the paper, and remaining
++     * constants and CRC32+Barrett polynomials remain unchanged.
++     *
++     * Replace the index of x from 128 to 512. As follows:
++     * k1 = ( x ^ ( 512 * 4 + 32 ) mod P(x) << 32 )' << 1 = 0x011542778a
++     * k2 = ( x ^ ( 512 * 4 - 32 ) mod P(x) << 32 )' << 1 = 0x01322d1430
++     * k3 = ( x ^ ( 512 + 32 ) mod P(x) << 32 )' << 1 = 0x0154442bd4
++     * k4 = ( x ^ ( 512 - 32 ) mod P(x) << 32 )' << 1 = 0x01c6e41596
++     */
++    static const uint64_t zalign(64) k1k2[] = { 0x011542778a, 0x01322d1430,
++                                                0x011542778a, 0x01322d1430,
++                                                0x011542778a, 0x01322d1430,
++                                                0x011542778a, 0x01322d1430 };
++    static const uint64_t zalign(64) k3k4[] = { 0x0154442bd4, 0x01c6e41596,
++                                                0x0154442bd4, 0x01c6e41596,
++                                                0x0154442bd4, 0x01c6e41596,
++                                                0x0154442bd4, 0x01c6e41596 };
++    static const uint64_t zalign(16) k5k6[] = { 0x01751997d0, 0x00ccaa009e };
++    static const uint64_t zalign(16) k7k8[] = { 0x0163cd6124, 0x0000000000 };
++    static const uint64_t zalign(16) poly[] = { 0x01db710641, 0x01f7011641 };
++    __m512i x0, x1, x2, x3, x4, x5, x6, x7, x8, y5, y6, y7, y8;
++    __m128i a0, a1, a2, a3;
++
++    /*
++     * There's at least one block of 256.
++     */
++    x1 = _mm512_loadu_si512((__m512i *)(buf + 0x00));
++    x2 = _mm512_loadu_si512((__m512i *)(buf + 0x40));
++    x3 = _mm512_loadu_si512((__m512i *)(buf + 0x80));
++    x4 = _mm512_loadu_si512((__m512i *)(buf + 0xC0));
++
++    x1 = _mm512_xor_si512(x1, _mm512_castsi128_si512(_mm_cvtsi32_si128(crc)));
++
++    x0 = _mm512_load_si512((__m512i *)k1k2);
++
++    buf += 256;
++    len -= 256;
++
++    /*
++     * Parallel fold blocks of 256, if any.
++     */
++    while (len >= 256)
++    {
++        x5 = _mm512_clmulepi64_epi128(x1, x0, 0x00);
++        x6 = _mm512_clmulepi64_epi128(x2, x0, 0x00);
++        x7 = _mm512_clmulepi64_epi128(x3, x0, 0x00);
++        x8 = _mm512_clmulepi64_epi128(x4, x0, 0x00);
++
++
++        x1 = _mm512_clmulepi64_epi128(x1, x0, 0x11);
++        x2 = _mm512_clmulepi64_epi128(x2, x0, 0x11);
++        x3 = _mm512_clmulepi64_epi128(x3, x0, 0x11);
++        x4 = _mm512_clmulepi64_epi128(x4, x0, 0x11);
++
++        y5 = _mm512_loadu_si512((__m512i *)(buf + 0x00));
++        y6 = _mm512_loadu_si512((__m512i *)(buf + 0x40));
++        y7 = _mm512_loadu_si512((__m512i *)(buf + 0x80));
++        y8 = _mm512_loadu_si512((__m512i *)(buf + 0xC0));
++
++        x1 = _mm512_xor_si512(x1, x5);
++        x2 = _mm512_xor_si512(x2, x6);
++        x3 = _mm512_xor_si512(x3, x7);
++        x4 = _mm512_xor_si512(x4, x8);
++
++        x1 = _mm512_xor_si512(x1, y5);
++        x2 = _mm512_xor_si512(x2, y6);
++        x3 = _mm512_xor_si512(x3, y7);
++        x4 = _mm512_xor_si512(x4, y8);
++
++        buf += 256;
++        len -= 256;
++    }
++
++    /*
++     * Fold into 512-bits.
++     */
++    x0 = _mm512_load_si512((__m512i *)k3k4);
++
++    x5 = _mm512_clmulepi64_epi128(x1, x0, 0x00);
++    x1 = _mm512_clmulepi64_epi128(x1, x0, 0x11);
++    x1 = _mm512_xor_si512(x1, x2);
++    x1 = _mm512_xor_si512(x1, x5);
++
++    x5 = _mm512_clmulepi64_epi128(x1, x0, 0x00);
++    x1 = _mm512_clmulepi64_epi128(x1, x0, 0x11);
++    x1 = _mm512_xor_si512(x1, x3);
++    x1 = _mm512_xor_si512(x1, x5);
++
++    x5 = _mm512_clmulepi64_epi128(x1, x0, 0x00);
++    x1 = _mm512_clmulepi64_epi128(x1, x0, 0x11);
++    x1 = _mm512_xor_si512(x1, x4);
++    x1 = _mm512_xor_si512(x1, x5);
++
++    /*
++     * Single fold blocks of 64, if any.
++     */
++    while (len >= 64)
++    {
++        x2 = _mm512_loadu_si512((__m512i *)buf);
++
++        x5 = _mm512_clmulepi64_epi128(x1, x0, 0x00);
++        x1 = _mm512_clmulepi64_epi128(x1, x0, 0x11);
++        x1 = _mm512_xor_si512(x1, x2);
++        x1 = _mm512_xor_si512(x1, x5);
++
++        buf += 64;
++        len -= 64;
++    }
++
++    /*
++     * Fold 512-bits to 384-bits.
++     */
++    a0 = _mm_load_si128((__m128i *)k5k6);
++
++    a1 = _mm512_extracti32x4_epi32(x1, 0);
++    a2 = _mm512_extracti32x4_epi32(x1, 1);
++
++    a3 = _mm_clmulepi64_si128(a1, a0, 0x00);
++    a1 = _mm_clmulepi64_si128(a1, a0, 0x11);
++
++    a1 = _mm_xor_si128(a1, a3);
++    a1 = _mm_xor_si128(a1, a2);
++
++    /*
++     * Fold 384-bits to 256-bits.
++     */
++    a2 = _mm512_extracti32x4_epi32(x1, 2);
++    a3 = _mm_clmulepi64_si128(a1, a0, 0x00);
++    a1 = _mm_clmulepi64_si128(a1, a0, 0x11);
++    a1 = _mm_xor_si128(a1, a3);
++    a1 = _mm_xor_si128(a1, a2);
++
++    /*
++     * Fold 256-bits to 128-bits.
++     */
++    a2 = _mm512_extracti32x4_epi32(x1, 3);
++    a3 = _mm_clmulepi64_si128(a1, a0, 0x00);
++    a1 = _mm_clmulepi64_si128(a1, a0, 0x11);
++    a1 = _mm_xor_si128(a1, a3);
++    a1 = _mm_xor_si128(a1, a2);
++
++    /*
++     * Fold 128-bits to 64-bits.
++     */
++    a2 = _mm_clmulepi64_si128(a1, a0, 0x10);
++    a3 = _mm_setr_epi32(~0, 0, ~0, 0);
++    a1 = _mm_srli_si128(a1, 8);
++    a1 = _mm_xor_si128(a1, a2);
++
++    a0 = _mm_loadl_epi64((__m128i*)k7k8);
++    a2 = _mm_srli_si128(a1, 4);
++    a1 = _mm_and_si128(a1, a3);
++    a1 = _mm_clmulepi64_si128(a1, a0, 0x00);
++    a1 = _mm_xor_si128(a1, a2);
++
++    /*
++     * Barret reduce to 32-bits.
++     */
++    a0 = _mm_load_si128((__m128i*)poly);
++
++    a2 = _mm_and_si128(a1, a3);
++    a2 = _mm_clmulepi64_si128(a2, a0, 0x10);
++    a2 = _mm_and_si128(a2, a3);
++    a2 = _mm_clmulepi64_si128(a2, a0, 0x00);
++    a1 = _mm_xor_si128(a1, a2);
++
++    /*
++     * Return the crc32.
++     */
++    return _mm_extract_epi32(a1, 1);
++}
++
++#elif defined(CRC32_SIMD_SSE42_PCLMUL)
++
++/*
++ * crc32_sse42_simd_(): compute the crc32 of the buffer, where the buffer
++ * length must be at least 64, and a multiple of 16.
++ */
++
+ #include <emmintrin.h>
+ #include <smmintrin.h>
+ #include <wmmintrin.h>
+diff --git a/crc32_simd.h b/crc32_simd.h
+index c0346dc..8462464 100644
+--- a/crc32_simd.h
++++ b/crc32_simd.h
+@@ -19,12 +19,18 @@ uint32_t ZLIB_INTERNAL crc32_sse42_simd_(const unsigned char* buf,
+                                          z_size_t len,
+                                          uint32_t crc);
+ 
++uint32_t ZLIB_INTERNAL crc32_avx512_simd_(const unsigned char* buf,
++                                          z_size_t len,
++                                          uint32_t crc);
++
+ /*
+  * crc32_sse42_simd_ buffer size constraints: see the use in zlib/crc32.c
+  * for computing the crc32 of an arbitrary length buffer.
+  */
+ #define Z_CRC32_SSE42_MINIMUM_LENGTH 64
+ #define Z_CRC32_SSE42_CHUNKSIZE_MASK 15
++#define Z_CRC32_AVX512_MINIMUM_LENGTH 256
++#define Z_CRC32_AVX512_CHUNKSIZE_MASK 63
+ 
+ /*
+  * CRC32 checksums using ARMv8-a crypto instructions.
+-- 
+2.34.1
+
diff --git a/third_party/zlib/patches/0012-lfs-open64.patch b/third_party/zlib/patches/0012-lfs-open64.patch
new file mode 100644
index 0000000000000..70e7b687a7294
--- /dev/null
+++ b/third_party/zlib/patches/0012-lfs-open64.patch
@@ -0,0 +1,40 @@
+From 6f21cb4b209d750486ede5472fdf7e35cf5ac3aa Mon Sep 17 00:00:00 2001
+From: Ramin Halavati <rhalavati@chromium.org>
+Date: Wed, 17 May 2023 15:21:43 +0200
+Subject: [PATCH] Add open64 for Large File System support to gzlib.
+
+---
+ third_party/zlib/gzlib.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/third_party/zlib/gzlib.c b/third_party/zlib/gzlib.c
+index 55da46a453fd1..bbdb797e8079d 100644
+--- a/third_party/zlib/gzlib.c
++++ b/third_party/zlib/gzlib.c
+@@ -7,11 +7,14 @@
+ 
+ #if defined(_WIN32) && !defined(__BORLANDC__)
+ #  define LSEEK _lseeki64
++#  define OPEN  open
+ #else
+ #if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
+ #  define LSEEK lseek64
++#  define OPEN  open64
+ #else
+ #  define LSEEK lseek
++#  define OPEN  open
+ #endif
+ #endif
+ 
+@@ -244,7 +247,7 @@ local gzFile gz_open(path, fd, mode)
+ #ifdef WIDECHAR
+         fd == -2 ? _wopen(path, oflag, 0666) :
+ #endif
+-        open((const char *)path, oflag, 0666));
++        OPEN((const char *)path, oflag, 0666));
+     if (state->fd == -1) {
+         free(state->path);
+         free(state);
+-- 
+2.40.1.606.ga4b1b128d6-goog
+
diff --git a/third_party/zlib/patches/0013-cpu-feature-detection-for-arm.patch b/third_party/zlib/patches/0013-cpu-feature-detection-for-arm.patch
new file mode 100644
index 0000000000000..0547851fe5d99
--- /dev/null
+++ b/third_party/zlib/patches/0013-cpu-feature-detection-for-arm.patch
@@ -0,0 +1,30 @@
+From c43ba7a55f091c0dcbfd8d89f7a5121269ce1b81 Mon Sep 17 00:00:00 2001
+From: Ho Cheung <uioptt24@gmail.com>
+Date: Thu, 27 Jul 2023 09:47:52 +0800
+Subject: [PATCH] [zlib] Perform CPU feature detection for ARM inside adler32()
+
+Perform CPU feature detection for ARM within adler32() to have the same
+behavior as x86.
+
+---
+ third_party/zlib/adler32.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/third_party/zlib/adler32.c b/third_party/zlib/adler32.c
+index 81c584f68e233..99a294496f7eb 100644
+--- a/third_party/zlib/adler32.c
++++ b/third_party/zlib/adler32.c
+@@ -90,9 +90,9 @@ uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf, z_size_t len) {
+         return adler | (sum2 << 16);
+     }
+
+-#if defined(ADLER32_SIMD_SSSE3)
++#if defined(ADLER32_SIMD_SSSE3) || defined(ADLER32_SIMD_NEON)
+     /*
+-     * Use SSSE3 to compute the adler32. Since this routine can be
++     * Use SIMD to compute the adler32. Since this function can be
+      * freely used, check CPU features here. zlib convention is to
+      * call adler32(0, NULL, 0), before making calls to adler32().
+      * So this is a good early (and infrequent) place to cache CPU
+--
+2.41.0.windows.3
diff --git a/third_party/zlib/patches/0014-minizip-unzip-with-incorrect-size.patch b/third_party/zlib/patches/0014-minizip-unzip-with-incorrect-size.patch
new file mode 100644
index 0000000000000..5ede561e3c20d
--- /dev/null
+++ b/third_party/zlib/patches/0014-minizip-unzip-with-incorrect-size.patch
@@ -0,0 +1,34 @@
+commit 764f0715d75c8d49339aa73d0ee2feb75d63473f
+Author: joaoe@opera.com <joaoe@opera.com@0039d316-1c4b-4281-b951-d872f2087c98>
+Date:   Wed May 7 20:53:02 2014 +0000
+
+    Fixed uncompressing files with wrong uncompressed size set.
+    
+    A zip file carries some metadata for each archived file, including the total
+    uncompressed size. If that size was incorrect, therefore the compressed file
+    being different in size when unpacking, the minizip code would fail with a
+    CRC error. Every other zip utility handles these files, so should the minizip
+    code for safety sake.
+    
+    BUG=359516
+    
+    Review URL: https://codereview.chromium.org/222243003
+    
+    git-svn-id: svn://svn.chromium.org/chrome/trunk/src@268940 0039d316-1c4b-4281-b951-d872f2087c98
+
+diff --git a/third_party/zlib/contrib/minizip/unzip.c b/third_party/zlib/contrib/minizip/unzip.c
+index ed763f89f1f87..82275d6c1775d 100644
+--- a/third_party/zlib/contrib/minizip/unzip.c
++++ b/third_party/zlib/contrib/minizip/unzip.c
+@@ -1572,11 +1572,6 @@ extern int ZEXPORT unzReadCurrentFile(unzFile file, voidp buf, unsigned len) {
+ 
+     pfile_in_zip_read_info->stream.avail_out = (uInt)len;
+ 
+-    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&
+-        (!(pfile_in_zip_read_info->raw)))
+-        pfile_in_zip_read_info->stream.avail_out =
+-            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
+-
+     if ((len>pfile_in_zip_read_info->rest_read_compressed+
+            pfile_in_zip_read_info->stream.avail_in) &&
+          (pfile_in_zip_read_info->raw))
diff --git a/third_party/zlib/patches/0015-minizip-unzip-enable-decryption.patch b/third_party/zlib/patches/0015-minizip-unzip-enable-decryption.patch
new file mode 100644
index 0000000000000..feeeb1c400777
--- /dev/null
+++ b/third_party/zlib/patches/0015-minizip-unzip-enable-decryption.patch
@@ -0,0 +1,28 @@
+commit f3ace98803035b8425d127fb3d874dafe0b9475a
+Author: Che-yu Wu <cheyuw@google.com>
+Date:   Mon Aug 6 14:09:22 2018 +0000
+
+    Enable traditional PKWARE decryption in zlib/contrib/minizip.
+    
+    Remove the #define which enables NOUNCRYPT by default.
+    Correct the value of rest_read_compressed when decompressing an encrypted zip.
+    
+    Bug: crbug.com/869541
+    Change-Id: Ia86c1d234a8193f405147d35ad05c29fe86f812d
+    Reviewed-on: https://chromium-review.googlesource.com/1161109
+    Reviewed-by: Chris Blume <cblume@chromium.org>
+    Commit-Queue: Che-yu Wu <cheyuw@google.com>
+    Cr-Commit-Position: refs/heads/master@{#580862}
+
+diff --git a/third_party/zlib/contrib/minizip/unzip.c b/third_party/zlib/contrib/minizip/unzip.c
+index 82275d6c1775d..c8a01b23efd42 100644
+--- a/third_party/zlib/contrib/minizip/unzip.c
++++ b/third_party/zlib/contrib/minizip/unzip.c
+@@ -1502,6 +1498,7 @@ extern int ZEXPORT unzOpenCurrentFile3(unzFile file, int* method,
+             zdecode(s->keys,s->pcrc_32_tab,source[i]);
+ 
+         s->pfile_in_zip_read->pos_in_zipfile+=12;
++        s->pfile_in_zip_read->rest_read_compressed-=12;
+         s->encrypted=1;
+     }
+ #    endif
diff --git a/third_party/zlib/patches/0016-minizip-parse-unicode-path-extra-field.patch b/third_party/zlib/patches/0016-minizip-parse-unicode-path-extra-field.patch
new file mode 100644
index 0000000000000..9a99a8ae027df
--- /dev/null
+++ b/third_party/zlib/patches/0016-minizip-parse-unicode-path-extra-field.patch
@@ -0,0 +1,117 @@
+commit c8834821f452a3d424edd0ed2a1e9ceeda38d0ea
+Author: Alex Danilo <adanilo@chromium.org>
+Date:   Thu May 12 03:29:52 2022 +0000
+
+    Extract: Parse Unicode Path Extra field in minizip
+    
+    Adds parsing of the Info-ZIP Extra field which overrides the
+    file name in the File Header only if the CRC in the extra field
+    is a CRC of the file name in the File Header.
+    
+    See https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
+    section 4.6.9 for reference.
+    
+    Also tidied up some whitespace indent.
+    
+    Bug: 953256, 953599
+    Tests: Manually tested, auto test in follow on CL
+    Change-Id: I1283dcb88a203c3bb56c1d9c504035a2e51aecbd
+    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3641742
+    Reviewed-by: Noel Gordon <noel@chromium.org>
+    Commit-Queue: Alex Danilo <adanilo@chromium.org>
+    Cr-Commit-Position: refs/heads/main@{#1002476}
+
+diff --git a/third_party/zlib/contrib/minizip/unzip.c b/third_party/zlib/contrib/minizip/unzip.c
+index c8a01b23efd42..42677cff82c96 100644
+--- a/third_party/zlib/contrib/minizip/unzip.c
++++ b/third_party/zlib/contrib/minizip/unzip.c
+@@ -193,6 +193,26 @@ typedef struct
+    Reads a long in LSB order from the given gz_stream. Sets
+ */
+ 
++local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def,
++                             voidpf filestream,
++                             int *pi) {
++    unsigned char c;
++    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
++    if (err==1)
++    {
++        *pi = (int)c;
++        return UNZ_OK;
++    }
++    else
++    {
++        *pi = 0;
++        if (ZERROR64(*pzlib_filefunc_def,filestream))
++            return UNZ_ERRNO;
++        else
++            return UNZ_EOF;
++    }
++}
++
+ local int unz64local_getShort(const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                               voidpf filestream,
+                               uLong *pX) {
+@@ -948,6 +968,62 @@ local int unz64local_GetCurrentFileInfoInternal(unzFile file,
+                 }
+ 
+             }
++            else if (headerId == 0x7075) /* Info-ZIP Unicode Path Extra Field */
++            {
++                int version = 0;
++
++                if (unz64local_getByte(&s->z_filefunc, s->filestream, &version) != UNZ_OK)
++                {
++                    err = UNZ_ERRNO;
++                }
++                if (version != 1)
++                {
++                    if (ZSEEK64(s->z_filefunc, s->filestream,dataSize - 1, ZLIB_FILEFUNC_SEEK_CUR) != 0)
++                    {
++                        err = UNZ_ERRNO;
++                    }
++                }
++                else
++                {
++                    uLong uCrc, uHeaderCrc, fileNameSize;
++
++                    if (unz64local_getLong(&s->z_filefunc, s->filestream, &uCrc) != UNZ_OK)
++                    {
++                        err = UNZ_ERRNO;
++                    }
++                    uHeaderCrc = crc32(0, (const unsigned char *)szFileName, file_info.size_filename);
++                    fileNameSize = dataSize - (2 * sizeof (short) + 1);
++                    /* Check CRC against file name in the header. */
++                    if (uHeaderCrc != uCrc)
++                    {
++                        if (ZSEEK64(s->z_filefunc, s->filestream, fileNameSize, ZLIB_FILEFUNC_SEEK_CUR) != 0)
++                        {
++                            err = UNZ_ERRNO;
++                        }
++                    }
++                    else
++                    {
++                        uLong uSizeRead;
++
++                        if (fileNameSize < fileNameBufferSize)
++                        {
++                             *(szFileName + fileNameSize) = '\0';
++                            uSizeRead = fileNameSize;
++                        }
++                        else
++                        {
++                            uSizeRead = fileNameBufferSize;
++                        }
++                        if ((fileNameSize > 0) && (fileNameBufferSize > 0))
++                        {
++                            if (ZREAD64(s->z_filefunc, s->filestream, szFileName, uSizeRead) != uSizeRead)
++                            {
++                                err = UNZ_ERRNO;
++                            }
++                        }
++                    }
++                }
++            }
+             else
+             {
+                 if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)
diff --git a/third_party/zxcvbn-cpp/google.patch b/third_party/zxcvbn-cpp/google.patch
new file mode 100644
index 0000000000000..5c1213439a011
--- /dev/null
+++ b/third_party/zxcvbn-cpp/google.patch
@@ -0,0 +1,2637 @@
+diff --git a/native-src/zxcvbn/adjacency_graphs_js_bindings.cpp b/native-src/zxcvbn/adjacency_graphs_js_bindings.cpp
+deleted file mode 100644
+index 7e1ae34..0000000
+--- a/native-src/zxcvbn/adjacency_graphs_js_bindings.cpp
++++ /dev/null
+@@ -1,49 +0,0 @@
+-#include <zxcvbn/common_js.hpp>
+-
+-#include <zxcvbn/adjacency_graphs.hpp>
+-
+-#include <emscripten/emscripten.h>
+-#include <emscripten/bind.h>
+-
+-namespace zxcvbn_js {
+-
+-emscripten::val qwerty_graph() {
+-  return to_val(zxcvbn::graphs().at(zxcvbn::GraphTag::QWERTY));
+-}
+-
+-emscripten::val dvorak_graph() {
+-  return to_val(zxcvbn::graphs().at(zxcvbn::GraphTag::DVORAK));
+-}
+-
+-emscripten::val keypad_graph() {
+-  return to_val(zxcvbn::graphs().at(zxcvbn::GraphTag::KEYPAD));
+-}
+-
+-emscripten::val mac_keypad_graph() {
+-  return to_val(zxcvbn::graphs().at(zxcvbn::GraphTag::MAC_KEYPAD));
+-}
+-
+-}
+-
+-EMSCRIPTEN_BINDINGS(adjacency_graphs) {
+-  emscripten::function("_qwerty_graph", &zxcvbn_js::qwerty_graph);
+-  emscripten::function("_dvorak_graph", &zxcvbn_js::dvorak_graph);
+-  emscripten::function("_keypad_graph", &zxcvbn_js::keypad_graph);
+-  emscripten::function("_mac_keypad_graph", &zxcvbn_js::mac_keypad_graph);
+-}
+-
+-#ifdef __EMSCRIPTEN__
+-
+-int main() {
+-  // workaround: these values are only guaranteed to exist after init
+-  EM_ASM({
+-      Module["qwerty"] = Module["_qwerty_graph"]();
+-      Module["dvorak"] = Module["_dvorak_graph"]();
+-      Module["keypad"] = Module["_keypad_graph"]();
+-      Module["mac_keypad"] = Module["_mac_keypad_graph"]();
+-    });
+-  emscripten_exit_with_live_runtime();
+-  return 0;
+-}
+-
+-#endif
+diff --git a/native-src/zxcvbn/common.hpp b/native-src/zxcvbn/common.hpp
+index cba756c..1f66367 100644
+--- a/native-src/zxcvbn/common.hpp
++++ b/native-src/zxcvbn/common.hpp
+@@ -1,7 +1,6 @@
+ #ifndef __ZXCVBN__COMMON_HPP
+ #define __ZXCVBN__COMMON_HPP
+ 
+-#include <zxcvbn/zxcvbn.h>
+ #include <zxcvbn/frequency_lists.hpp>
+ #include <zxcvbn/adjacency_graphs.hpp>
+ 
+@@ -12,7 +11,7 @@
+ 
+ namespace zxcvbn {
+ 
+-using guesses_t = zxcvbn_guesses_t;
++using guesses_t = double;
+ using guesses_log10_t = int;
+ using score_t = unsigned;
+ using idx_t = std::string::size_type;
+@@ -35,10 +34,10 @@ enum class RegexTag {
+ };
+ 
+ enum class SequenceTag {
+-  UPPER,
+-  LOWER,
+-  DIGITS,
+-  UNICODE,
++  kUpper,
++  kLower,
++  kDigits,
++  kUnicode,
+ };
+ 
+ struct PortableRegexMatch {
+@@ -67,7 +66,6 @@ enum class MatchPattern {
+ struct DictionaryMatch {
+   static constexpr auto pattern = MatchPattern::DICTIONARY;
+ 
+-  DictionaryTag dictionary_tag;
+   std::string matched_word;
+   rank_t rank;
+   bool l33t;
+diff --git a/native-src/zxcvbn/common_js.hpp b/native-src/zxcvbn/common_js.hpp
+deleted file mode 100644
+index 729cbad..0000000
+--- a/native-src/zxcvbn/common_js.hpp
++++ /dev/null
+@@ -1,515 +0,0 @@
+-#ifndef __ZXCVBN__COMMON_JS_HPP
+-#define __ZXCVBN__COMMON_JS_HPP
+-
+-#include <zxcvbn/common.hpp>
+-#include <zxcvbn/feedback.hpp>
+-
+-#include <zxcvbn/util.hpp>
+-
+-#include <emscripten/bind.h>
+-
+-#include <codecvt>
+-#include <locale>
+-#include <string>
+-#include <vector>
+-#include <unordered_map>
+-
+-namespace zxcvbn_js {
+-
+-template<class T, class M>
+-M _get_member_type(M T::*);
+-
+-// this makes me very sad
+-#define GET_MEMBER_TYPE(f) decltype(_get_member_type(f))
+-
+-template<class T, typename = void>
+-struct val_converter;
+-
+-template<class T>
+-emscripten::val to_val(const T & val) {
+-  return val_converter<T>::to(val);
+-}
+-
+-template<class T>
+-T from_val(const emscripten::val & val) {
+-  return val_converter<T>::from(val);
+-}
+-
+-template<class T>
+-T from_val_with_default(const emscripten::val & val, T def) {
+-  return ((val.isUndefined() || val.isNull())
+-          ? std::move(def)
+-          : val_converter<T>::from(val));
+-}
+-
+-template<class T>
+-struct val_converter<
+-  T, std::enable_if_t<
+-       std::is_same<std::decay_t<T>, void>::value ||
+-       std::is_same<std::decay_t<T>, bool>::value ||
+-       std::is_same<std::decay_t<T>, char>::value ||
+-       std::is_same<std::decay_t<T>, signed char>::value ||
+-       std::is_same<std::decay_t<T>, unsigned char>::value ||
+-       std::is_same<std::decay_t<T>, short>::value ||
+-       std::is_same<std::decay_t<T>, unsigned short>::value ||
+-       std::is_same<std::decay_t<T>, int>::value ||
+-       std::is_same<std::decay_t<T>, unsigned int>::value ||
+-       std::is_same<std::decay_t<T>, long>::value ||
+-       std::is_same<std::decay_t<T>, unsigned long>::value ||
+-       std::is_same<std::decay_t<T>, float>::value ||
+-       std::is_same<std::decay_t<T>, double>::value ||
+-       std::is_same<std::decay_t<T>, std::wstring>::value
+-       >> {
+-  static T from(const emscripten::val & val) {
+-    return val.as<T>();
+-  }
+-  static emscripten::val to(const T & val) {
+-    return emscripten::val(val);
+-  }
+-};
+-
+-
+-inline
+-std::string to_utf8(const std::wstring & elt) {
+-  std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> u8towide;
+-  return u8towide.to_bytes(elt);
+-}
+-
+-inline
+-std::wstring to_wide(const std::string & elt) {
+-  std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> u8towide;
+-  return u8towide.from_bytes(elt);
+-}
+-
+-template<>
+-struct val_converter<std::string> {
+-  static std::string from(const emscripten::val & val) {
+-    return to_utf8(from_val<std::wstring>(val));
+-  }
+-  static emscripten::val to(const std::string & val) {
+-    return to_val(to_wide(val));
+-  }
+-};
+-
+-template<typename T>
+-struct val_converter<std::vector<T>> {
+-  static std::vector<T> from(const emscripten::val & v) {
+-    auto l = v["length"].as<unsigned>();
+-
+-    std::vector<T> rv;
+-    for(unsigned i = 0; i < l; ++i) {
+-      rv.push_back(val_converter<T>::from(v[i]));
+-    }
+-
+-    return rv;
+-  };
+-
+-  static emscripten::val to(const std::vector<T> & v) {
+-    auto result = emscripten::val::array();
+-
+-    std::size_t i = 0;
+-    for (const auto & elt : v) {
+-      result.set(i, val_converter<T>::to(elt));
+-      i += 1;
+-    }
+-    return result;
+-  }
+-};
+-
+-template<class T>
+-struct val_converter<std::unordered_map<std::string, T>> {
+-  static std::unordered_map<std::string, T> from(const emscripten::val & val) {
+-    std::unordered_map<std::string, T> result;
+-    auto keys = emscripten::val::global("Object").call<emscripten::val>("keys", val);
+-    for (auto & str : val_converter<std::vector<std::string>>::from(keys)) {
+-      result.insert(std::make_pair(str, val_converter<T>::from(val[str])));
+-    }
+-    return result;
+-  }
+-  static emscripten::val to(const std::unordered_map<std::string, T> & val) {
+-    auto result = emscripten::val::object();
+-    for (const auto & item : val) {
+-      result.set(item.first, to_val(item.second));
+-    }
+-    return result;
+-  }
+-};
+-
+-template<>
+-struct val_converter<zxcvbn::SequenceTag> {
+-  static zxcvbn::SequenceTag from(const emscripten::val & val) {
+-    auto s = val_converter<std::string>::from(val);
+-    if (s == "upper") return zxcvbn::SequenceTag::UPPER;
+-    else if (s == "lower") return zxcvbn::SequenceTag::LOWER;
+-    else if (s == "digits") return zxcvbn::SequenceTag::DIGITS;
+-    else {
+-      assert(s == "unicode");
+-      return zxcvbn::SequenceTag::UNICODE;
+-    }
+-  }
+-  static emscripten::val to(const zxcvbn::SequenceTag & val) {
+-    std::string s = [&] {
+-      if (val == zxcvbn::SequenceTag::UPPER) return "upper";
+-      else if (val == zxcvbn::SequenceTag::LOWER) return "lower";
+-      else if (val == zxcvbn::SequenceTag::DIGITS) return "digits";
+-      else {
+-        assert(val == zxcvbn::SequenceTag::UNICODE);
+-        return "unicode";
+-      }
+-    }();
+-    return to_val(s);
+-  }
+-};
+-
+-template<>
+-struct val_converter<zxcvbn::RegexTag> {
+-  static zxcvbn::RegexTag from(const emscripten::val & val) {
+-    auto s = val_converter<std::string>::from(val);
+-    if (s == "recent_year") return zxcvbn::RegexTag::RECENT_YEAR;
+-    else if (s == "alpha_lower") return zxcvbn::RegexTag::ALPHA_LOWER;
+-    else {
+-      assert(s == "alphanumeric");
+-      return zxcvbn::RegexTag::ALPHANUMERIC;
+-    }
+-  }
+-  static emscripten::val to(const zxcvbn::RegexTag & val) {
+-    std::string s = [&] {
+-      if (val == zxcvbn::RegexTag::RECENT_YEAR) return "recent_year";
+-      else if (val == zxcvbn::RegexTag::ALPHA_LOWER) return "alpha_lower";
+-      else {
+-        assert(val == zxcvbn::RegexTag::ALPHANUMERIC);
+-        return "alphanumeric";
+-      }
+-    }();
+-    return to_val(s);
+-  }
+-};
+-
+-template<>
+-struct val_converter<zxcvbn::PortableRegexMatch> {
+-  static zxcvbn::PortableRegexMatch from(const emscripten::val & val) {
+-    return {
+-      val_converter<std::vector<std::string>>::from(val),
+-      from_val_with_default<std::size_t>(val["index"], 0),
+-    };
+-  }
+-  static emscripten::val to(const zxcvbn::PortableRegexMatch & val) {
+-    auto result = emscripten::val::array();
+-    std::size_t i = 0;
+-    for (const auto & elt : val.matches) {
+-      result.set(i, to_val(elt));
+-    }
+-    result.set("index", to_val(val.index));
+-    return result;
+-  }
+-};
+-
+-template<class K, class V>
+-std::unordered_map<V, K> invert_dict(const std::unordered_map<K, V> & dict) {
+-  std::unordered_map<V, K> result;
+-  for (const auto & item : dict) {
+-    result.insert(std::make_pair(item.second, item.first));
+-  }
+-  return result;
+-}
+-
+-const auto _default_dict_tag_to_name = std::unordered_map<zxcvbn::DictionaryTag, std::string>{
+-  {zxcvbn::DictionaryTag::PASSWORDS, "passwords"},
+-  {zxcvbn::DictionaryTag::ENGLISH_WIKIPEDIA, "english_wikipedia"},
+-  {zxcvbn::DictionaryTag::FEMALE_NAMES, "female_names"},
+-  {zxcvbn::DictionaryTag::SURNAMES, "surnames"},
+-  {zxcvbn::DictionaryTag::US_TV_AND_FILM, "us_tv_and_film"},
+-  {zxcvbn::DictionaryTag::MALE_NAMES, "male_names"},
+-  {zxcvbn::DictionaryTag::USER_INPUTS, "user_inputs"},
+-};
+-
+-const auto _default_name_to_dict_tag = invert_dict(_default_dict_tag_to_name);
+-
+-const auto _default_graph_tag_to_name = std::unordered_map<zxcvbn::GraphTag, std::string> {
+-  {zxcvbn::GraphTag::QWERTY, "qwerty"},
+-  {zxcvbn::GraphTag::DVORAK, "dvorak"},
+-  {zxcvbn::GraphTag::KEYPAD, "keypad"},
+-  {zxcvbn::GraphTag::MAC_KEYPAD, "mac_keypad"},
+-};
+-
+-const auto _default_name_to_graph_tag = invert_dict(_default_graph_tag_to_name);
+-
+-using DictTagType = std::underlying_type_t<zxcvbn::DictionaryTag>;
+-using GraphTagType = std::underlying_type_t<zxcvbn::GraphTag>;
+-
+-template<>
+-struct val_converter<zxcvbn::Match> {
+-  static zxcvbn::Match from(const emscripten::val & val) {
+-    auto i = from_val_with_default<zxcvbn::idx_t>(val["i"], 0);
+-    auto j = from_val_with_default<zxcvbn::idx_t>(val["j"], 0);
+-    auto token = from_val_with_default<std::string>(val["token"], std::string(j - i + 1, '_'));
+-    auto tlen = zxcvbn::util::character_len(token);
+-    if (tlen != (j - i + 1)) {
+-      j = i + tlen - 1;
+-    }
+-
+-#define MATCH_FN(title, upper, lower) {#lower, zxcvbn::MatchPattern::upper},
+-    const auto _default_name_to_pattern = std::unordered_map<std::string, zxcvbn::MatchPattern>{MATCH_RUN()};
+-#undef MATCH_FN
+-
+-#define PARSE_MEMBER(class_, member) \
+-    from_val<GET_MEMBER_TYPE(&zxcvbn::class_::member)>(val[#member])
+-#define PARSE_MEMBER_DEF(class_, member, def)                           \
+-    from_val_with_default<GET_MEMBER_TYPE(&zxcvbn::class_::member)>(val[#member], def)
+-
+-    auto match = [&] {
+-      auto pattern = [&] {
+-        if (val["pattern"].isUndefined()) {
+-          // NB: object is not tagged with pattern, try inferring from members
+-          if (!val["base_token"].isUndefined()) {
+-            return zxcvbn::MatchPattern::REPEAT;
+-          }
+-          else if (!val["ascending"].isUndefined()) {
+-            return zxcvbn::MatchPattern::SEQUENCE;
+-          }
+-          else if (!val["regex_name"].isUndefined()) {
+-            return zxcvbn::MatchPattern::REGEX;
+-          }
+-          else if (!val["year"].isUndefined()) {
+-            return zxcvbn::MatchPattern::DATE;
+-          }
+-          else if (!val["graph"].isUndefined()) {
+-            return zxcvbn::MatchPattern::SPATIAL;
+-          }
+-          else if (!val["rank"].isUndefined() ||
+-                   !val["l33t"].isUndefined()) {
+-            return zxcvbn::MatchPattern::DICTIONARY;
+-          }
+-          return zxcvbn::MatchPattern::UNKNOWN;
+-        }
+-        auto pattern_str = val_converter<std::string>::from(val["pattern"]);
+-        auto it = _default_name_to_pattern.find(pattern_str);
+-        if (it == _default_name_to_pattern.end()) throw std::runtime_error("invalid match");
+-        return it->second;
+-      }();
+-
+-      switch (pattern) {
+-      case zxcvbn::MatchPattern::DICTIONARY: {
+-        auto dictionary_tag = [&] {
+-          if (val["dictionary_name"].isUndefined()) {
+-            return static_cast<zxcvbn::DictionaryTag>(0);
+-          }
+-          auto dictionary_name = val_converter<std::string>::from(val["dictionary_name"]);
+-
+-          auto it2 = _default_name_to_dict_tag.find(dictionary_name);
+-          if (it2 == _default_name_to_dict_tag.end()) throw std::runtime_error("invalid dictionary");
+-          return it2->second;
+-        }();
+-
+-        auto default_sub = std::unordered_map<std::string, std::string>{};
+-
+-        return zxcvbn::Match(i, j, token, zxcvbn::DictionaryMatch{
+-            dictionary_tag,
+-              PARSE_MEMBER_DEF(DictionaryMatch, matched_word, ""),
+-              PARSE_MEMBER_DEF(DictionaryMatch, rank, 0),
+-              PARSE_MEMBER_DEF(DictionaryMatch, l33t, false),
+-              PARSE_MEMBER_DEF(DictionaryMatch, reversed, false),
+-              PARSE_MEMBER_DEF(DictionaryMatch, sub, default_sub),
+-              PARSE_MEMBER_DEF(DictionaryMatch, sub_display, ""),
+-              });
+-      }
+-      case zxcvbn::MatchPattern::SPATIAL: {
+-        auto graph_name = val_converter<std::string>::from(val["graph"]);
+-        auto it2 = _default_name_to_graph_tag.find(graph_name);
+-        if (it2 == _default_name_to_graph_tag.end()) throw std::runtime_error("bad graph tag!");
+-        auto graph = it2->second;
+-
+-        return zxcvbn::Match(i, j, token, zxcvbn::SpatialMatch{
+-            graph, PARSE_MEMBER(SpatialMatch, turns),
+-            PARSE_MEMBER(SpatialMatch, shifted_count)
+-              });
+-      }
+-      case zxcvbn::MatchPattern::SEQUENCE: {
+-        auto sequence_tag = from_val_with_default<GET_MEMBER_TYPE(&zxcvbn::SequenceMatch::sequence_tag)>(val["sequence_name"], zxcvbn::SequenceTag::UNICODE);
+-        return zxcvbn::Match(i, j, token, zxcvbn::SequenceMatch{
+-            sequence_tag,
+-              PARSE_MEMBER_DEF(SequenceMatch, sequence_space, 0),
+-              PARSE_MEMBER(SequenceMatch, ascending),
+-          });
+-      }
+-      case zxcvbn::MatchPattern::REPEAT: {
+-        return zxcvbn::Match(i, j, token, zxcvbn::RepeatMatch{
+-            PARSE_MEMBER(RepeatMatch, base_token),
+-            PARSE_MEMBER(RepeatMatch, base_guesses),
+-            PARSE_MEMBER_DEF(RepeatMatch, base_matches, std::vector<zxcvbn::Match>{}),
+-            PARSE_MEMBER(RepeatMatch, repeat_count),
+-              });
+-      }
+-      case zxcvbn::MatchPattern::REGEX: {
+-        auto regex_tag = val_converter<GET_MEMBER_TYPE(&zxcvbn::RegexMatch::regex_tag)>::from(val["regex_name"]);
+-        return zxcvbn::Match(i, j, token, zxcvbn::RegexMatch{
+-            regex_tag, PARSE_MEMBER(RegexMatch, regex_match),
+-          });
+-      }
+-      case zxcvbn::MatchPattern::DATE: {
+-        auto separator = from_val_with_default<std::string>(val["separator"], "");
+-        return zxcvbn::Match(i, j, token, zxcvbn::DateMatch{
+-            separator,
+-            PARSE_MEMBER(DateMatch, year),
+-            PARSE_MEMBER(DateMatch, month),
+-            PARSE_MEMBER(DateMatch, day),
+-            PARSE_MEMBER_DEF(DateMatch, has_full_year, 0),
+-          });
+-      }
+-      case zxcvbn::MatchPattern::BRUTEFORCE: {
+-        return zxcvbn::Match(i, j, token, zxcvbn::BruteforceMatch{});
+-      }
+-      default:
+-        assert(pattern == zxcvbn::MatchPattern::UNKNOWN);
+-        return zxcvbn::Match(i, j, token, zxcvbn::UnknownMatch{});
+-      }
+-    }();
+-
+-    match.guesses = from_val_with_default<zxcvbn::guesses_t>(val["guesses"], 0);
+-    match.guesses_log10 = from_val_with_default<zxcvbn::guesses_log10_t>(val["guesses_log10"], 0);
+-    return match;
+-  }
+-
+-  static emscripten::val to(const zxcvbn::Match & val) {
+-    auto result = emscripten::val::object();
+-    result.set("i", to_val(val.i));
+-    result.set("j", to_val(val.j));
+-    if (val.token.size()) {
+-      result.set("token", to_val(val.token));
+-    }
+-    if (val.guesses) {
+-      result.set("guesses", to_val(val.guesses));
+-      result.set("guesses_log10", to_val(std::log10(val.guesses)));
+-    }
+-    switch (val.get_pattern()) {
+-    case zxcvbn::MatchPattern::DICTIONARY: {
+-      auto & dmatch = val.get_dictionary();
+-      result.set("pattern", "dictionary");
+-      result.set("_dictionary_tag", to_val(DictTagType(dmatch.dictionary_tag)));
+-      result.set("matched_word", to_val(dmatch.matched_word));
+-      result.set("rank", to_val(dmatch.rank));
+-      result.set("l33t", to_val(dmatch.l33t));
+-      result.set("reversed", to_val(dmatch.reversed));
+-      result.set("sub", to_val(dmatch.sub));
+-      result.set("sub_display", to_val(dmatch.sub_display));
+-      break;
+-    }
+-    case zxcvbn::MatchPattern::SPATIAL: {
+-      auto & dmatch = val.get_spatial();
+-      result.set("pattern", "spatial");
+-      result.set("_graph", to_val(GraphTagType(dmatch.graph)));
+-      result.set("turns", to_val(dmatch.turns));
+-      result.set("shifted_count", to_val(dmatch.shifted_count));
+-      break;
+-    }
+-    case zxcvbn::MatchPattern::SEQUENCE: {
+-      auto & dmatch = val.get_sequence();
+-      result.set("pattern", "sequence");
+-      result.set("sequence_name", to_val(dmatch.sequence_tag));
+-      result.set("sequence_space", to_val(dmatch.sequence_space));
+-      result.set("ascending", to_val(dmatch.ascending));
+-      break;
+-    }
+-    case zxcvbn::MatchPattern::REPEAT: {
+-      auto & dmatch = val.get_repeat();
+-      result.set("pattern", "repeat");
+-      result.set("base_token", to_val(dmatch.base_token));
+-      result.set("base_guesses", to_val(dmatch.base_guesses));
+-      result.set("base_matches", to_val(dmatch.base_matches));
+-      result.set("repeat_count", to_val(dmatch.repeat_count));
+-      break;
+-    }
+-    case zxcvbn::MatchPattern::REGEX: {
+-      auto & dmatch = val.get_regex();
+-      result.set("pattern", "regex");
+-      result.set("regex_name", to_val(dmatch.regex_tag));
+-      result.set("regex_match", to_val(dmatch.regex_match));
+-      break;
+-    }
+-    case zxcvbn::MatchPattern::DATE: {
+-      auto & dmatch = val.get_date();
+-      result.set("pattern", "date");
+-      result.set("separator", to_val(dmatch.separator));
+-      result.set("year", to_val(dmatch.year));
+-      result.set("month", to_val(dmatch.month));
+-      result.set("day", to_val(dmatch.day));
+-      result.set("has_full_year", to_val(dmatch.has_full_year));
+-      break;
+-    }
+-    case zxcvbn::MatchPattern::BRUTEFORCE: {
+-      result.set("pattern", "bruteforce");
+-      break;
+-    }
+-    case zxcvbn::MatchPattern::UNKNOWN: {
+-      break;
+-    }
+-#ifndef NDEBUG
+-    default:
+-      assert(false);
+-#endif
+-    }
+-    return result;
+-  }
+-};
+-
+-template<class T>
+-struct val_converter<zxcvbn::optional::optional<T>> {
+-  static zxcvbn::optional::optional<T> from(const emscripten::val & val) {
+-    if (val.isNull()) {
+-      return zxcvbn::optional::nullopt;
+-    }
+-    else {
+-      return zxcvbn::optional::make_optional(val_converter<T>::from(val));
+-    }
+-  }
+-  static emscripten::val to(const zxcvbn::optional::optional<T> & val) {
+-    if (!val) {
+-      return emscripten::val::null();
+-    }
+-    else {
+-      return to_val(*val);
+-    }
+-  }
+-};
+-
+-template<>
+-struct val_converter<zxcvbn::Feedback> {
+-  static emscripten::val to(const zxcvbn::Feedback & val) {
+-    auto result = emscripten::val::object();
+-    result.set("warning", to_val(val.warning));
+-    result.set("suggestions", to_val(val.suggestions));
+-    return result;
+-  }
+-};
+-
+-inline
+-void fix_up_dictionary_tags(emscripten::val & result,
+-                            const std::unordered_map<zxcvbn::DictionaryTag, std::string> & _tag_to_name = _default_dict_tag_to_name) {
+-  auto len = result["length"].as<std::size_t>();
+-  for (decltype(len) i = 0; i < len; ++i) {
+-    auto v = result[i];
+-    if (v["_dictionary_tag"].isUndefined()) continue;
+-    auto val = v["_dictionary_tag"].as<DictTagType>();
+-    auto it = _tag_to_name.find(static_cast<zxcvbn::DictionaryTag>(val));
+-    assert(it != _tag_to_name.end());
+-    v.set("dictionary_name", it->second);
+-  }
+-}
+-
+-inline
+-void fix_up_graph_tags(emscripten::val & result,
+-                       const std::unordered_map<zxcvbn::GraphTag, std::string> & _tag_to_name = _default_graph_tag_to_name) {
+-  auto len = result["length"].as<std::size_t>();
+-  for (decltype(len) i = 0; i < len; ++i) {
+-    auto v = result[i];
+-    if (v["_graph"].isUndefined()) continue;
+-    auto val = v["_graph"].as<GraphTagType>();
+-    auto it = _tag_to_name.find(static_cast<zxcvbn::GraphTag>(val));
+-    assert(it != _tag_to_name.end());
+-    v.set("graph", it->second);
+-  }
+-}
+-
+-}
+-
+-#endif
+diff --git a/native-src/zxcvbn/feedback.cpp b/native-src/zxcvbn/feedback.cpp
+deleted file mode 100644
+index d22c296..0000000
+--- a/native-src/zxcvbn/feedback.cpp
++++ /dev/null
+@@ -1,174 +0,0 @@
+-#include <zxcvbn/feedback.hpp>
+-
+-#include <zxcvbn/frequency_lists.hpp>
+-#include <zxcvbn/optional.hpp>
+-#include <zxcvbn/scoring.hpp>
+-#include <zxcvbn/util.hpp>
+-
+-#include <regex>
+-
+-namespace zxcvbn {
+-
+-const Feedback DEFAULT_FEEDBACK = {
+-  "",
+-  {
+-    "Use a few words, avoid common phrases",
+-    "No need for symbols, digits, or uppercase letters",
+-  },
+-};
+-
+-static
+-optional::optional<Feedback> get_match_feedback(const Match & match, bool is_sole_match);
+-
+-static
+-Feedback get_dictionary_match_feedback(const Match & match, bool is_sole_match);
+-
+-Feedback get_feedback(score_t score,
+-                      const std::vector<Match> & sequence) {
+-  // starting feedback
+-  if (!sequence.size()) return DEFAULT_FEEDBACK;
+-
+-  // no feedback if score is good or great.
+-  if (score > 2) return {"", {}};
+-
+-  // tie feedback to the longest match for longer sequences
+-  auto longest_match = sequence.begin();
+-  for (auto match = longest_match + 1; match != sequence.end(); ++match) {
+-    if (match->token.length() > longest_match->token.length()) {
+-      longest_match = match;
+-    }
+-  }
+-
+-  auto maybe_feedback = get_match_feedback(*longest_match, sequence.size() == 1);
+-  auto extra_feedback = "Add another word or two. Uncommon words are better.";
+-  if (maybe_feedback) {
+-    auto & feedback = *maybe_feedback;
+-
+-    feedback.suggestions.insert(maybe_feedback->suggestions.begin(),
+-                                extra_feedback);
+-
+-    return feedback;
+-  }
+-  else {
+-    return {"", {extra_feedback}};
+-  }
+-}
+-
+-optional::optional<Feedback> get_match_feedback(const Match & match_, bool is_sole_match) {
+-  switch (match_.get_pattern()) {
+-  case MatchPattern::DICTIONARY: {
+-    return get_dictionary_match_feedback(match_, is_sole_match);
+-  }
+-
+-  case MatchPattern::SPATIAL: {
+-    auto & match = match_.get_spatial();
+-    auto warning = (match.turns == 1)
+-      ? "Straight rows of keys are easy to guess"
+-      : "Short keyboard patterns are easy to guess";
+-
+-    return Feedback{warning, {
+-        "Use a longer keyboard pattern with more turns",
+-          }};
+-  }
+-
+-  case MatchPattern::REPEAT: {
+-    auto warning = (match_.get_repeat().base_token.length() == 1)
+-      ? "Repeats like \"aaa\" are easy to guess"
+-      : "Repeats like \"abcabcabc\" are only slightly harder to guess than \"abc\"";
+-
+-    return Feedback{warning, {
+-        "Avoid repeated words and characters",
+-          }};
+-  }
+-
+-  case MatchPattern::SEQUENCE: {
+-    return Feedback{"Sequences like abc or 6543 are easy to guess",
+-        {"Avoid sequences"},
+-        };
+-  }
+-
+-  case MatchPattern::REGEX: {
+-    auto & match = match_.get_regex();
+-    if (match.regex_tag == RegexTag::RECENT_YEAR) {
+-      return Feedback{"Recent years are easy to guess", {
+-          "Avoid recent years",
+-          "Avoid years that are associated with you",
+-        }};
+-    }
+-    break;
+-  }
+-
+-  case MatchPattern::DATE: {
+-    return Feedback{"Dates are often easy to guess", {
+-        "Avoid dates and years that are associated with you",
+-      }};
+-  }
+-  default:
+-    break;
+-  }
+-  return optional::nullopt;
+-}
+-
+-static
+-Feedback get_dictionary_match_feedback(const Match & match_, bool is_sole_match) {
+-  assert(match_.get_pattern() == MatchPattern::DICTIONARY);
+-  auto & match = match_.get_dictionary();
+-  auto warning = [&] {
+-    if (match.dictionary_tag == DictionaryTag::PASSWORDS) {
+-      if (is_sole_match and !match.l33t and !match.reversed) {
+-        if (match.rank <= 10) {
+-          return "This is a top-10 common password";
+-        }
+-        else if (match.rank <= 100) {
+-          return "This is a top-100 common password";
+-        }
+-        else {
+-          return "This is a very common password";
+-        }
+-      }
+-      else if (match_.guesses_log10 <= 4) {
+-        return "This is similar to a commonly used password";
+-      }
+-    }
+-    else if (match.dictionary_tag == DictionaryTag::ENGLISH_WIKIPEDIA) {
+-      if (is_sole_match) {
+-        return "A word by itself is easy to guess";
+-      }
+-    }
+-    else if (match.dictionary_tag == DictionaryTag::SURNAMES ||
+-             match.dictionary_tag == DictionaryTag::MALE_NAMES ||
+-             match.dictionary_tag == DictionaryTag::FEMALE_NAMES) {
+-      if (is_sole_match) {
+-        return "Names and surnames by themselves are easy to guess";
+-      }
+-      else {
+-        return "Common names and surnames are easy to guess";
+-      }
+-    }
+-
+-    return "";
+-  }();
+-
+-  std::vector<std::string> suggestions;
+-  auto & word = match_.token;
+-  if (std::regex_search(word, START_UPPER)) {
+-    suggestions.push_back("Capitalization doesn't help very much");
+-  }
+-  else if (std::regex_search(word, ALL_UPPER) and
+-           // XXX: UTF-8
+-           util::ascii_lower(word) == word) {
+-    suggestions.push_back("All-uppercase is almost as easy to guess as all-lowercase");
+-  }
+-
+-  if (match.reversed and match_.token.length() >= 4) {
+-    suggestions.push_back("Reversed words aren't much harder to guess");
+-  }
+-  if (match.l33t) {
+-    suggestions.push_back("Predictable substitutions like '@' instead of 'a' don't help very much");
+-  }
+-
+-  return {warning, suggestions};
+-}
+-
+-}
+-
+diff --git a/native-src/zxcvbn/feedback.hpp b/native-src/zxcvbn/feedback.hpp
+deleted file mode 100644
+index 6f6b62b..0000000
+--- a/native-src/zxcvbn/feedback.hpp
++++ /dev/null
+@@ -1,20 +0,0 @@
+-#ifndef __ZXCVBN__FEEDBACK_HPP
+-#define __ZXCVBN__FEEDBACK_HPP
+-
+-#include <zxcvbn/common.hpp>
+-
+-#include <string>
+-#include <vector>
+-
+-namespace zxcvbn {
+-
+-struct Feedback {
+-  std::string warning;
+-  std::vector<std::string> suggestions;
+-};
+-
+-Feedback get_feedback(score_t score, const std::vector<Match> & sequence);
+-
+-}
+-
+-#endif
+diff --git a/native-src/zxcvbn/frequency_lists.cpp b/native-src/zxcvbn/frequency_lists.cpp
+index 4e4b727..2eb003f 100644
+--- a/native-src/zxcvbn/frequency_lists.cpp
++++ b/native-src/zxcvbn/frequency_lists.cpp
+@@ -1,24 +1,249 @@
+ #include <zxcvbn/frequency_lists.hpp>
+ 
+-#include <zxcvbn/_frequency_lists.hpp>
++#include <algorithm>
++#include <memory>
++#include <utility>
+ 
+-#include <unordered_map>
++#include "base/check.h"
++#include "base/check_op.h"
++#include "base/files/memory_mapped_file.h"
++#include "base/logging.h"
++#include "base/no_destructor.h"
++#include "base/notreached.h"
++#include "base/task/thread_pool.h"
++#include "third_party/abseil-cpp/absl/types/optional.h"
++#include "third_party/abseil-cpp/absl/types/variant.h"
+ 
+ namespace zxcvbn {
+ 
+-RankedDicts convert_to_ranked_dicts(std::unordered_map<DictionaryTag, RankedDict> & ranked_dicts) {
+-  RankedDicts build;
++namespace {
+ 
+-  for (const auto & item : ranked_dicts) {
+-    build.insert(item);
++// A big-endian 16-bit value, consisting of a 15-bit number and a marker bit in
++// the most significant position (in the first byte).
++// No alignment requirements.
++// This is used to store a "rank", which is the position at which a word
++// occurred in a wordlist.
++class MarkedBigEndianU15 {
++ public:
++  static constexpr size_t MAX_VALUE = (1 << 15) - 1;
++  static constexpr uint8_t MARKER_BIT = 0x80;
++  uint16_t get() const {
++    return (encoded_value[0] & ~MARKER_BIT) * 256 + encoded_value[1];
+   }
++  static void AppendToVector(uint16_t value, std::vector<char>& vec) {
++    CHECK(value <= MAX_VALUE);
++    vec.push_back((value >> 8) | MARKER_BIT);
++    vec.push_back(value & 0xff);
++  }
++  // Check whether the given byte has the high bit set.
++  // This always returns true for the first byte of a MarkedBigEndianU15, but
++  // may also be false-positive for the second byte.
++  // To reliably determine whether a given byte really is the start of a
++  // MarkedBigEndianU15, you need to also check the preceding byte if this
++  // returns true.
++  static bool IsPossibleMarkerByte(uint8_t c) { return (c & MARKER_BIT) != 0; }
++
++ private:
++  uint8_t encoded_value[2];
++};
++static_assert(
++    sizeof(MarkedBigEndianU15) == 2,
++    "object layout must fit with assumptions in the rest of this file");
++
++struct MergedEntry {
++  size_t rank;
++  std::string_view value;
++};
++
++// A reference to an entry inside a dictionary.
++// The entry consists of a MarkedBigEndianU15 representing the word's rank
++// (the position at which the word appears in the original wordlist) and an
++// inline string (ASCII, terminated with a byte that has the MARKER_BIT set)
++// that stores the actual word.
++class RankedDictEntryRef {
++ public:
++  explicit RankedDictEntryRef(const RankedDicts::Datawrapper& wrapper,
++                              size_t offset) {
++    size_t size = wrapper.size();
++    const char* data = wrapper.data();
++
++    CHECK_LT(offset + sizeof(MarkedBigEndianU15), size);
++    const char* raw_rank = data + offset;
++    rank_ = reinterpret_cast<const MarkedBigEndianU15*>(raw_rank)->get();
++
++    size_t value_start = offset + sizeof(MarkedBigEndianU15);
++    size_t value_end = value_start;
++    while (true) {
++      CHECK_LT(value_end, size);
++      if (MarkedBigEndianU15::IsPossibleMarkerByte(data[value_end])) {
++        break;
++      }
++      value_end++;
++    }
++    value_ = std::string_view(data + value_start, value_end - value_start);
++  }
++  RankedDictEntryRef(RankedDictEntryRef&) = delete;
++  RankedDictEntryRef& operator=(const RankedDictEntryRef&) = delete;
++
++  uint16_t rank() const { return rank_; }
++  std::string_view value() const { return value_; }
++
++  static void AppendToVector(MergedEntry entry, std::vector<char>& vec) {
++    if (entry.rank > MarkedBigEndianU15::MAX_VALUE) {
++      LOG(ERROR) << "MarkedBigEndianU15 clamping";
++      entry.rank = MarkedBigEndianU15::MAX_VALUE;
++    }
++    MarkedBigEndianU15::AppendToVector(entry.rank, vec);
++    vec.insert(vec.end(), entry.value.begin(), entry.value.end());
++  }
++
++ private:
++  size_t rank_;
++  std::string_view value_;
++};
++
++// Helper function that does nothing with the RankedDicts apart from letting
++// it destruct as it goes out of scope. This is called on the ThreadPool to
++// allow for potentially blocking behavior of `RankedDicts` destructor.
++void DoNothing(RankedDicts dicts) {}
++
++}  // namespace
++
++RankedDicts::Datawrapper::Datawrapper(std::vector<char> data)
++    : size_(data.size()), data_(data.data()), content_(std::move(data)) {}
++
++RankedDicts::Datawrapper::Datawrapper(
++    std::unique_ptr<base::MemoryMappedFile> map)
++    : size_((map && map->IsValid()) ? map->length() : 0u),
++      data_(map && map->IsValid() ? reinterpret_cast<const char*>(map->data())
++                                  : nullptr),
++      content_(std::move(map)) {}
++
++RankedDicts::RankedDicts(
++    const std::vector<std::vector<std::string_view>>& ordered_dicts) {
++  std::vector<MergedEntry> merged_dicts;
++  for (const std::vector<std::string_view>& strings : ordered_dicts) {
++    size_t rank = 1;
++    for (const std::string_view& s : strings) {
++      for (char c : s) {
++        if (MarkedBigEndianU15::IsPossibleMarkerByte(c)) {
++          NOTREACHED() << "RankedDicts bad character "
++                       << static_cast<unsigned char>(c);
++        }
++      }
+       merged_dicts.push_back({rank++, s});
++    }
++  }
++  std::sort(merged_dicts.begin(), merged_dicts.end(),
++            [](MergedEntry& a, MergedEntry& b) { return a.value < b.value; });
+ 
+-  return build;
++  if (merged_dicts.size() == 0)
++    return;
++
++  // first pass: calculate required total size
++  size_t dict_size = sizeof(MarkedBigEndianU15) * merged_dicts.size();
++  for (MergedEntry& entry : merged_dicts)
++    dict_size += entry.value.size();
++
++  // 1 byte at the end for trailing marker byte (for finding last string size)
++  std::vector<char> vec;
++  vec.reserve(dict_size + 1);
++
++  // second pass: place elements in allocated array
++  for (MergedEntry& entry : merged_dicts)
++    RankedDictEntryRef::AppendToVector(entry, vec);
++  CHECK_EQ(vec.size(), dict_size);
++  vec.push_back(MarkedBigEndianU15::MARKER_BIT);
++  data_ = Datawrapper(std::move(vec));
++}
++
++RankedDicts::RankedDicts(std::unique_ptr<base::MemoryMappedFile> map)
++    : data_(std::move(map)) {}
++
++// Performs a binary search over an array of variable-size elements.
++// To find an element in the middle between two others, we first locate the
++// *byte* in the middle, then seek forward until we hit a marker byte that
++// will only appear at the start of an allocation.
++absl::optional<rank_t> RankedDicts::Find(std::string_view needle) const {
++  // Special case for empty dictionary.
++  size_t size = data_.size();
++  if (size == 0) {
++    return absl::nullopt;
++  }
++  CHECK_GE(size, 3u);  // 2 bytes header, 1 byte trailing marker
++
++  // Create a range whose start and end point to marker bytes.
++  size_t range_start = 0;
++  size_t range_last = size - 2u;
++  CHECK(IsRealMarker(0));
++  while (!IsRealMarker(range_last))
++    range_last--;
++
++  while (true) {
++    size_t midpoint = range_start + (range_last - range_start) / 2;
++    // Find a marker byte from the midpoint onwards. (There must be one, since
++    // there is one at range_last.)
++    size_t adjusted_midpoint = midpoint;
++    while (!IsRealMarker(adjusted_midpoint))
++      adjusted_midpoint++;
++
++    // Perform the actual comparison.
++    RankedDictEntryRef mid_entry(data_, adjusted_midpoint);
++    std::string_view mid_value = mid_entry.value();
++    int cmp_result = mid_value.compare(needle);
++    if (cmp_result == 0)
++      return mid_entry.rank();
++    if (cmp_result < 0) {
++      if (adjusted_midpoint == range_last)
++        return absl::nullopt;
++      range_start = adjusted_midpoint + 1;
++      while (!IsRealMarker(range_start))
++        range_start++;
++    } else {
++      if (adjusted_midpoint == range_start)
++        return absl::nullopt;
++      range_last = adjusted_midpoint - 1;
++      while (!IsRealMarker(range_last))
++        range_last--;
++    }
++  }
++}
++
++// Determine whether an entry starts at the given offset; in other words,
++// determine whether a MarkedBigEndianU15 starts there.
++bool RankedDicts::IsRealMarker(size_t offset) const {
++  CHECK_LT(offset, data_.size());
++  const char* data = data_.data();
++  if (MarkedBigEndianU15::IsPossibleMarkerByte(data[offset])) {
++    if (offset == 0)
++      return true;
++    if (!MarkedBigEndianU15::IsPossibleMarkerByte(data[offset - 1])) {
++      return true;
++    }
++  }
++  return false;
+ }
+ 
+-RankedDicts default_ranked_dicts() {
+-  return convert_to_ranked_dicts(_frequency_lists::get_default_ranked_dicts());
++void SetRankedDictsImplementation(RankedDicts dicts) {
++  default_ranked_dicts() = std::move(dicts);
+ }
+ 
++void SetRankedDicts(RankedDicts dicts) {
++  // Destroying a `RankedDict` may block if it is based on a `MemoryMappedFile`.
++  // Therefore this helper moves the task of doing it to a thread pool.
++  base::ThreadPool::PostTask(
++      FROM_HERE, {base::MayBlock(), base::TaskPriority::BEST_EFFORT},
++      base::BindOnce(&DoNothing, std::move(default_ranked_dicts())));
++  default_ranked_dicts() = std::move(dicts);
++}
+ 
++RankedDicts& default_ranked_dicts() {
++  static base::NoDestructor<RankedDicts> default_dicts;
++  return *default_dicts;
+ }
++
++}  // namespace zxcvbn
+diff --git a/native-src/zxcvbn/frequency_lists.hpp b/native-src/zxcvbn/frequency_lists.hpp
+index c75ea30..fed3aaa 100644
+--- a/native-src/zxcvbn/frequency_lists.hpp
++++ b/native-src/zxcvbn/frequency_lists.hpp
+@@ -1,37 +1,85 @@
+ #ifndef __ZXCVBN__FREQUENCY_LISTS_HPP
+ #define __ZXCVBN__FREQUENCY_LISTS_HPP
+ 
+-#include <zxcvbn/frequency_lists_common.hpp>
+-#include <zxcvbn/_frequency_lists.hpp>
+-
+-#include <unordered_map>
+-
+ #include <cstdint>
++#include <memory>
++#include <string_view>
++#include <vector>
++
++#include "base/files/memory_mapped_file.h"
++#include "third_party/abseil-cpp/absl/types/optional.h"
++#include "third_party/abseil-cpp/absl/types/variant.h"
+ 
+ namespace zxcvbn {
+ 
+-using DictionaryTag = _frequency_lists::DictionaryTag;
++using rank_t = std::size_t;
++
++// Stores words from a set of dictionaries (originally ordered by word
++// frequency) in a sorted flat array.
++// Lookups run in roughly logarithmic time and, when a match is found, return
++// the position of the word in the original dictionary.
++// This data structure is optimized for memory efficiency over lookup speed.
++// It does not contain any pointers and its format is target-independent, so it
++// could theoretically directly be mapped from disk.
++//
++// Since this data structure sorts words alphabetically, the lookup code could
++// be extended to also answer the question "are there any entries that start
++// with the given prefix", which should permit speeding up dictionary_match().
++// That isn't implemented yet though.
++class RankedDicts {
++ public:
++  // Abstraction layer for the binary blob of data that contains the contents
++  // of the `RankedDicts`. The data can either be held directly in memory or
++  // be obtained from a memory mapped file.
++  // See `RankedDictEntryRef` and the rest of frequency_lists.cpp for
++  // documentation of the data structure.
++  class Datawrapper {
++   public:
++    explicit Datawrapper(std::vector<char> data);
++    explicit Datawrapper(std::unique_ptr<base::MemoryMappedFile> map);
++    Datawrapper() = default;
++    Datawrapper(Datawrapper&&) = default;
++
++    Datawrapper& operator=(Datawrapper&&) = default;
++
++    size_t size() const { return size_; }
++    // Returns a pointer to the data chunk belonging to the buffer. Returns a
++    // non-null value only if `size()` is non-zero.
++    const char* data() const { return data_; }
+ 
+-}
++   private:
++    size_t size_ = 0u;
++    const char* data_ = nullptr;
++    absl::variant<std::vector<char>, std::unique_ptr<base::MemoryMappedFile>>
++        content_;
++  };
+ 
+-namespace std {
++  explicit RankedDicts(
++      const std::vector<std::vector<std::string_view>>& ordered_dicts);
++  explicit RankedDicts(std::unique_ptr<base::MemoryMappedFile>);
++  RankedDicts() = default;
++  RankedDicts(RankedDicts&&) = default;
++  RankedDicts(const RankedDicts&) = delete;
+ 
+-template<>
+-struct hash<zxcvbn::DictionaryTag> {
+-  std::size_t operator()(const zxcvbn::DictionaryTag & v) const {
+-    return static_cast<std::size_t>(v);
++  RankedDicts& operator=(RankedDicts&&) = default;
++  RankedDicts& operator=(const RankedDicts&) = delete;
++
++  absl::optional<rank_t> Find(std::string_view needle) const;
++
++  std::string_view DataForTesting() const {
++    return std::string_view(data_.data(), data_.size());
+   }
+-};
+ 
+-}
++ private:
++  bool IsRealMarker(size_t offset) const;
+ 
+-namespace zxcvbn {
++  Datawrapper data_;
++};
+ 
+-using RankedDicts = std::unordered_map<DictionaryTag, const RankedDict &>;
++void SetRankedDicts(RankedDicts dicts);
+ 
+-RankedDicts convert_to_ranked_dicts(std::unordered_map<DictionaryTag, RankedDict> & ranked_dicts);
+-RankedDicts default_ranked_dicts();
++RankedDicts& default_ranked_dicts();
+ 
+-}
++} // namespace zxcvbn
+ 
+ #endif
+diff --git a/native-src/zxcvbn/frequency_lists_common.hpp b/native-src/zxcvbn/frequency_lists_common.hpp
+deleted file mode 100644
+index 40eee25..0000000
+--- a/native-src/zxcvbn/frequency_lists_common.hpp
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#ifndef __ZXCVBN__FREQUENCY_LISTS_COMMON_HPP
+-#define __ZXCVBN__FREQUENCY_LISTS_COMMON_HPP
+-
+-#include <string>
+-#include <unordered_map>
+-#include <utility>
+-
+-#include <cstdint>
+-
+-namespace zxcvbn {
+-
+-using rank_t = std::size_t;
+-using RankedDict = std::unordered_map<std::string, rank_t>;
+-
+-template<class T>
+-RankedDict build_ranked_dict(const T & ordered_list) {
+-  RankedDict result;
+-  rank_t idx = 1; // rank starts at 1, not 0
+-  for (const auto & word : ordered_list) {
+-    result.insert(std::make_pair(word, idx));
+-    idx += 1;
+-  }
+-  return result;
+-}
+-
+-}
+-
+-#endif
+diff --git a/native-src/zxcvbn/js_frequency_lists.cpp b/native-src/zxcvbn/js_frequency_lists.cpp
+deleted file mode 100644
+index 510ba3f..0000000
+--- a/native-src/zxcvbn/js_frequency_lists.cpp
++++ /dev/null
+@@ -1,65 +0,0 @@
+-#include <zxcvbn/_frequency_lists.hpp>
+-#include <zxcvbn/common_js.hpp>
+-
+-#include <emscripten/val.h>
+-#include <emscripten/emscripten.h>
+-
+-namespace zxcvbn {
+-
+-namespace _frequency_lists {
+-
+-static
+-std::vector<std::string> js_keys(const emscripten::val & val) {
+-  return zxcvbn_js::from_val<std::vector<std::string>>(emscripten::val::global("Object").call<emscripten::val>("keys", val));
+-}
+-
+-static
+-std::unordered_map<DictionaryTag, RankedDict> build_static_ranked_dicts() {
+-  auto result = std::unordered_map<DictionaryTag, RankedDict>();
+-
+-  auto js_frequency_list = emscripten::val::module_property("_frequency_lists");
+-
+-  assert(!js_frequency_list.isUndefined());
+-
+-  for (const auto & key : js_keys(js_frequency_list)) {
+-    RankedDict toadd;
+-    auto array = js_frequency_list[key];
+-    auto len = zxcvbn_js::from_val<std::size_t>(array["length"]);
+-    for (decltype(len) i = 0; i < len; ++i) {
+-      toadd.insert(std::make_pair(zxcvbn_js::from_val<std::string>(array[i]), i + 1));
+-    }
+-
+-    result.insert(std::make_pair(zxcvbn_js::_default_name_to_dict_tag.at(key),
+-                                 std::move(toadd)));
+-  }
+-
+-  return result;
+-}
+-
+-// Init _ranked_dicts in emscripten preMain() because it must
+-// happen after emscripten::val is initialized
+-static std::unordered_map<DictionaryTag, RankedDict> _ranked_dicts;
+-
+-extern "C"
+-int init_ranked_dicts() {
+-  _frequency_lists::_ranked_dicts = _frequency_lists::build_static_ranked_dicts();
+-  return 0;
+-}
+-
+-static
+-int schedule_build() {
+-  EM_ASM_INT({
+-      Module["addOnPreMain"](function () {Module["dynCall_i"]($0)});
+-    }, &init_ranked_dicts);
+-  return 0;
+-}
+-
+-extern const auto _schedule_built = schedule_build();
+-
+-std::unordered_map<DictionaryTag, RankedDict> & get_default_ranked_dicts() {
+-  return _ranked_dicts;
+-}
+-
+-}
+-
+-}
+diff --git a/native-src/zxcvbn/matching.cpp b/native-src/zxcvbn/matching.cpp
+index 6d53664..e247818 100644
+--- a/native-src/zxcvbn/matching.cpp
++++ b/native-src/zxcvbn/matching.cpp
+@@ -19,28 +19,44 @@
+ #include <utility>
+ #include <unordered_set>
+ 
++#include "base/no_destructor.h"
++#include "base/strings/string_util.h"
++#include "third_party/icu/source/common/unicode/unistr.h"
++#include "third_party/icu/source/i18n/unicode/regex.h"
++
+ namespace zxcvbn {
+ 
+ // TODO: make this a constexpr
+-extern const std::vector<std::pair<std::string, std::vector<std::string>>> L33T_TABLE = {
+-  {"a", {"4", "@"}},
+-  {"b", {"8"}},
+-  {"c", {"(", "{", "[", "<"}},
+-  {"e", {"3"}},
+-  {"g", {"6", "9"}},
+-  {"i", {"1", "!", "|"}},
+-  {"l", {"1", "|", "7"}},
+-  {"o", {"0"}},
+-  {"s", {"$", "5"}},
+-  {"t", {"+", "7"}},
+-  {"x", {"%"}},
+-  {"z", {"2"}},
+-};
++const std::vector<std::pair<std::string, std::vector<std::string>>>&
++L33T_TABLE() {
++  static base::NoDestructor<
++      std::vector<std::pair<std::string, std::vector<std::string>>>>
++      leet_table({
++          {"a", {"4", "@"}},
++          {"b", {"8"}},
++          {"c", {"(", "{", "[", "<"}},
++          {"e", {"3"}},
++          {"g", {"6", "9"}},
++          {"i", {"1", "!", "|"}},
++          {"l", {"1", "|", "7"}},
++          {"o", {"0"}},
++          {"s", {"$", "5"}},
++          {"t", {"+", "7"}},
++          {"x", {"%"}},
++          {"z", {"2"}},
++      });
++
++  return *leet_table;
++}
+ 
+ // TODO: make this constexpr
+-extern const std::vector<std::pair<RegexTag, std::regex>> REGEXEN = {
+-  {RegexTag::RECENT_YEAR, std::regex(R"(19\d\d|200\d|201\d)")},
+-};
++const std::vector<std::pair<RegexTag, std::regex>>& REGEXEN() {
++  static base::NoDestructor<std::vector<std::pair<RegexTag, std::regex>>>
++      regexen({
++          {RegexTag::RECENT_YEAR, std::regex(R"(19\d\d|200\d|201\d)")},
++      });
++  return *regexen;
++}
+ 
+ const auto DATE_MAX_YEAR = 2050;
+ const auto DATE_MIN_YEAR = 1000;
+@@ -106,28 +122,22 @@ std::string dict_normalize(const std::string & str) {
+   return util::ascii_lower(str);
+ }
+ 
+-std::vector<Match> omnimatch(const std::string & password,
+-                             const std::vector<std::string> & ordered_list) {
+-  auto ranked_dictionaries = default_ranked_dicts();
+-
+-  auto ranked_dict = build_ranked_dict(ordered_list);
+-  ranked_dictionaries.insert(std::make_pair(DictionaryTag::USER_INPUTS,
+-                                            std::cref(ranked_dict)));
++std::vector<Match> omnimatch(const std::string& password) {
++  RankedDicts& ranked_dictionaries = default_ranked_dicts();
+ 
+   std::vector<Match> matches;
+-  std::function<std::vector<Match>(const std::string &)> matchers[] = {
+-    std::bind(dictionary_match, std::placeholders::_1,
+-              std::cref(ranked_dictionaries)),
+-    std::bind(reverse_dictionary_match, std::placeholders::_1,
+-              std::cref(ranked_dictionaries)),
+-    std::bind(l33t_match, std::placeholders::_1,
+-              std::cref(ranked_dictionaries), std::cref(L33T_TABLE)),
+-    std::bind(spatial_match, std::placeholders::_1,
+-              std::cref(graphs())),
+-    repeat_match,
+-    sequence_match,
+-    std::bind(regex_match, std::placeholders::_1, std::cref(REGEXEN)),
+-    date_match,
++  std::function<std::vector<Match>(const std::string&)> matchers[] = {
++      std::bind(dictionary_match, std::placeholders::_1,
++                std::cref(ranked_dictionaries)),
++      std::bind(reverse_dictionary_match, std::placeholders::_1,
++                std::cref(ranked_dictionaries)),
++      std::bind(l33t_match, std::placeholders::_1,
++                std::cref(ranked_dictionaries), std::cref(L33T_TABLE())),
++      std::bind(spatial_match, std::placeholders::_1, std::cref(graphs())),
++      repeat_match,
++      sequence_match,
++      std::bind(regex_match, std::placeholders::_1, std::cref(REGEXEN())),
++      date_match,
+   };
+   for (const auto & matcher : matchers) {
+     auto ret = matcher(password);
+@@ -143,29 +153,22 @@ std::vector<Match> omnimatch(const std::string & password,
+ std::vector<Match> dictionary_match(const std::string & password,
+                                     const RankedDicts & ranked_dictionaries) {
+   std::vector<Match> matches;
+-  auto len = password.length();
+-  auto password_lower = dict_normalize(password);
+-  for (const auto & item : ranked_dictionaries) {
+-    auto dictionary_tag = item.first;
+-    auto & ranked_dict = item.second;
+-    for (decltype(len) i = 0, idx = 0; idx < len; util::utf8_decode(password, idx), ++i) {
+-      for (decltype(len) j = i, jdx = idx; jdx < len; ++j) {
+-        // j is inclusive, but jdx is not so eagerly iterate jdx
+-        util::utf8_decode(password, jdx);
+-
+-        auto word = password_lower.substr(idx, jdx - idx);
+-        auto it = ranked_dict.find(word);
+-        if (it != ranked_dict.end()) {
+-          auto rank = it->second;
+-          matches.push_back(Match(i, j, password.substr(idx, jdx - idx),
+-                                  DictionaryMatch{
+-                                      dictionary_tag,
+-                                      word, rank,
+-                                      false,
+-                                      false, {}, ""}));
+-          matches.back().idx = idx;
+-          matches.back().jdx = jdx;
+-        }
++  size_t len = password.length();
++  std::string password_lower = dict_normalize(password);
++  for (size_t i = 0, idx = 0; idx < len;
++       util::utf8_decode(password, idx), ++i) {
++    for (size_t j = i, jdx = idx; jdx < len; ++j) {
++      // j is inclusive, but jdx is not so eagerly iterate jdx
++      util::utf8_decode(password, jdx);
++
++      std::string word = password_lower.substr(idx, jdx - idx);
++      absl::optional<rank_t> result = ranked_dictionaries.Find(word);
++      if (result.has_value()) {
++        rank_t rank = *result;
++        matches.emplace_back(i, j, password.substr(idx, jdx - idx),
++                             DictionaryMatch{word, rank, false, false, {}, ""});
++        matches.back().idx = idx;
++        matches.back().jdx = jdx;
+       }
+     }
+   }
+@@ -344,12 +347,13 @@ std::vector<Match> spatial_match(const std::string & password,
+   return matches;
+ }
+ 
+-const auto SHIFTED_RX = std::regex("[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]");
+-
+ static
+ std::vector<Match> spatial_match_helper(const std::string & password,
+                                         const Graph & graph,
+                                         GraphTag graph_tag) {
++  const auto SHIFTED_RX =
++      std::regex("[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]");
++
+   std::vector<Match> matches;
+   if (!password.length()) return matches;
+   idx_t idx = 0;
+@@ -381,7 +385,7 @@ std::vector<Match> spatial_match_helper(const std::string & password,
+         if (it != graph.end()) {
+           return it->second;
+         }
+-        return std::vector<optional::optional<std::string>>();
++        return Graph::mapped_type();
+       }();
+       // consider growing pattern by one character if j hasn't gone over the edge.
+       if (j < clen) {
+@@ -390,10 +394,10 @@ std::vector<Match> spatial_match_helper(const std::string & password,
+         auto cur_char = password.substr(jdx, next_jdx - jdx);
+         for (auto & adj : adjacents) {
+           cur_direction += 1;
+-          if (adj && adj->find(cur_char) != adj->npos) {
++          if (adj.find(cur_char) != adj.npos) {
+             found = true;
+             found_direction = cur_direction;
+-            if (adj->find(cur_char) == 1) {
++            if (adj.find(cur_char) == 1) {
+               // index 1 in the adjacency means the key is shifted,
+               // 0 means unshifted: A vs a, % vs 5, etc.
+               // for example, 'q' is adjacent to the entry '2@'.
+@@ -440,69 +444,90 @@ std::vector<Match> spatial_match_helper(const std::string & password,
+ // repeats (aaa, abcabcabc) and sequences (abcdef) ------------------------------
+ //-------------------------------------------------------------------------------
+ 
+-std::vector<Match> repeat_match(const std::string & password) {
++std::vector<Match> repeat_match(const std::string& password) {
+   std::vector<Match> matches;
+-  std::regex greedy(R"((.+)\1+)");
+-  std::regex lazy(R"((.+?)\1+)");
+-  std::regex lazy_anchored(R"(^(.+?)\1+$)");
+-  idx_t lastIndex = 0;
++
++  auto unicode_password = icu::UnicodeString::fromUTF8(password);
++
++  UErrorCode status = U_ZERO_ERROR;
++  std::unique_ptr<icu::RegexPattern> greedy_pattern(icu::RegexPattern::compile(
++      icu::UnicodeString::fromUTF8(R"((.+)\1+)"), 0, status));
++  std::unique_ptr<icu::RegexMatcher> greedy_matcher(
++      greedy_pattern->matcher(unicode_password, status));
++
++  std::unique_ptr<icu::RegexPattern> lazy_pattern(icu::RegexPattern::compile(
++      icu::UnicodeString::fromUTF8(R"((.+?)\1+)"), 0, status));
++  std::unique_ptr<icu::RegexMatcher> lazy_matcher(
++      lazy_pattern->matcher(unicode_password, status));
++
++  std::unique_ptr<icu::RegexPattern> lazy_anchored_pattern(
++      icu::RegexPattern::compile(icu::UnicodeString::fromUTF8(R"(^(.+?)\1+$)"),
++                                 0, status));
++
++  int lastUnicodeIndex = 0;
++  size_t lastIndex = 0;
+   while (lastIndex < password.length()) {
+-    auto start_iter = lastIndex + password.begin();
+-    std::smatch greedy_match, lazy_match;
+-    std::regex_search(start_iter, password.end(),
+-                      greedy_match, greedy);
+-    std::regex_search(start_iter, password.end(),
+-                      lazy_match, lazy);
+-    if (!greedy_match.size()) break;
+-    std::smatch match;
+-    std::string base_token;
+-    if (greedy_match[0].length() > lazy_match[0].length()) {
++    if (!greedy_matcher->find(lastUnicodeIndex, status) ||
++        !lazy_matcher->find(lastUnicodeIndex, status)) {
++      break;
++    }
++
++    icu::RegexMatcher* matcher = nullptr;
++    icu::UnicodeString base_token;
++    if (greedy_matcher->group(status).length() >
++        lazy_matcher->group(status).length()) {
+       // greedy beats lazy for 'aabaab'
+       //   greedy: [aabaab, aab]
+       //   lazy:   [aa,     a]
+-      match = greedy_match;
++      matcher = greedy_matcher.get();
+       // greedy's repeated string might itself be repeated, eg.
+       // aabaab in aabaabaabaab.
+       // run an anchored lazy match on greedy's repeated string
+       // to find the shortest repeated string
+-      std::smatch lazy_anchored_match;
+-      auto greedy_found = match.str(0);
+-      auto ret = std::regex_search(greedy_found, lazy_anchored_match, lazy_anchored);
++      auto greedy_found = matcher->group(status);
++
++      std::unique_ptr<icu::RegexMatcher> lazy_anchored_matcher(
++          lazy_anchored_pattern->matcher(greedy_found, status));
++      auto ret = lazy_anchored_matcher->find(status);
+       assert(ret);
+       (void) ret;
+-      base_token = lazy_anchored_match.str(1);
+-    }
+-    else {
++      base_token = lazy_anchored_matcher->group(1, status);
++    } else {
+       // lazy beats greedy for 'aaaaa'
+       //   greedy: [aaaa,  aa]
+       //   lazy:   [aaaaa, a]
+-      match = std::move(lazy_match);
+-      base_token = match.str(1);
++      matcher = lazy_matcher.get();
++      base_token = matcher->group(1, status);
+     }
+-    auto idx = lastIndex + match.position();
+-    auto jdx = lastIndex + match.position() + match[0].length();
++
++    std::string matched_string;
++    matcher->group(status).toUTF8String(matched_string);
++
++    auto idx = password.find(matched_string, lastIndex);
++    auto jdx = idx + matched_string.size();
++
+     auto i = util::character_len(password, 0, idx);
+     auto j = i + util::character_len(password, idx, jdx) - 1;
+     // recursively match and score the base string
+-    auto sub_matches = omnimatch(base_token);
+-    auto base_analysis = most_guessable_match_sequence(
+-      base_token,
+-      sub_matches,
+-      false
+-      );
++    std::string base_string;
++    base_token.toUTF8String(base_string);
++    auto sub_matches = omnimatch(base_string);
++    auto base_analysis =
++        most_guessable_match_sequence(base_string, sub_matches, false);
+     std::vector<Match> base_matches;
+     std::move(base_analysis.sequence.begin(), base_analysis.sequence.end(),
+               std::back_inserter(base_matches));
+-    auto & base_guesses = base_analysis.guesses;
+-    matches.push_back(Match(i, j, match.str(0),
++    auto& base_guesses = base_analysis.guesses;
++    matches.push_back(Match(i, j, matched_string,
+                             RepeatMatch{
+-                              base_token,
++                                base_string,
+                                 base_guesses,
+                                 std::move(base_matches),
+-                                match[0].length() / base_token.length(),
+-                                }));
++                                matched_string.size() / base_string.size(),
++                            }));
+     matches.back().idx = idx;
+     matches.back().jdx = jdx;
++    lastUnicodeIndex = matcher->end(status);
+     lastIndex = jdx;
+   }
+   return matches;
+@@ -536,19 +561,19 @@ std::vector<Match> sequence_match(const std::string & password) {
+         SequenceTag sequence_name;
+         unsigned sequence_space;
+         if (std::regex_search(token, std::regex(R"(^[a-z]+$)"))) {
+-          sequence_name = SequenceTag::LOWER;
++          sequence_name = SequenceTag::kLower;
+           sequence_space = 26;
+         }
+         else if (std::regex_search(token, std::regex(R"(^[A-Z]+$)"))) {
+-          sequence_name = SequenceTag::UPPER;
++          sequence_name = SequenceTag::kUpper;
+           sequence_space = 26;
+         }
+         else if (std::regex_search(token, std::regex(R"(^\d+$)"))) {
+-          sequence_name = SequenceTag::DIGITS;
++          sequence_name = SequenceTag::kDigits;
+           sequence_space = 10;
+         }
+         else {
+-          sequence_name = SequenceTag::UNICODE;
++          sequence_name = SequenceTag::kUnicode;
+           sequence_space = 26;
+         }
+         result.push_back(Match(i, j, token,
+diff --git a/native-src/zxcvbn/matching.hpp b/native-src/zxcvbn/matching.hpp
+index 7ded5d8..4486038 100644
+--- a/native-src/zxcvbn/matching.hpp
++++ b/native-src/zxcvbn/matching.hpp
+@@ -10,8 +10,8 @@
+ 
+ namespace zxcvbn {
+ 
+-extern const std::vector<std::pair<std::string, std::vector<std::string>>> L33T_TABLE;
+-extern const std::vector<std::pair<RegexTag, std::regex>> REGEXEN;
++const std::vector<std::pair<std::string, std::vector<std::string>>>& L33T_TABLE();
++const std::vector<std::pair<RegexTag, std::regex>>& REGEXEN();
+ 
+ std::vector<Match> dictionary_match(const std::string & password,
+                                     const RankedDicts & ranked_dictionaries);
+@@ -39,8 +39,7 @@ std::vector<Match> regex_match(const std::string & password,
+ 
+ std::vector<Match> date_match(const std::string & password);
+ 
+-std::vector<Match> omnimatch(const std::string & password,
+-                             const std::vector<std::string> & ordered_list = {});
++std::vector<Match> omnimatch(const std::string & password);
+ 
+ }
+ 
+diff --git a/native-src/zxcvbn/matching_js_bindings.cpp b/native-src/zxcvbn/matching_js_bindings.cpp
+deleted file mode 100644
+index 1dfcb53..0000000
+--- a/native-src/zxcvbn/matching_js_bindings.cpp
++++ /dev/null
+@@ -1,262 +0,0 @@
+-#include <zxcvbn/matching.hpp>
+-
+-#include <zxcvbn/common_js.hpp>
+-
+-#include <emscripten/bind.h>
+-
+-namespace zxcvbn_js {
+-
+-static
+-bool empty(const emscripten::val & val) {
+-  return emscripten::val::global("Object").call<emscripten::val>("keys", val)["length"].as<std::size_t>() == 0;
+-}
+-
+-static
+-zxcvbn::RankedDict user_input_dictionary;
+-
+-static
+-void set_user_input_dictionary(const emscripten::val & ordered_list) {
+-  auto ret = val_converter<std::vector<std::string>>::from(ordered_list);
+-  user_input_dictionary = zxcvbn::build_ranked_dict(ret);
+-};
+-
+-
+-static
+-emscripten::val _dictionary_match(const std::wstring & wpassword,
+-                                  const emscripten::val & ranked_dictionaries = emscripten::val::undefined(),
+-                                  bool reversed = false,
+-                                  bool l33t = false,
+-                                  const emscripten::val & l33t_table = emscripten::val::undefined()) {
+-  auto password = to_utf8(wpassword);
+-  std::unordered_map<zxcvbn::DictionaryTag, std::string> _tag_to_name;
+-  std::unordered_map<zxcvbn::DictionaryTag, zxcvbn::RankedDict> _store;
+-  zxcvbn::RankedDicts dicts;
+-  if (ranked_dictionaries.isUndefined()) {
+-    dicts = zxcvbn::default_ranked_dicts();
+-
+-    dicts.insert(std::make_pair(zxcvbn::DictionaryTag::USER_INPUTS,
+-                                std::cref(user_input_dictionary)));
+-
+-    _tag_to_name = _default_dict_tag_to_name;
+-  }
+-  else {
+-    auto ranked_dicts = val_converter<std::unordered_map<std::string, zxcvbn::RankedDict>>::from(ranked_dictionaries);
+-    DictTagType tag_idx = _default_name_to_dict_tag.size();
+-    for (auto & item : ranked_dicts) {
+-      auto tag = static_cast<zxcvbn::DictionaryTag>(tag_idx);
+-      auto it = _default_name_to_dict_tag.find(item.first);
+-      if (it != _default_name_to_dict_tag.end()) {
+-        tag = it->second;
+-      }
+-      else {
+-        tag_idx += 1;
+-      }
+-      _tag_to_name.insert(std::make_pair(tag, item.first));
+-      _store.insert(std::make_pair(tag, std::move(item.second)));
+-    }
+-
+-    dicts = zxcvbn::convert_to_ranked_dicts(_store);
+-  }
+-
+-  auto ret = [&] {
+-    if (reversed) {
+-      return zxcvbn::reverse_dictionary_match(password, dicts);
+-    }
+-    else if (l33t) {
+-      std::vector<std::pair<std::string, std::vector<std::string>>> _store;
+-      auto & ret2 = [&] () -> const std::vector<std::pair<std::string, std::vector<std::string>>> & {
+-        if (l33t_table.isUndefined()) {
+-          return zxcvbn::L33T_TABLE;
+-        }
+-        else {
+-          auto ret = val_converter<std::unordered_map<std::string, std::vector<std::string>>>::from(l33t_table);
+-          std::move(ret.begin(), ret.end(), std::back_inserter(_store));
+-          return _store;
+-        }
+-      }();
+-      return zxcvbn::l33t_match(password, dicts, ret2);
+-    }
+-    else {
+-      return zxcvbn::dictionary_match(password, dicts);
+-    }
+-  }();
+-
+-  auto result = to_val(ret);
+-
+-  fix_up_dictionary_tags(result, _tag_to_name);
+-
+-  return result;
+-}
+-
+-static
+-emscripten::val dictionary_match(const std::wstring & wpassword,
+-                                 const emscripten::val & ranked_dictionaries) {
+-  return _dictionary_match(wpassword, ranked_dictionaries);
+-}
+-
+-
+-static
+-emscripten::val dictionary_match(const std::wstring & wpassword) {
+-  return _dictionary_match(wpassword);
+-}
+-
+-static
+-emscripten::val reverse_dictionary_match(const std::wstring & wpassword,
+-                                         const emscripten::val & ranked_dictionaries) {
+-  return _dictionary_match(wpassword, ranked_dictionaries, true);
+-}
+-
+-static
+-emscripten::val reverse_dictionary_match(const std::wstring & wpassword) {
+-  return _dictionary_match(wpassword, emscripten::val::undefined(), true);
+-}
+-
+-static
+-emscripten::val relevant_l33t_subtable(const std::wstring & wpassword,
+-                                       const emscripten::val & table) {
+-  auto ret = val_converter<std::unordered_map<std::string, std::vector<std::string>>>::from(table);
+-  std::vector<std::pair<std::string, std::vector<std::string>>> ret2;
+-  std::move(ret.begin(), ret.end(), std::back_inserter(ret2));
+-  auto result = zxcvbn::relevant_l33t_subtable(to_utf8(wpassword), ret2);
+-  return to_val(result);
+-}
+-
+-static
+-emscripten::val enumerate_l33t_subs(const emscripten::val & table) {
+-  auto ret = val_converter<std::unordered_map<std::string, std::vector<std::string>>>::from(table);
+-  auto result = zxcvbn::enumerate_l33t_subs(ret);
+-  return to_val(result);
+-}
+-
+-static
+-emscripten::val l33t_match(const std::wstring & wpassword,
+-                           const emscripten::val & ranked_dictionaries,
+-                           const emscripten::val & table) {
+-  return _dictionary_match(wpassword, ranked_dictionaries, false, true, table);
+-}
+-
+-static
+-emscripten::val l33t_match(const std::wstring & wpassword) {
+-  return _dictionary_match(wpassword, emscripten::val::undefined(), false, true);
+-}
+-
+-static
+-emscripten::val spatial_match(const std::wstring & wpassword,
+-                              const emscripten::val & graphs_val) {
+-  auto password = to_utf8(wpassword);
+-  zxcvbn::Graphs _new_graph;
+-
+-  std::unordered_map<zxcvbn::GraphTag, std::string> _tag_to_name;
+-  auto & new_graph = [&] () -> const zxcvbn::Graphs & {
+-    if (graphs_val.isUndefined()) {
+-      _tag_to_name = _default_graph_tag_to_name;
+-      return zxcvbn::graphs();
+-    }
+-    else {
+-      auto graphs = val_converter<std::unordered_map<std::string, zxcvbn::Graph>>::from(graphs_val);
+-
+-      GraphTagType tag_idx = _default_name_to_graph_tag.size();
+-      for (const auto & item : graphs) {
+-        auto tag = static_cast<zxcvbn::GraphTag>(tag_idx);
+-        auto it = _default_name_to_graph_tag.find(item.first);
+-        if (it != _default_name_to_graph_tag.end()) {
+-          tag = it->second;
+-        }
+-        else {
+-          tag_idx += 1;
+-        }
+-
+-        _tag_to_name.insert(std::make_pair(tag, item.first));
+-        _new_graph.insert(std::make_pair(tag, std::move(item.second)));
+-      }
+-
+-      return _new_graph;
+-    }
+-  }();
+-
+-  auto result = to_val(zxcvbn::spatial_match(password, new_graph));
+-
+-  fix_up_graph_tags(result, _tag_to_name);
+-
+-  return result;
+-}
+-
+-static
+-emscripten::val spatial_match(const std::wstring & wpassword) {
+-  return spatial_match(wpassword, emscripten::val::undefined());
+-}
+-
+-static
+-emscripten::val sequence_match(const std::wstring & wpassword) {
+-  return to_val(zxcvbn::sequence_match(to_utf8(wpassword)));
+-}
+-
+-static
+-emscripten::val repeat_match(const std::wstring & wpassword) {
+-  return to_val(zxcvbn::repeat_match(to_utf8(wpassword)));
+-}
+-
+-static
+-emscripten::val regex_match(const std::wstring & wpassword) {
+-  return to_val(zxcvbn::regex_match(to_utf8(wpassword), zxcvbn::REGEXEN));
+-}
+-
+-static
+-emscripten::val date_match(const std::wstring & wpassword) {
+-  return to_val(zxcvbn::date_match(to_utf8(wpassword)));
+-}
+-
+-static
+-emscripten::val omnimatch(const std::wstring & wpassword) {
+-  auto result = to_val(zxcvbn::omnimatch(to_utf8(wpassword)));
+-
+-  fix_up_dictionary_tags(result, _default_dict_tag_to_name);
+-  fix_up_graph_tags(result, _default_graph_tag_to_name);
+-
+-  return result;
+-}
+-
+-}
+-
+-EMSCRIPTEN_BINDINGS(matching) {
+-  emscripten::constant("no_util", true);
+-  emscripten::function("empty", &zxcvbn_js::empty);
+-  emscripten::function("set_user_input_dictionary", &zxcvbn_js::set_user_input_dictionary);
+-  emscripten::function("dictionary_match",
+-                       emscripten::select_overload<emscripten::val(
+-                         const std::wstring &,
+-                         const emscripten::val &)>(&zxcvbn_js::dictionary_match));
+-  emscripten::function("dictionary_match",
+-                       emscripten::select_overload<emscripten::val(
+-                         const std::wstring &)>(&zxcvbn_js::dictionary_match));
+-  emscripten::function("reverse_dictionary_match",
+-                       emscripten::select_overload<emscripten::val(
+-                         const std::wstring &,
+-                         const emscripten::val &)>(&zxcvbn_js::reverse_dictionary_match));
+-  emscripten::function("reverse_dictionary_match",
+-                       emscripten::select_overload<emscripten::val(
+-                         const std::wstring &)>(&zxcvbn_js::reverse_dictionary_match));
+-  emscripten::function("relevant_l33t_subtable", &zxcvbn_js::relevant_l33t_subtable);
+-  emscripten::function("enumerate_l33t_subs", &zxcvbn_js::enumerate_l33t_subs);
+-  emscripten::function("l33t_match",
+-                       emscripten::select_overload<emscripten::val(
+-                         const std::wstring &)>(&zxcvbn_js::l33t_match));
+-  emscripten::function("l33t_match", emscripten::select_overload<emscripten::val(
+-                         const std::wstring &,
+-                         const emscripten::val &,
+-                         const emscripten::val &
+-                         )>(&zxcvbn_js::l33t_match));
+-  emscripten::function("spatial_match",
+-                       emscripten::select_overload<emscripten::val(const std::wstring &)>(&zxcvbn_js::spatial_match));
+-  emscripten::function("spatial_match",
+-                       emscripten::select_overload
+-                       <emscripten::val(const std::wstring &,
+-                                        const emscripten::val &)>
+-                       (&zxcvbn_js::spatial_match));
+-  emscripten::function("sequence_match", &zxcvbn_js::sequence_match);
+-  emscripten::function("repeat_match", &zxcvbn_js::repeat_match);
+-  emscripten::function("regex_match", &zxcvbn_js::regex_match);
+-  emscripten::function("date_match", &zxcvbn_js::date_match);
+-  emscripten::function("omnimatch", &zxcvbn_js::omnimatch);
+-}
+-
+diff --git a/native-src/zxcvbn/optional.hpp b/native-src/zxcvbn/optional.hpp
+index 68b77e0..b3fb257 100644
+--- a/native-src/zxcvbn/optional.hpp
++++ b/native-src/zxcvbn/optional.hpp
+@@ -7,6 +7,7 @@
+ #include <new>
+ #include <stdexcept>
+ #include <type_traits>
++#include <utility>
+ 
+ #include <cstdint>
+ #include <cassert>
+diff --git a/native-src/zxcvbn/scoring.cpp b/native-src/zxcvbn/scoring.cpp
+index c652e2d..e5c120a 100644
+--- a/native-src/zxcvbn/scoring.cpp
++++ b/native-src/zxcvbn/scoring.cpp
+@@ -9,6 +9,8 @@
+ 
+ #include <cmath>
+ 
++#include "base/no_destructor.h"
++
+ namespace std {
+ 
+ template<class T, class U>
+@@ -27,6 +29,26 @@ const auto MIN_GUESSES_BEFORE_GROWING_SEQUENCE = static_cast<guesses_t>(10000);
+ const auto MIN_SUBMATCH_GUESSES_SINGLE_CHAR = static_cast<guesses_t>(10);
+ const auto MIN_SUBMATCH_GUESSES_MULTI_CHAR = static_cast<guesses_t>(50);
+ 
++const std::regex& START_UPPER() {
++  static base::NoDestructor<std::regex> start_upper(R"(^[A-Z][^A-Z]+$)");
++  return *start_upper;
++}
++
++const std::regex& END_UPPER() {
++  static base::NoDestructor<std::regex> end_upper(R"(^[^A-Z]+[A-Z]$)");
++  return *end_upper;
++}
++
++const std::regex& ALL_UPPER() {
++  static base::NoDestructor<std::regex> all_upper(R"(^[^a-z]+$)");
++  return *all_upper;
++}
++
++const std::regex& ALL_LOWER() {
++  static base::NoDestructor<std::regex> all_lower(R"(^[^A-Z]+$)");
++  return *all_lower;
++}
++
+ template<class Tret, class Tin>
+ Tret factorial(Tin n) {
+   // unoptimized, called only on small n
+@@ -53,7 +75,11 @@ std::size_t token_len(const Match & m) __attribute__((pure));
+ static
+ std::size_t token_len(const Match & m) {
+   std::size_t result = m.j - m.i + 1;
+-  assert(result == util::character_len(m.token));
++  // Bruteforce matches might be any substring of the original string, which are
++  // not necessarily aligned to UTF8 code points, and thus m.token might not be
++  // a valid UTF8 string.
++  if (m.get_pattern() != MatchPattern::BRUTEFORCE)
++    assert(result == util::character_len(m.token));
+   return result;
+ }
+ 
+@@ -199,7 +225,7 @@ ScoringResult most_guessable_match_sequence(const std::string & password,
+     if (!n) return optimal_match_sequence;
+     auto k = n - 1;
+     idx_t l = optimal.g[k].begin()->first;
+-    auto g = optimal.g[k].begin()->second;
++    guesses_t g = optimal.g[k].begin()->second;
+     for (const auto & item : optimal.g[k]) {
+       auto & candidate_l = item.first;
+       auto & candidate_g = item.second;
+@@ -281,7 +307,7 @@ guesses_t estimate_guesses(Match & match, const std::string & password) {
+ #define MATCH_FN(title, upper, lower) \
+   : match.get_pattern() == MatchPattern::upper ? lower##_guesses
+   guesses_t (*estimation_function)(const Match &) =
+-    false ? nullptr MATCH_RUN() : nullptr;
++    (false) ? nullptr MATCH_RUN() : nullptr;
+ #undef MATCH_FN
+   assert(estimation_function != nullptr);
+   auto guesses = estimation_function(match);
+@@ -441,11 +467,12 @@ guesses_t dictionary_guesses(const Match & match) {
+ 
+ guesses_t uppercase_variations(const Match & match) {
+   auto & word = match.token;
+-  if (std::regex_match(word, ALL_LOWER) || !word.size()) return 1;
++  if (std::regex_match(word, ALL_LOWER()) || !word.size())
++    return 1;
+   // a capitalized word is the most common capitalization scheme,
+   // so it only doubles the search space (uncapitalized + capitalized).
+   // allcaps and end-capitalized are common enough too, underestimate as 2x factor to be safe.
+-  for (const auto & regex : {START_UPPER, END_UPPER, ALL_UPPER}) {
++  for (const auto& regex : {START_UPPER(), END_UPPER(), ALL_UPPER()}) {
+     if (std::regex_match(word, regex)) return 2;
+   }
+   // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters
+diff --git a/native-src/zxcvbn/scoring.hpp b/native-src/zxcvbn/scoring.hpp
+index 901c71f..1038ee3 100644
+--- a/native-src/zxcvbn/scoring.hpp
++++ b/native-src/zxcvbn/scoring.hpp
+@@ -11,10 +11,10 @@
+ 
+ namespace zxcvbn {
+ 
+-const auto START_UPPER = std::regex(R"(^[A-Z][^A-Z]+$)");
+-const auto END_UPPER = std::regex(R"(^[^A-Z]+[A-Z]$)");
+-const auto ALL_UPPER = std::regex(R"(^[^a-z]+$)");
+-const auto ALL_LOWER = std::regex(R"(^[^A-Z]+$)");
++const std::regex& START_UPPER();
++const std::regex& END_UPPER();
++const std::regex& ALL_UPPER();
++const std::regex& ALL_LOWER();
+ 
+ const guesses_t MIN_YEAR_SPACE = 20;
+ const auto REFERENCE_YEAR = 2016;
+@@ -49,7 +49,7 @@ guesses_t estimate_guesses(Match & match, const std::string & password);
+ 
+ #define MATCH_FN(title, upper, lower) \
+   guesses_t lower##_guesses(const Match &);
+-MATCH_RUN();
++MATCH_RUN()
+ #undef MATCH_FN
+ 
+ guesses_t uppercase_variations(const Match & match);
+diff --git a/native-src/zxcvbn/scoring_js_bindings.cpp b/native-src/zxcvbn/scoring_js_bindings.cpp
+deleted file mode 100644
+index ceb43f4..0000000
+--- a/native-src/zxcvbn/scoring_js_bindings.cpp
++++ /dev/null
+@@ -1,181 +0,0 @@
+-#include <zxcvbn/common_js.hpp>
+-#include <zxcvbn/scoring.hpp>
+-
+-#include <emscripten/emscripten.h>
+-#include <emscripten/bind.h>
+-
+-#include <cstdint>
+-
+-namespace zxcvbn_js {
+-
+-static
+-double nCk(double a, double b) {
+-  return zxcvbn::nCk(a, b);
+-}
+-
+-static
+-double log2(double a) {
+-  return std::log2(a);
+-}
+-
+-static
+-double log10(double a) {
+-  return std::log10(a);
+-}
+-
+-static
+-emscripten::val most_guessable_match_sequence(const std::wstring & wpassword,
+-                                              emscripten::val matches,
+-                                              bool exclude_additive) {
+-  auto password = to_utf8(wpassword);
+-
+-  // NB: preserving the reference semantics of the JS version requires
+-  //     some careful plumbing (returning input match references,
+-  //     propagating mutations)
+-
+-  auto matches_native = val_converter<std::vector<zxcvbn::Match>>::from(matches);
+-
+-  // create native_match -> input match mapping
+-  std::unordered_map<zxcvbn::Match *, emscripten::val> match_to_val;
+-  for (decltype(matches_native.size()) i = 0; i < matches_native.size(); ++i) {
+-    match_to_val.insert(std::make_pair(&matches_native[i], matches[i]));
+-  }
+-
+-  auto native_result = zxcvbn::most_guessable_match_sequence(password, matches_native, exclude_additive);
+-
+-  // add guesses information to input matches
+-  for (decltype(matches_native.size()) i = 0; i < matches_native.size(); ++i) {
+-    auto val = matches[i];
+-    val.set("guesses", to_val(matches_native[i].guesses));
+-    val.set("guesses_log10", to_val(matches_native[i].guesses_log10));
+-  }
+-
+-  // convert sequence to reuse input matches
+-  auto sequence_array = emscripten::val::array();
+-  for (auto & ref : native_result.sequence) {
+-    auto it = match_to_val.find(&ref.get());
+-    auto toadd = (it != match_to_val.end()
+-                  ? it->second
+-                  : to_val(ref.get()));
+-    sequence_array.call<void>("push", toadd);
+-  }
+-
+-  auto result = emscripten::val::object();
+-
+-  result.set("password", to_val(native_result.password));
+-  result.set("sequence", std::move(sequence_array));
+-  result.set("guesses", to_val(native_result.guesses));
+-  result.set("guesses_log10", to_val(native_result.guesses_log10));
+-
+-  return result;
+-}
+-
+-static
+-emscripten::val most_guessable_match_sequence(const std::wstring & wpassword,
+-                                              emscripten::val matches) {
+-  return most_guessable_match_sequence(wpassword, std::move(matches), false);
+-}
+-
+-static
+-zxcvbn::guesses_t estimate_guesses(emscripten::val match,
+-                                   const std::wstring & wpassword) {
+-  auto password = to_utf8(wpassword);
+-
+-  auto native_match = from_val<zxcvbn::Match>(match);
+-  auto result = zxcvbn::estimate_guesses(native_match, password);
+-
+-  // propagate guess mutations
+-  match.set("guesses", to_val(native_match.guesses));
+-  match.set("guesses_log10", to_val(native_match.guesses_log10));
+-
+-  return result;
+-}
+-
+-static
+-zxcvbn::guesses_t date_guesses(const emscripten::val & match) {
+-  return zxcvbn::date_guesses(from_val<zxcvbn::Match>(match));
+-}
+-
+-static
+-zxcvbn::guesses_t repeat_guesses(const emscripten::val & match) {
+-  return zxcvbn::repeat_guesses(from_val<zxcvbn::Match>(match));
+-}
+-
+-static
+-zxcvbn::guesses_t sequence_guesses(const emscripten::val & match) {
+-  return zxcvbn::sequence_guesses(from_val<zxcvbn::Match>(match));
+-}
+-
+-static
+-zxcvbn::guesses_t regex_guesses(const emscripten::val & match) {
+-  return zxcvbn::regex_guesses(from_val<zxcvbn::Match>(match));
+-}
+-
+-static
+-zxcvbn::guesses_t spatial_guesses(const emscripten::val & match) {
+-  return zxcvbn::spatial_guesses(from_val<zxcvbn::Match>(match));
+-}
+-
+-static
+-zxcvbn::guesses_t dictionary_guesses(const emscripten::val & match) {
+-  return zxcvbn::dictionary_guesses(from_val<zxcvbn::Match>(match));
+-}
+-
+-static
+-zxcvbn::guesses_t uppercase_variations(const emscripten::val & match) {
+-  return zxcvbn::uppercase_variations(from_val<zxcvbn::Match>(match));
+-}
+-
+-static
+-zxcvbn::guesses_t l33t_variations(const emscripten::val & match) {
+-  return zxcvbn::l33t_variations(from_val<zxcvbn::Match>(match));
+-}
+-
+-}
+-
+-EMSCRIPTEN_BINDINGS(scoring) {
+-  emscripten::function("nCk", &zxcvbn_js::nCk);
+-  emscripten::function("log2", &zxcvbn_js::log2);
+-  emscripten::function("log10", &zxcvbn_js::log10);
+-  emscripten::function("most_guessable_match_sequence",
+-                       emscripten::select_overload<
+-                       emscripten::val
+-                       (const std::wstring & password,
+-                        emscripten::val matches,
+-                        bool exclude_additive)>
+-                       (&zxcvbn_js::most_guessable_match_sequence));
+-  emscripten::function("most_guessable_match_sequence",
+-                       emscripten::select_overload<
+-                       emscripten::val
+-                       (const std::wstring & password,
+-                        emscripten::val matches)>
+-                       (&zxcvbn_js::most_guessable_match_sequence));
+-  emscripten::function("estimate_guesses", &zxcvbn_js::estimate_guesses);
+-  emscripten::function("date_guesses", &zxcvbn_js::date_guesses);
+-  emscripten::function("repeat_guesses", &zxcvbn_js::repeat_guesses);
+-  emscripten::function("sequence_guesses", &zxcvbn_js::sequence_guesses);
+-  emscripten::function("regex_guesses", &zxcvbn_js::regex_guesses);
+-  emscripten::constant("MIN_YEAR_SPACE", zxcvbn::MIN_YEAR_SPACE);
+-  emscripten::constant("REFERENCE_YEAR", zxcvbn::REFERENCE_YEAR);
+-  emscripten::function("spatial_guesses", &zxcvbn_js::spatial_guesses);
+-  emscripten::function("dictionary_guesses", &zxcvbn_js::dictionary_guesses);
+-  emscripten::function("uppercase_variations", &zxcvbn_js::uppercase_variations);
+-  emscripten::function("l33t_variations", &zxcvbn_js::l33t_variations);
+-};
+-
+-#ifdef __EMSCRIPTEN__
+-
+-int main() {
+-  // workaround: emscripten::constant() can only handle integrals or aggregates
+-  // not doubles, also these are dynamically initialized
+-  EM_ASM_DOUBLE({
+-      Module["KEYBOARD_AVERAGE_DEGREE"] = $0;
+-    }, zxcvbn::KEYBOARD_AVERAGE_DEGREE);
+-  EM_ASM_INT({
+-      Module["KEYBOARD_STARTING_POSITIONS"] = $0;
+-    }, zxcvbn::KEYBOARD_STARTING_POSITIONS);
+-  emscripten_exit_with_live_runtime();
+-  return 0;
+-}
+-
+-#endif
+diff --git a/native-src/zxcvbn/util.cpp b/native-src/zxcvbn/util.cpp
+index 084d3cc..e7478d5 100644
+--- a/native-src/zxcvbn/util.cpp
++++ b/native-src/zxcvbn/util.cpp
+@@ -1,74 +1,57 @@
+ #include <zxcvbn/util.hpp>
+ 
+ #include <algorithm>
+-#include <codecvt>
+-#include <locale>
+ #include <string>
+ #include <utility>
+ 
+ #include <cassert>
+ 
++#include "base/strings/string_util.h"
++#include "base/strings/utf_string_conversion_utils.h"
++#include "base/strings/utf_string_conversions.h"
++
+ namespace zxcvbn {
+ 
+ namespace util {
+ 
++bool utf8_valid(std::string::const_iterator start,
++                std::string::const_iterator end) {
++  return base::IsStringUTF8(base::MakeStringPiece(start, end));
++}
++
++bool utf8_valid(const std::string & str) {
++  return utf8_valid(str.begin(), str.end());
++}
++
+ std::string ascii_lower(const std::string & in) {
+-  const char A = 0x41, Z = 0x5A;
+-  const char a = 0x61;
+-  auto result = in;
+-  std::transform(result.begin(), result.end(), result.begin(),
+-                 [&] (char c) {
+-                   return (c >= A && c <= Z
+-                           ? c - A + a
+-                           : c);
+-                 });
+-  return result;
++  return base::ToLowerASCII(in);
+ }
+ 
+ std::string reverse_string(const std::string & in) {
+-  std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> conv;
+-  auto ret = conv.from_bytes(in);
++  if (!utf8_valid(in))
++    return std::string(in.rbegin(), in.rend());
++
++  std::wstring ret = base::UTF8ToWide(in);
+   std::reverse(ret.begin(), ret.end());
+-  return conv.to_bytes(ret);
++  return base::WideToUTF8(ret);
+ }
+ 
+-const std::codecvt_utf8<char32_t> char32_conv;
++template<class It>
++std::pair<char32_t, It> _utf8_decode(It it, It end) {
++  assert(it != end);
++  const char* src = &*it;
++  size_t src_len = static_cast<size_t>(std::distance(it, end));
++  size_t char_index = 0;
++  base_icu::UChar32 code_point_out;
+ 
+-bool utf8_valid(std::string::const_iterator start,
+-                std::string::const_iterator end) {
+-  while (start != end) {
+-    std::mbstate_t st;
+-
+-    const char *from = &*start;
+-    const char *from_end = &*end;
+-    const char *from_next;
+-
+-    char32_t new_char;
+-    char32_t *to_next;
+-
+-    auto res = char32_conv.in(st, from, from_end, from_next,
+-                              &new_char, &new_char + 1, to_next);
+-    if (!((res == std::codecvt_utf8<char32_t>::result::partial &&
+-           from_next != from_end) ||
+-          (res == std::codecvt_utf8<char32_t>::result::ok &&
+-           from_next == from_end))) {
+-      return false;
+-    }
+-    start += (from_next - from);
+-  }
+-  return true;
++  base::ReadUnicodeCharacter(src, src_len, &char_index, &code_point_out);
++  return {code_point_out, it + ++char_index};
+ }
+ 
+-bool utf8_valid(const std::string & str) {
+-  return utf8_valid(str.begin(), str.end());
+-}
+ 
+ template<class It>
+ It _utf8_iter(It start, It end) {
+-  assert(start != end);
+-  std::mbstate_t st;
+-  auto amt = char32_conv.length(st, &*start, &*end, 1);
+-  return start + amt;
++  return _utf8_decode(start, end).second;
+ }
+ 
+ std::string::iterator utf8_iter(std::string::iterator start,
+@@ -99,38 +82,6 @@ std::string::size_type character_len(const std::string & str) {
+   return character_len(str, 0, str.size());
+ }
+ 
+-template<class It>
+-std::pair<char32_t, It> _utf8_decode(It it, It end) {
+-  std::mbstate_t st;
+-  char32_t new_char;
+-  char32_t *to_next;
+-
+-  assert(it != end);
+-
+-  const char *from = &*it;
+-  const char *from_end = &*end;
+-  const char *from_next;
+-  auto res = char32_conv.in(st, from, from_end, from_next,
+-                            &new_char, &new_char + 1, to_next);
+-  assert((res == std::codecvt_utf8<char32_t>::result::partial &&
+-          from_next != from_end) ||
+-         (res == std::codecvt_utf8<char32_t>::result::ok &&
+-          from_next == from_end));
+-  (void) res;
+-
+-  return std::make_pair(new_char, it + (from_next - from));
+-}
+-
+-std::pair<char32_t, std::string::iterator> utf8_decode(std::string::iterator start,
+-                                                       std::string::iterator end) {
+-  return _utf8_decode(start, end);
+-}
+-
+-std::pair<char32_t, std::string::const_iterator> utf8_decode(std::string::const_iterator start,
+-                                                             std::string::const_iterator end) {
+-  return _utf8_decode(start, end);
+-}
+-
+ char32_t utf8_decode(const std::string & start,
+                      std::string::size_type & idx) {
+   auto ret = _utf8_decode(start.begin() + idx, start.end());
+diff --git a/native-src/zxcvbn/util.hpp b/native-src/zxcvbn/util.hpp
+index b784c1f..90fa998 100644
+--- a/native-src/zxcvbn/util.hpp
++++ b/native-src/zxcvbn/util.hpp
+@@ -29,8 +29,6 @@ std::string::size_type character_len(const std::string &,
+                                      std::string::size_type end) __attribute__((pure));
+ std::string::size_type character_len(const std::string &)  __attribute__((pure));
+ 
+-std::pair<char32_t, std::string::iterator> utf8_decode(std::string::iterator);
+-std::pair<char32_t, std::string::const_iterator> utf8_decode(std::string::const_iterator);
+ char32_t utf8_decode(const std::string & start,
+                      std::string::size_type & idx);
+ 
+diff --git a/native-src/zxcvbn/zxcvbn.cpp b/native-src/zxcvbn/zxcvbn.cpp
+deleted file mode 100644
+index d9b5291..0000000
+--- a/native-src/zxcvbn/zxcvbn.cpp
++++ /dev/null
+@@ -1,50 +0,0 @@
+-#include <zxcvbn/zxcvbn.h>
+-
+-#include <zxcvbn/util.hpp>
+-#include <zxcvbn/scoring.hpp>
+-#include <zxcvbn/matching.hpp>
+-
+-extern "C" {
+-
+-struct zxcvbn_match_sequence {
+-  std::vector<zxcvbn::Match> sequence;
+-};
+-
+-int zxcvbn_password_strength(const char *password, const char *const *user_inputs,
+-                             zxcvbn_guesses_t *guesses,
+-                             zxcvbn_match_sequence_t *pmseq) {
+-  try {
+-    std::vector<std::string> sanitized_inputs;
+-    if (user_inputs) {
+-      while (*user_inputs) {
+-        sanitized_inputs.push_back(zxcvbn::util::ascii_lower(*user_inputs));
+-        user_inputs++;
+-      }
+-    }
+-
+-    auto matches = zxcvbn::omnimatch(password, sanitized_inputs);
+-    auto result = zxcvbn::most_guessable_match_sequence(password, matches, false);
+-
+-    if (guesses) {
+-      *guesses = result.guesses;
+-    }
+-
+-    if (pmseq) {
+-      std::vector<zxcvbn::Match> sequence;
+-      std::move(result.sequence.begin(), result.sequence.end(),
+-                std::back_inserter(sequence));
+-      *pmseq = new zxcvbn_match_sequence{std::move(sequence)};
+-    }
+-
+-    return 0;
+-  }
+-  catch (...) {
+-    return -1;
+-  }
+-}
+-
+-void zxcvbn_match_sequence_destroy(zxcvbn_match_sequence_t mseq) {
+-  delete mseq;
+-}
+-
+-}
+diff --git a/native-src/zxcvbn/zxcvbn.h b/native-src/zxcvbn/zxcvbn.h
+deleted file mode 100644
+index 67a6d03..0000000
+--- a/native-src/zxcvbn/zxcvbn.h
++++ /dev/null
+@@ -1,26 +0,0 @@
+-#ifndef __ZXCVBN_H
+-#define __ZXCVBN_H
+-
+-#include <stdint.h>
+-
+-#ifdef __cplusplus
+-extern "C" {
+-#endif
+-
+-typedef double zxcvbn_guesses_t;
+-
+-struct zxcvbn_match_sequence;
+-typedef struct zxcvbn_match_sequence *zxcvbn_match_sequence_t;
+-
+-int zxcvbn_password_strength(const char *pass, const char *const *user_inputs,
+-                             zxcvbn_guesses_t *guesses,
+-                             zxcvbn_match_sequence_t *mseq
+-                             );
+-
+-void zxcvbn_match_sequence_destroy(zxcvbn_match_sequence_t);
+-
+-#ifdef __cplusplus
+-}
+-#endif
+-
+-#endif
+diff --git a/native-src/zxcvbn/zxcvbn.hpp b/native-src/zxcvbn/zxcvbn.hpp
+deleted file mode 100644
+index a48bcd8..0000000
+--- a/native-src/zxcvbn/zxcvbn.hpp
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#ifndef __ZXCVBN__ZXCVBN_HPP
+-#define __ZXCVBN__ZXCVBN_HPP
+-
+-#include <zxcvbn/feedback.hpp>
+-#include <zxcvbn/scoring.hpp>
+-#include <zxcvbn/time_estimates.hpp>
+-
+-#include <string>
+-#include <vector>
+-
+-namespace zxcvbn {
+-
+-struct ZxcvbnResult {
+-  scoring::ScoringResult scoring;
+-  time_estimates::AttackTimes attack_times;
+-  feedback::Feedback feedback;
+-};
+-
+-ZxcvbnResult zxcvbn(const std::string & password, const std::vector<std::string> & user_inputs);
+-
+-}
+-
+-#endif
+diff --git a/native-src/zxcvbn/zxcvbn_js_bindings.cpp b/native-src/zxcvbn/zxcvbn_js_bindings.cpp
+deleted file mode 100644
+index f0ba44c..0000000
+--- a/native-src/zxcvbn/zxcvbn_js_bindings.cpp
++++ /dev/null
+@@ -1,104 +0,0 @@
+-#include <zxcvbn/common_js.hpp>
+-#include <zxcvbn/scoring.hpp>
+-#include <zxcvbn/matching.hpp>
+-#include <zxcvbn/time_estimates.hpp>
+-#include <zxcvbn/feedback.hpp>
+-
+-#include <chrono>
+-
+-#include <emscripten/bind.h>
+-
+-namespace zxcvbn_js {
+-
+-emscripten::val password_strength(const std::wstring & wpassword,
+-                                  const emscripten::val & user_inputs) {
+-  auto password = to_utf8(wpassword);
+-
+-  // reset the user inputs matcher on a per-request basis to keep things stateless
+-  std::vector<std::string> sanitized_inputs;
+-  auto len = from_val<std::size_t>(user_inputs["length"]);
+-  for (decltype(len) i = 0; i < len; ++i) {
+-    auto type_ = from_val<std::string>(user_inputs[i].typeof());
+-    if (type_ == "string" ||
+-        type_ == "number" ||
+-        type_ == "boolean") {
+-      sanitized_inputs.push_back(from_val<std::string>(user_inputs[i].call<emscripten::val>("toString").call<emscripten::val>("toLowerCase")));
+-    }
+-  }
+-
+-  auto start = std::chrono::high_resolution_clock::now();
+-  auto matches = zxcvbn::omnimatch(password, sanitized_inputs);
+-  auto scoring_result = zxcvbn::most_guessable_match_sequence(password, matches);
+-  auto stop = std::chrono::high_resolution_clock::now();
+-
+-  using FpSeconds = std::chrono::duration<double, std::chrono::milliseconds::period>;
+-
+-  auto result = emscripten::val::object();
+-
+-  result.set("password", wpassword);
+-
+-  // set scoring results
+-  auto match_sequence = std::vector<zxcvbn::Match>{};
+-  for (auto & elt : scoring_result.sequence) {
+-    match_sequence.push_back(std::move(elt.get()));
+-  }
+-
+-  result.set("guesses", to_val(scoring_result.guesses));
+-  result.set("guesses_log10", to_val(std::log10(scoring_result.guesses)));
+-  auto js_sequence = to_val(match_sequence);
+-  fix_up_dictionary_tags(js_sequence);
+-  fix_up_graph_tags(js_sequence);
+-  result.set("sequence", js_sequence);
+-
+-  // set calc_time
+-  result.set("calc_time", to_val(FpSeconds(stop - start).count()));
+-
+-  // set attack times
+-  auto attack_times = zxcvbn::estimate_attack_times(scoring_result.guesses);
+-
+-  auto crack_times_seconds = emscripten::val::object();
+-#define CT(v) crack_times_seconds.set(#v, to_val(attack_times.crack_times_seconds.v));
+-  CT(online_throttling_100_per_hour);
+-  CT(online_no_throttling_10_per_second);
+-  CT(offline_slow_hashing_1e4_per_second);
+-  CT(offline_fast_hashing_1e10_per_second);
+-#undef CT
+-  result.set("crack_time_seconds", crack_times_seconds);
+-
+-  auto crack_time_display = emscripten::val::object();
+-#define CT(v) crack_time_display.set(#v, to_val(attack_times.crack_times_display.v));
+-  CT(online_throttling_100_per_hour);
+-  CT(online_no_throttling_10_per_second);
+-  CT(offline_slow_hashing_1e4_per_second);
+-  CT(offline_fast_hashing_1e10_per_second);
+-#undef CT
+-  result.set("crack_time_display", crack_time_display);
+-
+-  result.set("score", to_val(attack_times.score));
+-
+-  // set feedback
+-  result.set("feedback", to_val(zxcvbn::get_feedback(attack_times.score, match_sequence)));
+-
+-  return result;
+-}
+-
+-emscripten::val password_strength(const std::wstring & wpassword) {
+-  return password_strength(wpassword, emscripten::val::array());
+-}
+-
+-}
+-
+-EMSCRIPTEN_BINDINGS(zxcvbn) {
+-  emscripten::function("password_strength",
+-                       emscripten::select_overload<
+-                       emscripten::val
+-                       (const std::wstring & wpassword)>(
+-                         &zxcvbn_js::password_strength));
+-  emscripten::function("password_strength",
+-                       emscripten::select_overload<
+-                       emscripten::val
+-                       (const std::wstring &,
+-                        const emscripten::val &)>(
+-                          &zxcvbn_js::password_strength));
+-
+-}
diff --git a/tools/binary_size/libsupersize/viewer/caspian/wasmbuild.patch b/tools/binary_size/libsupersize/viewer/caspian/wasmbuild.patch
new file mode 100644
index 0000000000000..1d24e9efc6215
--- /dev/null
+++ b/tools/binary_size/libsupersize/viewer/caspian/wasmbuild.patch
@@ -0,0 +1,129 @@
+diff --git a/build/config/BUILDCONFIG.gn b/build/config/BUILDCONFIG.gn
+index cc7e92ddb67cd..f9212d2e81c63 100644
+--- a/build/config/BUILDCONFIG.gn
++++ b/build/config/BUILDCONFIG.gn
+@@ -305,10 +305,11 @@ is_ios = current_os == "ios"
+ is_linux = current_os == "linux"
+ is_mac = current_os == "mac"
+ is_nacl = current_os == "nacl"
++is_wasm = current_os == "wasm"
+ is_win = current_os == "win" || current_os == "winuwp"
+ 
+ is_apple = is_ios || is_mac
+-is_posix = !is_win && !is_fuchsia
++is_posix = !is_win && !is_fuchsia && !is_wasm
+ 
+ # =============================================================================
+ # TARGET DEFAULTS
+diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
+index 6119aa066a982..a77ca7e4a2ab8 100644
+--- a/build/config/compiler/BUILD.gn
++++ b/build/config/compiler/BUILD.gn
+@@ -647,6 +647,20 @@ config("compiler") {
+     ldflags += [ "-fexperimental-relative-c++-abi-vtables" ]
+   }
+ 
++  if (is_wasm) {
++    ldflags += [
++      "-s",
++      "ALLOW_MEMORY_GROWTH=1",
++      "-s",
++      "LLD_REPORT_UNDEFINED=1",
++    ]
++
++    if (is_official_build) {
++      cflags += ["-flto=full"]
++      ldflags += ["-flto=full"]
++    }
++  }
++
+   # Add flags for link-time optimization. These flags enable
+   # optimizations/transformations that require whole-program visibility at link
+   # time, so they need to be applied to all translation units, and we may end up
+@@ -766,7 +780,7 @@ config("compiler") {
+ 
+   # TODO(crbug.com/40242425): Cleanup undefined symbol errors caught by
+   # --no-undefined-version.
+-  if (use_lld && !is_win && !is_mac && !is_ios) {
++  if (use_lld && !is_win && !is_mac && !is_ios && !is_wasm) {
+     ldflags += [ "-Wl,--undefined-version" ]
+   }
+ 
+@@ -777,7 +791,7 @@ config("compiler") {
+   if (use_lld && !enable_call_graph_profile_sort) {
+     if (is_win) {
+       ldflags += [ "/call-graph-profile-sort:no" ]
+-    } else {
++    } else if (!is_wasm) {
+       ldflags += [ "-Wl,--no-call-graph-profile-sort" ]
+     }
+   }
+@@ -1615,7 +1629,7 @@ config("default_warnings") {
+         "-Wno-ignored-pragma-optimize",
+       ]
+ 
+-      if (!is_nacl) {
++      if (!is_nacl && !is_wasm) {
+         cflags += [
+           # TODO(crbug.com/40231599) Evaluate and possibly enable.
+           "-Wno-deprecated-builtins",
+@@ -2380,6 +2394,9 @@ config("symbols") {
+ 
+     # All configs using /DEBUG should include this:
+     configs = [ ":win_pdbaltpath" ]
++  } else if (is_wasm) {
++    cflags = [ "-gseparate-dwarf" ]
++    ldflags = [ "-gseparate-dwarf" ]
+   } else {
+     cflags = []
+     if (is_mac && enable_dsyms) {
+diff --git a/build/toolchain/toolchain.gni b/build/toolchain/toolchain.gni
+index 844bc8e540bcc..93e6e0c437fab 100644
+--- a/build/toolchain/toolchain.gni
++++ b/build/toolchain/toolchain.gni
+@@ -47,6 +47,9 @@ if (is_apple) {
+   shlib_extension = ".so"
+ } else if (is_win) {
+   shlib_extension = ".dll"
++} else if (is_wasm) {
++  # WebAssembly does not stably support shared libraries. (as of Oct 2019)
++  shlib_extension = ".wasm"
+ } else {
+   assert(false, "Platform not supported")
+ }
+diff --git a/build/toolchain/wasm/BUILD.gn b/build/toolchain/wasm/BUILD.gn
+new file mode 100644
+index 0000000000000..4aed5264eae15
+--- /dev/null
++++ b/build/toolchain/wasm/BUILD.gn
+@@ -0,0 +1,30 @@
++# Copyright 2019 The Chromium Authors
++# Use of this source code is governed by a BSD-style license that can be
++# found in the LICENSE file.
++
++import("//build/toolchain/gcc_toolchain.gni")
++
++gcc_toolchain("wasm") {
++  cc = "emcc"
++  cxx = "em++"
++  nm = "emcc"
++  ar = "emar"
++  ld = cxx
++
++  toolchain_args = {
++    current_cpu = "wasm"
++    current_os = "wasm"
++
++    is_clang = true
++    use_remoteexec = false
++    use_debug_fission = false
++    clang_use_chrome_plugins = false
++    use_allocator_shim = false
++    is_component_build = false
++  }
++  executable_extension = ".js"
++  link_outputs = [
++    "{{output_dir}}/{{target_output_name}}.wasm",
++    "{{output_dir}}/{{target_output_name}}.wasm.debug.wasm",
++  ]
++}
diff --git a/tools/vscode/bazel_lsp/0001-Make-it-work-for-chromium-s-infra-configs.patch b/tools/vscode/bazel_lsp/0001-Make-it-work-for-chromium-s-infra-configs.patch
new file mode 100644
index 0000000000000..07ff4a943135f
--- /dev/null
+++ b/tools/vscode/bazel_lsp/0001-Make-it-work-for-chromium-s-infra-configs.patch
@@ -0,0 +1,160 @@
+From 7d6b126a63d76f85b49909b52838eef413eb2ba0 Mon Sep 17 00:00:00 2001
+From: Peter Wen <wnwen@google.com>
+Date: Mon, 11 Mar 2024 15:09:25 -0400
+Subject: [PATCH] Make it work for chromium's infra configs
+
+- Add the arg --lucicfg_stdlib_path to specify the directory that
+  lucicfg's stdlib resides. If this is missing then "go to definition"
+  for globals like `time.hour` will not work.
+- Handle `//` (absolute) and `./` (relative) load path prefixes. The
+  global prefix in a file under //src/infra/config assumes `//` refers
+  to //src/infra/config, and in a file under
+  //src/internal/infra/config then `//` refers to that directory
+  instead. The relative path assumes it's rooted in the current file's
+  directory.
+- Handle `@stdlib` load path prefix when --lucicfg_stdlib_path is
+  specified.
+- Handle global symbol resolution when it's not a starlark builtin by
+  resolving it in a file with the same name in the stdlib or in the root
+  builtins.star for the `luci` symbol. This also requires the
+  --lucicfg_stdlib_path arg.
+---
+ src/bazel.rs | 64 +++++++++++++++++++++++++++++++++++++++++++++++++++-
+ src/main.rs  |  6 +++++
+ 2 files changed, 69 insertions(+), 1 deletion(-)
+
+diff --git a/src/bazel.rs b/src/bazel.rs
+index 5455c33..ba0edf9 100644
+--- a/src/bazel.rs
++++ b/src/bazel.rs
+@@ -139,6 +139,7 @@ struct FilesystemCompletionOptions {
+ pub(crate) struct BazelContext<Client> {
+     workspaces: RefCell<HashMap<PathBuf, Rc<BazelWorkspace>>>,
+     query_output_base: Option<PathBuf>,
++    lucicfg_stdlib_path: Option<PathBuf>,
+     pub(crate) mode: ContextMode,
+     pub(crate) print_non_none: bool,
+     pub(crate) prelude: Vec<FrozenModule>,
+@@ -156,6 +157,7 @@ impl<Client: BazelClient> BazelContext<Client> {
+         prelude: &[PathBuf],
+         module: bool,
+         query_output_base: Option<PathBuf>,
++        lucicfg_stdlib_path: Option<PathBuf>,
+     ) -> anyhow::Result<Self> {
+         let globals = globals();
+         let prelude: Vec<_> = prelude
+@@ -193,6 +195,7 @@ impl<Client: BazelClient> BazelContext<Client> {
+         Ok(Self {
+             workspaces: RefCell::new(HashMap::new()),
+             query_output_base,
++            lucicfg_stdlib_path,
+             mode,
+             print_non_none,
+             prelude,
+@@ -642,6 +645,41 @@ impl<Client: BazelClient> LspContext for BazelContext<Client> {
+         current_file: &LspUrl,
+         workspace_root: Option<&Path>,
+     ) -> anyhow::Result<LspUrl> {
++        let mut paths_to_test = Vec::new();
++        // Handle '//' and '@stdlib//' prefixes.
++        if path.starts_with("//") {
++            // Assuming workspace_root is //src.
++            let src_path = match workspace_root {
++                Some(root_path) => root_path.to_path_buf(),
++                None => PathBuf::from("/"),
++            };
++            let relative_path = path[2..].to_owned();
++            let current_file_path = current_file.path();
++            let path_string = current_file_path.to_string_lossy();
++            if path_string.contains("/internal/infra/config/") {
++                paths_to_test.push(src_path.join("internal/infra/config").join(&relative_path));
++            } else if path_string.contains("/infra/config/") {
++                paths_to_test.push(src_path.join("infra/config").join(&relative_path));
++            }
++        } else if path.starts_with("@stdlib//") {
++            if let Some(lucicfg_stdlib_path) = self.lucicfg_stdlib_path.as_deref() {
++                let relative_path = path[9..].to_owned();
++                paths_to_test.push(lucicfg_stdlib_path.join(&relative_path));
++            }
++        } else if path.starts_with("./") {
++            let cur_path = match current_file.path().parent() {
++                Some(path) => path.to_path_buf(),
++                None => PathBuf::from("/"),
++            };
++            let relative_path = path.to_owned();
++            paths_to_test.push(cur_path.join(&relative_path));
++        }
++        for path in paths_to_test {
++            if path.exists() {
++                return Ok(Url::from_file_path(path).unwrap().try_into()?);
++            }
++        }
++
+         let label = Label::parse(path)?;
+         let workspace = self.workspace(workspace_root, current_file)?;
+ 
+@@ -775,12 +813,36 @@ impl<Client: BazelClient> LspContext for BazelContext<Client> {
+         self.try_get_environment(uri).unwrap_or_default()
+     }
+ 
++
+     fn get_url_for_global_symbol(
+         &self,
+         _current_file: &LspUrl,
+         symbol: &str,
+     ) -> anyhow::Result<Option<LspUrl>> {
+-        Ok(self.builtin_symbols.get(symbol).cloned())
++        if self.builtin_symbols.contains_key(symbol) {
++            return Ok(self.builtin_symbols.get(symbol).cloned());
++        }
++
++        let mut mapping = HashMap::new();
++
++        if let Some(lucicfg_stdlib_path) = self.lucicfg_stdlib_path.as_deref() {
++            if symbol == "luci" {
++                return Ok(Some(LspUrl::File(lucicfg_stdlib_path.join("builtins.star"))));
++            }
++
++            for entry in fs::read_dir(lucicfg_stdlib_path.join("internal"))? {
++                let entry = entry?;
++                let path = entry.path();
++
++                if path.is_file() {
++                    if let Some(file_stem) = path.file_stem() {
++                        mapping.insert(file_stem.to_string_lossy().to_string(), LspUrl::File(path));
++                    }
++                }
++            }
++        }
++
++        Ok(mapping.get(symbol).cloned())
+     }
+ 
+     fn get_string_completion_options(
+diff --git a/src/main.rs b/src/main.rs
+index d3e7400..cc8fab9 100644
+--- a/src/main.rs
++++ b/src/main.rs
+@@ -35,6 +35,11 @@ struct Args {
+     /// temp directory.
+     #[arg(long)]
+     query_output_base: Option<PathBuf>,
++
++    /// The absolute path to .../lucicfg/starlark/stdlib (requires
++    /// passing the full path that includes the stdlib directory).
++    #[arg(long)]
++    lucicfg_stdlib_path: Option<PathBuf>,
+ }
+ 
+ fn main() -> anyhow::Result<()> {
+@@ -56,6 +61,7 @@ fn main() -> anyhow::Result<()> {
+         &[],
+         true,
+         query_output_base,
++        args.lucicfg_stdlib_path,
+     )?;
+ 
+     starlark_lsp::server::stdio_server(ctx)?;
+-- 
+2.44.0.683.g7961c838ac-goog
+
-- 
2.43.0.windows.1

